<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Consumo abusivo de memória</title>
  <meta name="author" content="" />
  <meta name="description"
        content="Era um belo dia em um ambiente de processamento fictício de filas fictícias e threads fictícias. Eis um belo código com filas, threads e processamentos feitos em stop-motion:
#include..."/>

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta itemprop="name" content="Consumo abusivo de memória"/>
  <meta itemprop="description"
        content="Era um belo dia em um ambiente de processamento fictício de filas fictícias e threads fictícias. Eis um belo código com filas, threads e processamentos feitos em stop-motion:
#include..."/>
  <meta itemprop="image"
        content=""/>

  
  <meta property="og:title" content="Consumo abusivo de memória"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/consumo-abusivo-de-memoria/"/>
  <meta property="og:image"
        content=""/>
  <meta property="og:description"
        content="Era um belo dia em um ambiente de processamento fictício de filas fictícias e threads fictícias. Eis um belo código com filas, threads e processamentos feitos em stop-motion:
#include..."/>
  <meta property="og:site_name" content="Blogue do Caloni"/>
  <meta property="article:published_time"
        content="2012-05-19T00:00:00&#43;00:00"/>
  <meta property="article:section" content="post"/>

  
  
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site"
        content=""/>
  <meta name="twitter:title" content="Consumo abusivo de memória"/>
  <meta name="twitter:description"
        content="Era um belo dia em um ambiente de processamento fictício de filas fictícias e threads fictícias. Eis um belo código com filas, threads e processamentos feitos em stop-motion:
#include..."/>
  <meta name="twitter:creator"
        content=""/>
  <meta name="twitter:image:src"
        content="
                     /images/movies.png
                   "/>

  
  <link href="" rel="alternate" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">
  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/brand.svg">
        <div class="title is-6">&nbsp;Blogue do Caloni</div>
      </a>

      
      <label class="button navbar-burger is-white" for="navbar-burger-state">
        <span></span>                               
        <span></span>
        <span></span>
      </label>
    </div>

    
    <input type="checkbox" id="navbar-burger-state"/>

    <div class="navbar-menu">
      <div class="navbar-end" style="padding: 10px;">
      <big><b>
       <a title="posts dessa categoria" href="/categories/blog">blog</a>  <a title="posts dessa categoria" href="/categories/cinema">cinema</a>  <a title="posts dessa categoria" href="/categories/code">code</a> 
       <a href="/caloni"><span class="icon"><i class="fa fa-user"></i></a> <a href="index.xml"><span class="icon"><i class="fa fa-rss"></i></a>
      </big></b>
      </div>
    </div>

  </div>
</nav>


      
      <div class="container">
        <p class="title">Consumo abusivo de memória</p>

        <p class="subtitle">
<i>

    <a href="https://github.com/Caloni/post/commits/master/consumo-abusivo-de-memoria.md" title="History">
    2012-05-19
    </a>

<span class="icon"><i class="fa fa-clock-o"></span></i>6 </i>
 <span class="icon"><i class="fa fa-pencil"></i></span><a href="https://github.com/Caloni/post/blob/master/consumo-abusivo-de-memoria.md" title="GitHub">1178</a>
</p>

        <div class="taglist">
            <i>Este ainda é um rascunho publicado prematuramente e está sujeito a mudanças substanciais.</i>

        </div>

        

        
          <div class="content">
            
              <p>Era um belo dia em um ambiente de processamento fictício de filas fictícias e threads fictícias. Eis um belo código com filas, threads e processamentos feitos em stop-motion:</p>
<pre><code>#include &lt;windows.h&gt; // critical section, create thread...
#include &lt;list&gt; // nossa lista interna
#include &lt;time.h&gt; // randomização

struct Queue // uma fila (duh)
{
    size_t bufferSize; // cada item é um buffer de tamanho fixo
    DWORD wait; // antes de processar, aguardemos esse tempo fixo
    CRITICAL_SECTION cs; // stl é thread-safe, pero no mucho
    std::list&lt;char*&gt; items; // os itens!
};

DWORD WINAPI InsertItems(LPVOID pvQueue) // insere, insere, insere....
{
    Queue&amp; queue = *(Queue*) pvQueue;
    for( int i = 0; i &lt; 10 * 1000; ++i ) // 10k itens!
    {
        char* buffer = new char[queue.bufferSize];
        memset(buffer, (int) (i % ('Z' - 'A')) + 'A', queue.bufferSize); // teoricamente de A a Z
        buffer[queue.bufferSize - 1] = 0; // string C pra facilitar nossa depuração
        EnterCriticalSection(&amp;queue.cs); // deixa eu entrar!
        queue.items.push_back(buffer);
        LeaveCriticalSection(&amp;queue.cs); // deixa eu sair!
        Sleep(10); // dá uma dormidinha (sempre menor dormidinhas do processamento)
    }
    return ERROR_SUCCESS; // &quot;tá tudo certo!&quot; (by Starcraft 2)
}

DWORD WINAPI ProcessItems(LPVOID pvQueue) // processa, processa, processa...
{
    Queue&amp; queue = *(Queue*) pvQueue;
    DWORD wait = 2;
    Sleep(10000); // como um advogado oportunista, aguardamos por alguém pra processar
    while( ! queue.items.empty() ) // agora vai até esvaziar o recinto
    {
        EnterCriticalSection(&amp;queue.cs); // deixa eu entrar!
        char* buffer = queue.items.front();
        queue.items.pop_front();
        LeaveCriticalSection(&amp;queue.cs); // deixa eu sair!
        delete [] buffer;
        Sleep(queue.wait); // aguarda por... por quanto mesmo?
    }
    return ERROR_SUCCESS; // &quot;tá tudo certo!&quot; (by Starcraft 2)
}

int main(int argc, char* argv[]) // No princípio havia a pilha, quando Deus disse: 'int main!'
{
    static const size_t QUEUES_SIZE = 20; // número de filas sendo processadas
    static const size_t QUEUE_ITEM_SIZE = 0x1000; // 1KB é o chunk alocado por item
    static const DWORD WAIT_TIMES[] = { 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1000 }; // alguém vai esperar demais

    Queue queues[QUEUES_SIZE]; // as filas
    HANDLE queueThreads[QUEUES_SIZE * 2]; // as threads que processam as filas

    srand((unsigned int)time(0)); // randomizemos tudo

    for( size_t i = 0; i &lt; QUEUES_SIZE; ++i )
    {
        queues[i].bufferSize = QUEUE_ITEM_SIZE + i; // para diferenciarmos as filas
        queues[i].wait = WAIT_TIMES[ rand() % (sizeof(WAIT_TIMES) / sizeof(DWORD)) ]; // vamos esperar por... por quanto mesmo?
        InitializeCriticalSection(&amp;queues[i].cs); // deu crash em algumas situações em release (stl deveria ser thread-safe...)
        queueThreads[i] = CreateThread(NULL, 0, InsertItems, &amp;queues[i], 0, NULL); // criamos thread de inserção
        queueThreads[QUEUES_SIZE + i] = CreateThread(NULL, 0, ProcessItems, &amp;queues[i], 0, NULL); // criamos thread de processamento
    }

    WaitForMultipleObjects(QUEUES_SIZE * 2, queueThreads, TRUE, INFINITE); // espera a 'gaguera'
    return 0; // &quot;tá tudo certo!&quot; (by Starcraft 2)
}
</code></pre>
<p>Se olharmos de perto o processamento e a memória consumida por esse processo, veremos que no início existe um boom de ambos, mas após um momento de pico, o processamento praticamente pára, mas a memória se mantém:</p>
<p>Depois de pesquisar por meus tweets favoritos, fica fácil ter a receita para verificarmos isso usando nosso depurador favorito: WinDbg!</p>
<p>windbg -pn MemoryConsumption.exe</p>
<p>Achamos onde está a memória consumida. Agora precisamos de dicas do que pode estar consumindo essa memória. Vamos começar por listar os chunks alocados por tamanho de alocação:</p>
<pre><code>0:004&gt; !heap -stat -h 0
Allocations statistics for
 heap @ 00670000
group-by: TOTSIZE max-display: 20


 size #blocks total ( %) (percent of total busy bytes)
 1037 25e5 - 2667433 (33.04)
 1025 25e6 - 263da3e (32.90)
 1024 25e4 - 2639410 (32.89)
...
</code></pre>
<p>O Top 3 é de tamanhos conhecidos pelo código, de 1024 a 1024 + QUEUESSIZE - 1. O de tamanho 1037, por exemplo, possui 0x25e5 blocos alocados. Vamos listar cada um deles:</p>
<pre><code>0:004&gt; !heap -flt s 1037
 _HEAP @ 420000
 _HEAP @ 670000
 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state
 00558600 0221 0000 [00] 00558618 01037 - (busy)         &lt;--- vamos usar esse primeiro mais tarde
 0055fd38 0221 0221 [00] 0055fd50 01037 - (busy)
 00561f48 0221 0221 [00] 00561f60 01037 - (busy)
 00565260 0221 0221 [00] 00565278 01037 - (busy)
 0056c998 0221 0221 [00] 0056c9b0 01037 - (busy)
 0056daa0 0221 0221 [00] 0056dab8 01037 - (busy)
 0056eba8 0221 0221 [00] 0056ebc0 01037 - (busy)
 00570db8 0221 0221 [00] 00570dd0 01037 - (busy)
 00572fc8 0221 0221 [00] 00572fe0 01037 - (busy)
 005740d0 0221 0221 [00] 005740e8 01037 - (busy)
 0058abc8 0221 0221 [00] 0058abe0 01037 - (busy)
 00595618 0221 0221 [00] 00595630 01037 - (busy)
 00599a38 0221 0221 [00] 00599a50 01037 - (busy)
 0059de58 0(...)
</code></pre>
<p>A listagem do depurador nos dá o endereço onde o chunk foi alocado no heap e o endereço devolvido para o usuário, onde colocamos nossas tralhas. Através de ambos é possível trackear a pilha da chamada que alocou cada pedaço de memória. Isso, claro, se previamente tivermos habilitado essa informação através do GFlags.aspx):</p>
<pre><code>0:004&gt; !heap -p -a 00558600
 address 00558600 found in
 _HEAP @ 670000
 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state
 00558600 0221 0000 [00] 00558618 01037 - (busy)
 Trace: b7a24
 7722dfa2 ntdll!RtlAllocateHeap+0x00000274
 5b628343 MSVCR100D!_heap_alloc_base+0x00000053
 5b63697c MSVCR100D!_nh_malloc_dbg+0x000002dc
 5b63671f MSVCR100D!_nh_malloc_dbg+0x0000007f
 5b6366cc MSVCR100D!_nh_malloc_dbg+0x0000002c
 5b639c5b MSVCR100D!malloc+0x0000001b
 5b627db1 MSVCR100D!operator new+0x00000011
 e84dee MemoryConsumption!operator new[]+0x0000000e
 e818be MemoryConsumption!InsertItems+0x0000004e
 7679339a kernel32!BaseThreadInitThunk+0x0000000e
 771e9ef2 ntdll!__RtlUserThreadStart+0x00000070
 771e9ec5 ntdll!_RtlUserThreadStart+0x0000001b
</code></pre>
<p>Dessa forma temos onde cada memória foi alocada, o que nos dará uma informação valiosa, dependendo qual o tipo de problema estamos tentando resolver.</p>
<pre><code>0:004&gt; u e818be
MemoryConsumption!InsertItems+0x4e [c:\...\memoryconsumption.cpp @ 18]:
00e818be 83c404 add esp,4
00e818c1 898514ffffff mov dword ptr [ebp-0ECh],eax
00e818c7 8b9514ffffff mov edx,dword ptr [ebp-0ECh]
00e818cd 8955e0 mov dword ptr [ebp-20h],edx
00e818d0 8b45f8 mov eax,dword ptr [ebp-8]
00e818d3 8b08 mov ecx,dword ptr [eax]
00e818d5 51 push ecx
00e818d6 8b45ec mov eax,dword ptr [ebp-14h]
</code></pre>
<p>Outra informação relevante é o que está gravado na memória, que pode nos dar insights de que tipo de objeto estamos lidando:</p>
<pre><code>0:004&gt; db 00558618
00558618 c0 b7 8c 0b 98 03 55 00-00 00 00 00 00 00 00 00 ......U.........
00558628 13 10 00 00 01 00 00 00-15 94 00 00 fd fd fd fd ................
00558638 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
00558648 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
00558658 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
00558668 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
00558678 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
00558688 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ
</code></pre>
<p>Não é o caso, mas vamos supor que fosse um objeto/tipo conhecido. Poderíamos simplesmente &ldquo;importar&rdquo; o tipo diretamente do PDB que estamos para modelar a memória que encontramos em volta. Mais detalhes em outro artigo.</p>
<ul>
<li>
<p>CreateThread.aspx). Cria uma nova linha de execução.</p>
</li>
<li>
<p>WaitForMultipleObjects.aspx). Pode aguardar diferentes linhas de execução terminarem.</p>
</li>
<li>
<p>std::list. Lista na STL para inserir/remover objetos na frente e atrás (ui).</p>
</li>
<li>
<p>Initialize.aspx), Enter.aspx) e LeaveCriticalSection.aspx). Uma maneira simples de criar blocos de entrada atômica (apenas uma thread entra por vez).</p>
</li>
<li>
<p>memset. Se você não sabe usar memset, provavelmente não entendeu nada desse artigo.</p>
</li>
</ul>

            

          </div>

        <div class="taglist">
            
    
      <a href="/categories/code">code</a> 
      <a href="/tags/draft">draft</a> 
    
    <a href="https://twitter.com/intent/tweet?text=Era%20um%20belo%20dia%20em%20um%20ambiente%20de%20processamento%20fict%c3%adcio%20de%20filas%20fict%c3%adcias%20e%20threads%20fict%c3%adcias.%20Eis%20um%20belo%20c%c3%b3digo%20com...%20http%3a%2f%2fwww.caloni.com.br%2fconsumo-abusivo-de-memoria%2f from @caloni " style="text-decoration: underline;" title="Twitter">twitter</big></a>


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/sobrecarga-de-funcao-as-avessas/">Sobrecarga de função às avessas<span class="icon"><i class="fa fa-arrow-right"></i></span></a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/coletando-dumps-automaticamente/"><span class="icon"><i class="fa fa-arrow-left"></i></span>Coletando dumps automaticamente</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
