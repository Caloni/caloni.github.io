<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - C Resolve Tudo Clos</title>
  <meta name="author" content="" />
  <meta name="description"
        content="Continuando nossa série, conforme sugerido pelo @colemaker do grupo C/C&#43;&#43;/42/Império do Brasil, a próxima ideia a ser implementada em C é o sistema polimórfico de chamadas do Lisp orientado a objetos...."/>

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta itemprop="name" content="C Resolve Tudo Clos"/>
  <meta itemprop="description"
        content="Continuando nossa série, conforme sugerido pelo @colemaker do grupo C/C&#43;&#43;/42/Império do Brasil, a próxima ideia a ser implementada em C é o sistema polimórfico de chamadas do Lisp orientado a objetos...."/>
  <meta itemprop="image"
        content=""/>

  
  <meta property="og:title" content="C Resolve Tudo Clos"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/c-resolve-tudo-clos/"/>
  <meta property="og:image"
        content=""/>
  <meta property="og:description"
        content="Continuando nossa série, conforme sugerido pelo @colemaker do grupo C/C&#43;&#43;/42/Império do Brasil, a próxima ideia a ser implementada em C é o sistema polimórfico de chamadas do Lisp orientado a objetos...."/>
  <meta property="og:site_name" content="Blogue do Caloni"/>
  <meta property="article:published_time"
        content="2019-05-17T00:00:00&#43;00:00"/>
  <meta property="article:section" content="post"/>

  
  
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site"
        content=""/>
  <meta name="twitter:title" content="C Resolve Tudo Clos"/>
  <meta name="twitter:description"
        content="Continuando nossa série, conforme sugerido pelo @colemaker do grupo C/C&#43;&#43;/42/Império do Brasil, a próxima ideia a ser implementada em C é o sistema polimórfico de chamadas do Lisp orientado a objetos...."/>
  <meta name="twitter:creator"
        content=""/>
  <meta name="twitter:image:src"
        content="
                     /images/movies.png
                   "/>

  
  <link href="" rel="alternate" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">
  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/brand.svg">
        <div class="title is-6">&nbsp;Blogue do Caloni</div>
      </a>

      
      <label class="button navbar-burger is-white" for="navbar-burger-state">
        <span></span>                               
        <span></span>
        <span></span>
      </label>
    </div>

    
    <input type="checkbox" id="navbar-burger-state"/>

    <div class="navbar-menu">
      <div class="navbar-end" style="padding: 10px;">
      <big><b>
       <a title="posts dessa categoria" href="/categories/blog">blog</a>  <a title="posts dessa categoria" href="/categories/cinema">cinema</a>  <a title="posts dessa categoria" href="/categories/code">code</a> 
      </big></b>
      </div>
    </div>

  </div>
</nav>


      
      <div class="container">
        <p class="title">C Resolve Tudo Clos</p>

        <p class="subtitle">
<i>

    <a href="https://github.com/Caloni/blog/blob/master/content/post/c-resolve-tudo-clos.md" title="source">
    2019-05-17
    </a>

</p>

        <div class="taglist">
            <i>Este ainda é um rascunho publicado prematuramente e está sujeito a mudanças substanciais.</i>

        </div>

        

        
          <div class="content">
            
              <p>Continuando nossa série, conforme sugerido pelo @colemaker do grupo C/C++/42/Império do Brasil, a próxima ideia a ser implementada em C é o sistema polimórfico de chamadas do Lisp orientado a objetos. Esse sistema permite realizar a seguinte manobra:</p>
<pre><code>(defgeneric thing(x y))

;; BAR inhherits FOO
(defclass foo()())

(defmethod thing ((x foo) (y foo))
  (format t &quot;Both are of type FOO~%&quot;))

(def method thing ((x bar) (y foo))
  (format t &quot;X is a BAR, Y is a FOO. Next...~%&quot;)
  (call-next-method))

(def method thing ((x foo) (y bar))
  (format t &quot;X is a FOO, Y is a BAR. Next...~%&quot;)
  (call-next-method))

(defun test-dispatch ()
  (let ((x (make-instance 'bar))
        (y (make-instance 'bar)))
    (thing x y)))

output:
CL-USER&gt; (test-dispatch)
X is a BAR, Y is a FOO. Next...
X is a FOO, Y is a BAR. Next...
Both are of type FOO
NIL
</code></pre>
<p>O aspecto-chave aqui, conforme eu descobri, é implementar a estratégia de prioridades entre as sobrecargas dos métodos de acordo com os tipos passados. Analisando bem por cima devemos sempre priorizar os métodos com os tipos mais específicos e ir realizando underpromotion até chegarmos no menos específico (se houver).</p>
<p>A implementação está no GitHub. Para o sistema de tipos em C nada como fazer do zero:</p>
<pre><code>/* defclass(foo, cclass_instance); */
typedef struct foo_instance { cclass_instance type; } foo_instance;
static foo_instance foo = { &quot;foo&quot; };

/* defclass(bar, foo); */
typedef struct bar_instance { cclass_instance type; } bar_instance; 
static bar_instance bar = { &quot;bar&quot; };
</code></pre>
<p>As estruturas estão usando STL. O quê? Mas não era C? Sim, você tem toda razão. Porém, estou usando uma lib mais conhecida. Há milhares de libs containers em C para você escolher para trocar a implementação. Lembre-se que o mais importante não é ser purista, mas atingir os objetivos. Como eventualmente veremos nessa série de artigos, o próprio C++ e toda a sua biblioteca pode ser implementada em C. Este é apenas um atalho para fins didáticos e de produtividade (como eu já falei, produtividade não é o foco aqui, mas enxergar por debaixo dos panos).</p>
<p>Inicialmente feito em STL pela produtividade, a solução atual no GitHub é feita inteiramente em C usando a glib (lib comum em Linux com estrutura de dados, etc). O legal dessa biblioteca é que ela tem 20 anos (desde 1998) e já foi muito usada e testada, além de possuir estruturas e algoritmos simples que fazem parte do pacote básico de qualquer programador, como arrays, strings, hash tables.</p>
<pre><code>#include &quot;cclos.h&quot;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;gmodule.h&gt;


typedef GPtrArray Argv;

typedef struct _Method
{
    void* fun;
    Argv* argv;
} Method;

typedef void (*FP_Argv0)();
typedef void (*FP_Argv1)(cclass_instance*);
typedef void (*FP_Argv2)(cclass_instance*, cclass_instance*);
typedef void (*FP_Argv3)(cclass_instance*, cclass_instance*, cclass_instance*);

typedef GHashTable ClassMap;
typedef GPtrArray Methods;
typedef GHashTable MethodMap;

static ClassMap* g_classes;
static MethodMap* g_methods;
static Methods* g_calledMethods;


void cdefgeneric_initialize()
{
    g_classes = g_hash_table_new(g_str_hash, g_str_equal);
    g_methods = g_hash_table_new(g_str_hash, g_str_equal);
}


Method* method_new(void* fun, Argv* argv)
{
    Method* ret = (Method*)malloc(sizeof(Method));
    if (ret)
    {
        ret-&gt;fun = fun;
        ret-&gt;argv = argv ? argv : g_ptr_array_new();
    }
    return ret;
}

Argv* method_free(Method* method, gboolean free_seg)
{
    Argv* ret = free_seg ? g_ptr_array_free(method-&gt;argv, TRUE), NULL : method-&gt;argv;
    free(method);
    return ret;
}


const char* defclass(const char* name, const char* deriv)
{
    gboolean insertOk = g_hash_table_insert(g_classes, (gpointer*)name, (gpointer*)deriv);
    return name;
}

#define extractargv(argv, argc) \
        va_list vl; \
        va_start(vl, argc); \
        for (int i = 0; i &lt; argc; ++i) \
        { \
            cclass_instance* arg = va_arg(vl, cclass_instance*); \
            g_ptr_array_add(argv, arg); \
        }

void defmethod(const char* name, void* fun, int argc, ...)
{
    Method* method = method_new(fun, NULL);
    Methods* methods = (Methods*)g_hash_table_lookup(g_methods, name);
    extractargv(method-&gt;argv, argc);
    if (!methods)
    {
        methods = g_ptr_array_new();
        g_hash_table_insert(g_methods, (gpointer) name, (gpointer) methods);
    }
    g_ptr_array_add(methods, method);
}

void callmethod(const char* name, Method* method)
{
    g_ptr_array_add(g_calledMethods, (gpointer) method-&gt;fun);
    cclass_instance** argv = (cclass_instance * *)method-&gt;argv-&gt;pdata;

    if (method-&gt;argv-&gt;len == 0)
    {
        FP_Argv0 fun = (FP_Argv0)method-&gt;fun;
        fun();
    }
    else if (method-&gt;argv-&gt;len == 1)
    {
        FP_Argv1 fun = (FP_Argv1)method-&gt;fun;
        fun(argv[0]);
    }
    else if (method-&gt;argv-&gt;len == 2)
    {
        FP_Argv2 fun = (FP_Argv2)method-&gt;fun;
        fun(argv[0], argv[1]);
    }
    else if (method-&gt;argv-&gt;len == 3)
    {
        FP_Argv3 fun = (FP_Argv3)method-&gt;fun;
        fun(argv[0], argv[1], argv[2]);
    }
}

Method* find_method_by_fun(const char* name, void* fun)
{
    Method* method = NULL;
    Methods* methods = (Methods*) g_hash_table_lookup(g_methods, name);
    if (methods)
    {
        Method** meths = (Method**)methods-&gt;pdata;
        guint i = 0;
        while (i &lt; methods-&gt;len)
        {
            Method* m = meths[i];
            if (m-&gt;fun == fun)
            {
                method = m;
                break;
            }
            ++i;
        }
    }
    return method;
}

int calcdistance_arg(cclass_instance* arg, cclass_instance* underpromo)
{
    int ret = 0;
    char* promo = (char*)arg-&gt;type;

    while (strcmp(promo, underpromo-&gt;type) != 0)
    {
        promo = (char*)g_hash_table_lookup(g_classes, (gpointer*)promo);
        if (!promo || strlen(promo) == 0)
        {
            ret = -1;
            break;
        }
        ++ret;
    }

    return ret;
}

int calcdistance(cclass_instance** args, cclass_instance** underpromo, int len)
{
    int ret = 0;
    for (int i = 0; i &lt; len; ++i)
    {
        int dist = calcdistance_arg(args[i], underpromo[i]);
        if (dist == -1) return -1;
        ret += dist;
    }
    return ret;
}

void call_next_method(const char* name, int argc, ...)
{
    Method* method = method_new(NULL, NULL);
    extractargv(method-&gt;argv, argc);

    int nextdist = 666;
    Methods* methods = (Methods*)g_hash_table_lookup(g_methods, name);
    if (methods)
    {
        guint i = 0;
        while( i &lt; methods-&gt;len )
        {
            Method* m = ((Method * *)methods-&gt;pdata)[i];
            gboolean alreadyCalled = FALSE;
            guint cms = 0;

            while (cms &lt; g_calledMethods-&gt;len)
            {
                void* fun = ((void **)g_calledMethods-&gt;pdata)[cms];
                if (fun == m-&gt;fun)
                {
                    alreadyCalled = TRUE;
                    break;
                }
                ++cms;
            }

            if ( ! alreadyCalled)
            {
                int dist = -1;

                if (method-&gt;argv-&gt;len == m-&gt;argv-&gt;len)
                    dist = calcdistance((cclass_instance * *)method-&gt;argv-&gt;pdata, (cclass_instance * *)m-&gt;argv-&gt;pdata, method-&gt;argv-&gt;len);

                if (dist &gt;= 0 &amp;&amp; dist &lt; nextdist)
                {
                    if (dist &lt; nextdist)
                    {
                        method-&gt;fun = m-&gt;fun;
                        nextdist = dist;
                    }
                }
            }

            ++i;
        }

        if (method-&gt;fun)
            callmethod(name, method);
    }
}

void call(const char* name, int argc, ...)
{
    g_calledMethods = g_ptr_array_new();

    Method* method = method_new(NULL, NULL);
    extractargv(method-&gt;argv, argc);

    int nextdist = 666;
    Methods* methods = g_hash_table_lookup(g_methods, name);
    if (methods)
    {
        guint i = 0;
        while( i &lt; methods-&gt;len )
        {
            Method* m = ((Method * *)methods-&gt;pdata)[i];
            int dist = -1;

            if (method-&gt;argv-&gt;len == m-&gt;argv-&gt;len)
                dist = calcdistance((cclass_instance * *)method-&gt;argv-&gt;pdata, (cclass_instance * *)m-&gt;argv-&gt;pdata, method-&gt;argv-&gt;len);

            if (dist &gt;= 0 &amp;&amp; dist &lt; nextdist)
            {
                if (dist &lt; nextdist)
                {
                    method-&gt;fun = m-&gt;fun;
                    nextdist = dist;
                }
            }

            ++i;
        }

        if (method-&gt;fun)
            callmethod(name, method);
    }

    method_free(method, TRUE);
}
</code></pre>
<p>O código é bem simples. Mapas e listas com strings e ponteiros para organizar as estruturas por detrás do sistema de tipos que estamos implementando e seus métodos sobrecarregados. Cada método possui um nome, um endereço de ponteiro e o número dos seus argumentos. Todos os argumentos são do tipo polimórfico, seguindo o que provavelmente existe por detrás da própria implementação do Lisp.</p>
<p>O código que utiliza a clos.c é bem direto e enxuto. Como no Lisp.</p>
<pre><code>#include &quot;cclos.h&quot;
#include &lt;stdio.h&gt;

/* defclass(foo, cclass_instance); */
typedef struct foo_instance { cclass_instance type; } foo_instance;
static foo_instance foo = { &quot;foo&quot; };

/* defclass(bar, foo); */
typedef struct bar_instance { cclass_instance type; } bar_instance; 
static bar_instance bar = { &quot;bar&quot; };

void test_dispatch()
{
    bar_instance x = bar;
    bar_instance y = bar;
    call(&quot;thing&quot;, 2, &amp;x, &amp;y);
}

void thing_foo_foo(cclass_instance* x, cclass_instance* y)
{
    printf(&quot;Both are of type FOO\n&quot;);
}

void thing_bar_foo(cclass_instance* x, cclass_instance* y)
{
    printf(&quot;X is BAR, Y is FOO. Next...\n&quot;);
    call_next_method(&quot;thing&quot;, 2, x, y);
}

void thing_foo_bar(cclass_instance* x, cclass_instance* y)
{
    printf(&quot;X is FOO, Y is BAR. Next...\n&quot;);
    call_next_method(&quot;thing&quot;, 2, x, y);
}

int main()
{
    cdefgeneric_initialize();
    defclass(&quot;foo&quot;, &quot;cclass&quot;);
    defclass(&quot;bar&quot;, &quot;foo&quot;);
    defmethod(&quot;thing&quot;, &amp;thing_foo_foo, 2, &amp;foo, &amp;foo);
    defmethod(&quot;thing&quot;, &amp;thing_bar_foo, 2, &amp;bar, &amp;foo);
    defmethod(&quot;thing&quot;, &amp;thing_foo_bar, 2, &amp;foo, &amp;bar);
    test_dispatch();
}
</code></pre>
<p>Futuros posts sobre C Resolve Tudo poderão utilizar a glib ou qualquer outra. Uma outra vantagem da linguagem C é que sua biblioteca padrão é muito enxuta, sendo fácil de ter disponível em seu ambiente um compilador C com a clib, e em cima dela você pode utilizar qualquer biblioteca de sua escolha para estruturas e algoritmos mais complexos. Ou fazer a sua própria.</p>

            

          </div>

        <div class="taglist">
            
    
        
        
            <a href="https://github.com/Caloni/cdefgeneric" style="text-decoration: underline;">clos()</a>
        
        
        
        
        <a href="/blob/master/data/post/c-resolve-tudo-clos.toml" style="text-decoration: underline;">references</a>
    
      [<a href="/categories/code">code</a>] 
      [<a href="/tags/draft">draft</a>] 
    
    <a href="https://twitter.com/intent/tweet?text=Continuando%20nossa%20s%c3%a9rie%2c%20conforme%20sugerido%20pelo%20%40colemaker%20do%20grupo%20C%2fC%2b%2b%2f42%2fImp%c3%a9rio%20do%20Brasil%2c%20a%20pr%c3%b3xima%20ideia%20a%20ser...%20http%3a%2f%2fwww.caloni.com.br%2fc-resolve-tudo-clos%2f from @caloni " style="text-decoration: underline;" title="Twitter">twitter</big></a>


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/barcelona/">Barcelona<span class="icon"><i class="fa fa-arrow-right"></i></span></a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/c-resolve-tudo/"><span class="icon"><i class="fa fa-arrow-left"></i></span>C Resolve Tudo: Orientação a Objetos (com Polimorfismo)</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
