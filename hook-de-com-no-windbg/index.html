<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  
  
      
  
      
  

  <head>
  <meta charset="utf-8" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Hook de COM no WinDbg</title>
  <meta name="author" content="" />

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta property="og:title" content="Hook de COM no WinDbg"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/hook-de-com-no-windbg/"/>
  <meta property="og:image"
        content="/img/author.jpg"/>
  <meta property="og:description"
        content="Continuando com o tema hooks no WinDbg, vamos aqui &quot;hookear&quot; e analisar as chamadas de métodos de um objeto COM. O que será feito aqui é o mesmo experimento feito para uma palestra de..."/>

  
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/img/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">

  <div class="container">

    <div class="navbar-brand">
        <img alt="Brand" src="/img/brand.svg">
        &nbsp;
        <a class="navbar-item" title="Go to Home" href="/">
            <div class="is-6">Blogue do Caloni</div>
        </a>
    </div>

    

  </div>
</nav>


      
      <div class="container">
        <p class="title">

Hook de COM no WinDbg

</p>

        <p class="subtitle">

  Wanderley Caloni,
  
    
  
    
  
  2007-09-18<a href="https://github.com/Caloni/blog/blob/master/content/posts/hook-de-com-no-windbg.md">.</a>

</p>

        

        
          <div class="content">

            
              <p>Continuando com o tema <a href="http://www.caloni.com.br/blog/?s=hook+WinDbg"><em>hooks</em> no WinDbg</a>, vamos aqui &quot;hookear&quot; e analisar as chamadas de métodos de um objeto COM. O que será feito aqui é o mesmo experimento feito para uma palestra de engenharia reversa que apresentei há um tempo atrás [1], mas com as opções de <em>pause</em>, <em>rewind</em>, <em>replay</em> e câmera lenta habilitadas.</p>
<p>Antes de começar, se você não sabe nada sobre COM, não deveria estar aqui, mas <a href="http://search.msdn.microsoft.com/search/Default.aspx?brand=msdn&amp;locale=en-us&amp;query=component+object+model">aqui</a>, <a href="http://www.1bit.com.br/content.1bit/weblog/sopa_de_letrinhas_com">aqui</a> e <a href="http://compare.buscape.com.br/categoria?id=3482&amp;lkout=1&amp;kw=COM+Don+Box&amp;site_origem=1293522">aqui</a>.</p>
<p>Pra começar, vamos dar uma olhada na representação da interface IUnknown em UML e em memória:</p>
<p><a href="/images/vtable_layout.png"><img src="http://i.imgur.com/qPjEQSJ.png" alt="Layout da VTable"></a></p>
<p>Como podemos ver, para implementar o polimorfismo, os endereços das funções virtuais de uma classe são colocados em uma tabela, a chamada <em>vtable</em>, famosa tanto no COM quanto no C++. Existe uma tabela para cada classe-base polimórfica, e não para cada objeto. Se fosse para cada objeto não faria sentido deixar esses endereços &quot;do lado de fora&quot; do leiaute. E não seria nada simples e elegante fazer uma cópia desse objeto.</p>
<p>Assim, quando você chama uma função virtual de um objeto, o código em <em>assembly</em> irá chamar o endereço que estiver na posição correspondente ao método chamado dentro da <em>vtable</em>. Se você chama AddRef, por exemplo, que é o segundo método na tabela, será chamado o endereço da posição número dois. Com isso, mesmo desconhecendo de que tipo é o objeto a função certa será chamada, porque existe um ponteiro para essa tabela no início da interface.</p>
<p>Sabendo de tudo isso, agora sabemos como teoricamente proceder para colocar uns <em>breakpoints</em> nessas chamadas:</p>
<p><a href="/images/vtable_breakpoints.png"><img src="http://i.imgur.com/sElYmOP.png" alt="Breakpoints na VTable"></a></p>
<p>Note que o <em>breakpoint</em> não é colocado dentro da tabela, o que seria absurdo. Uma tabela são dados e dados geralmente não são executados (eu disse geralmente). Porém, usamos a tabela para saber onde está o começo da função para daí colocar a parada nesse endereço, que por fazer parte do código da função é (quem diria!) executado.</p>
<p>Agora vamos sair da teoria e tentar fazer as coisas mais ou menos parecidas na prática.</p>
<h4 id="imalloc">IMalloc</h4>
<p>O nosso sorteado desse artigo foi o IMalloc, a interface de alocação de memória do COM, que existe desde a época em que não se sabia direito pra que esse tal de COM iria servir. O IMalloc é definido como se segue:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">MIDL_INTERFACE(<span style="color:#e6db74">&#34;00000002-0000-0000-C000-000000000046&#34;</span>)
IMalloc : <span style="color:#66d9ef">public</span> IUnknown
{
	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>STDMETHODCALLTYPE Alloc( 
	<span style="color:#75715e">/* [in] */</span> SIZE_T cb) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>STDMETHODCALLTYPE <span style="color:#a6e22e">Realloc</span>( 
	<span style="color:#75715e">/* [in] */</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pv,
	<span style="color:#75715e">/* [in] */</span> SIZE_T cb) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> STDMETHODCALLTYPE <span style="color:#a6e22e">Free</span>( 
	<span style="color:#75715e">/* [in] */</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pv) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">virtual</span> SIZE_T STDMETHODCALLTYPE <span style="color:#a6e22e">GetSize</span>( 
	<span style="color:#75715e">/* [in] */</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pv) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> STDMETHODCALLTYPE <span style="color:#a6e22e">DidAlloc</span>( 
	<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>pv) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> STDMETHODCALLTYPE <span style="color:#a6e22e">HeapMinimize</span>(<span style="color:#66d9ef">void</span>) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
};
 

</code></pre></div><p>Nesse experimento, como iremos interceptar quando alguém aloca ou desaloca memória, nossos alvos são os métodos Alloc e Free. Para saber onde eles estão na tabela, é só contar, começando pelos métodos do IUnknown, que é de quem o IMalloc deriva. Se houvessem mais derivações teríamos que contar da primeira interface até a última. Portanto: QueryInterface um, AddRef dois, Release três, Alloc quatro, Realloc cinco, Free seis. OK. Contar foi a parte mais fácil.</p>
<p>Agora iremos precisar interceptar primeiro a função que irá retornar essa interface, pois do contrário não saberemos onde fica a <em>vtable</em>. Nesse caso, a função é a <a href="http://msdn2.microsoft.com/en-us/library/ms693395.aspx">ole32!CoGetMalloc</a>. Muitas vezes você irá usar a <a href="http://msdn2.microsoft.com/en-us/library/ms680701.aspx">ole32!CoCreateInstance(Ex)</a> ou a <a href="http://msdn2.microsoft.com/en-us/library/ms684007.aspx">CoGetClassObject</a> diretamente na DLL que pretende interceptar. Outras vezes, você receberá o ponteiro em alguma ocasião diversa. O importante é conseguir o ponteiro de alguma forma.</p>
<p>Nesse exemplo iremos obter o ponteiro através de um aplicativo de teste trivial, ignorando todas aquelas proteções <em>antidebugging</em> que podem estar presentes no momento da reversa, feitos por alguém que <a href="http://www.caloni.com.br/blog/?s=antidebug">lê meu blog</a> (quanta pretensão!):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">/** @brief A stupid sample for show WinDbg COM hooking!
</span><span style="color:#75715e">* @author Wanderley Caloni (wanderley@caloni.com.br)
</span><span style="color:#75715e">*/</span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;objbase.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;objidl.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	CoInitialize(NULL); <span style="color:#75715e">// initialize the COM library
</span><span style="color:#75715e"></span>
	IMalloc<span style="color:#f92672">*</span> malloc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">//IMalloc interface pointer
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// if we get the interface...
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span>( SUCCEEDED(CoGetMalloc(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>malloc)) )
	{
		<span style="color:#75715e">// allocate 4KB (use your HP hyper-plus to make the necessary reckons)
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span>( <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> pAlloc <span style="color:#f92672">=</span> malloc<span style="color:#f92672">-&gt;</span>Alloc(<span style="color:#ae81ff">0x1000</span>) )
		{
			malloc<span style="color:#f92672">-&gt;</span>Free(pAlloc); <span style="color:#75715e">// everthing allocated, must be released =)
</span><span style="color:#75715e"></span>		}

		malloc<span style="color:#f92672">-&gt;</span>Release(); <span style="color:#75715e">// decrement the reference counter for the COM object we created
</span><span style="color:#75715e"></span>	}

	CoUninitialize(); <span style="color:#75715e">// we don&#39;t need the COM library anymore
</span><span style="color:#75715e"></span>} 

</code></pre></div><p>Vamos fazer de conta que é desnecessário dizer como se compila o fonte acima.</p>
<pre><code>cl /c imalloc-hook.cpp
link imalloc-hook.obj ole32.lib
</code></pre>
<h4 id="agora-é-só-depurar">Agora é só depurar!</h4>
<p>WinDbg. Na opção &quot;File, Open Executable&quot; selecionamos a nossa vítima, cujo nome você escolhe na hora de compilar o fonte acima. Aqui, ele irá chamar imalloc-hook.exe. A seguir, colocamos um <em>breakpoint</em> na função da ole32, mandamos rodar, e esperamos a parada do código:</p>
<pre><code>0:000&gt; bp ole32!CoGetMalloc
0:000&gt; bl
0 e 774ddcf8     0001 (0001)  0:**** ole32!CoGetMalloc
0:000&gt; g
Breakpoint 0 hit
ModLoad: 76360000 7637d000   C:WINDOWSsystem32IMM32.DLL
...
ModLoad: 746e0000 7472b000   C:WINDOWSsystem32MSCTF.dll
eax=0012ff7c ebx=00000000 ecx=775e67f0 edx=775e67f0 esi=00000001 edi=00403374
eip=774ddcf8 esp=0012ff70 ebp=0012ffc0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ole32!CoGetMalloc:
774ddcf8 8bff            mov     edi,edi
</code></pre>
<p>Maravilha. Alguém chamou a função que queríamos (quem será?). Agora podemos dar uma olhada na pilha e no <a href="http://msdn2.microsoft.com/en-us/library/ms693395.aspx">protótipo da CoGetMalloc</a>:</p>
<pre><code>HRESULT CoGetMalloc(DWORD
</code></pre>
<p>dwMemContext</p>
<pre><code>, LPMALLOC *
</code></pre>
<p>ppMalloc</p>
<pre><code>);
0:000&gt; dd esp L3
0012ff70
</code></pre>
<p>0040101d000000010012ff7c</p>
<pre><code> ;
</code></pre>
<p>retorno - dwMemContext - ppMalloc</p>
<pre><code>0:000&gt; dd poi(esp+8) L1
0012ff7c  00000000
</code></pre>
<p>Como podemos ver nos parâmetros da pilha, o nosso chamador passou certinho o valor 1 no campo reservado e um ponteiro no segundo parâmetro para uma área onde, se der tudo certo, será escrito o endereço de um IMalloc, que podemos chamar carinhosamente de <strong><em>this</em></strong>. De início vemos que a variável está zerada. Agora vamos executar a função até a saída e examinar os resultados.</p>
<pre><code>0:000&gt; bp /1 /c @$csp @$ra;g ; esse é o resultado do comando &quot;Debug, Step Out&quot;
Breakpoint 1 hit
eax=00000000 ebx=00000000 ecx=775e6034 edx=775e67f0 esi=00000001 edi=00403374
eip=0040101d esp=0012ff7c ebp=0012ffc0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
IMalloc+0x101d:
0040101d 85c0            test    eax,eax
0:000&gt; dd 0012ff7c L1     ; o endereço da variável
0012ff7c  775e6034        ; o endereço da interface
0:000&gt; dd 775e6034 L1     ; onde está a vtable?
775e6034  775e600c        ; o endereço da vtable
0:000&gt; dd 775e600c
775e600c  77562cfb 774dcf29 774dcf29 774dd00d ; a vtable ! ! !
775e601c  774dd665 774dcfe8 774dd400 77562d46 ; a vtable ! ! !
775e602c  77562d6e 775e6034 775e600c 774c0000 ; a vtable ! ! !
775e603c  00000000 00000000 00154d70 774cbff4
775e604c  00000000 00000000 00000000 00000000
...
</code></pre>
<p>E não é que tudo deu certo? A variável foi preenchida, e partir dela demos uma espiadela nos endereços das funções da <em>vtable</em>. Nós pegamos o valor da variável que foi preenchida (o endereço da interface) e obtemos os seus primeiros 4 bytes (o endereço da <em>vtable</em>) e listamos o seu conteúdo (a própria <em>vtable</em>!). Agora basta usarmos o resultados de nossas contagens lá em cima e colocarmos os <em>breakpoints</em> nas funções corretas. E mandar rodar. E analisar os resultados.</p>
<pre><code>0:000&gt; bp 774dd00d &quot;.echo IMalloc::Alloc&quot;
0:000&gt; bp 774dcfe8 &quot;.echo IMalloc::Free&quot;
0:000&gt; g
IMalloc::Alloc
eax=775e6034 ebx=00000000 ecx=775e600c edx=774dd00d esi=00000001 edi=00403374
eip=774dd00d esp=0012ff70 ebp=0012ffc0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ole32!IsValidIid+0xe4:
774dd00d 8bff            mov     edi,edi
0:000&gt; dd esp L3
0012ff70  &lt;strong&gt;00401031 775e6034 00001000&lt;/strong&gt; ; o this é nosso, e foi pedido para alocar 4KB (0x1000)
0:000&gt; bp /1 /c @$csp @$ra;g ; Step Out para pegar o retorno
Breakpoint 3 hit
eax=001597f0 ebx=00000000 ecx=7c9106eb edx=00150608 esi=00000001 edi=00403374
eip=00401031 esp=0012ff7c ebp=0012ffc0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
IMalloc+0x1031:
00401031 85c0            test    eax,eax
0:000&gt; reax
eax=001597f0 ; esse é o endereço da memória alocada
g
IMalloc::Free
eax=774dcfe8 ebx=00000000 ecx=775e6034 edx=775e600c esi=00000001 edi=00403374
eip=774dcfe8 esp=0012ff70 ebp=0012ffc0 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
ole32!IsValidIid+0xbf:
774dcfe8 8bff            mov     edi,edi
0:000&gt; dd esp L3
0012ff70  &lt;strong&gt;00401041 775e6034 001597f0&lt;/strong&gt; ; nosso this e endereço alocado (pedindo pra desalocar)
g ; é isso aí
</code></pre>
<p>Note que a função pode eventualmente ser chamada internamente (pelo próprio objeto) ou até por outro objeto que não estamos interessados em interceptar (lembre-se que os métodos de uma classe são compartilhados por todos os objetos). Por isso é importante sempre dar uma olhada no primeiro parâmetro, que é o <strong><em>this</em></strong> que obtemos primeiramente.</p>
<p>Com isso termina o nosso pequeno experimento de como é possível interceptar chamadas COM simplesmente contando e usando o WinDbg. OK, talvez um pouquinho a mais, mas nada de quebrar a cabeça.</p>
<p>[1] Engenharia Reversa para Principiantes:</p>
<!-- raw HTML omitted -->

            

          </div>

        <div class="taglist">
            
    
      <a href="/tags/draft">draft</a>  <a href="/tags/code">code</a> 
    <a class="externalgray" href="https://t.me/bloguedocalonidiscuss">discuss</a>


        </div>

        <div class="navigation-bottom">
            <span class="next-in-section"><a href="http://www.caloni.com.br/a-mobilidade-das-variaveis-no-printf/">&#x25C1; A mobilidade das variáveis no printf</a></span>
<span class="prev-in-section"><a href="http://www.caloni.com.br/aquisicao-de-recurso-e-inicializacao/">&#x25B7; Aquisição de recurso é inicialização</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2021<a href="https://github.com/Caloni/blog">.</a> </i></span>
  </div>
</footer>

  </body>

</html>
