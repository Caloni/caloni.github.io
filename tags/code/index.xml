<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>code on Blogue do Caloni</title>
    <link>http://www.caloni.com.br/tags/code/</link>
    <description>Recent content in code on Blogue do Caloni</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Sun, 05 Jul 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.caloni.com.br/tags/code/" rel="self" type="application/rss+xml" />
    
     
        <item>
  <title>Close Remote Socket</title>
  <link>http://www.caloni.com.br/close-remote-socket/</link>
  <pubDate>2020-07-05</pubDate>
  
  <guid>http://www.caloni.com.br/close-remote-socket/</guid>
  <description>&lt;p&gt;I got used to close sockets in Windows using TCP View, but I haven&#39;t learned yet how to do this in Linux. Some Google and now I know. It is kinda simple in terminal mode, as any task a programmer needs to do in your system.&lt;/p&gt;
&lt;p&gt;You just need to find the process using netstat, find the socket descriptor using lsof, debug the process with gdb, close the socket using call command, close the debugger. You done. How simple is that, right?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Find Path ou Por Que O Vcpkg Não Colocou o Path da Minha Biblioteca?</title>
  <link>http://www.caloni.com.br/find-path/</link>
  <pubDate>2020-07-01</pubDate>
  
  <guid>http://www.caloni.com.br/find-path/</guid>
  <description>&lt;p&gt;Algumas bibliotecas portadas para o vcpkg, gerenciador de pacotes direto do fonte da Microsoft, não vêm exatamente como esperamos que elas venham em ambientes mais estáveis como UNIX-like. A GLib, por exemplo, uma biblioteca fenomenal se você deseja trabalhar com um framework puramente em C, está disponível pelo vcpkg através do pacote glib, mas vem encapsulado no namespace unofficial::glib::glib. Isso ocorre porque este não é um port oficial.&lt;/p&gt;
&lt;p&gt;Se você estivesse em um ambiente UNIX precisaria fazer malabarismos com o PkgConfig, o gerenciador de pacotes do GTK (onde a GLib pertence). No entanto, depois de configurado, tudo o que precisaria fazer é incluir uma macro para os diretórios de include e outra macro para os diretórios de libraries e o programa compilaria. No caso do Windows essa macros não existem.&lt;/p&gt;
&lt;p&gt;Lendo a documentação de como instalar o SQLite na documentação do vcpkg me deparei com uma informação até então oculta para mim: &amp;quot;Unlike other platforms, we do not automatically add the include directory to your compilation line by default. If you&#39;re using a library that does not provide CMake integration, you will need to explicitly search for the files and add them yourself using find_path and find_library.&amp;quot;&lt;/p&gt;
&lt;p&gt;Então tá. Feito isso, e rodando o cmake com o -DCMAKE_TOOLCHAIN_FILE passando o diretório de instalação do vcpkg, tudo se resolve. O solution do Visual Studio finalmente consegue encontrar os includes e libraries da glib. Ou qualquer outra biblioteca portada que você queira usar.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>C&#43;&#43; Co Routines</title>
  <link>http://www.caloni.com.br/cpp-co-routines/</link>
  <pubDate>2020-06-21</pubDate>
  
  <guid>http://www.caloni.com.br/cpp-co-routines/</guid>
  <description>&lt;p&gt;Entre os gêneros mais famosos do cinema e da programação está o terror, esse estado mental que se caracteriza pelo medo ou pela aversão a uma situação que envolve a perda de controle. Nesse quesito se encaixam as novas corrotinas que serão adotadas pelo padrão C++.&lt;/p&gt;
&lt;p&gt;No último Caloni Bode Cast Live Privado, aqueles que não estão publicados no YouTube, conversei com um amigo por mais uma vez (já perdi a conta quantas foram) sobre a famigerada implementação, mas acho que dessa vez detectei melhor o que torna essa nova biblioteca de C++ tão repugnante para os amantes de boas soluções de engenharia e do padrão da linguagem.&lt;/p&gt;
&lt;p&gt;A primeira ressalva diz respeito à alocação dinâmica. Ao usar esse modelo de rotinas cooperativas o programador é obrigado a alocar espaço para o estado dinamicamente, o que fere duas premissas da linguagem: o controle absoluto do modelo de execução para o programador e a certeza que ele irá apenas pagar em performance o que ele usar. Se os fãs da linguagem fossem religiosos, eles diriam agora que esta não foi uma decisão muito cristã do comitê.&lt;/p&gt;
&lt;p&gt;Eu continuo defendendo que a linguagem C seja usada caso surjam contra-indicações na prática da STL.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Printf</title>
  <link>http://www.caloni.com.br/printf/</link>
  <pubDate>2020-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/printf/</guid>
  <description>&lt;p&gt;Entre os segredos escondidos das funções básicas da lib padrão da linguagem C o printf e o scanf lideram o ranking. O printf possui a capacidade de alinhamento de colunas das string impressas com tamanho variável. Sabia disso? Pois é, isso não se ensina nas escolas.&lt;/p&gt;
&lt;p&gt;A impressão básica de uma string passada como argumento com printf deve ser feita usando na string de formatação os caracteres &amp;quot;%s&amp;quot;. Agora, se você colocar um sinal de menos entre esses dois caracteres essa string será alinhada à esquerda. Mas o que é direita e esquerda se o tamanho usado pela impressão vai ser exatamente o tamanho da string? Aí é que entra o especificador de tamanho, logo após o opcional sinal de menos e antes do s que determina o tipo string. Dessa forma a string de formatação final para uma string variável alinhada à esquerda em uma coluna de trinta caracteres de tamanho seria &amp;quot;%-30s&amp;quot;.&lt;/p&gt;
&lt;p&gt;Porém, existe um problema com essa abordagem: a string variável pode ter mais de trinta caracteres. Nesse caso existe mais uma opção &amp;quot;escondida&amp;quot; do printf, que é especificar esse trinta em um argumento passado junto dos valores. Para isso basta trocar o número por asterisco e passar o tamanho como se passa qualquer outro valor à função, seguindo a ordem de recebimento. Por exemplo, um printf(&amp;quot;%-30s&amp;quot;, &amp;quot;minha_string&amp;quot;) poderia virar printf(&amp;quot;%-*s&amp;quot;, 30, &amp;quot;minha_string&amp;quot;). Note que agora o tamanho trinta não está mais fixo no código e pode ser uma variável inteira.&lt;/p&gt;
&lt;p&gt;Fiz um exemplo bem sucinto, que pede o nome das branches master e slave de um controle de fonte e imprime as duas no final, alinhando o nome das branches à esquerda e o número de commits de cada uma à direita, incluindo um header. É assim que o printf resolve esse tipo de problema de saída formatada: de maneira simples e elegante, sem inventar moda nem querer &amp;quot;revolucionar&amp;quot; a computação.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Historical Price</title>
  <link>http://www.caloni.com.br/historical-price/</link>
  <pubDate>2020-06-13</pubDate>
  
  <guid>http://www.caloni.com.br/historical-price/</guid>
  <description>&lt;p&gt;Havia um job esta semana de um assunto que me encanta desde a época de investidor: base histórica de cotações. Estamos falando de ações da Bovespa. Na época que era investidor frequente mantinha uma base que era atualizada por um programinha em Java (esqueci o nome), mas nunca tive certeza se os ajustes feitos pelo programa eram os corretos. Surgiu agora a possibilidade de eu realizar código que converte uma base histórica recebida com um minuto por linha em campos divididos por ponto-e-vírgula (o CSV do Windows) para candles de várias periodicidades. E isso justo agora que ando estudando awk. Então não deu outra: usei esta linguagem clássica como ferramenta para esta conversão.&lt;/p&gt;
&lt;p&gt;O código ficou, em minha humilde opinião, elegante e pequeno, pois se aproveita da composição das periodicidades. Ou seja, o período de cinco minutos é a consolidação de cinco linhas de um minuto, mas a de quinze minutos não são quinze linhas de um minuto, mas três de cinco minutos, que já estão sendo calculados a cada cinco linha. E assim por diante. Usando os arrays associativos do awk é possível manter o estado de cada candle até o momento de gerar a saída desejada, que no exemplo que codifiquei ficou como um comando SQL de insert em um banco fictício que grava cada tipo de candle em uma tabela.&lt;/p&gt;
&lt;p&gt;O uso de um array por candle simplificou o código, pois ao criar uma função que manipula o candle que está finalizando e o próximo eu posso simplesmente passá-los como argumentos. Dessa forma eu só preciso compor os filtros de linhas de acordo com o resto da divisão do seu número. No exemplo inicial, o candle de cinco minutos está finalizando quando RN é igual a cinco ou múltiplos de cinco, enquanto um novo candle se inicia em múltiplos de seis.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Awk</title>
  <link>http://www.caloni.com.br/awk/</link>
  <pubDate>2020-06-07</pubDate>
  
  <guid>http://www.caloni.com.br/awk/</guid>
  <description>&lt;p&gt;Meu amigo sugeriu que aprender awk poderia ser útil de várias maneiras. Uma delas para organizar finanças pessoais. Dei uma lida em alguns tutoriais, sendo que o melhor custo benefício foi o Awk in 20 Minutes, de Fred Hebert (ele é o mesmo autor de um livro sobre erlang). Gostei. É sobre tratamento de texto como sed, mas em uma versão estendida e criada na época com a mesma sintaxe de C.&lt;/p&gt;
&lt;p&gt;Por ela ser uma ferramenta antiga usa conceitos antigos, como field e record. Ela foi criada para formatar texto em formato de planilha, ou banco de dados. Um field, ou campo, é uma coluna na planilha, e um record, ou registro, é uma linha dessa planilha. Imagine que você pode usar awk para manipular e extrair dados de qualquer texto que contenha esse padrão, sendo que os detalhes como o separador de campos e registros, por padrão espaço e nova-linha, podem ser alterados no começo do programa.&lt;/p&gt;
&lt;p&gt;Como toda linguagem usada como ferramenta do dia-a-dia existem os comandos mais úteis:&lt;/p&gt;
&lt;p&gt;Existem tópicos mais avançados como funções, seja embutidas ou criadas pelo usuário (inclusive em C), e versões mais novas como nawk e gawk. Assim como existe o vim e existem plugins, sendo que passo muito bem sem usar plugins no meu vim. Acho difícil que um dia precise estender awk, exceto por curiosidade e para aguçar minha criatividade. E como o próprio guia GNU da ferramenta sugere, se seu programa awk atingir algumas centenas de linhas é melhor você refazer em outra linguagem. Python, por exemplo (brincadeira).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Leak de Memória</title>
  <link>http://www.caloni.com.br/leak-de-memoria/</link>
  <pubDate>2020-06-07</pubDate>
  
  <guid>http://www.caloni.com.br/leak-de-memoria/</guid>
  <description>&lt;p&gt;Esse fim de semana vi um programa, sem leak de memória, que só de ficar alocando e desalocando apresentava um consumo crescente no Process Explorer. Imaginando que poderia ser alguma lib externa, como o redis, fui eliminando uma por uma as variáveis do sistema, até chegar em um loop em que a única coisa feita no corpo do código era alocar e desalocar memória. E ela apenas subia.&lt;/p&gt;
&lt;p&gt;Essa memória é alocada para um objeto acessível por uma interface. Abaixo dessa abstração reside uma mensagem do protocol buffers, ainda na versão 2. Isso quer dizer que cada new e delete construía uma nova mensagem protobuf, além da vtable da interface, e destruía em seguida. Apenas um campo int era preenchido como teste. Para monitorar melhor a memória usei um segundo campo string, pois daí posso alocar quantos bytes quiser para ele e o gráfico do Process Explorer fica dando um berro que não dá para ignorar.&lt;/p&gt;
&lt;p&gt;Então me veio o pensamento sobre a versão debug, que não é confiável. Uma versão debug de uma lib pode decidir que é importante manter coisas na memória que o programa não pediu, mas que é importante para diagnóstico. Então compilei a versão release. O padrão de consumo se repetiu, embora em um ritmo menor porque versão release é mais performática. O consumo crescente ainda estava aí.&lt;/p&gt;
&lt;p&gt;O jeito foi ir destroçando o código, classe por classe, até fazer o padrão de consumo crescente estabilizar. Este projeto tem uma arquitetura complexa, cheia de interfaces e classes que manipulam dados internos através delas. É complicado destrinchar e me custou o domingo inteiro. E quando finalmente encontrei o problema, não tinha nada a ver com o que eu imaginava. Se tratava da fila de linhas de log que não eram apagadas porque o servidor de log não havia sido configurado no componente, e como ele nunca conectava, a lib de log decidia manter as linhas em memória até conseguir. Pode ser um erro de arquitetura ou uma decisão de segurança. De qualquer forma, não há leak. Apenas um sintoma.&lt;/p&gt;
&lt;p&gt;Essa sessão de debugging me deu alguns insights, entre eles um que é sempre mais frequente: nunca supor nada antes de analisar um problema. Minha estratégia de dividir para conquistar sempre foi a única que gerou resultados rápidos, ainda que às custas de não confiar em minha intuição. A longo prazo essa estratégia é vencedora, pois a intuição não utilizada sem critérios fica mais afiada conforme você acumula conhecimento. É como o cara dos Axiomas de Zurique (o livro) dizia, intuição é um quase-conhecimento. Saber cada vez mais irá fazer com que você consiga caminhar mais rapidamente por onde quer chegar.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Azure Missing Lines</title>
  <link>http://www.caloni.com.br/azure-missing-lines/</link>
  <pubDate>2020-06-04</pubDate>
  
  <guid>http://www.caloni.com.br/azure-missing-lines/</guid>
  <description>&lt;p&gt;É curioso como os problemas mais triviais não são resolvidos em ferramentas feitas para resolver esses problemas. No Azure Pipelines existe um fluxo padrão para configurar um build em que você primeiro cria uma tarefa para obter o código de um repositório git remoto e em seguida configura, compila e empacota através de uma máquina chamada de agente. O problema surge logo nesses primeiros passos, para desespero do iniciante.&lt;/p&gt;
&lt;p&gt;Para se autenticar no repositório remoto, é claro que a ferramenta irá se integrar por algum endpoint com o serviço, seja BitBucket, GitHub ou outros. Uma conta desse serviço é usada e o acesso está liberado. Porém, se o repositório possui submodules, e estes foram configurados como acessos via ssh, a automação do Azure já para de funcionar neste momento.&lt;/p&gt;
&lt;p&gt;A causa desse bug é simples: não existe ambiente para as chaves SSH estarem configuradas antes de existir um agente (uma máquina) onde o build irá acontecer. A correção, felizmente, também é simples, apesar de inapropriada: primeiro deve-se baixar o repo sem submodules, instalar a chave SSH, e apenas agora iniciar e atualizar os submodules.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Transmission</title>
  <link>http://www.caloni.com.br/transmission/</link>
  <pubDate>2020-06-01</pubDate>
  
  <guid>http://www.caloni.com.br/transmission/</guid>
  <description>&lt;p&gt;Dia de fazer funcionar o download automágico de legendas depois que o Transmission baixou meu Netflix caseiro. O download funcionou, mas não foi dos melhores, pois o sincronismo e o encoding veio errado, e o rename de _pb para o nome do arquivo não está acontecendo rodando pelo transmission-daemon. Fora isso tá com tudo em cima.&lt;/p&gt;
&lt;p&gt;No final do dia a correção era mais simples que imaginava: eu só precisava desabilitar duas flags: o uso de sufixo no nome do arquivo salvo e a flag que força todo arquivo a ser salvo como utf8 (os arquivos em português do Brasil são salvos no encoding do Windows, o ISO-8859-1 ou Windows 1252 para os mais íntimos). No final do dia todos os bugs conterão uma correção trivial escondida do outro lado do muro chinês.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Bug no Calonibot Rodando Como Serviço</title>
  <link>http://www.caloni.com.br/bug-no-calonibot-rodando-como-servico/</link>
  <pubDate>2020-05-10</pubDate>
  
  <guid>http://www.caloni.com.br/bug-no-calonibot-rodando-como-servico/</guid>
  <description>&lt;p&gt;Esse não é o primeiro bug, nem será o último, mas serve de lição. Se quiser rodar um daemon no seu raspberrypi que atualize seu repo git de tempos em tempos ele poderá falhar, já que que roda em conta de root e essa conta não possui suas credenciais. Nem deveria, para ser sincero...&lt;/p&gt;
&lt;p&gt;Uma maneira de tornar a leitura de seu repo relativamente segura é entregar credenciais de somente leitura para seu serviço. Foi o que eu fiz no caso do calonibot, que atualiza seu próprio repositório de tempos em tempos porque nele está contido o index.xml principal do site para ele realizar uma busca mais completa quando você pedir a ele (que é atualizado sempre que publico um novo artigo).&lt;/p&gt;
&lt;p&gt;Para que isso funcione para repositórios configurados com chave ssh você terá que copiar essa chave para o diretório /root/.ssh, como se fosse a home do seu usuário. Depois de feito isso reinicie o serviço e ele deverá funcionar como novo.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O Bug Mais Bizarro que já Resolvi</title>
  <link>http://www.caloni.com.br/o-bug-mais-bizarro-que-ja-resolvi/</link>
  <pubDate>2020-05-10</pubDate>
  
  <guid>http://www.caloni.com.br/o-bug-mais-bizarro-que-ja-resolvi/</guid>
  <description>&lt;p&gt;Máquina IBM velha e empoeirada. Criptografia blowfish. Assembly 16 bits. Programa residente. E nenhum depurador funcionando. Tudo o que eu tinha se resumia em dois itens de inventário: o conhecimento, adquirido aos poucos do sistema, e minha imaginação. Era uma amena semana de abril em 2008 isolado em uma sala. Tudo que havia em volta eram papéis com anotações feitas. Observava uma nova pista todo dia, embora sem ter muita certeza. Àquela altura qualquer coisa serviria.&lt;/p&gt;
&lt;p&gt;Do outro lado da sala, uma estagiária recém-chegada na empresa observava de longe, talvez com uma certa curiosidade, ou medo, daquele rapaz ligar e desligar um desktop empoeirado enquanto a cada aperto do botão de ligar ele olhava fixamente para a tela por uma ou às vezes duas horas seguidas. Ficava a manhã inteira observando um único boot em câmera lenta. A câmera mais lenta possível, dessas que capturam o bater de asas de um beija-flor. Cada movimentação de um registrador demorava vários minutos de reflexão.&lt;/p&gt;
&lt;p&gt;Toda essa odisseia começou com o cara do suporte, um sujeito bonachão que atraía os bugs mais bizarros para nossos sistemas só de olhar para eles. Não eram os piores bugs, mas com certeza os mais bizarros. E quando digo bizarro estou falando de bugs que não dá para imaginar acontecendo na vida real. Quando esse sujeito aparecia junto surgiam bugs na própria &lt;a href=&#34;http://www.caloni.com.br/matrix&#34;&gt;Matrix&lt;/a&gt;; um gato preto passa duas vezes seguidas pela porta, mas não caminhando: flutuando próximo do teto.&lt;/p&gt;
&lt;p&gt;O sujeito chegou na sala de desenvolvimento falando dessa máquina que tinha acabado de chegar do cliente. Haviam instalado a criptografia de disco. Os dados não estavam perdidos, pois o Windows ainda mostrava o seu logo esvoaçante segundos depois de ligarmos o velho desktop de guerra, que já havia vivido pelo menos duas décadas a vida de escritório e não seria agora que deixaria seus dados sumirem sem mais nem menos. Nada disso. O problema era que se você desligasse e ligasse de novo, nada mais aparecia. Tela preta. Sem logo esvoaçante ou cursor piscando. O disco rígido não se mexia. Era um mistério completo.&lt;/p&gt;
&lt;p&gt;Mas o bizarro mesmo não era isso, mas o que vinha depois. Você desligava a pobre máquina, novamente. Apertava o botão de ligar. E como uma mulher nos seus trinta ainda não vividos, ela subia com tudo no lugar: logo do Windows, barulhinho irritante da sua tela de boas vindas e as agulhas do disco magnético piscando freneticamente. Tudo certo mais uma vez na terra do Tio Bill. Era possível logar na máquina e usá-la o resto do dia com todos os dados criptografados íntegros.&lt;/p&gt;
&lt;p&gt;Agora, sim, o bug está completamente descrito: nos boots ímpares a máquina não bootava. Nos boots pares não havia nada de errado (ou vice-versa). Antes que você comece a confabular o que poderia ser, um cacoete que todos nós, programadores, costumamos ter, já aviso que nesse bug não há relação com energia ou memória RAM. Você podia desligar a máquina e tirar da tomada. Ir tomar um café. Uma hora depois coloca a tomada de novo e a liga. A bendita não funciona. Tire a tomada novamente. Mais um café. Desenergizada novamente, botão de ligar. E tudo estava certinho.&lt;/p&gt;
&lt;p&gt;A criptografia desse sistema operava em dois níveis, necessários naquela época. O PC é uma monstruosidade construída em camadas legadas, uma em cima da outra. Abaixo de tudo existe a BIOS que controla todo mundo. Até um certo ponto, pelo menos. O que importa é que nesse primeiro momento do boot não existe sistema operacional. Não existe a querida proteção de memória que os SOs implementam (com a ajuda da arquitetura) para isolar os programas, onde qualquer violação de memória é tratada graciosamente com uma mensagem de erro. Não, mano. Aqui é o modo real. Fica esperto, que se um ponteiro ficar doido você vai levar tiro pra tudo quanto é lado. Ou como diria Morpheus: &amp;quot;Welcome... to the desert... of the real.&amp;quot;&lt;/p&gt;
&lt;p&gt;Nesse ambiente pesadão e promíscuo, onde as memórias se encostam e trocam de valores sem qualquer pudor, programas residentes se mantém em memória através do famigerado hook de interrupções. Interrupções é como chamamos as funções originais escritas e armazenadas na BIOS. Ponteiros de funções com código carregado da sua memória. Fazer um hook de uma interrupção é se colocar na frente de uma função dessas, trocando o ponteiro de função pelo endereço de sua função na memória. Então, por exemplo, se um programa roda e consegue sobrescrever o endereço da interrupção responsável por escrever na tela, esse programa pode ligar e desligar pixels que o programa original nem imagina. E em vez do logo esvoaçante e inofensivo do Windows, você poderia escrever o que seria o antepassado do gemidão do zap, versão ASCII Art.&lt;/p&gt;
&lt;p&gt;No caso de um programa de criptografia de disco a interrupção mais importantes é... acertou: a de disco. Uma interrupção de disco é responsável por ler e escrever dados de e para o disco. No primeiro momento do boot é vital para o sistema operacional que ele consiga ler setores do disco onde ele próprio está armazenado. Ele deve conseguir ler seus dados do disco, mesmo criptografados, e esses dados precisam ser descriptografados antes que exista um driver de criptografia instalado no Sistema Operacional no ar. É o dilema do ovo e da galinha. É aí que entra o que chamamos de programa residente, o que contém a função de criptografia e cujo endereço é colocado no lugar da interrupção da BIOS para comandos de disco.&lt;/p&gt;
&lt;p&gt;É claro que contando isso para vocês a posteriori parece mais fácil, mas meu primeiro instinto foi espetar o WinDbg, o depurador de sistema do Windows, nessa máquina. Porém, rapidamente descobri que não existia sistema operacional para ser depurado. O Windows nem conseguiu subir ainda, quanto mais deixar as pessoas depurarem ele. Então a solução foi apelar para o SoftIce 16 bits, um depurador em modo real, que funciona até que bem sozinho. Porém, o próprio depurador já é um programa residente, e não funciona tão bem quando existem outros programas residentes querendo espaço no disco. Como o programa de criptografia instalava um hook na int13 (essa é a interrupção de disco), as sessões de depuração nessa fase ficavam estranhas rapidamente. O depurador de modo real travava nas primeiras passadas de código. Não havia memória o suficiente ou as chamadas das ints entravam em conflito. De qualquer forma, quando memória entra em conflito no modo real, o barato fica loko, e o jeito é começar tudo de novo em um novo boot (par ou ímpar, mas sempre o segundo).&lt;/p&gt;
&lt;p&gt;Então o jeito foi usar o debug.com. Este era um programa que vinha no pacote MS-DOS e em alguns Windows mais velhos que consistia em um depurador de modo real. Era possível carregar um segmento de um arquivo ou da memória real para este depurador e ele seguia passo a passo para você a execução do programa. Em assembly de modo real, claro. Esse foi o jeito que eu consegui ir entendendo o fluxo de execução, pois eram muitos valores e variáveis. Eventualmente até o debug.com também travava, mas isso não importava tanto, pois era possível ir mapeando seu funcionamento aos poucos, anotando as descoberta uma a uma em um pedaço de papel. Uma técnica que pode ser interessante se você se encontrar em tal situação é escrever as ints 3 (interrupção de breakpoint) diretamente na memória do programa e deixar ela ser ativada para depois que capotar sobrescrever com o código antigo. Eventualmente isso também travava. Daí nesse momento o jeito era fingir que estava tudo bem e continuar a execução de um outro ponto, anotando em um pedaço de papel o estado dos registradores e da memória até o momento, para depois ir ligando os pontos.&lt;/p&gt;
&lt;p&gt;Depois de alguns dias nesse modus operandi o mundo externo importava cada vez menos. Eu só enxergava registradores sendo movidos, valores sendo empilhados e desempilhados. Na hora do café, esse era o meu tema favorito, para desespero dos meus colegas. Comecei a vislumbrar a possibilidade de existir um bug no código do algoritmo de criptografia. O algoritmo usado se chama Blowfish, um cifrador simétrico em bloco. Seu funcionamento é basicamente pegar um bloco de dados a serem criptografados, aplicar uma chave, e cuspir o mesmo tamanho do bloco de volta. Ele se chama simétrico porque aplicando a mesma chave a um bloco criptografado obtém-se o bloco original.&lt;/p&gt;
&lt;p&gt;Não lembro como tive esse insight, mas essa alternância típica dos algoritmos simétricos fazia tocar alguns sinos na minha cabeça de que o bug bizarro dos boots ímpares e pares poderia estar relacionado de alguma forma. Só não sabia ainda como.&lt;/p&gt;
&lt;p&gt;Pois bem: bora aprender como funciona esse algoritmo, passo a passo, pois o código usado no sistema estava obviamente escrito em assembly. Não é um código difícil em C, mas um tanto extenso em Assembly. De qualquer forma, tudo é possível se você está trancado em uma sala sem ninguém para importunar. Tudo que você precisa é de tempo e paciência. E café. Não se esqueça do café.&lt;/p&gt;
&lt;p&gt;A semana passou rápido. Tudo que me lembro é que de fato foi uma semana de 40 ou mais horas, embora para mim o tempo tivesse parado. A mágica de estar compenetrado em um problema e fazer parte do problema, e eventualmente da solução, me fez descobrir a origem do bug. E a semana inteira se condensou em alguns poucos momentos de prazer em ter capturado esse desgraçado. Irei descrevê-lo agora.&lt;/p&gt;
&lt;p&gt;Tudo começa com o IV: o Initialization Vector. Ele é um array de bytes usado em algoritmos criptográficos para diminuir a previsibilidade da série de bytes resultantes do algoritmo. Sem o IV pode-se usar força bruta com várias chaves até encontrar a certa. Com o IV, que é alterado de maneira previsível, mas difícil de rastrear, a mesma chave gera séries de bytes completamente diferentes, impedindo esse tipo de ataque.&lt;/p&gt;
&lt;p&gt;O que estava acontecendo nesse caso para o boot estar intermitente era que, como comentado no &lt;a href=&#34;http://www.caloni.com.br/code/o-bug-mais-bizarro-que-ja-resolvi.patch.txt&#34;&gt;commit que gloriosamente assinei&lt;/a&gt;, as escritas em disco durante o boot gravavam a série de bytes com um IV invertido. Portanto, na hora de ler bytes do disco ele entregaria os dados errados, obviamente, e a máquina não bootaria. Porém, como o algoritmo blowfish é simétrico, e pelo boot conter sempre os mesmos dados no disco, uma segunda escrita feita em um segundo boot inverteria o IV já invertido, gravando os dados originalmente invertidos da maneira correta, e a vida nessa versão de boot seguia feliz e contente, com logo esvoaçante até a música de boas vindas do Windows. Bootando pela terceira vez era repetido o problema do boot pela primeira vez, e assim por diante. Essa era a mágica do boot bizarro desta máquina, a única máquina que descobrimos que escrevia nos setores do disco durante o boot. A maioria apenas lia setores onde estava o sistema operacional para carregá-lo.&lt;/p&gt;
&lt;p&gt;Descrevendo a descoberta desse bug hoje, doze anos após o ocorrido, ainda não entendo como consegui descobri-lo. Porém, ele exigiu tanta concentração que me lembro com um prazer indescritível de ter sido capaz de fazê-lo. Todo o tempo despendido se tornou uma marca de felicidade em minha memória, gravada em meu HD temporário desta vida. Lembrarei desses momentos com carinho, e como ela está criptografada também, entenderei que em alguns momentos ela irá soar amarga, mas em vários outros irei ter certeza de ter sido um feito e tanto para um ser humano entender uma máquina em seus detalhes mais obscuros. Esta é a verdadeira felicidade da profissão.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Cast Operator</title>
  <link>http://www.caloni.com.br/cast-operator/</link>
  <pubDate>2020-04-22</pubDate>
  
  <guid>http://www.caloni.com.br/cast-operator/</guid>
  <description>&lt;p&gt;O código abaixo não é C++ moderno. É 98. Porém, ele já demonstra alguns problemas na linguagem que foram aumentados desde então. Não se sabe exatamente qual a tradução semântica de construções tão parecidas quanto o operador-função e o operador-cast. Enquanto o primeiro serve para transformar objetos em funções chamáveis o segundo serve para extrair tipos de maneira educada.&lt;/p&gt;
&lt;p&gt;O operador de cast só funciona se um cast estiver envolvido. Caso ele seja um método com explicit o cast precisa ser explícito como no exemplo. Se ele não fosse bastaria uma atribuição normal.&lt;/p&gt;
&lt;p&gt;Ele não pode simplesmente ser chamado como um operador-função. Até porque podem haver vários deles. Enquanto o operador de função trabalha com overload nos parâmetros o operador de cast trabalha com o retorno. Uma vez eu fiz uma brincadeira que meu amigo Fernando tinha me pedido: como fazer sobrecarga de função pelo retorno. Acredito que o exemplo desse post antigo possa exemplificar melhor o que quero dizer.&lt;/p&gt;
&lt;p&gt;Já a diferença sintática e semântica dos operadores de função e cast é sutil, quase inexistente. Como muitas coisas em C++ moderno:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Minha palestra sobre Windbg</title>
  <link>http://www.caloni.com.br/mbconf-at-home-2020-palestra-windbg/</link>
  <pubDate>2020-04-18</pubDate>
  
  <guid>http://www.caloni.com.br/mbconf-at-home-2020-palestra-windbg/</guid>
  <description>&lt;p&gt;A MBConf@Home2020 foi um sucesso. Parabéns aos organizadores, palestrantes e apoiadores. Eu nunca fui em um evento de tecnologia em que tudo funcionou do começo ao fim. Simplesmente fantástico o nível de qualidade da organização. Fora que trezentas pessoas ficaram em casa e participaram conosco dessa troca de conhecimento =).&lt;/p&gt;
&lt;p&gt;Minhas palestra foi a seguinte: dei uma pincelada no que é o WinDbg para os que ainda não conhecem e realizei algumas manobras pouco usuais de depuração, tentando fugir um pouco da rotina do programador e me enfiando no que seriam minhas sessões antigas de hacking ou cracking da época que analisava trojans ou depurava serviços que saíam depois que meu depurador remoto já tinha ido embora. Segue mais ou menos o roteiro e os pontos levantados.&lt;/p&gt;
&lt;p&gt;Hoje em dia o caminho mais fácil é pelo Visual Studio Community, que instala por padrão um Windows SDK. Nessa instalação é possível modificar os itens checando o &amp;quot;Debugging Tools for Windows&amp;quot;, que é o pacote que contém o ecossistema do WinDbg.&lt;/p&gt;
&lt;p&gt;Pulei essa parte. Tempo curto e me enrolei um pouco. E não era o caso de ficar focado na rotina de programador.&lt;/p&gt;
&lt;p&gt;Não fui eu que escrevi o MessageBox... juro. E nesse caso não ter o código-fonte é a rotina do crackudo, que vai ter que explorar no assembly o funcionamento de um programa. Depuramos um que chama MessageBox alterando a mensagem exibida (em 32 bits). Foi legal essa diferença entre Ansi e Unicode que me perdi no começo, pois serviu para exemplificar questões de API que precisam ser conhecidas.&lt;/p&gt;
&lt;p&gt;Abordamos o boot do Windows com nt, o uso do kd.exe por baixo dos panos do WinDbg (o DarkMode do WinDbg) e configuramos o cabo. Cabo?&lt;/p&gt;
&lt;p&gt;Cabo virtual, sargento. Usamos a VMWare, pré-configurada após alguns pesadelos de impressora se metendo no meio do caminho. Configuramos a porta serial, que é a melhor ever. E apontamos como named pipe para o WinDbg &amp;quot;de fora&amp;quot; conectar. Ou o kd.exe. As linhas abaixo são equivalentes.&lt;/p&gt;
&lt;p&gt;Para exemplificar a depuração de um serviço bem no início (ou fim) ou o load de processos antes dele existir checamos uma flag na gflags.exe da máquina depurada para que quando o notepad.exe subisse o ntsd fosse depurá-lo e passasse o controle para o debug do sistema. E com isso fechamos o círculo sagrado da depuração holística.&lt;/p&gt;
&lt;p&gt;Não. Para depurar a BIOS local há o caminho do debug.com (um depurador bem simples da época do Windows 95) ou o Softice DOS, embora eu me lembre que tive umas dores de cabeça com ele por causa dos conflitos entre interrupções e programas residentes. A depuração estática acaba ganhando nesse quesito, que é basicamente abrir o assembly, papel e caneta. E imaginação.&lt;/p&gt;
&lt;p&gt;Já para debug de BIOS em rede. Bem... esse é um nível hackudo. Sei que a Intel tem desenvolvido chips para diagnóstico e obtenção de dados de hardware pela rede antes mesmo do SO estar ligado, mas não cheguei a pesquisar a fundo.&lt;/p&gt;
&lt;p&gt;Sim. Como o Mercês me ajudou a lembrar, existe um rundll32.exe, um executável que já vem no Windows e que pode carregar a DLL para você. Daí tudo que você precisa fazer é colocar o breakpoint das funções exportadas que deseja chamar. Dá para especificar essas funções pelo rundll32.exe também:&lt;/p&gt;
&lt;p&gt;Recomendo sempre o WinDbg.info como cheat sheet e docs.microsoft.com em seus artigos &amp;quot;Getting Started with WinDbg (User-Mode)&amp;quot; e &amp;quot;Getting Started with WinDbg (Kernel-Mode)&amp;quot; (sorry, m$, vcs mudam os links demais para eu colocar aqui).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Winmock</title>
  <link>http://www.caloni.com.br/winsock-mock/</link>
  <pubDate>2020-04-10</pubDate>
  
  <guid>http://www.caloni.com.br/winsock-mock/</guid>
  <description>&lt;p&gt;Testar sistemas com rede simulada pode ser muito complexo ou muito simples. Se for feito em C ou se os endpoints forem em C é muito simples: basta trocar as funções originais pelas suas. Como tudo em C são funções com nome bem definido e assinatura flexível (você não precisa declarar a assinatura da função, ou pode mudar no meio do caminho).&lt;/p&gt;
&lt;p&gt;Criei este pequeno projeto de mock da winsock para exemplificar. Ele utiliza um recurso interessante da winsock, um define chamado INCLWINSOCKAPIPROTOTYPES, que pode desabilitar a publicação das assinaturas das funções de socket do header winsock2.h. E por que isso é importante? Porque essas assinaturas já possuem a informação que essas funções deverão ser importadas de uma DLL (no caso a Ws232.dll). Isso muda o nome da função C. Além disso, a convenção de chamada da API do Windows é baseada em Pascal, e não cdecl, sendo a desvantagem não existir número de argumentos variáveis na pilha. Adiante veremos como isso é útil para simplificar nosso código de mock.&lt;/p&gt;
&lt;p&gt;Em primeiro lugar vamos montar um projeto para iniciar um client socket para exemplificar o uso da winsock. Na verdade, de qualquer UNIX socket.&lt;/p&gt;
&lt;p&gt;Esse código pode ser testado diretamente do Blogue do Caloni. Só que não. Ele não está apto no momento a retornar o conhecido ack do IRC. Um dia talvez. Mas no momento não. As funções com o prefixo winmock estão no projeto C client que usa as funções de socket para se comunicar com o servidor. Alguns snippets:&lt;/p&gt;
&lt;p&gt;As funções C do winsock/socket, connect, send, recv, select, etc, são apenas funções C cujos nomes são conhecidíssimos. Elas são linkadas com programas que usam alguma biblioteca de socket. Nada impede que nós mesmos sobrescrevamos essas funções para implementá-las nós mesmos em nosso programa. É isso o que nosso projeto de unittest integrado faz, usando o define já citado para evitar que as funções winsock tomem o lugar.&lt;/p&gt;
&lt;p&gt;A linha mais importante é &amp;quot;adddefinitions(-DINCLWINSOCKAPIPROTOTYPES=0)&amp;quot;, que irá manter as assinaturas do header da winsock longe da compilação.&lt;/p&gt;
&lt;p&gt;Tanto a INCLWINSOCKAPIPROTOTYPES quanto a INCLWINSOCKAPITYPEDEFS podem ser muito úteis para incluir algumas coisas do header, mas não todas. E como os protótipos das funções winsock não estão disponíveis, podemos implementar as nossas:&lt;/p&gt;
&lt;p&gt;Com isso o linker irá usar nossas funções em vez da lib de winsock, e na execução podemos simular eventos e operações de rede. Para flexibilizar para que cada teste monte seu ambiente transformamos a implementação em chamadas de ponteiros de função que podem ser trocadas. Por padrão preenchemos esses ponteiros com uma função que não faz nada. Note que com a convenção de chamadas de C não precisamos especificar os argumentos e funções com diferentes tipos e números de parâmetros podem chamar a mesma função.&lt;/p&gt;
&lt;p&gt;Agora é possível escrever um sistema de simulação do Blogue do Caloni que retorna o ack que precisamos para que o teste funcione.&lt;/p&gt;
&lt;p&gt;extern &amp;quot;C&amp;quot; {
}&lt;/p&gt;
&lt;p&gt;using namespace std;&lt;/p&gt;
&lt;p&gt;static string lastsend;&lt;/p&gt;
&lt;p&gt;extern &amp;quot;C&amp;quot; {&lt;/p&gt;
&lt;p&gt;int select_default(int nfds, fd_set FAR* readfds, fd_set FAR* writefds, fd_set FAR* exceptfds, const struct timeval FAR* timeout)
{
}&lt;/p&gt;
&lt;p&gt;int getaddrinfo_default(PCSTR pNodeName, PCSTR pServiceName, const ADDRINFOA* pHints, PADDRINFOA* ppResult)
{
}&lt;/p&gt;
&lt;p&gt;int send_default(SOCKET s, const char FAR* buf, int len, int flags)
{
}&lt;/p&gt;
&lt;p&gt;int recv_default(SOCKET s, char FAR* buf, int len, int flags)
{&lt;/p&gt;
&lt;p&gt;}
}&lt;/p&gt;
&lt;p&gt;class clientTest : public ::testing::Test {
protected:
clientTest() {
};&lt;/p&gt;
&lt;p&gt;~clientTest() override {
}&lt;/p&gt;
&lt;p&gt;void SetUp() override {
}&lt;/p&gt;
&lt;p&gt;void TearDown() override {
}&lt;/p&gt;
&lt;p&gt;// your stuff
};&lt;/p&gt;
&lt;p&gt;TESTF(clientTest, ConnectSendReceive)
{
struct CONNECTION* conn = NULL;
if (winmock_connect(&amp;quot;caloni.com.br&amp;quot;, 80, &amp;amp;conn) == 0)
{
}
}&lt;/p&gt;
&lt;p&gt;Uma observação importante sobre getaddrinfo: ele não possui esse salvaguarda de define e irá dar erro no linker de redefinição. Porém, apenas se incluirmos o header onde ele é definido. Podemos nos proteger com o mesmo define no código-fonte original do client:&lt;/p&gt;
&lt;p&gt;Durante a compilação do unittest warnings como os abaixo aparecerão, mas não se preocupe, pois sabemos o que estamos fazendo.&lt;/p&gt;
&lt;p&gt;Para se divertir brincando de rede de mentirinha, baixe o projeto completo.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Callback Hell</title>
  <link>http://www.caloni.com.br/callback-hell/</link>
  <pubDate>2020-04-09</pubDate>
  
  <guid>http://www.caloni.com.br/callback-hell/</guid>
  <description>&lt;p&gt;Foi aprendendo sobre kernel do Windows que eu descobri que a linguagem C suporta todas as abstrações que um homem crescido precisa para desenvolver sistemas. Também aprendi que você precisa ser um homem crescido para saber usar direito.&lt;/p&gt;
&lt;p&gt;A linguagem C possui 32 palavras-chave e nenhuma parafusadeira elétrica. Existe um motivo para isso: fazer tudo na mão desenvolve o caráter. Se não desenvolve, pelo menos escancara a má pessoa que você é.&lt;/p&gt;
&lt;p&gt;Olhe para o sistema de callbacks, por exemplo. É uma ferramenta poderosa. Com ponteiros de função e endereços de estrutura você pode chamar quem você quiser a hora que quiser. Há tantas possibilidades que é muito fácil errar.&lt;/p&gt;
&lt;p&gt;Aí que surge o famigerado Callback Hell.&lt;/p&gt;
&lt;p&gt;Esse termo se popularizou através da linguagem Javascript por causa que em Javascript é muito fácil deixar a coisas pra depois. Você deixa seu callback pra ser chamado uma outra hora e esquece dele. E ele faz o mesmo. E mais uma vez. E de novo. Você entendeu a ideia.&lt;/p&gt;
&lt;p&gt;No final das contas, depurar código Javascript escrito por outra pessoa seria uma sala no inferno reservada para aqueles programadores que acharam durante a vida que resolveriam todos os problemas do mundo até às 18:00. Tudo que eles precisavam fazer era criar mais um pequeno callback no finalzinho daquela função. Como se diz em Go Horse Power, commit e era isso.&lt;/p&gt;
&lt;p&gt;A linguagem C permite você fazer a mesma coisa. Basta que o endereço da estrutura que você passou como contexto do seu callback tenha um ponteiro de função que vai ser chamado passando mais um membro dessa estrutura como contexto, que irá conter outro ponteiro de função que... você entendeu a ideia.&lt;/p&gt;
&lt;p&gt;No final das contas, depurar um código em C escrito por uma pessoa que evita resolver problemas de arquitetura criando mais um callback deve demonstrar como existem pessoas sem caráter que sabem declarar um ponteiro de função. Cuidado com essas pessoas. Elas podem te levar até uma salinha reservada no inferno.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Meu Try Lock de Pelúcia</title>
  <link>http://www.caloni.com.br/try-lock-de-pelucia/</link>
  <pubDate>2020-04-07</pubDate>
  
  <guid>http://www.caloni.com.br/try-lock-de-pelucia/</guid>
  <description>&lt;p&gt;Alguns implementam mutex pero no mucho, que é aquele mutex que não faz nada porque ele sabe que só tem uma thread rodando no processo. É uma solução elegante para abstrair o uso de lock em um processo que pode ou não rodar multithread.&lt;/p&gt;
&lt;p&gt;Já isso me lembra o try lock de pelúcia de um driver de uma empresa que trabalhei certa vez. Como havia situações onde o lock não era nunca liberado, e a thread estava rodando em um nível de interrupção que não poderia mais voltar, ou ela agendava uma execução menos prioritária ou obtia o lock. Mas baixar a prioridade não era uma opção para o programador MacGyver. Então o código acabou ficando mais ou menos assim:&lt;/p&gt;
&lt;p&gt;Ninguém mandou mexer com o dadinho.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Code Jam 2020</title>
  <link>http://www.caloni.com.br/code-jam-2020/</link>
  <pubDate>2020-04-05</pubDate>
  
  <guid>http://www.caloni.com.br/code-jam-2020/</guid>
  <description>&lt;p&gt;O Code Jam esse ano terminou rápido para mim. Estou enferrujado? Nem tanto. Apenas dei menos atenção ao evento no seu início, mas apesar de me concentrar nas últimas 11 horas não tive um resultado satisfatório, obtendo 24 pontos ao total, o que não me dá direito para o torneio, que exige pelo menos 30.&lt;/p&gt;
&lt;p&gt;Minha abordagem nesse problema foi o básico de ir lendo os valores e verificando para cada novo elemento da linha se havia repetição nos valores já lidos da mesma linha. Eu me compliquei na hora de fazer a mesma coisa para as colunas, pois inseri essa checagem dentro do loop da linha, evitando, assim, sempre a última coluna. Foi a parte que mais perdi tempo útil de todo o torneio (não li todos os exercícios antes).&lt;/p&gt;
&lt;p&gt;Esse foi o mais simples de todos. Entendendo o enunciado, em que o título dá uma dica valiosa sobre o comportamento do algoritmo (aninhado), foi só usar a mesma lógica que nós programadores usamos na hora de aninhar parênteses.&lt;/p&gt;
&lt;p&gt;Esse exercício me parecia fácil no começo. Desenhei na minha janela um esboço da ideia inicial, que era manter um registro de todos os minutos de um dia e a cada nova tarefa popular cada minuto. Meu erro principal foi não considerar que todos os minutos de uma tarefa devem estar sob a responsabilidade de apenas uma pessoa. Corrigido isso, meu código passou nos poucos testes disponíveis no problema, mas não passou na hora de submeter. Estou sem saber até agora o que fiz de errado.&lt;/p&gt;
&lt;p&gt;Esse foi o mais divertido porque envolveu mexer em ambiente. O script iterativo do Google (interactiverunner.py) não funcionou direito no Windows, mas depois de uns testes no WSL percebi que o erro mesmo é não dar flush nos printf do meu lado. Sempre haverá problemas de buffer em stdin/stdout.&lt;/p&gt;
&lt;p&gt;De qualquer forma, não consegui resolver mais do que 10 bits. Já estava ficando tarde e eu me perdi em digressões de como tornar o código maleável para adivinhar mais que duas viradas quânticas. Deixei esse código experimental de lado e fui ler o próximo.&lt;/p&gt;
&lt;p&gt;Apenas li o enunciado. Ele falava sobre o quadrado latino, assim como o problema original. E como tive dores de cabeça por causa desse primeiro exercício, e faltava apenas uma hora e meia para terminar a prova, dei por satisfeito mais um ano brincando de programar.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Golang e C</title>
  <link>http://www.caloni.com.br/golang-e-c/</link>
  <pubDate>2020-04-05</pubDate>
  
  <guid>http://www.caloni.com.br/golang-e-c/</guid>
  <description>&lt;p&gt;É muito difícil configurar a linguagem Go no ambiente Windows para compilar código C. O único ambiente de compilação que o projeto leva a sério são os ports do GCC, e não o Visual Studio, que seria a ferramenta nativa. Dessa forma, realizei boa parte das travessuras desse artigo em Linux, usando o WSL com a distro Ubuntu ou CentOS. Deve funcionar em qualquer Unix da vida.&lt;/p&gt;
&lt;p&gt;A linguagem Go na versão mais nova precisa que seja definida através da cgo, o backend C do ambiente de build da linguagem, uma função trampolim, que é uma função escrita em C que irá chamar uma função escrita em Go. Essa função pode ser passada como parâmetro de callback para uma biblioteca C que quando a biblioteca C chamar esse ponteiro de função ele irá atingir a função trampolim, que por sua vez, chama a função Go, que é onde queremos chegar depois de todo esse malabarismo.&lt;/p&gt;
&lt;p&gt;Em resumo: o main em Go chama C.setcallback (função C exportada) passando o endereço do seu callback (em cgo) e em uma segunda chamada ou nessa mesma pede para chamar esse callback. O módulo em C pode ou não chamar essa função nessa thread ou mais tarde, através do ponteiro de função que estocou (gcallback). Ao chamá-la, ativará a função GoCallbackcgo, que por sua vez chamará GoCallback, essa sim, já no módulo Go (embora ambas estejam no mesmo executável, já que C e Go podem ser linkados juntos de maneira transparente.&lt;/p&gt;
&lt;p&gt;O módulo em Go precisa de um forward declaration para a função cgo e precisa exportar a função Go que será chamada por ela através do importantíssimo comentário export antes da função (se retirado este comentário a solução para de funcionar):&lt;/p&gt;
&lt;p&gt;O módulo trampolim de Go é muito simples. Além de incluir o mesmo header em C para os tipos especificados ali, ela faz uma foward declaration da função do módulo Go anterior e chama esta função, repassando a chamada para o mundo Go.&lt;/p&gt;
&lt;p&gt;Mais uma vez há algo extremamente importante nos detalhes: a chamada import &amp;quot;C&amp;quot; logo após o código dentro dos comentários desse módulo.&lt;/p&gt;
&lt;p&gt;O resto é C padrão. O header define os tipos (inclusive do callback) e as funções exportadas:&lt;/p&gt;
&lt;p&gt;A parte C apenas implementa as funções:&lt;/p&gt;
&lt;p&gt;E para exportar essas funções basta um arquivo def no projeto:&lt;/p&gt;
&lt;p&gt;O CMakeLists.txt deste projeto pode apenas especificar qual o tipo de biblioteca. Não há nada de especial na parte C. Ou seja, funciona com qualquer código que você saiba as assinaturas das funções.&lt;/p&gt;
&lt;p&gt;Após compilar ambas as soluções na mesma pasta (considerando que foi criada uma subpasta onde estão esses fontes) basta executar o binário Go e ver a mágica funcionando. No meu caso, tive que executar tudo no WSL. Ainda preciso ver como configura essa bagaça de Go no Windows.&lt;/p&gt;
&lt;p&gt;Criei um repositório com os fontes deste artigo. Bom proveito =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Git Subtree</title>
  <link>http://www.caloni.com.br/git-subtree/</link>
  <pubDate>2020-03-22</pubDate>
  
  <guid>http://www.caloni.com.br/git-subtree/</guid>
  <description>&lt;p&gt;É a segunda vez que uso subtrees no Git. Não é algo que me acostumei usar por rotina, mas é uma técnica que eu recomendo que todo programador conheça para unir repositórios que não dependa dos pesadelos de configurar submodules.&lt;/p&gt;
&lt;p&gt;Há vários tutoriais na internet sobre seu uso (como o da Atlasian), além do próprio manual do Git e sua ajuda. Só quero enfatizar neste post que ele existe, é fácil de usar, e pode resolver alguns problemas de gerenciamento de projeto:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unir repositórios que foram separados em algum momento ou que nasceram separados.&lt;/li&gt;
&lt;li&gt;Unir dependências que não estão online, mas que precisam estar caminhando em paralelo.&lt;/li&gt;
&lt;li&gt;Compor árvores de histórico distintas e não se preocupar muito de onde elas vieram (exceto quando for necessário juntar de novo, e nesse caso o commit que as une possui algumas informações).&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Projeto Hu Cpp: Not Fast Enough</title>
  <link>http://www.caloni.com.br/projeto-hu-cpp-not-fast-enough/</link>
  <pubDate>2020-03-17</pubDate>
  
  <guid>http://www.caloni.com.br/projeto-hu-cpp-not-fast-enough/</guid>
  <description>&lt;p&gt;Continuando minhas aventuras em tentar ser mais rápido que o Hugo, fiz uma versão que gera um html porco com os parágrafos obtidos no parser porco de markdown, rodando em cima dos meus 2740 posts. Este é o código novo:&lt;/p&gt;
&lt;p&gt;Lembrando o resultado do Hugo no post passado:&lt;/p&gt;
&lt;p&gt;Agora executando o meu programinha caseiro (b.bat é uma batch que executa todos os posts usando o comando for do Windows; ptime é uma versão Windows do time do Linux, que mede performance na execução de um programa).&lt;/p&gt;
&lt;p&gt;Noventa segundos para 2700 posts! É uma vergonha! Programadores C++/Boost/Asio, vamos nos matar.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Projeto Hu Cpp</title>
  <link>http://www.caloni.com.br/projeto-hu-cpp/</link>
  <pubDate>2020-03-15</pubDate>
  
  <guid>http://www.caloni.com.br/projeto-hu-cpp/</guid>
  <description>&lt;p&gt;Utilizo o Hugo como renderizador do meu saite já faz um tempo. Depois que juntei os posts do finado Cine Tênis Verde e do meu blogue técnico a soma dos textos ultrapassou a marca dos dois mil. Atualmente levo cerca de quinze segundos para renderizar todo o saite antes de publicá-lo.&lt;/p&gt;
&lt;p&gt;Não é uma marca ruim, considerando que estamos com quase três mil textos, e embora o leiaute do saite seja muito simples, é justamente o que eu desejo para rápido carregamento e busca. Não tenho do que reclamar.&lt;/p&gt;
&lt;p&gt;Porém, um programador C nunca fica satisfeito com uma solução Golang.&lt;/p&gt;
&lt;p&gt;Sabe esses pensamentos que não saem da cabeça? Estava devaneando há uns dias sobre se não seria interessante renderizar meu saite usando uma solução em C ou C++ e ver qual seria o resultado. Claro que seria uma solução in house, cheia de bugs e completamente limitado. Mas quem liga? Meu único objetivo é a diversão, e não pretendo criar um produto genérico. Hugo já satisfaz até o mais exigente dos programadores (exceto o Elias), pois resolve vários problemas do interminável conflito entre conteúdo e design.&lt;/p&gt;
&lt;p&gt;Por falar no dito cujo, me lembrei da nossa disputa no saite Os Programadores. Era uma resolução de exercício envolvendo leitura e parseamento de um arquivo json. Tive o insight de usar algo parecido com o que desenvolvi naquela vez.&lt;/p&gt;
&lt;p&gt;Esse código lê um arquivo markdown e divide o header nos campos que eu utilizo e o texto em parágrafos. Esse é o começo mínimo para começar a converter os arquivos em html. Ele usa o mapeamento de arquivo em memória como no desafio 5 acima. Não precisaria, mas já que a diversão é fazer mais rápido que o Hugo, por quê não?&lt;/p&gt;
&lt;p&gt;Meu próximo passo é pegar esse parser e converter todos os arquivos para html, da maneira mais porca possível. Quer dizer, quase da maneira mais porca. Não estou usando Pascal.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como Funciona o MPTunnel</title>
  <link>http://www.caloni.com.br/como-funciona-o-mptunnel/</link>
  <pubDate>2019-12-11</pubDate>
  
  <guid>http://www.caloni.com.br/como-funciona-o-mptunnel/</guid>
  <description>&lt;p&gt;A ideia por trás de um sistema multipath de rede é fornecer mais de um caminho para o tráfego de pacotes. O objetivo pode ser diminuir a perda de pacotes por causa da instabilidade da rede, mas também isso irá fazer com que o throughput da comunicação seja maior pela diminuição da razão da perda de pacotes, além da melhor rota acabar sendo por onde os pacotes irão chegar primeiro, em uma espécie de seleção natural da arquitetura.&lt;/p&gt;
&lt;p&gt;Esta é uma implementação em user space de UDP multipath. Assim como a contraparte em sua versão TCP, você pode estabilizar várias conexões entre o servidor local e o remoto.&lt;/p&gt;
&lt;p&gt;MPTCP (MultiPath TCP) é uma boa ideia para tornar a conexão de rede mais robusta, mas apenas funciona em TCP, e em um ambiente multiplataforma não há soluções em kernel mode exceto o ECMP desenvolvido no último Linux, cujos artigos de Jakub Sitnicki explicam os detalhes. E foi através da busca por uma implementação de MPUDP que foi escrita essa ferramenta por greensea, um usuário do GitHub.&lt;/p&gt;
&lt;p&gt;Existem dois servidores Server A e Server B. A conexão de rede entre Server A e Server B é instável (com uma razão alta de perda de pacotes). Dessa forma, nós gostaríamos de estabilizar um túnel multipath entre Server A e Server B, esperando que a conexão entre ambos se torne mais estável (diminua a razão de perda de pacotes). Com o broadcast dos pacotes por vários caminhos o resultado a longo prazo é uma comunicação cuja performance é prioridade.&lt;/p&gt;
&lt;p&gt;mpclient é a parte cliente do mptunnel, ele pode rodar no ServerA. Você deve dizer ao mpclient a informação dos servidores bridge. Uma vez que o mpclient é iniciado, ele abre uma porta local UDP para listen e redireciona qualquer pacote de/para os servidores bridge.&lt;/p&gt;
&lt;p&gt;mpserver é a parte servidora do mptunnel, ele pode rodar no ServerB. Você deve dizer ao mpserver a informação do Server B. Uma vez que mpserver é iniciado, ele irá redirecionar qualquer pacote de/para o Server B.&lt;/p&gt;
&lt;p&gt;Os servidores bridge são simples, eles apenas redirecionam os pacote do mpclient para mpserver, ou pacotes do mpserver para mpclient. Você pode usar nc ou socat para entregar um servidor bridge.&lt;/p&gt;
&lt;p&gt;Para a solução ser rodável em Linux, Windows e Mac OS os fontes compilam em um ambiente POSIX mínimo, já disponível nos três SOs, sendo que para Windows este ambiente é o Cygwin.&lt;/p&gt;
&lt;p&gt;O resumo para compilar em Linux é instalar o gcc, o make, o git, as dependências, baixar o projeto e compilar. Esses passos devem funcionar em qualquer Linux, mas foi testado em Ubuntu.&lt;/p&gt;
&lt;p&gt;O primeiro passo é baixar e instalar o cygwin com os seguintes pacotes adicionais ao padrão:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gcc-core, socat, git, make, libev, libev-devel, libintl-devel.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Em seguida deve-se baixar o repositório do mtunnel e do terminal cygwin executar o build.&lt;/p&gt;
&lt;p&gt;Dentro deste repositório há como exemplo dois programas client/server em UDP, udpclient.c e udpserver.c. Eles se comunicam de um lado para outro enviando mensagens de hello com um número na frente que é incrementado pelo servidor.&lt;/p&gt;
&lt;p&gt;Eu quero conectar em meu udpserver, mas a conexão é instável e a razão de perda de pacotes é alta, gerando um throughput muito pequeno. Para aumentar o throughput, ou seja, diminuir a perda de pacote, eu posso rodar um MPUDP para o servidor e estabilizar uma &amp;quot;conexão&amp;quot; UDP através da redundância das bridges.&lt;/p&gt;
&lt;p&gt;O udpserver está em listen na porta 6666 UDP e eu executo o mpserver no servidor da seguinte forma:&lt;/p&gt;
&lt;p&gt;Localmente executo o mpclient da seguinte forma:&lt;/p&gt;
&lt;p&gt;Abaixo está o conteúdo do arquivo client.mpclient.conf&lt;/p&gt;
&lt;p&gt;Em cada &amp;quot;servidor bridge&amp;quot; (no exemplo está tudo local, mas não precisaria) use socat para redirecionar os pacotes:&lt;/p&gt;
&lt;p&gt;Os servidores bridge irão ficar em listen nas portas 4001, 4002 e 4003 e redirecionar qualquer pacote recebido para localhost:2000, e vice-versa.&lt;/p&gt;
&lt;p&gt;Agora eu faço o cliente conectar em localhost:4000 que o mpclient está em listen ele irá estabiizar uma conexão sobre o MultiPath UDP tunnel.&lt;/p&gt;
&lt;p&gt;Dois scripts estão disponíveis para iniciar e parar a arquitetura de exemplo acima chamados respectivamente sample.start.sh e sample.stop.sh.&lt;/p&gt;
&lt;p&gt;Para observar a performance da solução os samples udpclient/udpserver servirão para medir a eficiência de uma comunicação onde as bridges se tornam instáveis, e para isso eles precisarão de uma rota remota entre as bridges. Este teste requer ao menos uma máquina a mais que esteja acessível na rede pelas portas a serem usadas (pode ser uma máquina virtual).&lt;/p&gt;
&lt;p&gt;Altere a execução das bridges da seguinte forma, trocando o endereço remoto pelo correto.&lt;/p&gt;
&lt;p&gt;Isso fará com que três dos quatros bridges sejam remotos, enquanto o último estará funcionando totalmente local. Ao iniciar o mptunnel nesta configuração a comunicação entre udpclient e udpserver continuará funcionando na mesma velocidade mesmo que a comunicação na rede seja interrompida, graças ao quarto caminho totalmente local.&lt;/p&gt;
&lt;p&gt;Outros cenários podem ser desenhados levando em conta a velocidade de uma rede ou sua instabilidade.&lt;/p&gt;
&lt;p&gt;Mptunnel adiciona alguma informação de controle dentro dos pacotes, incluindo informação síncrona. mpserver e mpclient devem ser iniciados ao mesmo tempo. Se o mpclient ou o mpserver terminar, você terá que reiniciar ambos para restabelecer o túnel.&lt;/p&gt;
&lt;p&gt;Atualmente você pode especificar apenas um único host alvo. Alguém sabe se existe uma biblioteca C de proxy SOCKS5? Penso que ao tornar o mpclient como um servidor proxy SOCKS irá torná-lo mais fácil de usar.&lt;/p&gt;
&lt;p&gt;Mptunnel não encripta os pacotes por padrão, apesar de ter essa opção, pois isso irá diminuir o throughput. Em alguns testes o throughput atual é 3Mbps enquanto usando três túneis com criptografia, e após desabilitar a criptografia o throughput sobe para 300Mbps. Se você ainda quiser que o mptunnel encripte os pacotes, defina a variável de ambiente MPTUNNELENCRYPT=1.&lt;/p&gt;
&lt;p&gt;Para compilar o mptunnel, essas bibliotecas são requeridas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;libev&lt;/li&gt;
&lt;li&gt;mlvpn, uma solução similar para multipath UDP.&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Vcpkg: Bootstrap</title>
  <link>http://www.caloni.com.br/vcpkg-bootstrap/</link>
  <pubDate>2019-11-29</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg-bootstrap/</guid>
  <description>&lt;p&gt;A versatilidade do vcpkg, gerenciador de pacotes multiplataforma da Microsoft, é permitir modificar tudo no projeto, desde código-fonte, pacotes instaláveis e a própria origem do repositório. Através do controle de fonte um vcpkg pode ser alimentado por diversas fontes, e por cada pacote existir em uma pasta separada permite a coexistência de várias versões e origens. Além disso, a forma de compilar os projetos e o código-base pode ser alterado exatamente da forma com que o projeto precisa.&lt;/p&gt;
&lt;p&gt;Sabendo de tudo isso, a única coisa que você precisa em um projeto isolado é um script de bootstrap que baixe um repositório vcpkg customizado para o projeto, compile, instale os pacotes necessários e integre com o Visual Studio antes de iniciar a compilação do próprio projeto. Dessa forma é possível montar o ambiente de maneira automática e sanitizada para qualquer membro da equipe ou máquina de build.&lt;/p&gt;
&lt;p&gt;Vejamos como seria um bootstrap.bat:&lt;/p&gt;
&lt;p&gt;Com esse script na pasta raiz do seu projeto ele irá criar uma subpasta chamada vcpkg e após realizar as operações descritas acima integrar ao Visual Studio. Dessa forma quando for compilar o projeto os includes e libs já estarão disponíveis para que ele funcione, mesmo diretamente de uma máquina limpa.&lt;/p&gt;
&lt;p&gt;Esse script pode ser integrado à lib principal do projeto ou o projeto da solution que primeiro deve compilar (porque todos dependem dele). Para isso existe o Pre-Build Event nas configurações de um projeto do Visual Studio. Os comandos que estiverem lá serão executados sempre antes da compilação.&lt;/p&gt;
&lt;p&gt;O único passo não-descrito neste artigo é baixar o projeto e iniciar o build, tarefas triviais de integração.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>DTLS Simples... simples?</title>
  <link>http://www.caloni.com.br/dtls-simples/</link>
  <pubDate>2019-11-13</pubDate>
  
  <guid>http://www.caloni.com.br/dtls-simples/</guid>
  <description>&lt;p&gt;O protocolo DTLS, grosso modo, é um addon do TLS, que é a versão mais nova e segura do SSL, só que em vez de usar por baixo o TCP, que garante entrega na ordem certa dos pacotes, além de outras garantias, o UDP é permitido. Ou seja, datagramas. Em teoria essa forma de usar TLS é uma versão mais light, com menos overheadh e tráfico de banda. E a pergunta que tento responder aqui é: será que isso é verdade?&lt;/p&gt;
&lt;p&gt;A primeira tarefa é conseguir compilar e rodar um sample DTLS para Windows, que é meu sistema operacional alvo. Para criar um sample client/server de DTLS usando a biblioteca OpenSSL (no momento 1.1.1d) precisei de alguns passos de setup, conforme especificado neste tutorial. O repositório DTLS-Examples possui alguns starts para começarmos a compilar e rodar um pouco de código, mas nem tudo são flores na hora de rodar para Windows.&lt;/p&gt;
&lt;p&gt;O exemplo que peguei, dtlsudpecho.c, como diz o nome, usa DTLS em cima de UDP. As funções de setup e de definição de callbacks e settings do OpenSSL são configuradas de acordo com o esperado, mas por algum motivo quando a conexão entre um server e um client é estabelecida o server dispara vários listenings e a conexão estabelecida pelo client permanece sem escrita e leitura.&lt;/p&gt;
&lt;p&gt;Após compilar o OpenSSL e antes de iniciar os testes gerei os certificados:&lt;/p&gt;
&lt;p&gt;Analisando a troca de pacotes pelo Wire Shark descobri um erro no handshake envolvendo fragmentação.&lt;/p&gt;
&lt;p&gt;Tentando descobrir o motivo encontrei alguns issues no GitHub a respeito de problemas no OpenSSL, e a solução era definir um MTU (Maximum transmission unit) em vez de deixar o OpenSSL usar o default, que é pequeno demais para poder enviar as mensagens do handshake de uma só vez, requisito do protocolo.&lt;/p&gt;
&lt;p&gt;Isso corrigiu o envio do ClientHello, mas após isso o handshake entrou em loop no envio do resto das mensagens até retornar com erro.&lt;/p&gt;
&lt;p&gt;Do roteiro descrito pela RFC faltam as mensagens Finished após ChangeCipherSpec, o que terminaria o fluxo, mas por algum motivo o Finished nunca chega em nenhum dos lados, e as mensagens a partir de ServerHello se repetem até o retorno de erro de conexão (SSLERRORSSL). O Sequence Number do server e client indicam que apesar da troca de mensagens estar ocorrendo existe um loop.&lt;/p&gt;
&lt;p&gt;Encontrei um gist que acompanha passo a passo o setup necessário da biblioteca. Ao pesquisar mais a respeito encontrei um artigo de Christopher A. Wood que também está explorando esse protocolo usando OpenSSL e que é o autor do primeiro repositório de exemplo de DTLS, que falha não por não funcionar, mas por estar usando TCP em vez de UDP ao usar a flag SOCKSTREAM em vez de SOCKDGRAM na criação do socket.&lt;/p&gt;
&lt;p&gt;Depois de muito analisar o protocolo desenhando cada pacote na janela do escritório resolvi abandonar essa miríade de detalhes e dar um passo atrás, usando o próprio openssl.exe compilado com os parâmetros abaixo. E, surpreso, mas nem tanto (afinal de contas, a compilação do OpenSSL passou pelos testes pós-build) eu consigo executar o protocolo DTLS em UDP IPV4 sem nenhuma falha:&lt;/p&gt;
&lt;p&gt;O passo seguinte foi entender o código e as diferenças com os samples que havia tentado fazer funcionar da única maneira que penso ser possível: depurando. Sem conseguir navegar em todos os detalhes do fonte do OpenSSL recompilei o projeto com full debug alterando as flags de compilação no Makefile gerado para Windows (/Od e /Zi ajudam) e iniciei os dois modos acima depurando em duas instâncias do Visual Studio. Encontrei uma ou outra chamada à biblioteca OpenSSL que não havia notado ainda, mas nada que parece fazer a diferença.&lt;/p&gt;
&lt;p&gt;Mas nenhuma dessas mudanças fez efeito no projeto de teste. O próximo passo seria copiar cada chamada feita à lib OpenSSL pelo openssl.exe e colar no projeto de teste para descobrir onde está o pulo do gato que nenhum dos samples na internet parece ter encontrado (ao menos para Windows), mas há uma solução preguiçosa que é muito mais efetiva e testada: usar os fontes da própria pasta apps do projeto OpenSSL.&lt;/p&gt;
&lt;p&gt;O próximo e último passo é customizar o código-fonte base no qual a OpenSSL valida o protocolo DTLS para o uso que pretendo fazer para ele: um executador de processos remoto.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Vcpkg: openssl.cnf</title>
  <link>http://www.caloni.com.br/vcpkg-openssl-cnf/</link>
  <pubDate>2019-09-17</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg-openssl-cnf/</guid>
  <description>&lt;p&gt;Mais uma aventura em vcpkg. Dessa vez o projeto openssl, a biblioteca de SSL open-source multiplataforma. O vcpkg divide esse port por SO, sendo o openssl-windows o port que alterei. A alteração foi enviada como PR para a Microsoft, mas no momento está apenas no repo da BitForge.&lt;/p&gt;
&lt;p&gt;O que acontece é que alguns comandos executados no openssl.exe compilado e instalado do vcpkg precisam conter o arquivo de configuração disponível, como o &lt;code&gt;genrsa&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;A compilação do openssl-windows pelo vcpkg gera o arquivo, mas o apaga após o build. Há uma checagem pós-build no vcpkg.exe que verifica se há arquivos sobrando na estrutura de diretórios que será copiada para a pasta installed/triplet após a conclusão da instalação no módulo postbuildlint. A função checknofilesindir verifica se há arquivos sobrando nos diretórios onde eles não deveriam estar e cancela a instalação. Por isso que originalmente o openssl-windows/portfile.cmake apaga o openssl.cnf gerado na pasta raiz e na subpasta debug do build.&lt;/p&gt;
&lt;p&gt;Minha mudança foi apenas não apagar o arquivo openssl.cnf release e movê-lo para a pasta onde está localizado o openssl.exe. Dessa forma fica simples de detectá-lo, mas ainda assim é necessário apontar para a ferramenta onde ele está, definindo a variável de ambiente OPENSSLCONF ou passando como parâmetro.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Vcpkg: Boost para Windows XP</title>
  <link>http://www.caloni.com.br/vcpkg-boost-windows-xp/</link>
  <pubDate>2019-09-16</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg-boost-windows-xp/</guid>
  <description>&lt;p&gt;Quem programa em C++ no Brasil geralmente precisa estar preparado para manter velharias. Boa parte do parque de máquinas das empresas usam Windows, e não estou falando de Windows 10, mas muitas vezes XP. Apesar da Microsoft ter largado uma das melhores versões do seu SO para trás, milhares de máquinas ainda rodam esse bichinho, e muitos programadores precisam manter e desenvolver em nome da compatibilidade.&lt;/p&gt;
&lt;p&gt;Porém, o desenvolvimento de libs C++ foram aos poucos largando o suporte ao XP (em C isso não existe muito, pois é mais fácil ser portável em C), pois muitos mecanismos de SOs modernos surgiram depois, como um mutex light ou mutex apenas de read. E como eles olham para o mercado global, o Brasil acaba ficando para trás.&lt;/p&gt;
&lt;p&gt;E isso inclui a Boost, o famoso conjunto de bibliotecas usado pelos engenheiros que gostam de complicar seu código. O suporte oficial a XP da Boost acabou na 1.60, mas é possível compilar, se você quiser, versões mais novas, como a 1.68, que usaremos neste artigo. Com ela é possível gerar uma versão compatível com Windows XP usando o builder da Boost e alguns parâmetros mágicos, como toolset e define.&lt;/p&gt;
&lt;p&gt;O parâmetro toolset usa no caso a versão compatível para XP do conjunto de compilação do Visual Studio 2015, e o define BOOSTUSEWINAPIVERSION é colocado para suportar pelo menos Windows XP. Já o stagedir seria apenas para separar a compilação padrão para a que suporta XP e é opcional para manter duas compilações distintas. Importante lembrar que, apesar da Microsoft ter extinto o suporte a XP, até o Visual Studio mais novo possui um toolset, compilador e libs para Windows, que suporte o sistema operacional.&lt;/p&gt;
&lt;p&gt;Esses mesmos parâmetros usados no build da Boost podem ser usados dentro do vcpkg, o compilador de pacotes multiplataforma da Microsoft. Como esperado, as libs do vcpkg compilam usando tudo do último em sua máquina: Boost, Visual Studio e o suporte ao último Windows (no caso do pacote da Boost, não, se usa o Windows Vista em diante). Mas você pode e deve modificar os ports padrões sempre que necessário. Este artigo explica como fazer partindo do zero sem receita de bolo. Vamos escanear o problema e resolvê-lo. Para isso vamos usar um exemplo bem simples da Boost.Log, que possui dependências mais novas que o Windows XP.&lt;/p&gt;
&lt;p&gt;O status inicial e inocente de um projeto que deseja rodar para XP em Visual Studio 2015 (nosso caso de uso, poderia ser o VS mais novo) é criar um projeto que usa Boost.Log pelo wizard, instalar, se ainda não estiver instalado, o Boost.Log no vcpkg, e acabou. Só que não. Eis o código:&lt;/p&gt;
&lt;p&gt;Agora eis as configurações:&lt;/p&gt;
&lt;p&gt;Esse é um erro que geralmente acontece por dois motivos. O primeiro é quando rodamos um executável de 64 bits em um ambiente 32, mas este não é o caso. O segundo é  quando rodamos um executável que possui alguma DLL faltando ou funções específicas de alguma DLL, que é o caso. Para descobrir as dependências de um executável basta rodar o comando dumpbin de dentro de um terminal com as ferramentas do Visual Studio disponíveis.&lt;/p&gt;
&lt;p&gt;Dependências de APIs relacionadas com o SRWLock dizem respeito ao Slim Read/Write Lock do Windows, implementado a partir do Windows Vista. A primeira coisa a ser descoberta pelo programador é: quem está usando essas funções? Se não está no seu próprio código, provavelmente está em uma das libs linkadas. E uma dessas libs com certeza é o Boost.Log, pelo include no código.&lt;/p&gt;
&lt;p&gt;Note as linhas onde ::InitializeSRWLock é chamado. O escopo global indica que há uma dependência estática entre essa função API e o executável se essa parte do código for compilada, o que pode ser descoberto através da IDE do Visual Studio abrindo os arquivos e verificando se a parte onde há essas chamadas fica &amp;quot;cinza&amp;quot; (há defines que impedem essa parte de compilar), ou depurando e inserindo breakpoints nessa parte, que deverá ser chamada. O dumpbin poderia ser usado de novo caso houvesse símbolos para explorar o uso dessas funções de dentro do executável, mas por padrão a compilação do Boost não gera símbolos, tornando a tarefa ingrata, pois estará tudo em assembly sem tradução para o fonte.&lt;/p&gt;
&lt;p&gt;Então, ficamos mesmo na análise do código-fonte e da compilação:&lt;/p&gt;
&lt;p&gt;Se analisarmos onde BOOSTUSEWINAPIVERSION é definido descobriremos que ele é um reflexo do famigerado WIN32WINNT, que é o define que o Windows usa para determinar qual a versão mínima que o executável deve rodar. Windows Vista é 0x0600, Windows XP é 0x0501 (com SP 2 em diante 0x0502).&lt;/p&gt;
&lt;p&gt;Isso quer dizer que devemos compilar nosso projeto indicando que pretendemos rodar em Windows XP:&lt;/p&gt;
&lt;p&gt;E aí começam os problemas de linker.&lt;/p&gt;
&lt;p&gt;Aparentemente a própria lib Boost.Log está entrando em contradição com ela mesma, pois há usos dos métodos new e delete, por exemplo, entre vários. A análise da lib compilada irá nos revelar que esses nomes realmente não existem.&lt;/p&gt;
&lt;p&gt;Não há nenhum símbolo com esse namespace. Precisamos agora averiguar de onde ele vem.&lt;/p&gt;
&lt;p&gt;Então o Boost precisa ser compilado com esse define, também. Do contrário ele deve conter o namespace v2smtnt6 em sua lib. Mudando o define no nosso projeto ele irá apenas mudar a definição nos headers, mas não na lib já compilada.&lt;/p&gt;
&lt;p&gt;Mas para isso precisamos descobrir como o Boost é compilado no vcpkg. Sabemos que ele utiliza arquivos cmake dentro de cada subpasta em port, que junto de uma série de scripts já disponíveis pela ferramenta irá executar ações de compilação, instalação, etc. De dentro do Boost.Log encontramos alguns arquivos para analisar.&lt;/p&gt;
&lt;p&gt;Não há nada que indique a versão do Windows, mas há um include de boost-modular-build.cmake que parece útil.&lt;/p&gt;
&lt;p&gt;Há muito mais coisa nesse cmake, incluindo definição de toolset e os define de WIN32WINNT, que está como 0x602, ou seja, acima do Windows XP. No entanto, esses flags são da compilação do Visual Studio, e não do b2.exe, o compilador do Boost. Como vimos no início do artigo, são os parâmetros para o b2.exe que precisam ser modificados. Ao analisar sua execução de dentro do próprio cmake podemos verificar que há uma variável com essas opções, o bmOPTIONS. O que faz muito sentido.&lt;/p&gt;
&lt;p&gt;Me parece que o segredo é inserir ou modificar os argumentos dessa variável e as libs da Boost estarão automagicamente modificadas. Me parece isso hoje, horas e horas depois de analisar o build do vcpkg. Mas vou lhe economizar essas horas. Podemos realizar essa mudança pontualmente no boost-modular-build-helper, mas também devemos recompilá-lo, o que inclui suas dependências e toda a bagaça.&lt;/p&gt;
&lt;p&gt;Eu sei, é triste, mas mais uma caneca de café, uma partidinha de xadrez, e está pronta a recompilação. Fun fact: antigamente a compilação do Boost te dava essa dica de ir fazer café.&lt;/p&gt;
&lt;p&gt;And voilà! Não há mais dependências das APIs muito novas e conseguimos executar nosso programa em Windows XP. Mas, mais importante que isso, o que aprendemos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A verificar os símbolos importados por um executável usando &lt;code&gt;dumpbin&lt;/code&gt;, se certificando de que ele poderá rodar em SOs mais antigos.&lt;/li&gt;
&lt;li&gt;A buscar pelo uso de funções novas pelos fontes compilados pelo vcpkg.&lt;/li&gt;
&lt;li&gt;A analisar o build do vcpkg para poder modificá-lo e ser compatível com o ambiente que precisamos.&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Vcpkg: Atualizando Lib Asio</title>
  <link>http://www.caloni.com.br/vcpkg-atualizando-lib-asio/</link>
  <pubDate>2019-09-07</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg-atualizando-lib-asio/</guid>
  <description>&lt;p&gt;Hoje tive que compilar a versão 1.13.0 do Asio para Windows, mas o vcpkg não suporta essa versão ainda, apesar de suportar uma versão (1.12.2.2). Daí entra os problemas que todo programador Windows tem para manter bibliotecas de terceiro compilando em seu ambiente, mas agora com o vcpkg isso nem é tão difícil assim. Vamos lá.&lt;/p&gt;
&lt;p&gt;Primeiro de tudo, os pacotes disponíveis no vcpkg podem não ser os disponíveis no branch oficial, que é apenas uma base, que está sendo atualizado e mantido por uma equipe grande que responde os issues, é verdade, mas nem sempre possui as versões que precisamos no dia-a-dia. Para adicionar ou modificar os pacotes deve-se mexer na pasta port do projeto. Dentro dela há uma pasta para cada pacote disponível.&lt;/p&gt;
&lt;p&gt;É lá que fica a pasta asio, com seus quatro arquivos: asio-config.cmake, CMakeLists.txt, CONTROL e portfile.cmake. No CONTROL temos o sumário do pacote (nome, descrição, versão), no asio-config.cmake a receita CMake para fazer o build e em CMakeLists.txt como instalar. Isso varia de pacote para pacote, mas no caso de libs como a asio ela fica no GitHub, então em algum lugar nas instruções de instalação (aqui no caso em portfile.cmake) você irá encontrar o uso da função vcpkgfromgithub.&lt;/p&gt;
&lt;p&gt;A versão acima é a original. Ela irá obter os fontes baixando pela referência master do git, mas poderia ser outro branch ou tag. Para trocar a versão para a 1.13-0, por exemplo, existe uma tag para isso. Tudo que você precisa é mudar em HEADREF, mas para ficar mais bonito mude em REF também (além de atualizar o CONTROL, que contém informações sobre o pacote que o vcpkg irá exibir para o usuário). De início o SHA512 do download irá falhar, mas assim que você rodar o vcpkg install asio ele irá cuspir qual o hash correto. Daí é só atualizar no arquivo e rodar novamente.&lt;/p&gt;
&lt;p&gt;No caso dessa versão é assim que deverá ficar o portfile.cmake:&lt;/p&gt;
&lt;p&gt;Feito isso o pacote é baixado, compilado e instalado exatamente como a versão 1.12.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Do Bit para o Código</title>
  <link>http://www.caloni.com.br/do-bit-para-o-codigo/</link>
  <pubDate>2019-09-03</pubDate>
  
  <guid>http://www.caloni.com.br/do-bit-para-o-codigo/</guid>
  <description>&lt;p&gt;Olá. Esta é uma viagem para dentro do computador. Como funciona um computador? Você sabe? Pois é, nem eu. Mas vamos explorar alguns pontos onde nossa vã metafísica mal encosta na singularidade que é uma arquitetura Von Neumann.&lt;/p&gt;
&lt;p&gt;Em primeiro lugar, um bit. O que é um bit? Um bit nada mais é que um dado que se traduz em uma informação com dois, e apenas dois, valores possíveis: ligado ou desligado. Em eletrônica um bit precisa ser extraído de nosso mundo analógico, e quando eu digo analógico eu digo físico, onde existem átomos, prótons e elétrons, mas não existem bits, ou se existem, eles são muito complicados no momento.&lt;/p&gt;
&lt;p&gt;Por enquanto, a esmagadora maioria dos computadores utiliza a frequência de uma onda para representar um bit, e dizer se ele está ligado ou desligado. Um filtro de onda consegue detectar se a frequência está alta ou baixa, sendo que alta e baixa também é uma interpretação arbitrária. É estipulado uma determinada frequência e através dela o filtro sensibiliza para o mundo digital se no momento o fio condutor desta frequência está acima ou abaixo dessa frequência, o que para nós, humanos, irá significar se o bit está ligado ou desligado.&lt;/p&gt;
&lt;p&gt;Note que tanto faz a maneira com que você traduz a frequência, desde que haja apenas dois valor possíveis, condição sine qua non para definir um bit. Você pode interpretar uma frequência acima do nível estabelecido como ligado ou desligado, mas a partir dessa definição a frequência oposta, abaixo desse nível, deve ser o oposto do que foi definido, para assim termos o ligado/desligado (ou desligado/ligado).&lt;/p&gt;
&lt;p&gt;A onda (mais uma intepretação da realidade) gerada pela frequência do sinal elétrico, então, é dividida em dois espaços, delimitados pelo filtro, que funciona como um filtro de linha: apenas a partir de um certo valor da onda ele deixa passar os elétrons, que irão definir do outro lado se o bit está ligado ou desligado.&lt;/p&gt;
&lt;p&gt;Isso não quer dizer que o bit desligado (ou ligado, depende de como você definir) não contém eletricidade correndo antes do filtro, apenas que seu valor está abaixo do estabelecido para contar como ligado (ou desligado).&lt;/p&gt;
&lt;p&gt;A partir deste ponto podemos trabalhar com o mundo digital. Limpamos as &amp;quot;imperfeições&amp;quot; do mundo físico e transformamos elétrons esquivos em apenas dois valores possíveis: 0 e 1.&lt;/p&gt;
&lt;p&gt;Conseguindo usar e armazenar bits, a matemática fica muito mais simples e intuitiva para seres humanos, que só precisam trabalhar com uma base numérica de 2 valores em vez de 10. As mãos dos computadores possuem apenas um dedo cada, somando dois no total.&lt;/p&gt;
&lt;p&gt;Como a base é dois convencionamos a dar nomes para as potências de 2 para conseguirmos trabalhar com valores maiores que 0 e 1. 2 elevado a 8, por exemplo, chamamos de byte, embora não no mundo todo, isso também pode mudar de interpretação, dependendo da arquitetura. Porém, na grande maioria do mundo, um byte serão 8 bits, cada um pondendo valer 0 ou 1, e juntando todos, podemos representar os valores de 0 a 255, pois 2 elevado a 8 são 256 combinações (e devemos incluir o zero).&lt;/p&gt;
&lt;p&gt;A partir daí não existe muita mágica, pois juntando bytes podemos ter kilobytes (1024 bytes), dos kilobytes podemos ter megabytes, assim por diante até chegarmos no seu &amp;quot;HD de 2 Tera&amp;quot;, o que quer dizer 2 terabytes de informação, ou 35184372088832 bits, todos organizados para serem acessados, ou um a um ou em blocos. O que for mais conveniente para a arquitetura.&lt;/p&gt;
&lt;p&gt;Como acessamos esses bits? Bom, informação gera informação na tecnologia da informação. Precisamos dizer, usando bits, quais bits queremos obter do seu &amp;quot;HD de 2 Tera&amp;quot;. O primeiro? O segundo? O vigésimo-quinto? O de número 35184372088832?&lt;/p&gt;
&lt;p&gt;Para conseguir acessar precisamos de acesso, e esse acesso precisa conseguir deixar eu falar qual bit/byte que eu quero, ou seja, permitir que eu consiga passar esse valor (primeiro, segundo, etc). Onde está esse bit/byte nós chamamos de endereço, e para passar o endereço de um bit/byte para um HD usamos algo chamado barramento, que é como uma rodovia pode onde passam no máximo X bits.&lt;/p&gt;
&lt;p&gt;Porém, como vimos, dependendo do número de bits há um limite da quantidade de valores que podemos representar, e isso irá limitar o nosso acesso aos bits que queremos do &amp;quot;HD de 2 Tera&amp;quot;.&lt;/p&gt;
&lt;p&gt;Bom, já deu pra ver que 64 bits é suficiente para pegar muitos e muitos bits. O problema é que endereçar toda essa gente custa tempo, pois cada bit precisa ser interpretado para daí o HD conseguir chegar no bit que ele precisa para daí devolver o seu bit. Imagine que para acessar 1 bit você precisa enviar 64?&lt;/p&gt;
&lt;p&gt;Como esse modelo é impraticável criamos uma contraparte: em vez de apenas retornar 1 bit vamos diminuir a resolução e entregar já o bloco mais próximo de bits. Você manda 32 bits, por exemplo, e eu te mando uns 16 bytes, o que dá 65536 bits pela tabelinha acima. É um ótimo negócio, pois enviar bits e bytes para lá e para cá é muito mais barato, computacionalmente falando, do que ter que fazer uma busca de 1 bit em uma imensidão de bits. Essa quantidade de bits que o computador trabalha sempre que pedimos chamamos de palavra (word), o que faz muito sentido: estamos conversando com o computador, e ele responde com palavras geralmente, não com letras. Quem diabos responde um &amp;quot;olá&amp;quot; com &amp;quot;b&amp;quot;?&lt;/p&gt;
&lt;p&gt;Já aprendemos muita coisa. Sabemos que os elétrons de um fio condutor pode ser dividido em frequências alta e baixa da onda e que essa divisão transforma o mundo analógico/físico em mundo digital, com bits valendo apenas 0 e 1. Sabemos que 1 bit sozinho não faz muita coisa, então começamos a ajuntá-los com nomes como byte, kilobyte e &amp;quot;HD de 2 Tera&amp;quot;. Sabemos que para conseguir pegar os nossos bits de volta o computador pede bits que dizem onde eles estão, o que chamamos de endereço. E como mandar 32 bits para obter apenas 1 é muito trabalho de busca à toa, sabemos que o computador nos entrega de volta uma palavra, que é um naco de 8, 16, 32 bits ou valores maiores. É assim que nos comunicamos com os computadores: com palavras (words).&lt;/p&gt;
&lt;p&gt;Então, agora, o código abaixo não deve ser o menor mistério para nós:&lt;/p&gt;
&lt;p&gt;O programa acima verifica se a variável argc contém o valor 2. Argc é um int, o que quer dizer que na minha arquitetura são 4 bytes, ou 32 bits. Se esses 32 bits estão configurados com 0s e 1s de tal maneira que a soma de todos totalizam o valor 2, então meu código entrará dentro do primeiro if. Se não, então o código cairá no else e enviará os caracteres &amp;quot;How to use...&amp;quot; blá blá blá para a saída padrão através da chamada da função da libc puts. Esses caracteres também são formados por bits. Cada caractere possui 8 bits. E estão configurados de tal forma que darão um valor de 0 a 255 que será interpretado de tal maneira: o nth elemento da entrada de uma tabela de caracteres. Essa tabela se chama tabela ascii, e contém os números 0 a 9, as letras de a até z (e maiúculas, A até Z), alguns sinais, etc. Essa é uma nova forma de interpretar os números que conseguimos somando os bits, e só funciona dessa forma porque a linguagem C está especificada dessa maneira.&lt;/p&gt;
&lt;p&gt;Essas letras representam o alfabeto romano, usado por boa parte do Ocidente, mas para o computador isso é apenas um comando que depois de passar por várias camadas de interpretação, incluindo o sistema operacional (que controla bits e bytes acima do computador), irá acender determinados leds em seu monitor para que o ser humano que estiver olhando para ele irá entender que aquilo é a letra H, por exemplo. No caso de H, imagine que ele está acendendo uma série de leds da cor da letra que está vendo exatamente na posição que você está olhando, enquanto em volta está acendendo a cor do fundo onde essa letra está sendo &amp;quot;impressa&amp;quot;. Se pudéssemos enxergar com um zoom, poderíamos ver cada um desses leds acesos, mas perderíamos a noção de qual letra no final está sendo desenhada. Na época de monitores de tubo e preto e branco era até possível ver os dois, mas hoje em dia o celular mais vagabundo exibe milhões e milhões de leds em sua cara.&lt;/p&gt;
&lt;p&gt;Poderíamos continuar explicando o que é esse FILE e como ele se relaciona com o seu &amp;quot;HD de 2 Tera&amp;quot; para abrir apenas os bits que dizem respeito ao nome do arquivo, que é uma entrada em outra tabela de nomes de arquivos que ele encontra perguntando para o sistema operacional e assim lendo a posição correta dos bits que você precisa e assim por diante até que sua mente estrale e você entenda a miríade de abstrações e interpretações da realidade com que estamos lidando. Daí você veria que eu sou que nem você, dos bits e bytes, dos bauds e sockets, e que me surpreendo a cada dia em como mais e mais interpretações são possíveis de serem criadas a partir de um mundo digital inteiro construído a partir de nosso mundo físico. Bem-vindo ao meu mundo, ao nosso mundo, programador =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Some things I learned in a Hacker Rank exercise</title>
  <link>http://www.caloni.com.br/hacker-rank/</link>
  <pubDate>2019-08-08</pubDate>
  
  <guid>http://www.caloni.com.br/hacker-rank/</guid>
  <description>&lt;p&gt;A couple of days ago I subscribed to Hacker Hank, a website specialized in provide interview exercises. The site is as a better version of Code Jam, with the possibility to Compile &amp;amp; Run the code, as well as running several test cases.&lt;/p&gt;
&lt;p&gt;Talking with friends about one of them proposed a interesting puzzle called Find the Running Median. This is a good problem because it is easy to understand and tricky to implement.&lt;/p&gt;
&lt;p&gt;My first attempt was naive, but worked for test cases where there were no duplicated numbers, a detail I overlooked in the description and happenned the very first test (lucky me it is possible to download the test cases, input and output, giving in return some of the points accumulated solving other problems).&lt;/p&gt;
&lt;p&gt;So I started to draw in my window a new solution, based on inplace sort algorithm, using the same vector proposed skeleton by the site. The idea was to just move elements inside the vector, ordering them as calculating the median to evey new number.&lt;/p&gt;
&lt;p&gt;I still wasn&#39;t thinking about the sort algorithm until I began to try and fail several times, but this try/error bitch always taught me how to make things faster then embryological bullshit to born from scribbed windows. It only requested a debugger to make the edit, compile, debug triple step.&lt;/p&gt;
&lt;p&gt;I was still trying in the window, thought, until in one of these iteractions with the compiler/debugger I achieved a simples, clearer solution, using only offsets from the vector instead of iterators.&lt;/p&gt;
&lt;p&gt;This version almost done it, except for timeout error. Hacker Hank has a timeout of 2 seconds to C++ solutions and I was exceding it. After some thought (more try/error) I thought about change the container, but before I made a simples test: instead of using erase/insert methods make the things manually as in good old C.&lt;/p&gt;
&lt;p&gt;And it worked. Now what I learned looking the other solutions.&lt;/p&gt;
&lt;p&gt;There are incredible tools in C++, even since 98 or 11, that are frequently overlooked, but it is important to notice that the language has a framework for processing: containers, algorithms and so on. By example, looking for other solutions I learned about the characteristics of multiset and priorityqueue (spoiler: both have a ordering predicate and are logarithmic). There are smart functions in algorithm, too, as lowerbound.&lt;/p&gt;
&lt;p&gt;A lot of solutions simply ignored the skeleton provided by the site and began its own code from scratch, eliminating the &amp;quot;request&amp;quot; that the numbers must be stored first in a vector. Sometimes, when there as skeleton in our life, we use them as guidelines, forgetting that &amp;quot;there is no spoon&amp;quot;.&lt;/p&gt;
&lt;p&gt;I hope you learned something, too. You can see my Hacker Rank attempts in the site (nickname caloni) or my GitHub repository.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>tiodb</title>
  <link>http://www.caloni.com.br/tiodb/</link>
  <pubDate>2019-07-27</pubDate>
  
  <guid>http://www.caloni.com.br/tiodb/</guid>
  <description>&lt;p&gt;Antigamente ele era conhecido apenas como tio, mas seu nome foi trocado para a nova modinha dos hubs com o sufixo db: são os chamados nosql. De qualquer forma, o tio, ou The Information Overlord (pesquise na web para ver se acha essa referência), começou com um núcleo e uma ideia muito simples que continuam até hoje, e que ainda é difícil de achar por aí: um servidor que mantém em memória contêineres STL disponíveis via socket em um protocolo simples. Este artigo irá explicar como baixar os fontes do servidor, compilar e acessar esses contêineres via telnet, o que possibilita a integração com virtualmente qualquer coisa que se comunique via socket.&lt;/p&gt;
&lt;p&gt;Para executar as ações descritas abaixo você irá precisar de Visual Studio [1], Vcpkg [2] e CMake [3]. Os fontes do projeto oficial se encontram no GitHub [4]. A partir dele clone o repo localmente e entre pelo terminal na pasta server/tio.&lt;/p&gt;
&lt;p&gt;A partir dessa pasta você irá construir o tiodb.exe, que é o único executável que você precisa compilar do projeto. Nele há um CMakeLists.txt e você irá precisa de algumas libs do boost compiladas. Então, por que não compilar todas elas? Se você não tiver o vcpkg, baixe-o do repositório do GitHub e compile seguindo as instruções do README. Tendo ele compilado basta mandar instalar os pacotes boost para x86.&lt;/p&gt;
&lt;p&gt;Isso pode demorar. Hora do café.&lt;/p&gt;
&lt;p&gt;Após o boost x86 instalado e sabendo que seu CMake está disponível no path, crie uma pasta para seu build, mova para ela pelo terminal e execute o seguinte comando:&lt;/p&gt;
&lt;p&gt;Em seguida poderão haver problemas relacionados com o padrão C++ que eliminou a classe autoptr, por exemplo (mudar para uniqueptr) ou no Boost, que possui a dependência do módulo datetime não-especificado (esses problemas logo devem se resolver no repo oficial, mas no momento você pode obter essas mudanças no meu repo [5]).&lt;/p&gt;
&lt;p&gt;Após configurado o ambiente via CMake em um mundo ideal tudo deve estar funcionando. Basta agora compilar o projeto em si.&lt;/p&gt;
&lt;p&gt;O comando acima pode ser executado se você estiver com o ambiente do Visual Studio configurado em seu terminal. Outra opção, IDE friendly, é abrir o tiodb.sln e compilar pelo Visual Studio. De qualquer forma, se tudo der certo (novamente: em um mundo ideal) você deverá ter um executável em Debug\tiodb.exe. Basta executá-lo e ele irá abrir a porta 2605 em sua máquina e ficar escutando requisições.&lt;/p&gt;
&lt;p&gt;Com o tio rodando você pode partir para o telnet, usando a ferramenta telnet disponível no SO ou alguma outra ferramenta de terceiro como Putty (no Windows). Vamos criar uma lista direto de lá e já demonstrar alguns comandos do protocolo texto.&lt;/p&gt;
&lt;p&gt;Há comandos para criar contêineres, inserir itens, obter itens, etc. Para ser sincero, não imaginava que fosse tão complexo. Faz anos que mexo indiretamente com o tio e faz muito tempo que não abro um telnet. Fui olhar o código-fonte, mas a interpretação não é óbvia. Fui olhar a documentação, mas ainda assim não é muito clara [6] (nem fácil de achar).&lt;/p&gt;
&lt;p&gt;Bom, essas foram as aventuras iniciais. A partir daí podemos explorar mais.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://visualstudio.microsoft.com/&#34;&gt;https://visualstudio.microsoft.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;https://github.com/microsoft/vcpkg&#34;&gt;https://github.com/microsoft/vcpkg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;https://cmake.org/&#34;&gt;https://cmake.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[4] &lt;a href=&#34;https://github.com/tiodb/tiodb&#34;&gt;https://github.com/tiodb/tiodb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[5] &lt;a href=&#34;https://github.com/Caloni/tiodb&#34;&gt;https://github.com/Caloni/tiodb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[6] &lt;a href=&#34;https://code.google.com/archive/p/tio/wikis/Protocol.wiki&#34;&gt;https://code.google.com/archive/p/tio/wikis/Protocol.wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>SLQLocalDB</title>
  <link>http://www.caloni.com.br/sqllocaldb/</link>
  <pubDate>2019-07-21</pubDate>
  
  <guid>http://www.caloni.com.br/sqllocaldb/</guid>
  <description>&lt;p&gt;Hoje foi o dia de redescobrir meu velho ranço com a solução Microsoft para banco de dados. Já perdi horas, dias e semanas com problemas de conexão com algum servidor SQL Server porque a instalação possuía configurações de segurança específicas, a string de conexão não estava exatamente de acordo com a versão instalada ou uma combinação macabra desses e de mais alguns problemas.&lt;/p&gt;
&lt;p&gt;Após degladiar novamente com problemas com o SQL Server Express 17 minha esperança para este projeto que requer este banco de dados foi uma versão mínima chamada de LocalDB [1]. Essa versão tem objetivo de servir para desenvolvedores, pois é tão mínima que apenas roda quando você usa, além de permitir isolamento por contas e compartilhamento entre contas e até remoto via named pipe. Parece bom, não?&lt;/p&gt;
&lt;p&gt;O marketing da Microsoft sempre será melhor do que as reais soluções entregues. Depois de ver tudo isso funcionar em um banco criado com o LocalDB em pequenos e simples passos, as dores de cabeça começaram na hora de compartilhar ou de criar do zero este mesmo banco em uma conta de sistema, que é como rodam geralmente os serviços do projeto:&lt;/p&gt;
&lt;p&gt;O fun fact até aqui é que a primeira versão que tentei, a Express 2017, sequer chegava nesse ponto, dando erros de conexão com named pipe ou timeout no login. Não estou certo de como funcionaria um login em um acesso local em um arquivo, mas essa era uma mensagem extremamente longa e potencialmente inútil. Encontrei uma outra alma sofredora na internet neste mesmo dia de hoje que recomendou fazer o rollback para o Server 2016 [2] (por isso a versão 13.1 no prompt acima), mas os erros apenas mudam de figura ou se repetem indefinidamente.&lt;/p&gt;
&lt;p&gt;Aliás, outro fato curioso e revoltante é que a Microsoft sequer mantém a versão anterior dos seus produtos para download. A versão 2016 achei no site de alguém que se dispôs a mantê-los. Do contrário, a solução seria &lt;del&gt;sentar e chorar&lt;/del&gt; olhar o código-fonte.&lt;/p&gt;
&lt;p&gt;Rá, brincadeira. Não tem o código-fonte.&lt;/p&gt;
&lt;p&gt;Um erro frequente e algumas vezes reportado pelas internet é o do login, mesmo. Pesquisando mais a fundo encontrei um artigo no Code Project [3] (quem diria, velhos tempos em que postava nele) de 2014 onde a pessoa explicava que depois de ler muito e testar muito ele descobriu praticamente depurando a instância do SQL Server e descobrindo que o problema estava em um crash que nunca voltava, sendo necessário dropar todas as conexões (ou o conhecido restart que várias pessoas também recomendaram).&lt;/p&gt;
&lt;p&gt;Esse não é o meu problema. Meu problema é conseguir rodar a solução na conta de sistema, e desconfio que o modo em que o psexec executa o cmd.exe na conta de sistema pode estar relacionado, pois contas interativas em sistema são fontes clássicas de configuration mismatch (talvez falte ou sobre variáveis de ambiente, alguns handles perdidos, essas coisas).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb&#34;&gt;https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;https://feedback.azure.com/forums/908035-sql-server/suggestions/36481279-sql-server-2017-express-localdb-shared-instance-co&#34;&gt;https://feedback.azure.com/forums/908035-sql-server/suggestions/36481279-sql-server-2017-express-localdb-shared-instance-co&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;https://www.codeproject.com/Tips/775607/How-to-fix-LocalDB-Requested-Login-failed&#34;&gt;https://www.codeproject.com/Tips/775607/How-to-fix-LocalDB-Requested-Login-failed&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Como Publicar Seu Blog Em Hugo Para Ebook</title>
  <link>http://www.caloni.com.br/como-publicar-seu-blog-em-hugo-para-ebook/</link>
  <pubDate>2019-07-10</pubDate>
  
  <guid>http://www.caloni.com.br/como-publicar-seu-blog-em-hugo-para-ebook/</guid>
  <description>&lt;p&gt;Eu publico meu blog inteiro de tempos em tempos para um ebook que construo formatando primeiro em html através de um tema do Hugo, o parser de blog que estou usando no momento porque ele suporta 2500 posts sem reclamar. É uma receita simples de sucesso se você precisar ter todo seu conteúdo indexado para rápida referência ou leitura cronológica.&lt;/p&gt;
&lt;p&gt;A primeira coisa a ser feita é preparar um tema para formatar seu html. Eu já tenho um linkado no meu blogue e que precisa apenas formatar o index.html, pois todo o conteúdo e índices estarão lá. Segue um exemplo atual que uso. Ele possui índice alfabético, inclusão de um arquivo-diário que mantenho, listagem das categorias (com índices para cada uma delas) e listagem cronológica (e link para pular direto para o conteúdo).&lt;/p&gt;
&lt;p&gt;Como eu uso Kindle eu construo a partir desse html um arquivo .mobi, mas creio ser simples de construir qualquer outro formato através desse html final. No caso do Kindle preciso de alguns arquivos para usar o kindlegen (a ferramenta da Amazon) que mantenho na pasta static do hugo, como o .ncx e o .opf (além da capa, cover.jpg). Uso uma batch muito pequena para fazer todos os passos e copiar o .mobi resultante para meu Kindle (conectado por um cabo USB e com um drive montado em K:).&lt;/p&gt;
&lt;p&gt;Importante lembrar que a codificação do hugo (utf8) deve bater com a codificação esperada pelo gerador de ebook. Que me lembre não há muito mais segredos. Basta escrever e de vez em quando rodar o script novamente =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>C Resolve Tudo: goto</title>
  <link>http://www.caloni.com.br/goto/</link>
  <pubDate>2019-05-28</pubDate>
  
  <guid>http://www.caloni.com.br/goto/</guid>
  <description>&lt;p&gt;Para quem decide usar a linguagem C para resolver tudo, a gota da água é o goto. Ele é flexível, cabe em (quase) qualquer ponto do código e tem 1001 utilidades. O goto é o bombril da engenharia de software.&lt;/p&gt;
&lt;p&gt;O uso mais simples dessa importante construção da linguagem é pular de um ponto para outro do código em que esses pontos não estão diretamente relacionados, como geralmente ocorre, como sair de um laço, não entrar em um if ou selecionar um case do switch (lembrando que no caso do case do switch ele é no fundo um goto disfarçado).&lt;/p&gt;
&lt;p&gt;Claro que esse uso é trivial demais para valer a pena uma troca de fluxo tão desestruturada. Há formas mais úteis de desviar o fluxo padrão. No exemplo acima bastaria colocar todo o código que se segue dentro do grupo pertencente ao if e o goto seria desnecessário.&lt;/p&gt;
&lt;p&gt;Mas, por exemplo, imagine que precisamos nos desfazer de recursos na ordem inversa ao qual vão sendo adquiridos. Pode-se aninhar indefinidamente ifs ou usar um bloco de código de unwinding que vai fechando os recursos na ordem inversa e inicia sua chamada dependendo de onde ocorreu o erro. Código é melhor para ilustrar:&lt;/p&gt;
&lt;p&gt;Esse estilo de liberação de recursos é muito usado em códigos de kernel e software mais básico, pois simplifica a visualização e aumenta a flexibilidade. Compare com a versão estruturada:&lt;/p&gt;
&lt;p&gt;Aliás, esse uso do goto é a maneira de aplicar RAII em C (Resource acquisition is initialization). Implícito em linguagens como C++ e seus destrutores de objetos, em C é você que precisa fazer a faxina. E se a bagunça foi feita da direita pra esquerda a faxina deve ser feita da esquerda pra direita.&lt;/p&gt;
&lt;p&gt;Esse uso super-aninhado do código me lembra do exemplo clássico de sair de muitos loops aninhados. Apenas por didática, vamos citá-lo:&lt;/p&gt;
&lt;p&gt;Comentei no começo do texto que os cases do switch são labels de goto disfarçados. E são mesmo. Um dos algoritmos mais famosos de transformação de loop chamado Duff&#39;s device junta um do-while com switch e realiza uma cópia de buffer com um número de bytes variável:&lt;/p&gt;
&lt;p&gt;O que está acontecendo no código acima: é possível inserir qualquer tipo de mudança de fluxo dentro do switch. Duff aproveitou essa particularidade da linguagem para produzir jumps que poderiam ser feitos em assembly. Dependendo do resto da divisão por oito o salto é realizado para um case diferente, que executará parte do laço até o while comparador final. A vantagem desse tipo de abordagem é que evita-se sair da programação estruturada, e muito menos precisa-se apelar para o assembly.&lt;/p&gt;
&lt;p&gt;Esse código também seria possível de ser feito com o goto clássico, mas note que nesse caso ele fica mais verboso, pois é necessário fazer um if diferente para cada condição.&lt;/p&gt;
&lt;p&gt;Caso você tenha estranhada a definição inicial da função, ela é como se definia os argumentos em linguagem C antes do padrão ANSI, com os nomes e logo em seguida a declaração das variáveis como se fossem locais (porque de fato elas são, embora sua inicialização seja feita antes da chamada). Como este código data dos anos 80 e como o padrão só foi finalizado em 89, percebe-se que ainda se usava o formato antigo no código.&lt;/p&gt;
&lt;p&gt;Passemos para o próximo uso: código infinito. Esse é um uso clássico, e diferente do uso degenerado de laços em que a condição é sempre verdadeira (while(true), for(;;)) usando o goto fica bem-documentado que o objetivo é ficar eternamente nesse loop. Um laço infinito que eu me lembro é quando dá tela azul no Windows. O código-fonte do kernel era algo mais ou menos assim:&lt;/p&gt;
&lt;p&gt;Os programadores usaram o apelo clássico do while. Sem motivo, pois goto é usado direto como RAII (já explicado acima). A maneira procedural de fazer seria assim:&lt;/p&gt;
&lt;p&gt;Isso lembra outra utilidade do goto que você pode anotar no seu caderninho: ele pode voltar o fluxo, de baixo para cima.&lt;/p&gt;
&lt;p&gt;Esse último exemplo é um dos programas C mais lindos do universo. Sua única instrução é o comando rotulado por infinite e referencia ele mesmo. É quase o salto incondicional do assembly, materializado na linguagem mais elegante jamais criada em nossa realidade.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>C Resolve Tudo Clos</title>
  <link>http://www.caloni.com.br/c-resolve-tudo-clos/</link>
  <pubDate>2019-05-17</pubDate>
  
  <guid>http://www.caloni.com.br/c-resolve-tudo-clos/</guid>
  <description>&lt;p&gt;Continuando nossa série, conforme sugerido pelo @colemaker do grupo C/C++/42/Império do Brasil, a próxima ideia a ser implementada em C é o sistema polimórfico de chamadas do Lisp orientado a objetos. Esse sistema permite realizar a seguinte manobra:&lt;/p&gt;
&lt;p&gt;O aspecto-chave aqui, conforme eu descobri, é implementar a estratégia de prioridades entre as sobrecargas dos métodos de acordo com os tipos passados. Analisando bem por cima devemos sempre priorizar os métodos com os tipos mais específicos e ir realizando underpromotion até chegarmos no menos específico (se houver).&lt;/p&gt;
&lt;p&gt;A implementação está no GitHub. Para o sistema de tipos em C nada como fazer do zero:&lt;/p&gt;
&lt;p&gt;As estruturas estão usando STL. O quê? Mas não era C? Sim, você tem toda razão. Porém, estou usando uma lib mais conhecida. Há milhares de libs containers em C para você escolher para trocar a implementação. Lembre-se que o mais importante não é ser purista, mas atingir os objetivos. Como eventualmente veremos nessa série de artigos, o próprio C++ e toda a sua biblioteca pode ser implementada em C. Este é apenas um atalho para fins didáticos e de produtividade (como eu já falei, produtividade não é o foco aqui, mas enxergar por debaixo dos panos).&lt;/p&gt;
&lt;p&gt;Inicialmente feito em STL pela produtividade, a solução atual no GitHub é feita inteiramente em C usando a glib (lib comum em Linux com estrutura de dados, etc). O legal dessa biblioteca é que ela tem 20 anos (desde 1998) e já foi muito usada e testada, além de possuir estruturas e algoritmos simples que fazem parte do pacote básico de qualquer programador, como arrays, strings, hash tables.&lt;/p&gt;
&lt;p&gt;O código é bem simples. Mapas e listas com strings e ponteiros para organizar as estruturas por detrás do sistema de tipos que estamos implementando e seus métodos sobrecarregados. Cada método possui um nome, um endereço de ponteiro e o número dos seus argumentos. Todos os argumentos são do tipo polimórfico, seguindo o que provavelmente existe por detrás da própria implementação do Lisp.&lt;/p&gt;
&lt;p&gt;O código que utiliza a clos.c é bem direto e enxuto. Como no Lisp.&lt;/p&gt;
&lt;p&gt;Futuros posts sobre C Resolve Tudo poderão utilizar a glib ou qualquer outra. Uma outra vantagem da linguagem C é que sua biblioteca padrão é muito enxuta, sendo fácil de ter disponível em seu ambiente um compilador C com a clib, e em cima dela você pode utilizar qualquer biblioteca de sua escolha para estruturas e algoritmos mais complexos. Ou fazer a sua própria.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>C Resolve Tudo: Orientação a Objetos (com Polimorfismo)</title>
  <link>http://www.caloni.com.br/c-resolve-tudo/</link>
  <pubDate>2019-05-17</pubDate>
  
  <guid>http://www.caloni.com.br/c-resolve-tudo/</guid>
  <description>&lt;p&gt;Como programadores há um vício em nossas cabeças que é estar constantemente buscando a bala de prata, ou seja, a solução final e única para todos os nossos problemas de implementação. Com o tempo e alguma experiência descobrimos que tal coisa não existe, mas até lá nos encantamos com esse ou aquele framework, e claro, com essa ou aquela linguagem.&lt;/p&gt;
&lt;p&gt;As linguagens que são criadas depois da revolução dos computadores pessoais querem facilitar a vida do programador médio embutindo soluções já testadas por programadores de verdade e evitando a todo custo que o código incorra em erros comuns. Além disso, há movimentos nas comunidades e no mercado que geram tendências que influenciam essas linguagens, o que explica design patterns, orientação a objetos, programação funcional, xp, scrum, devops e qualquer outra bala de prata que vá se solidificando.&lt;/p&gt;
&lt;p&gt;Expliquei tudo isso para chegar no tema deste artigo: você pode fazer tudo isso usando linguagem C.&lt;/p&gt;
&lt;p&gt;Mas aí você deve estar se perguntando: &amp;quot;supor que uma linguagem resolve tudo não é estar defendendo também uma bala de prata?&amp;quot;. A resposta é sim e não. Sim, é uma bala de prata se você pensar que pode fazer do zero sites e interfaces gráficas modernas em C puro. Mas a resposta também é não porque eu estou trabalhando em uma outra camada, aquela em que as soluções que ficam pra sempre são implementadas. Estou falando de pensar sempre na linguagem C quando estiver interessado no funcionamento das outras soluções.&lt;/p&gt;
&lt;p&gt;Esse mindset propost tem como objetivo impedir que você pense que as outras soluções são mágicas porque se você consegue pensar em C ela é real. Se tem algo que a linguagem C não é esse algo é mágica. C é uma simples abstração de uma máquina virtual que se relaciona de maneira muito íntima com as implementações em assembly de várias arquiteturas. Mágica é algo que te impede de enxergar em que momento uma solução se encontra com o hardware. C nunca irá te impedir de fazer isso.&lt;/p&gt;
&lt;p&gt;Dito isto, vamos analisar algumas balas de prata e entender como em C isso é implementado para revelar a mágica.&lt;/p&gt;
&lt;p&gt;A Orientação a Objetos se divide em algumas features. Algumas não vale a pena falar aqui, como tratar tudo como objeto. C já faz isso através de structs. Você pode montar uma struct que possua métodos, inclusive, através de ponteiros para função. E esses métodos já são sobrecarregáveis e virtuais.&lt;/p&gt;
&lt;p&gt;A sobrecarga se torna algo trivial, bem documentada através dos nomes das funções que você está chamando. Tudo fica às claras, nada implícito, nada disse que me disse. Se eu chamo um método NewMyClass2 é óbvio que estou construindo uma segunda versão baseada na primeira, e posso inclusive comparar para ver se os métodos são originais ou sobrescritos com obj.method == &amp;amp;method, por exemplo. Além disso, é possível realizar composições de tipos onde alguns métodos são sobrescritos enquanto outros são compostos por chamadas duplas, triplas. Não há qualquer limitação ao polimorfismo exceto o que você define.&lt;/p&gt;
&lt;p&gt;Os métodos são &amp;quot;estáticos&amp;quot; por default (não há contexto), o que aliás facilita programação funcional, mas você pode buscar contexto onde te interessa, passando como parâmetro toda a &amp;quot;classe&amp;quot;, seja por valor ou referência, ou passando até uma versão parcial dela. Há inúmeras maneiras de construir um objeto em C, pois ele não está restrito às regras de sintaxe da definição da linguagem, uma vez que é você que define. Além disso, como você deve ter percebido, para declarar tipos de structs é necessário o uso dessa palavra-chave, mas a linguagem C já possui um sistema de typedef para trocar convenientemente qualquer definição de tipo como um nome único.&lt;/p&gt;
&lt;p&gt;Note que podemos ao redefinir a função de soma a de multiplicação também é alterada, mesmo não alterando seu funcionamento (mas alterando uma função que ela usa).&lt;/p&gt;
&lt;p&gt;Este é apenas um exemplo besta de polimorfismo, além de um exemplo trivial de como OO em C é infinitamente mais rico e mais complexo. Está nas mãos do programador definir até onde vai a solução proposta. E é bom saber que não existe bala de prata.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Coroutines Em C: Picoro</title>
  <link>http://www.caloni.com.br/coroutines-em-c-picoro/</link>
  <pubDate>2019-05-08</pubDate>
  
  <guid>http://www.caloni.com.br/coroutines-em-c-picoro/</guid>
  <description>&lt;p&gt;Tantas linguagens hoje em dia tentando implementar a abstração de corrotinas e inserindo mais camadas de abstração (fibras e cereais)... há duas implementações já no Boost, ambas dependendo de uma biblioteca de contexto de stack que é dependente de arquitetura (programada em Assembly).&lt;/p&gt;
&lt;p&gt;E aqui está a linguagem C com sua elegância, minimalismo e a filosofia &amp;quot;just works&amp;quot;, por mais ou menos 50 anos.&lt;/p&gt;
&lt;p&gt;Estava pesquisando sobre bibliotecas de corrotinas em C e encontrei a Picoro, de Tony Finch. Três coisas me encantaram nela:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;portabilidade (fácil de testar em qualquer arquitetura).&lt;/li&gt;
&lt;li&gt;simplificade (um header e um .c com menos de 200 linhas, e a maioria são comentários).&lt;/li&gt;
&lt;li&gt;manutenção (o último commit é de 2010, ou seja, ninguém mais mexeu nela por nove anos).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ela é uma biblioteca feita para resolver o problema mais básico de toda corrotina: troca de contexto. Isso é feito de maneira descentralizada, embora ela inicie com uma corrotina principal: a primeira que constrói uma corrotina. A partir dessa é possível criar outras e dar resume em qualquer uma delas que não tenha terminado.&lt;/p&gt;
&lt;p&gt;A linguagem C já implementa troca de contexto através das funções padrão setjmp e longjmp. Há um tipo dependente de arquitetura, jmpbuf, que é usado para guardar o contexto. O salto é feito no estilo da função fork do Unix, ou seja, não há inclusão de mais nenhuma sintaxe diferente do usual: é um if que retorna 0 (contexto principal) ou não-0 (estamos em outro contexto).&lt;/p&gt;
&lt;p&gt;O picoro organiza tudo isso em torno de uma lista ligada. Aliás, de duas listas ligadas: running e idle, onde o head de cada uma delas é usado para verificar se há corrotinas paradas ou em execução. Há algumas regras básicas para que tudo funcione. Por exemplo, uma corrotina que já foi executada até o final ou que está bloqueada pela chamada de resume não pode ser posta para rodar.&lt;/p&gt;
&lt;p&gt;Vamos começar com um exemplo simples: apenas um corrotina que recebe um inteiro e incrementa três vezes. A cada vez que ele incrementa ele devolve o controle de execução via yield. O main cria três dessas corrotinas e dá resume em cada uma delas três vezes, finalizando a execução de todas. Ao final, o counter final é de 9.&lt;/p&gt;
&lt;p&gt;É importante observar que o uso de troca de contexto pode facilmente consumir a pilha, pois ela está sendo compartilhada com muitas funções em paralelo. Para reservar espaço a &lt;code&gt;coroutinestart&lt;/code&gt; aloca um array de 16 KB (fixo). Esses detalhes de implementação podem ser alterados, pois a biblioteca é tão mínima e simples de entender que construir qualquer coisa em cima dela é trivial.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Visual Studio Unit Test (C&#43;&#43;)</title>
  <link>http://www.caloni.com.br/visual-studio-unit-test/</link>
  <pubDate>2019-05-06</pubDate>
  
  <guid>http://www.caloni.com.br/visual-studio-unit-test/</guid>
  <description>&lt;p&gt;Desde o Visual Studio 2015 há suporte a unit tests em C++ automatizado na IDE. Porém, a partir do VS 2017 15.5 o suporte aumentou drasticamente, vindo embutidos os suportes para as bibliotecas de teste Google Test, Boost.Test e CTest. Além, é claro, do Microsoft Unit Testing Framework for C++, o caseiro da M$.&lt;/p&gt;
&lt;p&gt;Além disso, é possível você mesmo integrar o Visual Studio com outra lib de testes. Mas para que gastar tempo? Várias integrações já estão disponíveis no Visual Studio Marketplace. Ligue já!&lt;/p&gt;
&lt;p&gt;OK, parei com o merchan. Até porque não ganho nada com isso. Vamos ao código.&lt;/p&gt;
&lt;p&gt;Pelo Wizard do VS podemos criar para um projeto C++ qualquer um projeto de teste. No momento estou vendo os tipos de projeto Native Unit Test e Google Test.&lt;/p&gt;
&lt;p&gt;Este é nosso projeto de exemplo:&lt;/p&gt;
&lt;p&gt;Para conseguir testar o projeto principal adicione-o como referência.&lt;/p&gt;
&lt;p&gt;Após isso basta incluir algum header que contenha os tipos, funções, classes e métodos que deseja testar e vá criando métodos de teste dentro da classe de exemplo:&lt;/p&gt;
&lt;p&gt;Agora abrindo o jogo para você, amigo programador C++ que gosta de saber tudo que ocorre debaixo dos panos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Um projeto Unit Test é apenas uma DLL com uns códigos de template.&lt;/li&gt;
&lt;li&gt;Esse código já adiciona a lib de unit test da Microsoft e cria uma classe com exemplo de uso.&lt;/li&gt;
&lt;li&gt;Adicione todo código do projeto original que ele precisa para compilar.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Por isso eu tirei a tranqueira de precompiled header do projeto de unit test, retirei a referência (sugestão do tutorial da Microsoft) e apenas adicionei o mesmo cpp para ser compilado.&lt;/p&gt;
&lt;p&gt;Agora mais mágica: se você abrir a janela Test Explorer ele irá encontrar seus testes e enumerá-los!&lt;/p&gt;
&lt;p&gt;Se você já programou um pouco em Windows com C++ já deve saber o truque: como o Unit Test é uma DLL ela simplesmente exporta os símbolos necessários para que o Visual Studio encontre o que precisa. O básico que um plugin dos velhos tempos faz: exportar interfaces com um pouco de reflection.&lt;/p&gt;
&lt;p&gt;Se você habilitar Undecorate C++ Functions no Dependency Walker verá que ele exporta justamente uma espécie de reflection, na forma de structs:&lt;/p&gt;
&lt;p&gt;E se você prestar atenção na ordem de exportação desse símbolos verá que o primeiro se chama GetTestClassInfo. Acabou a magia, não é mesmo?&lt;/p&gt;
&lt;p&gt;Os headers e fontes do CppUnitTest ficam em paths do Visual Studio como VC\Auxiliary\VS\UnitTest, nas pastas include e lib. Nele é possível dar uma olhada no significado das macros e das classes disponibilizadas. Logo abaixo das macros, no arquivo principal, é possível ver como funciona o reflection:&lt;/p&gt;
&lt;p&gt;É uma lib pequena e elegante que permite uma interação não apenas com a IDE, como poderia ser automatizada por um script, uma vez que sabe-se o funcionamento interno e algumas interfaces.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Const Int Pointer Var</title>
  <link>http://www.caloni.com.br/const-int-pointer-var/</link>
  <pubDate>2019-04-29</pubDate>
  
  <guid>http://www.caloni.com.br/const-int-pointer-var/</guid>
  <description>&lt;p&gt;A melhor forma de declarar variáveis ponteiros (constante ou não, mas segue o exemplo) é const int pointer var. Explicação:&lt;/p&gt;
&lt;p&gt;Quem diz o asterisco fazer parte do tipo e não da variável tem razão. Pensando dessa forma ele tem que ficar próximo do tipo.&lt;/p&gt;
&lt;p&gt;Porém, outra forma de interpretar a variável é que ela equivale a um inteiro quando usado com asterisco, o que também é verdade. Ou seja, int pointer var significa que pointer var equivale a um int (constante ou não, mas preciso dessa variável não-const para o exemplo). É por isso que pointer var igual a dez possui o mesmo valor de atribuição do que int var seguido de var igual a dez, ou seja, pointer var é sinônimo do l-value var (se var fosse um inteiro e não um ponteiro).&lt;/p&gt;
&lt;p&gt;Além disso, outro argumento pró-proximidade da variável é que declarações de múltiplas variáveis na mesma linha precisam de múltiplos asteriscos: const int pointer var1, pointer var2, pointer var3.&lt;/p&gt;
&lt;p&gt;Portanto, como ambos os lados estão certos, separar o asterisco de ambos não dá prioridade a nenhuma forma que o programador poderá interpretar essa decisão, seja como parte do tipo ou da variável. Cada programador com seu próprio estilo irá enxergar em const int pointer  var a proximidade com int ou com var de acordo com seu próprio bias (e estará certo em sua análise).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>OpenSSH no Windows</title>
  <link>http://www.caloni.com.br/openssh-windows/</link>
  <pubDate>2019-04-29</pubDate>
  
  <guid>http://www.caloni.com.br/openssh-windows/</guid>
  <description>&lt;p&gt;O Secure Shell (SSH) é um protocolo de sucesso nos unixes da vida para terminal remoto e seguro por décadas, mas no Windows nunca houve uma forma simples e protegida de abrir um terminal ou copiar arquivos. A opção é instalar um cygwin com esse componente ou tentar compilar um protocolo SSL e em cima dele o SSH. Porém, há detalhes na autenticação que estão relacionadas com o Sistema Operacional e que precisa ser feito. O OpenSSH é uma maneira de compilar tudo isso e ainda funcionar no Windows.&lt;/p&gt;
&lt;p&gt;O software WinSCP, um client SFTP para Windows, possui um guia sobre como instalar essa opção no Windows. A partir do Windows Server 2019 e Windows 10 1809 isso não será mais necessário, pois já estará disponível entre as ferramentas opcionais instaláveis do SO (Apps &amp;gt; Apps &amp;amp; features &amp;gt; Manage optional features, &amp;quot;OpenSSH server&amp;quot;). Para os que ainda precisam manter o passado há uma maneira.&lt;/p&gt;
&lt;p&gt;Se você preferir não compilar a partir dos fontes você pode baixar um pacote dos binários pelo GitHub. Basta extrair tudo para uma pasta e rodar o script PowerShell de instalação e o serviço sshd estará instalado no modo manual (se você já usou o cygwin sabe que o nome é o mesmo). O local indicado para conter os arquivos é em C:\Program Files\OpenSSH, conforme o tutorial do WinSCP.&lt;/p&gt;
&lt;p&gt;Após instalado você deve abrir a porta 22 pelo firewall do Windows (há uma maneira PowerShell de fazer se tiver um Windows novo ou usar a interface mesmo se tiver um antigo). Após esse último passo tudo deverá estar funcionando, e basta criar seu par de chaves pública/privada com o ssh-keygen.exe e adicionar no servidor com ssh-add.exe, além de copiar para um arquivo chamado authorizedkeys... enfim, está tudo no tutorial.&lt;/p&gt;
&lt;p&gt;Menos a parte de mudar o sshdconfig.&lt;/p&gt;
&lt;p&gt;Como nos informa um post do Stack Overflow, é preciso comentar no arquivo c:\programdata\ssh\sshconfig, próximo do final, essas duas linhas:&lt;/p&gt;
&lt;p&gt;Para isso:&lt;/p&gt;
&lt;p&gt;Aí, sim. Reiniciar, o serviço e testar a conexão:&lt;/p&gt;
&lt;p&gt;Os programas ssh.exe (shell remoto) e scp.exe (cópia remota de arquivos) também estão disponíveis no pacote OpenSSH, mas a versão do Cygwin ou até do Git (que vem com um pacote de ferramentas básicas de Linux) funcionam.&lt;/p&gt;
&lt;p&gt;Se seu objetivo é realizar backups remotos silenciosos e para isso você instalar um serviço que irá executar o scp.exe de tempos em tempos é preciso tomar cuidado com as credenciais usadas e onde estarão as chaves de criptografia. O padrão usado pelo OpenSSH no Windows é na pasta C:\Users\Usuário.ssh, mas para um processo na conta de sistema esse valor deve ser diferente. No caso de um terminal executando pelo psexec.exe ele ficou apontando para c:\windows\system32.ssh, mas para serviços rodando como SYSTEM é capaz que seja outro valor. Enfim, é necessário testar e verificar os resultados dos testes.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Code Jam 2019 Qualification Round</title>
  <link>http://www.caloni.com.br/code-jam-2019-qualification-round/</link>
  <pubDate>2019-04-07</pubDate>
  
  <guid>http://www.caloni.com.br/code-jam-2019-qualification-round/</guid>
  <description>&lt;p&gt;Estou viajando e com poucas horas de acesso a um computador, mas os dois primeiros desafios do Code Jam esse ano foram tão simples que sequer precisaram de meia-hora. Isso para um chinês, campeões em campeonatos de programação, deve ser equivalente a cinco minutos com um código C enxuto. Mas estou apenas aprendendo.&lt;/p&gt;
&lt;p&gt;Resuminho: o problema é receber um número e retornar dois números cuja soma seja igual ao primeiro. A única restrição é que nesses números não poderá ter o algarismo quatro.&lt;/p&gt;
&lt;p&gt;Solução: copiar como string o número para o primeiro deles e colocar zero no segundo; sempre que houver a incidência do caractere &#39;4&#39; trocar por &#39;3&#39; no primeiro número e &#39;1&#39; no segundo (ou a soma que lhe convier).&lt;/p&gt;
&lt;p&gt;Resuminho: tem que atravessar um labirinto formado por quadrados de N x N começando acima à esquerda saindo abaixo na direita. Enviar uma string com os comandos E ou S (East/South) para sair do labirinto. A pegadinha é não repetir nenhum dos comandos de uma garota que resolveu o labirinto antes.&lt;/p&gt;
&lt;p&gt;Solução: essa pegadinha é o que ironicamente resolve o problema, pois basta inverter os comandos S e E da string recebida como o caminho da garota e ele nunca se repete e sai do mesmo jeito, pois é o labirinto mais fácil do mundo.&lt;/p&gt;
&lt;p&gt;Resuminho: encontrar quais números primos são usados como letras do alfabeto baseado em uma sequência em que o primeiro número é a multiplicação do primo da primeira letra pela segunda, o segundo número é a multiplicação da segunda pela terceira e assim por diante.&lt;/p&gt;
&lt;p&gt;Solução: tentei fazer na força bruta criando o dicionário de primos usado procurando o resto zero das divisões dos números e depois já com o alfabeto montado reproduzir as reproduções. Apesar do sample funcionar devo ter perdido pelo tempo ou um erro que não descobri.&lt;/p&gt;
&lt;p&gt;Resuminho: descobrir quais bits não estão sendo retornados em um echo (ex: manda-se &#39;1010&#39; e recebe &#39;010&#39;) com um limite de envios para o servidor (este é um problema interativo).&lt;/p&gt;
&lt;p&gt;Solução: imaginei dividir o envio pelo número de blocos defeituosos para alternar os 0s e 1s e assim ir dividindo pela metade de acordo com as respostas até ter as posições que não estão retornando. Não cheguei a terminar o código, mas a ideia geral era que como o limite de blocos defeituosos era de 15 ou N-1 (N é o número de bits) e o máximo de chutes é 5, imaginei que a divisão de 2 elevado a 5 fosse o limite da solução.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Free Pascal e VS Code</title>
  <link>http://www.caloni.com.br/free-pascal-e-vs-code/</link>
  <pubDate>2019-03-09</pubDate>
  
  <guid>http://www.caloni.com.br/free-pascal-e-vs-code/</guid>
  <description>&lt;p&gt;Agora que o VS Code é a ferramenta universal para todas as plataformas e linguagens imagináveis, acreditem ou não, há até plugin para Pascal. Ao instalar a extensão mantida por Alessandro Fragnani você recebe o intelisense e algumas dicas durante erros de programação.&lt;/p&gt;
&lt;p&gt;A própria integração com o Free Pascal Compiler, o compilador open source de Pascal multiplataforma, já é mostrada na Home desse plugin. É só seguir os modelos e alterar de acordo com o que pede o VS Code (que está sendo atualizado constantemente).&lt;/p&gt;
&lt;p&gt;Após isso o Terminal, Run Build Task exibe a opção de rodar o fpc.exe para seu programa e a compilação sai perfeita ou ele aponta os erros direto no fonte. O programa resultante pode ser executado por fora ou dentro do VS Code e tudo OK.&lt;/p&gt;
&lt;p&gt;PS: Se quiser depurar é possível gerar informação de debug para o gdb via a flag -g, ou apenas usar o velho writeln(&#39;passou por aqui&#39;). Alguns dizem que o segundo uso algumas vezes é conveniente. Faz sentido se é um programa de faculdade.&lt;/p&gt;
&lt;p&gt;Bons programas verdadeiramente estruturados! (Pascal, diferente de C, permite procedures aninhadas, passando o self durante as chamadas internas; isso, sim, é linguagem bem desenhada).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Debug Remoto no Visual Studio 2010 ou Superior</title>
  <link>http://www.caloni.com.br/debug-remoto-visual-studio-2010-superior/</link>
  <pubDate>2019-03-06</pubDate>
  
  <guid>http://www.caloni.com.br/debug-remoto-visual-studio-2010-superior/</guid>
  <description>&lt;p&gt;Já escrevi sobre debug remoto no finado C++ Builder, sobre como usar o msvcmon.exe no VS 2003 e o msvsmon.exe no 2010+. Sobre como depurar um serviço quando a máquina está para desligar, e até sobre depurar através de um servidor de símbolos. Está na hora de tornar a depuração mais simples para programadores de serviços Win32.&lt;/p&gt;
&lt;p&gt;Resumo dos comandos:&lt;/p&gt;
&lt;p&gt;Hoje em dia, às vésperas do Visual Studio 2019, espero que todo mundo use pelo menos o Visual Studio 2010 porque a partir dessa versão tornou-se muito fácil depurar remotamente, pois um pacote feito para isso já é instalado junto do Visual Studo. É uma pasta que basta copiar e colar na máquina-alvo. Para encontrá-la basta digitar &amp;quot;Remote Debugger&amp;quot; dentro do Program Files.&lt;/p&gt;
&lt;p&gt;Copie essa pasta para a máquina onde estará os processos que deseja depurar e escolha sua arquitetura (x86, x64, i64), pois cada uma possui uma sub-pasta com os mesmos arquivos. Executa uma vez o msvsmon.exe dentro de uma delas e ele irá configurar para você o firewall do Windows. Feito isso e configurando através da janela que aparece o resto dos parâmetros basta atachar o processo ou iniciá-lo remotamente pela configuração do seu projeto no Visual Studio.&lt;/p&gt;
&lt;p&gt;Mas este artigo não é sobre isso, é um pouco mais fundo: depurar serviços. Eles rodam na conta de sistema e muitas vezes é preciso depurá-los antes ou depois do logon na máquina. Às vezes é um teste sob as condições de sistema, o que é igualmente importante. Seja como for a maneira de fazer isso com o msvsmon.exe é transformá-lo também em um serviço. Para isso usaremos o NSSM: o Non-Sucking Service Manager. Copie ele para a mesma máquina e o executa com o comando install nome-do-serviço. Os campos principais são os mais importantes.&lt;/p&gt;
&lt;p&gt;Mas este artigo não é sobre isso, é um pouco mais fundo: depurar serviços. Eles rodam na conta de sistema e muitas vezes é preciso depurá-los antes ou depois do logon na máquina. Às vezes é um teste sob as condições de sistema, o que é igualmente importante. Seja como for a maneira de fazer isso com o msvsmon.exe é transformá-lo também em um serviço. Para isso usaremos o NSSM: o Non-Sucking Service Manager. Copie ele para a mesma máquina e o executa com o comando install nome-do-serviço. Os campos principais são os mais importantes.&lt;/p&gt;
&lt;p&gt;Se você digitar msvsmon.exe /h ou algo do gênero irá encontrar os parâmetros que precisa.&lt;/p&gt;
&lt;p&gt;OBS: Eu costumo executar sem segurança alguma, pois minhas máquinas de teste são VMs locais e o perigo de vulnerabilidade não é menor do que minha própria máquina real.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Bug no Boost Asio usando função AcceptEx do Winsock</title>
  <link>http://www.caloni.com.br/bug-boost-asio-acceptex-winsock/</link>
  <pubDate>2019-01-06</pubDate>
  
  <guid>http://www.caloni.com.br/bug-boost-asio-acceptex-winsock/</guid>
  <description>&lt;p&gt;Depois de um mês de correção e mais um ou dois meses preparando um compilado do que ocorreu no software que estamos mantendo, foi descoberta uma situação muito peculiar que ocorre tanto em Windows XP quanto no Windows 10, mas que no 10 tem uma correção bem-educada e no XP... bom, nem tanto.&lt;/p&gt;
&lt;p&gt;O problema ocorreu em um uso padrão do Boost.Asio de modo assíncrono. Sem querer entrar muito em código nesse momento -- que teve como base nosso projeto de servidor de requisições mais rápido do universo, o motherforker -- se trata apenas de um listening que usa spawn de um lambda para tratar os accepts e dentro dele cria processos, redirecionando sua entrada e saída.&lt;/p&gt;
&lt;p&gt;Nas entranhas do Boost.Asio na implementação para Windows o accept utiliza a API AcceptEx, que já cria o socket cliente antes mesmo da conexão ser fechada. Se trata de uma operação de IO assíncrono como os que tem no Windows: faz tudo que é necessário fazer e é responsabilidade do programa verificar se houve IO (de maneira síncrona ou assíncrona). No caso do Asio a maneira de verificar é via checagem do handle de completion durante os momentos de idle do ioservice.&lt;/p&gt;
&lt;p&gt;Quando há uma nova conexão o método createProcessGetOutputAndSendBack lê dados do socket cliente como um comando a ser executado e utiliza a API CreateProcess passando esse comando. A saída desse processo criado é capturada via saída-padrão. Para isso é usada a flag de herança de handles e handles de arquivos (poderiam ser pipes) são usados para enviar entrada, capturar saída, etc.&lt;/p&gt;
&lt;p&gt;Após o término do processo a saída estará no arquivo aberto em si.hStdOutput. Basta abri-lo para leitura e enviar seu conteúdo via socket para o cliente. O trabalho dessa conexão termina por aí.&lt;/p&gt;
&lt;p&gt;O que não estava previsto é que junto da herança dos handles vai também handles indesejados. Como o de &amp;quot;\Device\Afd&amp;quot;, que é um recurso usado na comunicação do winsock. Ao usar as funções síncronas e tradicionais do winsock, que constitui em criar o socket server, dar listen e no accept o socket cliente ter sido criado, o AcceptEx exige já um socket cliente criado, o que é feito no sample da Microsoft com a função socket e no Boost.Asio com a duplicação do socket existente (que também foi criado via socket function).&lt;/p&gt;
&lt;p&gt;Esses dois sockets são herdáveis por default (implementação da função socket) e são representados pelos handles listados no Process Explorer como já visto, pelo nome &amp;quot;\Device\Afd&amp;quot;. O contador de handles é aumentado a partir da criação do processo-filho e esses dois handles aparecem em ambos os processos.&lt;/p&gt;
&lt;p&gt;Até aí tudo bem. O problema na verdade ocorre no segundo request enviado quando o primeiro request não terminou (e.g. o primeiro request é um notepad.exe que irá demorar e o segundo request um &amp;quot;cmd /c dir&amp;quot;, que executa e já volta com a saída). Nessa situação todos os sockets criados até aqui -- incluindo o cliente do primeiro request -- são herdados para o segundo processo-filho, e por questões que estão além do escopo desse estudo, mas que poderão ser verificados ao se analistar os drivers das camadas de TDI do Windows (kernel mode), o send da saída do segundo request para o socket cliente fica travado até a saída do primeiro processo-filho, onde ocorre dos handles serem fechados.&lt;/p&gt;
&lt;p&gt;É uma situação complexa, que depende de várias variáveis, mas ela ocorre, se todas as variáveis ocorrerem ao mesmo tempo. Um resumo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Criação do socket cliente com a função socket.&lt;/li&gt;
&lt;li&gt;Uso do AcceptEx para aceitar conexões.&lt;/li&gt;
&lt;li&gt;Criação de process-filho com flag de herança de handles habilitada.&lt;/li&gt;
&lt;li&gt;Processo-filho do primeiro request ainda em execução.&lt;/li&gt;
&lt;li&gt;Recebimento do segundo request e criação do segundo processo-filho.&lt;/li&gt;
&lt;li&gt;Escrita no socket cliente do segundo request enquanto o primeiro request ainda não foi finalizado.&lt;/li&gt;
&lt;li&gt;BUG: Cliente do segundo request não recebe sua resposta.&lt;/li&gt;
&lt;li&gt;RESULTADO ESPERADO: Que o cliente do primeiro request não interferisse no segundo.&lt;/li&gt;
&lt;li&gt;Detalhe: Cliente do segundo requeste recebe eventualmente sua resposta após o primeiro request terminar.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A primeira solução para evitar handles herdáveis que não são desejáveis é proposta pelo Raymond Chen em seu blog: usar as API InitializeProcThreadAttributeList e UpdateProcThreadAttribute. Com isso é possível especificar quais handles podem ser herdados pelo processo-filho, e obviamente iremos colocar na lista apenas os arquivos de entrada e saída padrão (obs: não duplicar saída-padrão com erro-padrão quando ambos são o mesmo arquivo/handle).&lt;/p&gt;
&lt;p&gt;As API InitializeProcThreadAttributeList e UpdateProcThreadAttribute não existem no Windows XP, o que quer dizer que isso exige uma segunda solução, que eu considerei antes de achar a terceira solução que teria que ser ad hoc: criar um processo-neto, sendo que o filho não receberá os handles herdados, mas irá criar o neto herdando os arquivos de entrada e saída padrão, enviando a saída de volta por um método à parte (ex: usando o nome de um arquivo em comum).&lt;/p&gt;
&lt;p&gt;A terceira solução encontrada durante a compilação deste artigo é usar em vez da função socket, que não dá o controle sobre herança de handle, a função WSASocketW, onde existe um argumento dwFlags em que é possível passar o valor WSAFLAGNOHANDLEINHERIT (0x80), onde o handle do socket não será criado com a flag de herdável. Dessa forma apenas o socket cliente não se torna herdável e com isso o primeiro request não trava o segundo. A vantagem dessa correção é que ela é pontual no código e é de uma API já antiga, portanto compatível com todos os Windows.&lt;/p&gt;
&lt;p&gt;UPDATE: Na verdade a flag de não-herança do socket só passou a existir no Windows 7 com SP1, o que inviabiliza essa solução para Windows Vista e XP, como previamente foi dito.&lt;/p&gt;
&lt;p&gt;Essas correções dizem respeito ao sample de uso do winsock como modelo server/client da própria Microsoft. Ele foi modificado em um repositório que criei para meus testes e poderá ser usado como correção de todos que tiverem o mesmo problema utilizando a API do Windows diretamente.&lt;/p&gt;
&lt;p&gt;Já para o Boost.Asio será necessário um estudo de impacto e o envio de uma proposta de correção (ou uso de um patch em que a criação do socket cliente deve ser feita sem herança). Isso pode potencialmente quebrar o funcionamento de outros tipos de programas que dependem direta ou indiretamente da herança de todos os sockets, ou talvez o Boost.Asio tenha uma maneira educada de entregar o controle da criação de sockets dependente de implementação. Eu não sei. Este é um próximo passo da pesquisa.&lt;/p&gt;
&lt;p&gt;UPDATE: Embora use a função WSASocketW o Boost.Asio não suporta a parametrização das flags, e sua implementação não é sobrecarregável, fazendo parte do namespace socketopt. Foi criado um issue no GitHub do projeto Boost.Asio para ver os comentários e colocações da equipe. No aguardo.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>A Maneira Errada de Começar um Projeto é com Visual Studio</title>
  <link>http://www.caloni.com.br/a-maneira-errada-de-comecar-um-projeto-e-com-visual-studio/</link>
  <pubDate>2018-12-11</pubDate>
  
  <guid>http://www.caloni.com.br/a-maneira-errada-de-comecar-um-projeto-e-com-visual-studio/</guid>
  <description>&lt;p&gt;Estava eu trabalhando com um sample e resolvi colocar controle de fonte para analisar as mudanças. E a mudança mais inesperada que eu vi quando digitei git diff foi que ele achou que meus arquivos de código-fonte estivessem em binário.&lt;/p&gt;
&lt;p&gt;Essa lambança ocorreu com uma versão atual do Visual Studio 2017 após eu resolver ser preguiçoso e deixar o template dele criar o projeto para mim.&lt;/p&gt;
&lt;p&gt;Particularmente não sou fã de deixar as IDEs criarem arquivos, porque geralmente elas estão cheias de más intenções disfarçadas de boas envolvendo alguma tecnologia proprietária. No caso da Microsoft há os precompiled headers, que sujam o projeto antes mesmo do tempo de compilação ser um problema. E agora descobri que os arquivos estão sendo gerados em UNICODE Windows.&lt;/p&gt;
&lt;p&gt;Se você tiver o mesmo problema e quiser corrigir segue o passo-a-passo: salve os arquivos com um encoding de gente grande como utf8. Fim do passo-a-passo.&lt;/p&gt;
&lt;p&gt;Isso pode ser obtido na janela de &amp;quot;Save As&amp;quot; do Visual Studio. Há uma flecha para baixo do lado do botão Save onde você pode abrir a opção &amp;quot;Save with Encoding&amp;quot;.&lt;/p&gt;
&lt;p&gt;Na prática, troque possivelmente de &amp;quot;Unicode - Codepage 1200&amp;quot; para &amp;quot;Unicode (UTF-8 without signature) - Codepage 65001&amp;quot;.  A partir do segundo commit o git começará a entender que você atingiu a maioridade e vai comparar os arquivos como gente grande para você.&lt;/p&gt;
&lt;p&gt;A partir do segundo commit o git começará a entender que você atingiu a maioridade e vai comparar os arquivos como gente grande para você.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Boost.Bind e os Erros Escrotos</title>
  <link>http://www.caloni.com.br/boost-bind-e-os-erros-escrotos/</link>
  <pubDate>2018-10-01</pubDate>
  
  <guid>http://www.caloni.com.br/boost-bind-e-os-erros-escrotos/</guid>
  <description>&lt;p&gt;Estou voltando a programar algumas coisas no boost. Algo que eu perdi ao me isolar do movimento de modernização do C++ foi a capacidade brilhante da biblioteca boost em encapsular e abstrair conceitos de engenharia de software de maneira portável e mantendo a filosofia por trás da STL, que ainda é a melhor maneira de trabalhar algoritmos já criada em qualquer linguagem de programação séria.&lt;/p&gt;
&lt;p&gt;Isso não quer dizer que a linguagem C++ está indo para um bom caminho. Muito pelo contrário. Uma miríade de questões semânticas dividem opiniões e nunca resolvem de fato problemas do mundo real. Verdadeiros arcabouços masturbatórios, o comitê da linguagem se debate em vão quando tenta buscar maneiras de tornar uma linguagem arcaica em um exemplo de expressividade.&lt;/p&gt;
&lt;p&gt;Isso às vezes não importa muito para o dia-a-dia, mas outras vezes importa. Veja o caso da biblioteca Boost.Bind, uma das mais antigas a entrar para o projeto. Sua função é simples: expandir o conceito do std::bind para quantos argumentos for necessário. Isso foi criado na época com a ajuda de inúmeros overloads da função (em modo template), mas hoje é possível fazer com variadic templates. Seu uso é simples, intuitivo, direto, e resolve muitos problemas de encaixe de código:&lt;/p&gt;
&lt;p&gt;No entanto, o que era para ser um uso simples e direto de uma feature bem-vinda ao cinto de utilidades do programador C++ se transforma em um pesadelo quando as coisas não se encaixam tão bem:&lt;/p&gt;
&lt;p&gt;Vou plotar aqui todas as mensagens de erro para sentir o drama:&lt;/p&gt;
&lt;p&gt;Este é o erro encontrado usando o último Visual Studio (2017 15.9.0 Preview 2.0) e o Boost 1.68.0. A primeira linha deveria significar alguma coisa (que é para onde todo programador C++ deve olhar):&lt;/p&gt;
&lt;p&gt;Mas não. Se olharmos para o código-fonte onde ocorreu o problema, a caixa de encaixe perfeito se quebra:&lt;/p&gt;
&lt;p&gt;O que isso quer dizer? O que aconteceu? Onde que eu errei?&lt;/p&gt;
&lt;p&gt;Claro que ao final da longa listagem de erros (que se torna ainda mais longa, dependendo de quantos argumentos sua função tem) há alguma luz no fim do túnel:&lt;/p&gt;
&lt;p&gt;Mas claro que essa luz pode estar ofuscada quando os tipos dos argumentos são templates de templates de templates... enfim. Deu pra entender onde o caos consegue chegar quando se trata de harmonizar uma biblioteca perfeita com uma linguagem em constante construção.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Coroutine Internals</title>
  <link>http://www.caloni.com.br/coroutine-internals/</link>
  <pubDate>2018-09-18</pubDate>
  
  <guid>http://www.caloni.com.br/coroutine-internals/</guid>
  <description>&lt;p&gt;Uma corrotinas é um mecanismo de troca de contexto onde apenas uma thread está envolvida. Ela me faz lembrar do Windows 3.0, não exatamente por não existirem threads (e não existiam mesmo), mas pelo caráter cooperativo dos diferentes códigos.&lt;/p&gt;
&lt;p&gt;Só que no caso do Windows se a rotina de impressão travasse todo o sistema congelava.&lt;/p&gt;
&lt;p&gt;A volta das corrotinas via C++ moderno ocorre, para variar, no Boost. E a arquitetura é simples: mantenha um histórico das stacks das diferentes tasks da thread. Vamos pegar o caso mais simples da Boost.Coroutine para analisar:&lt;/p&gt;
&lt;p&gt;Se você já é um programador esperto já deve ter percebido que na saída do prompt será impresso &amp;quot;Hello, world!&amp;quot;, com a vírgula no meio sendo impressa pela função main e as duas palavras da ponta pela função cooperative, ainda que ela seja chamada apenas uma vez.&lt;/p&gt;
&lt;p&gt;Note que falei chamada porque se a stack não retornou da função ela não terminou ainda seu trabalho. Não houve o &amp;quot;return&amp;quot;. Outra forma de entender isso é que ela é chamada aos poucos. Enfim, deixo para você a discussão semântica. O fato é que a saída é &amp;quot;Hello, world&amp;quot;.&lt;/p&gt;
&lt;p&gt;Depurando encontramos a stack de cooperative, que nos indica que ela não partiu do main, apesar de ter sido chamada através da construção de coroutine pulltype. O método sink chamado logo após imprimir &amp;quot;Hello&amp;quot; deve colocar essa rotina para dormir, voltando o controle para main.&lt;/p&gt;
&lt;p&gt;Analisando como isso é feito vemos que o depurador do Visual Studio está fazendo caquinha, pois rodando passo-a-passo voltei para a mesma função cooperative sem passar pelo main. No entanto, a vírgula &amp;quot;, &amp;quot; foi impressa.&lt;/p&gt;
&lt;p&gt;Para conseguirmos depurar diferentes rotinas dentro da mesma thread é imperativo entendermos como o mecanismo de troca de contexto funciona por baixo dos panos. Para isso nada como depurar as próprias trocas de contexto.&lt;/p&gt;
&lt;p&gt;O tamanho total da stack reservada no Windows é de 1 MB, mas a granuralidade padrão é de 64 KB (&amp;quot;que é suficiente para qualquer um&amp;quot; - Gates, Bill). Então é por isso que quando o Boost aloca uma stack com atributos padrões esse é o tamanho que vemos (65536).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The default size for the reserved and initially committed stack memory is specified in the executable file header. Thread or fiber creation fails if there is not enough memory to reserve or commit the number of bytes requested. The default stack reservation size used by the linker is 1 MB. To specify a different default stack reservation size for all threads and fibers, use the STACKSIZE statement in the module definition (.def) file. The operating system rounds up the specified size to the nearest multiple of the system&#39;s allocation granularity (typically 64 KB). To retrieve the allocation granularity of the current system, use the GetSystemInfo function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Detalhe curioso de arquitetura x86 (32 bits): na hora de alocar, o sp (stack pointer) aponta para o final da pilha. Isso porque no x86 a pilha cresce &amp;quot;para baixo&amp;quot;.&lt;/p&gt;
&lt;p&gt;Logo em seguida, no topo da pilha, é empilhado o objeto da corrotina:&lt;/p&gt;
&lt;p&gt;Bom, entrando mais a fundo na implementação de corrotinas do Boost, temos o objeto pullcoroutineimpl, que possui flags, ponteiro para exceção e o contexto do chamador e do chamado para se localizar.&lt;/p&gt;
&lt;p&gt;O coroutinecontext possui elementos já conhecidos de quem faz hook de função: trampolins. Ou seja, funções usadas para realizar saltos incondicionais de um ponto a outro do código independente de contexto. Na minha época de hooks isso se fazia alocando memória na heap e escrevendo o código assembly necessário para realizar o pulo, geralmente de uma colinha de uma função naked (funções naked não possuem prólogo e epílogo, que são partes do código que montam e desmontam contextos dentro da pilha, responsável pela montagem dos frames com ponto de retorno, variáveis locais, argumentos).&lt;/p&gt;
&lt;p&gt;A função que faz a mágica do pulo do gato é a pull, que muda o estado da rotina para running e realiza o salto de contexto. Vamos analisar essa parte com muita calma.&lt;/p&gt;
&lt;p&gt;Quem desfaz a mágica, &amp;quot;desempilhando&amp;quot; o contexto para voltar ao chamador da corrotina (através do contexto apenas, não da pilha) é a função push.&lt;/p&gt;
&lt;p&gt;Com os dados disponíveis nos objetos de contexto (no exemplo do main, a variável source) é possível pelo Windbg analisar qualquer tipo de stack com o comando k.&lt;/p&gt;
&lt;p&gt;A variável de uma coroutine contém o contexto do chamador e do chamado. Quando houver a necessidade de explorar uma pilha não-ativa é preciso obter o valor de sp através dessa variável. Ela fica um pouco escondida, mas está lá. Acredite.&lt;/p&gt;
&lt;p&gt;Usando o comando k = BasePtr StackPtr InstructionPtr passando o conteúdo de sp como o stack pointer o Windbg deve mostrar a pilha de todas as formas possíveis (especificar se terá FPO, mostrar código-fonte, argumentos, etc). Para a demonstração live fica bom ter um loop &amp;quot;eterno&amp;quot; para poder repetir a análise quantas vezes forem necessárias:&lt;/p&gt;
&lt;p&gt;DICA: É importante detachar do processo, mesmo que estejamos analisando em modo não-invasivo, porque a porta de Debug pode ser ocupada e o Visual Studio vai ficar pra sempre esperando receber eventos de debug que ele não vai mais receber.&lt;/p&gt;
&lt;p&gt;Após rodarmos novamente o programa ele pára no main. Podemos atachar com o WinDbg quantas vezes precisarmos:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Vcpkg Internals: como o gerenciador de pacotes da M$ funciona por dentro (e como fazer seu próprio pacote!)</title>
  <link>http://www.caloni.com.br/vcpkg-internals/</link>
  <pubDate>2018-09-12</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg-internals/</guid>
  <description>&lt;p&gt;Depois de entender mais ou menos como funciona o vcpkg é hora de realmente entrar no código e entender qual a grande sacada dessa ferramenta da Microsoft.&lt;/p&gt;
&lt;p&gt;Uma das formas mais divertidas de entender o funcionamento de um fonte é compilar e sair depurando. E foi o que eu fiz. Através dos step ins e step outs foi possível ter as primeiras impressões de em qual pé está o projeto, além de pegar boas ideias para meu próprio código.&lt;/p&gt;
&lt;p&gt;Por exemplo, no começo do programa encontrei uma saída simples e eficaz de como tratar entrada e saída (ou só saída) de dentro de um terminal:&lt;/p&gt;
&lt;p&gt;Com tudo UTF-8 a vida fica mais fácil.&lt;/p&gt;
&lt;p&gt;Outro ponto interessante é que o fonte é muito C++ moderno, com direito a inclusive usar headers ainda experimentais, como o filesystem (C++ 17). Ele usa também um conjunto de paths sobre onde estão as coisas (instalação, pacotes, etc). Há muito código no vcpkg que são módulos independentes que soam como retrabalho de coisas comuns, como parseamento de argumentos, mas o objetivo do projeto é ser independente de tudo. Do contrário ele não seria um bom gerenciador de pacotes.&lt;/p&gt;
&lt;p&gt;O arquivo vcpkg\installed\vcpkg\status contém em formato texto simples o status de todos os pacotes instalados (se foi instalado com sucesso ou não, etc). A pasta vcpkg\ports contém todos os pacotes, instalados ou não. O início de tudo é o executável na pasta-raiz após compilado, vcpkg.exe, feito em C++ e que realiza todas as bruxarias para montar a hierarquia de pastas e arquivos em texto. Tudo é tão simples e baseado em arquivos de texto que vejo que a M$ finalmente se rendeu ao jeito unix de fazer as coisas (mais conhecido como o jeito certo).&lt;/p&gt;
&lt;p&gt;No gerenciador de pacotes há um conceito chamado de triplet, que não é uma novidade; é uma forma de especificar um conjunto de elementos do ambiente para cross compiling utilizando um simples nome.&lt;/p&gt;
&lt;p&gt;O vcpkg já vem com alguns triplets de fábrica, mas você pode criar os seus próprios na pasta triplets, alterando várias variáveis de controle de compilação:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VCPKG_TARGET_ARCHITECTURE. A arquitetura alvo (x86, x64, arm, arm64).&lt;/li&gt;
&lt;li&gt;VCPKG_CRT_LINKAGE. A linkagem do CRT (que é mais conhecida pelo pessoal do Zwindows; valores: dynamic, static).&lt;/li&gt;
&lt;li&gt;VCPKG_LIBRARY_LINKAGE. O mesmo do CRT, mas para libs (as bibliotecas podem ignorar se elas não suportam isso).&lt;/li&gt;
&lt;li&gt;VCPKG_CMAKE_SYSTEM_NAME. A plataforma alvo, que pode ser vazio (o Windows desktop padrão), WindowsStore, Darwin (Mac OSX) ou Linux.&lt;/li&gt;
&lt;li&gt;VCPKG_PLATFORM_TOOLSET. O toolset do Visual Studio (mais uma coisa do Zwindows); v141, v140 são valores válidos (vazio também).&lt;/li&gt;
&lt;li&gt;VCPKG_VISUAL_STUDIO_PATH. Onde está a instalação do Visual Studio (é, o vcpkg tem uma certa tendência pro Zwindows).&lt;/li&gt;
&lt;li&gt;VCPKG_CHAINLOAD_TOOLCHAIN_FILE. Esse não é do Zwindows, mas do CMake; a possibilidade de escolher outro toolchain (diferente de scripts/toolchains) para o CMake.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Há diversas flags de compilação que podem ser especificadas direto no triplet:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VCPKG_CXX_FLAGS_DEBUG&lt;/li&gt;
&lt;li&gt;VCPKG_CXX_FLAGS_RELEASE&lt;/li&gt;
&lt;li&gt;VCPKG_C_FLAGS&lt;/li&gt;
&lt;li&gt;VCPKG_C_FLAGS_DEBUG&lt;/li&gt;
&lt;li&gt;VCPKG_C_FLAGS_RELEASE&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A macro do CMake PORT será interpretada pelo triplet. Isso é uma garantia de mudanças nos settings para portabilidade. Por exemplo:&lt;/p&gt;
&lt;p&gt;Que compila qualquer coisa que entre no match &amp;quot;qt5-*&amp;quot; como dinâmico (DLLs), embora todo o resto possa ser estático.&lt;/p&gt;
&lt;p&gt;A integração com o Visual Studio ocorre com o uso daqueles pedaços de configuração de projetos que são as abas de propriedades. Você mesmo pode criar abas de propriedade como arquivos separados do seu vcxproj para configurações comuns a mais projetos.&lt;/p&gt;
&lt;p&gt;Para realizar a integração o comando é vcpkg integrate install&amp;quot;:&lt;/p&gt;
&lt;p&gt;Note que as coisas para quem usa CMake são automáticas e fáceis de usar. Basta acrescentar o toolchain especificado. Já para Visual Studio...&lt;/p&gt;
&lt;p&gt;O mecanismo envolve uma pasta do msbuild:&lt;/p&gt;
&lt;p&gt;Dentro dessa pasta é colocado um desses pedaços de configuração (propriedades) chamado vcpkg.system.props.&lt;/p&gt;
&lt;p&gt;Essa diretiva usa a pasta definida pela variável de ambiente LOCALAPPDATA (geralmente C:\Users&amp;lt;seu-usuario&amp;gt;\AppData\Local) para localizar um outro arquivo, o vcpkg.user.targets.&lt;/p&gt;
&lt;p&gt;No exemplo estou usando um vcpkg disponível na pasta c:\libs (que é basicamente um clone do repositório GitHub do vcpkg). Note que ele inclui automaticamente nos projetos do Visual Studio um target dentro dele, o vcpkg\scripts\buildsystems\msbuild\vcpkg.targets. Vejamos o que tem nele:&lt;/p&gt;
&lt;p&gt;Note como as pastas de instalação dos pacotes do triplet selecionado são incluídas na configuração de um projeto do Visual Studio. As libs ficam na subpasta installed/triplet/lib, os binários em installed/triplet/bin, os includes em installed/triplet/include e assim por diante. A ramificação dos pacotes está de acordo com o basename de cada um deles.&lt;/p&gt;
&lt;p&gt;A mágica ocorre já na hora de dar include. E é mágica desde o autocomplete até o link. Por exemplo, digamos que vamos fazer um embedded de Python usando o exemplo do help:&lt;/p&gt;
&lt;p&gt;O programa compila e linka. Para provar que ele usa a lib instalada (versão debug):&lt;/p&gt;
&lt;p&gt;Se você prestou atenção ao conteúdo de msbuild\vcpkg.targets lá em cima vai ter visto que há uma condição que adiciona toda e qualquer lib como dependência adicional ao projeto compilando:&lt;/p&gt;
&lt;p&gt;É isso que resolve o problema de saber qual o nome da lib resultante de um pacote instalado. Porém, isso não é o ideal, principalmente por dois motivos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Os nomes de configuração do projeto tem que ser Debug ou Release (maneiras de melhorar já está sendo discutido no GitHub).&lt;/li&gt;
&lt;li&gt;O usuário final não tem qualquer controle do que adicionar como dependência; simplesmente vai todos os pacotes instalados (mais uma discussão no GitHub).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Porém, no momento é assim que funciona. Para o problema #1 a solução paliativa é o próprio usuário adicionar em seu msbuild as condições de sua configuração. A sugestão da thread é boa:&lt;/p&gt;
&lt;p&gt;Pelo menos tudo que começar com Debug (ou Release) já entraria no filtro.&lt;/p&gt;
&lt;p&gt;UPDATE: Essa sugestão já foi adicionada à última versão do vcpkg. É feita uma normalização do nome:&lt;/p&gt;
&lt;p&gt;Assim o que seguir é Debug ou Release =).&lt;/p&gt;
&lt;p&gt;Um outro potencial problema dos usuários de Visual Studio para compilar e rodar projetos C++ são as dependências de binários (DLLs). É possível que um pacote seja compilado de maneira dinâmica, ou seja, com DLLs de dependência. Essas DLLs na instalação do pacote devem constar na pasta bin, mas por conta dessa pasta não fazer parte dos diretórios de sistema o depurador do Visual Studio irá carregar um executável em sua pasta de geração em que não encontrará as eventuais DLLs que ele precisa para rodar.&lt;/p&gt;
&lt;p&gt;Para &amp;quot;corrigir&amp;quot; isso, ou melhor dizendo, contornar a experiência, também foi adicionado um comando Post Build no vcpkg.targets com um comando Power Shell que copia esses binários para a pasta de geração do projeto atual. Dessa forma o projeto pode rodar sem problemas, o usuário fica feliz e consegue terminar sua programação antes de passar para o deploy (e facilita deploys de testes, pois basta copiar a pasta de geração do executável que todas suas dependências estarão lá).&lt;/p&gt;
&lt;p&gt;O script executado pelo PowerShell fica em vcpkg\scripts\buildsystems\msbuild e recebe o TargetPath (o binário-alvo) como parâmetro e onde estão os binários instalados pelo vcpkg, e com base na saída da ferramenta dumpbin extrai as dependências do executável e as busca no diretório bin:&lt;/p&gt;
&lt;p&gt;Isso é o equivalente ao uso padrão de dumpbin com grep e sed:&lt;/p&gt;
&lt;p&gt;A cópia dos binários é feito com um teste simples de &amp;quot;path existe&amp;quot; com deploy:&lt;/p&gt;
&lt;p&gt;Fato curioso: no script do PowerShell existem alguns hacks para alguns pacotes, incluindo Qt.&lt;/p&gt;
&lt;p&gt;O uso do CMake permite aos usuários do vcpkg ter boas ideias apenas lendo os scripts do projeto. Se você abrir o solution vcpkg.sln dentro de toolsrc vai descobrir todos os scripts listados por lá. Há funções espertinhas como o download e extração de pacotes 7zip do Source Forge.&lt;/p&gt;
&lt;p&gt;Essa parte fica em vcpkg/scripts/cmake. Olhe, por exemplo, como retornar a versão do Windows SDK (vcpkggetwindowssdk.cmake):&lt;/p&gt;
&lt;p&gt;Assim como o esquema de triplets, tudo pode ser atualizado conforme o gosto do freguês, adicionando funções e configurações úteis em seu clone do repositório, e feitas atualizações com a versão oficial.&lt;/p&gt;
&lt;p&gt;O vcpkg não é apenas um ecossistema de libs compiladas e instaladas em uma pasta para serem usadas localmente. Pode ser um caminho simples e rápido para você conseguir compilar libs conhecidas e entregar para um terceiro um zip com todos os includes, libs e dependências do seu projeto.&lt;/p&gt;
&lt;p&gt;Para trabalhar em equipe é vital que todos falem a mesma língua. Uma das formas disso acontecer é usar um gerenciamento de pacotes que inclua todos os ambientes que a equipe usa. Como geralmente esses ambiente não são os mesmos, o uso de pacotes próprios do vcpkg é um plus da ferramenta que vem para somar em padronização de fontes e compilação.&lt;/p&gt;
&lt;p&gt;Primeiro de tudo é interessante existir um local público de download dos fontes (caso o projeto seja opensource; se bem que é possível que o endereço seja apenas visível para usuários logados ou outro mecanismo de proteção).&lt;/p&gt;
&lt;p&gt;Uma estrutura simples de lib que compila com CMake, por exemplo, deverá conter alguns arquivos mínimos:&lt;/p&gt;
&lt;p&gt;Um .cpp com a implementação, um .h público para o usuário acessar, uma licença de uso (LICENSE) e um arquivo CMakeLists.txt são o suficiente para demonstar o uso. Dentro do CMakeLists.txt temos as seguintes diretivas:&lt;/p&gt;
&lt;p&gt;A partir de um zip na internet da pasta bitforge já é possível começar a montar seu próprio pacote:&lt;/p&gt;
&lt;p&gt;Dica: você pode também testar ou implantar isso localmente usando Python:&lt;/p&gt;
&lt;p&gt;O arquivo portfile.cmake já possui teoricamente tudo o que precisa para falhar. Há alguns caveats que podem te dar bastante dor de cabeça no começo. Por isso mesmo eu vou economizar algum tempo para você.&lt;/p&gt;
&lt;p&gt;Em primeiro lugar, preste atenção no diretório onde estarão os fontes. É costume do template usar o mesmo nome do zip, o que nem sempre é verdade (aqui não é, não existe versão no nome da pasta zipada):&lt;/p&gt;
&lt;p&gt;Então em vez de:&lt;/p&gt;
&lt;p&gt;Isso:&lt;/p&gt;
&lt;p&gt;O erro que deve acontecer na falta dessa mudança é o seguinte:&lt;/p&gt;
&lt;p&gt;Em segundo lugar, a cópia do header é feita tanto em release quanto em debug. A compilação via vcpkg irá te avisar que tem alguma coisa errada pois está duplicado, mas já há uma linha mágica que pode ser adicionada:&lt;/p&gt;
&lt;p&gt;O erro que deve acontecer na falta dessa mudança é o seguinte:&lt;/p&gt;
&lt;p&gt;E por último, é obrigatório ter um arquivo de copyright, no caso o nosso LICENSE do projeto. O portfile.cmake já tem o comando, mas está comentado:&lt;/p&gt;
&lt;p&gt;O erro que deve acontecer na falta dessa mudança é o seguinte:&lt;/p&gt;
&lt;p&gt;Basicamente isso é o que você precisa para começar a construir seu pacote:&lt;/p&gt;
&lt;p&gt;O próximo passo é instalar:&lt;/p&gt;
&lt;p&gt;E voilá! Agora o include está disponível, as funções estão disponíveis, o link está funcionando e seu pacote pode ser compartilhado com toda a empresa. Basta copiar a pasta ports/bitforge ou adicioná-la no repositório por um commit.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>GetArg: the ultimate badass argv/argc parser</title>
  <link>http://www.caloni.com.br/getarg/</link>
  <pubDate>2018-08-30</pubDate>
  
  <guid>http://www.caloni.com.br/getarg/</guid>
  <description>&lt;p&gt;Sim, eu acho que já resumi o suficiente meu parseador de argv/argc no meu último artigo sobre o tema. Sim, eu também acho que a versão com STL bonitinha (mas ordinária). A questão agora não são as dependências, mas o uso no dia-a-dia: precisa ter o argc nessa equação?&lt;/p&gt;
&lt;p&gt;A resposta é não. Pois, como sabemos, o padrão C/C++ nos informa que o argv é um array de ponteiros de strings C que termina em nulo. Sabemos que ele termina, então o argc é apenas um helper para sabermos de antemão onde ele termina. Mas quando precisamos, por exemplo, passar o argv/argc para uma thread Windows, que aceita apenas um argumento mágico, talvez minha versão antiga não seja tão eficaz, pois isso vai exibir que eu aloque memória de um struct que contenha ambas as variáveis, etc. Por que não simplesmente utilizar apenas o argv?&lt;/p&gt;
&lt;p&gt;Nessa versão elminamos a necessidade do argc e de brinde ganhamos a possibilidade de usar um único ponteiro como start de um parseamento de argumentos.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Meu Novo Parseador de Argc Argv</title>
  <link>http://www.caloni.com.br/meu-novo-parseador-de-argc-argv/</link>
  <pubDate>2018-08-21</pubDate>
  
  <guid>http://www.caloni.com.br/meu-novo-parseador-de-argc-argv/</guid>
  <description>&lt;p&gt;Eis que me deparo com um projeto onde não posso usar STL. Ou seja, nada de map nem string. Isso quer dizer que minha função bonita e completa de parseamento de argumentos argc/argv não pode ser usado. Essa é uma má notícia. A boa notícia é que achei uma forma muito mais simples e à prova de falhas de fazer isso. Ele basicamente percorre o array argv em busca do nome do parâmetro enviado para a função. Uma vez que ele encontre ele retorna o próximo elemento. Na falta de próximo elemento ele simplesmente retorna uma string vazia que não é nulo, mas já indica que há o parâmetro na lista de argumento.&lt;/p&gt;
&lt;p&gt;Essa função é tão simples, e tem tão poucas dependências (strcmp) que você pode usá-la em praticamente qualquer programa que use argc/argv e que use os parâmetros dos mais complexos. Ao chamar essa função se passa o argc e o argv recebido no main e o terceiro argumento é apenas o nome de um argumento válido que pode ser recebido via linha de comando. O resultado é um ponteiro (obtido no próprio argv) da próxima string ou uma string C vazia constante (não precisa de alocação) se for o último argv. E caso ele não ache o retorno é NULL. Seu uso comum é uma linha apenas, ou uma linha para cada argumento buscado. Sua complexidade é linear, mas, ei, quem está querendo performance no início do programa?&lt;/p&gt;
&lt;p&gt;Uma última observação: dependendo do uso você pode ou não usar o retorno, e ele possui semântica booleana, pois caso o argumento não exista o retorno é NULL e por isso não cai dentro do if (pois NULL traduzido em booleano é false). Eis uma função para copiar e colar abusivamente.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Vídeo: Visual Studio e seu depurador (comentado)</title>
  <link>http://www.caloni.com.br/video-depuracao-visualstudio-101-comentado/</link>
  <pubDate>2018-07-27</pubDate>
  
  <guid>http://www.caloni.com.br/video-depuracao-visualstudio-101-comentado/</guid>
  <description>&lt;p&gt;Segue meu segundo vídeo curto onde estou apenas demonstrando como é o depurador do Visual Studio. Mas dessa vez com comentários =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Vídeo: Depuração Visual Studio 101</title>
  <link>http://www.caloni.com.br/video-depuracao-visualstudio-101/</link>
  <pubDate>2018-07-24</pubDate>
  
  <guid>http://www.caloni.com.br/video-depuracao-visualstudio-101/</guid>
  <description>&lt;p&gt;Redescobrindo meu canal no YouTube me empolguei em publicar mais alguma coisa. Os meu primeiros vídeos, no meu canal pessoal, são longos e possuem narração um pouco confusa, mas explicam bem alguns detalhes do Visual Studio. Agora com meu primeiro vídeo curto estou apenas demonstrando sem voz como é o depurador do Visual Studio. Enjoy =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Stanford Encyclopedia of Philosophy Para Kindle</title>
  <link>http://www.caloni.com.br/stanford-encyclopedia-of-philosophy-para-kindle/</link>
  <pubDate>2018-07-15</pubDate>
  
  <guid>http://www.caloni.com.br/stanford-encyclopedia-of-philosophy-para-kindle/</guid>
  <description>&lt;p&gt;A enciclopédia mais completa e de maior respeito da internet não é um enciclopédia geral, mas uma de filosofia. Está hospedada na Universidade de Stanford e possui revisão por pares e toda a autoridade de ser escrita por especialistas nos verbetes em questão. O único problema (até agora) era não ser possível baixá-la para degustar no Kindle. Até agora.&lt;/p&gt;
&lt;p&gt;Para realizar esta operação será necessário usar as seguintes ferramentas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wget&lt;/li&gt;
&lt;li&gt;sed&lt;/li&gt;
&lt;li&gt;sort&lt;/li&gt;
&lt;li&gt;Calibre&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O projeto de conversão (disponível aqui) foi feito pensando em usuários do Windows, mas pode ser adaptado facilmente para qualquer ambiente. Se trata de um conjunto de arquivos batch (script) que realiza vários comandos, a saber:&lt;/p&gt;
&lt;p&gt;Este batch baixa todo o conteúdo do site da Stanford em um único diretório. O processo pode demorar mais ou menos, dependendo da sua banda, mas aqui em casa (50MB) demorou cerca de meia-hora pra mais.&lt;/p&gt;
&lt;p&gt;Este batch chama dois outros batch, call calibreremovehead.bat e call calibreremovebottom.bat, que limpam das entradas os cabeçalhos e finais em comum que são repetitivos e desnecessários para gerar um ebook, como links úteis de navegação. Como as entradas do site já possuem marcadores, isso facilitou o trabalho.&lt;/p&gt;
&lt;p&gt;Esta batch gera os índices das entradas baseado em seus títulos, e os nomes dos arquivos serão usados para links no TOC do Calibre.&lt;/p&gt;
&lt;p&gt;Algumas entradas possuem o marcador em, que deve ser retirado antes de ordenar os títulos.&lt;/p&gt;
&lt;p&gt;Se não ordenarmos por título o único índice de nosso livro será inútil.&lt;/p&gt;
&lt;p&gt;Ao final do processo com o wget percebi que algumas entradas foram baixadas mais de uma vez. Várias delas. Por isso eliminei as duplicatas usando um programa Windows chamado doublekiller.exe, mas basta você usar qualquer ferramenta que encontra os .html da mesma pasta que possuem o mesmo hash e eliminar as duplicadas. Isso deve ser feito nesse passo antes de:&lt;/p&gt;
&lt;p&gt;Essa parte do processo precisa converter as entradas no formato Título Link para entradas HTML com a tag a, no formato que o Calibre espera:&lt;/p&gt;
&lt;p&gt;Por fim, antes de usar o Calibre é necessário juntar os arquivos de template em um arquivo final de TOC, o calibre.html. Ao final desse processo passaremos ao Calibre em si.&lt;/p&gt;
&lt;p&gt;Para realizar este passo basta arrastar ou abrir o arquivo html central que foi criado, e a partir dele iniciar a conversão. Note que após arrastar já será criado um zip com todos os HTMLs relacionados.&lt;/p&gt;
&lt;p&gt;Após abrir pelo Calibre ele insere na biblioteca e é só converter para MOBI (Kindle) ou EPUB (outros leitores) ou qualquer outro formato desejado. A nota final aqui é que como se trata de um arquivo gigantesco (50 MB em HTML zipado, 80 MB em MOBI) é melhor baixar a versão 64 bits do Calibre e ter muita memória RAM. Voilà!&lt;/p&gt;
&lt;p&gt;E por hoje é só. Se tudo der certo você poderá copiar e colar dentro do seu leitor todas as entradas de uma enciclopédia indispensável para quem está estudando filosofia. Enjoy.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Python27, protobuf, py2exe e buildexe</title>
  <link>http://www.caloni.com.br/python27-protobuf-py2exe-cx_freeze/</link>
  <pubDate>2018-07-14</pubDate>
  
  <guid>http://www.caloni.com.br/python27-protobuf-py2exe-cx_freeze/</guid>
  <description>&lt;p&gt;Para quem está tentando compilar um executável usando py2exe e protobuf, #ficadica: desista. Ele não vai funcionar ou se funcionar vai dar trabalho. Em vez disso melhor usar buildexe (através do pacote cxfreeze), que é um esquema marotinho que permite configurar tudo e há apenas um patchzinho que precisa ser feito.&lt;/p&gt;
&lt;p&gt;Para entender como as coisas dão errado primeiro vamos instalar os requisitos de um pacote fictício em um ambiente virtualizado do Python (para evitar mexer na instalação padrão):&lt;/p&gt;
&lt;p&gt;Depois instalamos os requisitos de nosso pacote fictício:&lt;/p&gt;
&lt;p&gt;Agora vem a hora do erro. O protobuf que foi instalado possui um pequeno bug que impede que o buildexe obtenha essa dependência corretamente na hora de gerar o executável:&lt;/p&gt;
&lt;p&gt;Para fazer funcionar há um pequeno patch: criar um arquivo \init\.py dentro da pasta google onde está instalado o pacote do protobuf:&lt;/p&gt;
&lt;p&gt;Após essa pequena operação já será possível gerar o executável com sucesso:&lt;/p&gt;
&lt;p&gt;Agora ao listarmos os executáveis gerados encontraremos nosso amigo fictício:&lt;/p&gt;
&lt;p&gt;NOTA: conteúdo do arquivo setup.py:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Vcpkg: gerenciador de libs c&#43;&#43; para Linux, Mac OS... e Windows!</title>
  <link>http://www.caloni.com.br/vcpkg/</link>
  <pubDate>2018-07-14</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg/</guid>
  <description>&lt;p&gt;O ambiente padronizado de bibliotecas C/C++ dos sistemas UNIX é motivo de inveja dos programadores Windows por séculos. Mas, finalmente, a Microsoft tem acordado diante da ressurreição do C++, com seus novos bug fixes e new deprecated features.&lt;/p&gt;
&lt;p&gt;E com isso uma série de atividades têm permeada a evolução da ferramenta de desenvolvimento da Microsoft, o Visual Studio:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Updates frequentes&lt;/li&gt;
&lt;li&gt;Projetos internos lançados como open source no GitHub&lt;/li&gt;
&lt;li&gt;Compra do GitHub&lt;/li&gt;
&lt;li&gt;Suporte a mais de um compilador (como clang)&lt;/li&gt;
&lt;li&gt;Depuração Linux (Ubuntu) dentro do Windows&lt;/li&gt;
&lt;li&gt;Ambiente Linux (Ubuntu) dentro do Windows&lt;/li&gt;
&lt;li&gt;Pesado suporte ao CMake&lt;/li&gt;
&lt;li&gt;Ambiente padronizado de bibliotecas para Windows, Linux e Mac OS (vcpkg)&lt;/li&gt;
&lt;li&gt;Suporte à compilação de bibliotecas clássicas dos ambientes UNIX via vcpkg&lt;/li&gt;
&lt;li&gt;Deploy de suas próprias bibliotecas padronizadas via vcpkg&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Usar o vcpkg no Windows é tão simples que parece mágica. Ou Linux.&lt;/p&gt;
&lt;p&gt;Para instalar você só precisa seguir o passo-a-passo do GitHub deles e usar PowerShell. O prompt PS faz tudo automático. O vcpkg é basicamente um conjunto de CMakes que fazem o serviço direito e conseguem compilar quase 1000 libs, a maioria nascidas no Linux, e integrar diretamente com projetos do VS2017.&lt;/p&gt;
&lt;p&gt;Para provar todo o seu poder vamos usar a pior lib de todas: GTK.&lt;/p&gt;
&lt;p&gt;O GTK não é apenas uma biblioteca, mas um conjunto de infinitas dependências. Há um tutorial gigantesco para compilar para Windows (defasado) e novos problemas surgem cada vez que alguém tenta utilizá-lo. Eu gastei mais de 40 horas para entender esses problemas compilando todas as dependências (estava em 95%) quando surgiu o vcpkg e jogou todos meus esforços no lixo (ainda bem).&lt;/p&gt;
&lt;p&gt;Com o vcpkg tudo que é necessário fazer é rodar o comando de install com o nome da lib e toda a compilação é feita automaticamente. Depois disso, se não houver paths de include nos seus projetos do Visual Studio ele próprio irá levar em conta o path de instalação dessas libs (compilação e link). Parece mágica mesmo para quem passou décadas se matando para compilar alguma coisa que preste no Windows e que veio do Linux.&lt;/p&gt;
&lt;p&gt;Vantagens do vcpkg:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Economia de tempo (de pesquisa, de compilação, de tudo)&lt;/li&gt;
&lt;li&gt;Uniformidade no uso das libs&lt;/li&gt;
&lt;li&gt;Flexibilidade para colocar suas próprias libs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Desvantagens do vcpkg:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Apenas as libs mais novas estão sendo suportadas (e não há suporte para Visual Studio mais antigo, nem SOs mais antigos como XP).&lt;/li&gt;
&lt;li&gt;Usuário Linux nenhum no mundo vai querer usar (motivo: Microsoft e este já é um problema resolvido neste mundo)&lt;/li&gt;
&lt;li&gt;Depende de um gerenciador proprietário (se bem que é tudo open source e não há restrições como o Java; qualquer um pode montar seu repositório).&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Manipulando Mouse e Teclado no Windows</title>
  <link>http://www.caloni.com.br/manipulando-mouse-e-teclado-no-windows/</link>
  <pubDate>2018-07-04</pubDate>
  
  <guid>http://www.caloni.com.br/manipulando-mouse-e-teclado-no-windows/</guid>
  <description>&lt;p&gt;Uma forma extremamente bem comportada que o Windows tem para manipular entrada de mouse e teclado são as funções API BlockInput/SendInput [1][2]. Enquanto uma bloqueia todos os eventos de input vindo de todos os lugares do sistema, o outro consegue enviar inputs apenas por software. Imagine a peça que você pode pregar em seus amigos.&lt;/p&gt;
&lt;p&gt;No entanto, estas funções não são para amadores. É preciso entender o que são threads, por exemplo, pois apenas a thread que chamou BlockInput pode depois chamar SendInput com sucesso. Além disso, apenas essa thread pode desbloquear novamente os inputs chamando BlockInput novamente, mas dessa vez passando FALSE em seu único parâmetro. E de qualquer forma, uma vez que o programa que chamou BlockInput com TRUE morreu o sistema detecta e tudo volta ao normal.&lt;/p&gt;
&lt;p&gt;Essas funções API podem ser úteis para interação remota, por exemplo, quando um usuário não consegue realizar uma operação e ele pode mais atrapalhar do que ajudar você pode bloquear os inputs dele e emular seus próprios cliques de mouse e teclado pela rede.&lt;/p&gt;
&lt;p&gt;Nota: usar essas APIs na própria máquina pode ser bem frustrante. Tenha sempre em mãos uma VM de teste.&lt;/p&gt;
&lt;p&gt;Funções citadas neste texto:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/desktop/ms646290(v=vs.85).aspx&#34;&gt;https://msdn.microsoft.com/en-us/library/windows/desktop/ms646290(v=vs.85).aspx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/windows/desktop/ms646310(v=vs.85).aspx&#34;&gt;https://msdn.microsoft.com/en-us/library/windows/desktop/ms646310(v=vs.85).aspx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>SSL e seu limite de pacote</title>
  <link>http://www.caloni.com.br/ssl-limite-de-pacote/</link>
  <pubDate>2018-05-22</pubDate>
  
  <guid>http://www.caloni.com.br/ssl-limite-de-pacote/</guid>
  <description>&lt;p&gt;O protocolo TLS/SSL tem por objetivo criar uma camada de criptografia assimétrica para a aplicação. E quando eu falo em camada não estou me referindo às camadas OSI. Nem às camadas TCP/IP. Isso porque o SSL não se encaixa em nenhuma das duas. Ele interfere com muitas, inclusive a aplicação. E aprendi isso a duras penas: na ponta do depurador.&lt;/p&gt;
&lt;p&gt;O pacote SSL tem um limite de 16 KB, ou 16384 bytes. Esse é o limite que será respeitado por qualquer implementação do protocolo, o que inclui o uso de Boost.Asio e seu uso da OpenSSL. O que isso quer dizer na teoria é que você não pode trafegar sentido server=&amp;gt;client nada maior que 16k bytes. O que isso quer dizer na prática é que sua aplicação não pode escrever mais que 16k bytes de uma vez no socket que vai dar pau.&lt;/p&gt;
&lt;p&gt;Sim, a camada de aplicação tem que estar ligada que existe SSL abaixo dela.&lt;/p&gt;
&lt;p&gt;Isso quer dizer que este snippet de código, por exemplo:&lt;/p&gt;
&lt;p&gt;Não é inocente e não funciona sempre. Se sock for um socket cuja comunicação está encriptada por SSL (em outras palavras -- em Boostês -- ele for um sslsocket) você precisa escrever output em pequenas quantidades. Como em outra implementação inocente:&lt;/p&gt;
&lt;p&gt;Se isso não for feito e a ponta server escrever, digamos, 512KB, ou 17KB, ou qualquer coisa acima de 16KB, ela irá receber... 16 KB. E acabou. O resto se perder.&lt;/p&gt;
&lt;p&gt;Portanto, quando for mexer com SSL, esqueça OSI e esqueça TCP/IP. As coisas funcionam de uma maneira muito mais esotérica que qualquer programador de redes jamais viu, e jamais verá.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Boost Meta State Machine</title>
  <link>http://www.caloni.com.br/boost-meta-state-machine/</link>
  <pubDate>2018-05-21</pubDate>
  
  <guid>http://www.caloni.com.br/boost-meta-state-machine/</guid>
  <description>&lt;p&gt;O Boost Meta State Machine (MSM for short) é uma das duas bibliotecas mais famosinhas de state machine do Boost. Ela é uma versão estática que permite incluir chamadas para as entradas e saídas de um estado baseado em eventos. A sua principal vantagem é poder visualizar toda a máquina de estado em um só lugar, e sua principal desvantagem é pertecer ao Boost, o que quer dizer que você vai precisar fazer seu terceiro doutorado e ler uma documentação imensa sobre UML antes de conseguir produzir alguma coisa. Ou ler este artigo de 10 minutos tops.&lt;/p&gt;
&lt;p&gt;A parte bonitinha de se ver é os eventos e estados completamente ordenados:&lt;/p&gt;
&lt;p&gt;Claro que a indentação ajuda. Para cada entrada e saída de um estado é possível utilizar os métodos onentry e onexit de cada struct que define um estado, seja este método um template totalmente genérico ou especificado por evento (e cada evento também é um struct, com direito a dados específicos).&lt;/p&gt;
&lt;p&gt;Quando é criada uma nova máquina de estados o estado inicial é chamado pelo evento onentry genérico. Como sabemos qual é o estado inicial? Isso é definido pelo typedef initialstate dentro da classe da máquina de estado (que deve herdar de statemachinedef no estilo WTL, com sobrecarga estática):&lt;/p&gt;
&lt;p&gt;O estado final também é definido, mas por herança. O estado final, que também é uma struct, deve herdar de terminatestate:&lt;/p&gt;
&lt;p&gt;A partir daí o método processevent serve para enviar eventos à máquina de estado que irá alterar seu estado dependendo do fluxo criado no nome transitiontable dentro da máquina de estado (a tabelinha que vimos acima). A partir daí tudo é possível; a máquina de estado está à solta:&lt;/p&gt;
&lt;p&gt;Mas nesse exemplo didático está comportada em uma função apenas. Claro que cada método recebe a própria máquina de estado para ter a chance de alterá-la, ou guardá-la para uso futuro. Ela é recebida como parâmetro assim como o evento. E o evento, por ser uma struct também, pode conter outros dados relevantes para a transição.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Lista Ligada; tá ligado?</title>
  <link>http://www.caloni.com.br/lista-ligada/</link>
  <pubDate>2018-04-24</pubDate>
  
  <guid>http://www.caloni.com.br/lista-ligada/</guid>
  <description>&lt;p&gt;Uma lista ligada é uma lista de alguma coisa. Essa alguma coisa podem ser inteiros, strings ou estruturas inteiras. Independente do que for, você vai precisar de uma estrutura. Sabe por quê? Porque existe além dos dados em si mais uma informação que você precisará guardar em cada elemento de sua lista: o próximo elemento.&lt;/p&gt;
&lt;p&gt;Sua estrutura pode ser simples e direta. Digamos uma lista ligada de idades vai ter o endereço do próximo elemento e o dado propriamente dito deste elemento (a idade):&lt;/p&gt;
&lt;p&gt;A primeira coisa que você precisa ter em sua lista é onde ela começa. Isso pode ser uma variável especial que não é usada para nada exceto indicar qual o primeiro elemento da sua lista (esse, sim, um elemento). Ele pode ser simplesmente um ponteiro para o próximo (no caso o primeiro) elemento.&lt;/p&gt;
&lt;p&gt;Este ponteiro começa em NULL porque a lista está vazia. Mas assim que inserirmos um item ele deixará de ser nulo.&lt;/p&gt;
&lt;p&gt;A única coisa que liga um elemento ao outro é o membro next:&lt;/p&gt;
&lt;p&gt;Geralmente adicionamos um novo elemento no meio de uma lista, e por isso não nos preocupamos aqui com o membro next sobrescrito (que obviamente é NULL). Porém, para um resultado mais genérico podemos verificar se ele de fato é NULL. Se não for ele se tornará o next do elemento inserido (o que quer dizer que ele não será o último!):&lt;/p&gt;
&lt;p&gt;Se formos sempre inserir um novo elemento no final também é interessante termos um ponteiro para o último elemento:&lt;/p&gt;
&lt;p&gt;É preciso prestar atenção quando temos muitas variáveis sobrando no código. Caso você esteja com sua lista ligada vazia, por exemplo, ghead e glast precisam ser atualizados!&lt;/p&gt;
&lt;p&gt;Se a lista não estiver vazia apenas o glast deve ser atualizado.&lt;/p&gt;
&lt;p&gt;Remover é a parte mais complicada de uma lista ligada, pois temos que atualizar o elemento de trás (se houver):&lt;/p&gt;
&lt;p&gt;Não parece tão complicado. Mas imagine que para realizar esta façanha você terá que encontrar o elemento que quer apagar, mas mantendo o elemento anterior em outra variável.&lt;/p&gt;
&lt;p&gt;Este artigo está incompleto de propósito, pois é preciso pensar antes de implementar uma solução. Para que você precisa de uma lista ligada, pra começo de conversa?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Projeto Aluno</title>
  <link>http://www.caloni.com.br/projetoaluno/</link>
  <pubDate>2018-03-21</pubDate>
  
  <guid>http://www.caloni.com.br/projetoaluno/</guid>
  <description>&lt;p&gt;Observar um estudante de computação (qualquer curso) lutando nos primeiros meses para conseguir fazer seus programas compilarem em C é um misto de emoções. É uma mistura entre risos, risadas e gargalhadas. Há vários motivos para isso, mas o principal, o que vem à minha mente sempre que isso acontece, é a eterna questão: por que a pessoa encontra fórum de programação para perguntar sobre variável mas não consegue ler duas páginas de um livro?&lt;/p&gt;
&lt;p&gt;Essa questão está intrinsicamente ligada ao fracasso completo do sistema de ensino (qualquer nível), que no caso de programadores, se proliferou em diversas faculdades caça-níqueis porque &amp;quot;este é o mercado onde se ganha bem&amp;quot;. Ninguém questiona por que se ganha bem neste mercado. É só fazer uma faculdade e o dinheiro começa a fluir. Negócio certo.&lt;/p&gt;
&lt;p&gt;Mas quando a primeira variável começa a dar problema, o desespero bate na bunda. &amp;quot;Por que esse programa não está funcionando?&amp;quot;, &amp;quot;Eu só queria resolver isso e voltar pra internet&amp;quot;, &amp;quot;Que droga, chegou a data limite e não sei de quem posso copiar&amp;quot;, &amp;quot;Por que esse exemplo que peguei sei-lá-de-onde está dando esse erro que nunca vi na vida?&amp;quot;.&lt;/p&gt;
&lt;p&gt;&amp;quot;O que é UB? Universidade do Brasil?&amp;quot;, &amp;quot;Tá ficando mais complicado ainda; vou pesquisar pra ver se acho o email desse tal de Goku.&amp;quot;, &amp;quot;Já sei, vou mudar de IDE! Isso, sim, vai resolver meu problema.&amp;quot;&lt;/p&gt;
&lt;p&gt;&amp;quot;Ah, não. Textão ninguém aguenta!&amp;quot;, &amp;quot;TL;DR&amp;quot;.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Contra o &#39;Array de 100 bytes é suficiente&#39;</title>
  <link>http://www.caloni.com.br/contra-o-array-de-100-bytes-eh-suficiente/</link>
  <pubDate>2018-03-11</pubDate>
  
  <guid>http://www.caloni.com.br/contra-o-array-de-100-bytes-eh-suficiente/</guid>
  <description>&lt;p&gt;Desde o C++ moderno (pós-03) o uso de arrays de tamanho fixo estão se tornando depreciados. E por um bom motivo: você nunca sabe realmente qual o tamanho que você precisa para um array de bytes até você saber. Daí a próxima grande questão é: &amp;quot;como gerenciar essa memória dinâmica de forma efetiva?&amp;quot;. E a resposta moderna sempre é: &amp;quot;não faça isso você mesmo&amp;quot;. Eis o porquê:&lt;/p&gt;
&lt;p&gt;Quando lidamos com funções legadas elas se misturam de tal maneira com código novo que a merda da alocação/desalocação dinâmica manual vai se espalhando também. A não ser que a gente comece a usar o novo modelo RAII e deixe a memória ser gerenciada automaticamente:&lt;/p&gt;
&lt;p&gt;Note que estamos obtendo o endereço do primeiro elemento do nosso vector STL porque, desde o padrão C++0x03, vetores são garantidos que serão contínuos. Essa garantia de leiaute de memória pode facilitar muitos usos de vector que estavam dependentes da implementação. O exemplo acima é apenas o mais simples deles, mas imagine que qualquer tipo de memória contígua cujo tamanho é desconhecido em tempo de compilação pode ser deixado seu gerenciamento para a STL cuidar.&lt;/p&gt;
&lt;p&gt;Ah, e a partir do C++11 podemos usar vector::data() para obter os dados sem deferenciar o primeiro elemento. Particularmente acho mais expressiva a sintaxe dos arrays, mas fica a gosto do freguês.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Variáveis static local Nunca São Inicializadas Se Você Não Chama Sua Função</title>
  <link>http://www.caloni.com.br/variaveis-static-local-nunca-sao-inicializadas-se-voce-nao-chama-sua-funcao/</link>
  <pubDate>2018-02-20</pubDate>
  
  <guid>http://www.caloni.com.br/variaveis-static-local-nunca-sao-inicializadas-se-voce-nao-chama-sua-funcao/</guid>
  <description>&lt;p&gt;Uma dúvida muito comum dos programadores iniciantes em C/C++ diz respeito às variáveis static que são declaradas dentro de um escopo, como uma função. Sabemos que se ela fosse declarada global, fora de qualquer escopo, ela seria inicializada antes do main ser chamado, como diz este trecho de alguém que pesquisou a respeito:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;C++ Primer says. Each local static variable is initialized before the first time execution passes through the object&#39;s definition. Local statics are not destroyed when a function ends; they are destroyed when program terminates.&amp;quot; - Someone that google it for but did not get it&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mas no caso de variáveis static declaradas dentro de uma função isso não acontece, e ela pode ser inicializada a qualquer momento. Basta alguém chamar a função onde ela foi definida.&lt;/p&gt;
&lt;p&gt;Note que mesmo trocando static int para static const int a mesma coisa acontece. Apenas conseguimos forçar a inicialização antes do main quando há alguma variável global (static ou não) que chame a função.&lt;/p&gt;
&lt;p&gt;O problema disso é que é possível que duas threads chamem func() &amp;quot;ao mesmo tempo&amp;quot;, gerando uma dupla inicialização caso a implementação da libc não seja thread-safe. E a menos que o padrão especifique que essa inicialização deva ser thread safe, melhor fazer as coisas direito.&lt;/p&gt;
&lt;p&gt;Mas, a título de curiosidade, é bom saber que o Visual Studio 2017 essa parte da libc já possui um mecanismo de proteção, como o sugestivo nome tlsindex já indica:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como Parsear Argc Argv para um map STL</title>
  <link>http://www.caloni.com.br/como-parsear-argc-argv-para-um-map-stl/</link>
  <pubDate>2018-01-26</pubDate>
  
  <guid>http://www.caloni.com.br/como-parsear-argc-argv-para-um-map-stl/</guid>
  <description>&lt;p&gt;Os clássicos argv/argc são úteis quando os parâmetros de um programa são conhecidos e geralmente obrigatórios (até a ordem pode ser obrigatória). Isso funciona muito bem para C. Porém, há a possibilidade de STLzar esses argumentos de forma simples, usando a lógica UNIX de fazer as coisas e transformando tudo em um map de string para string. E tudo isso cabe em uma função pequena que você pode copiar e levar com você em seu cinto de utilidades:&lt;/p&gt;
&lt;p&gt;Com a função ParseCommandLine disponível assim que você adicionar este header (eu chamo de args.h) basta no início do seu main chamá-lo passando o argv e o argc recebidos:&lt;/p&gt;
&lt;p&gt;O resultado é que a variável args irá conter um mapa entre parâmetros e valores. Se seu programa for chamado com, por exemplo, a seguinte linha de comando:&lt;/p&gt;
&lt;p&gt;A variável args irá conter três elementos: &amp;quot;--name&amp;quot;, &amp;quot;--surname&amp;quot; e &amp;quot;--enable-log&amp;quot;. Nos dois primeiros ele irá entregar os valores respectivos &amp;quot;Agatha&amp;quot; e &amp;quot;Christie&amp;quot; se indexado (args[&amp;quot;--name&amp;quot;], por exemplo). No terceiro elemento o valor é uma string vazia. Apenas a existência dele é o flag. Costumo usar isso para conseguir depurar por parâmetro:&lt;/p&gt;
&lt;p&gt;De maneira geral argv/argc já estão divididos quando o programa começa. O que o ParseCommandLine faz é apenas entregar os parâmetros formatados da maneira usual para tratarmos rapidamente as opções passadas dinamicamente para o programa.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como Achar Erros no Printf via Dump</title>
  <link>http://www.caloni.com.br/como-achar-erros-no-printf-via-dump/</link>
  <pubDate>2018-01-25</pubDate>
  
  <guid>http://www.caloni.com.br/como-achar-erros-no-printf-via-dump/</guid>
  <description>&lt;p&gt;Às vezes, e apenas às vezes, é útil ter um dump do processo que acabou de capotar e ter um singelo backup do pdb (arquivo de símbolos) dos binários envolvidos nessa tragédia. Com alguns cliques pontuais e uma análise simples da stack, da variável e do código envolvido é possível chegar em um veredito sem muitas controversas se foi isso mesmo que gerou o crash. No caso peguei hoje um caso assim.&lt;/p&gt;
&lt;p&gt;Abrir um dump (dmp) pode ser feito pelo Visual Studio, Windbg ou sua ferramenta de análise favorita. Mais importante que isso é carregar seus símbolos adequadamente. Com o dump e símbolos abertos é possível analisar a stack de chamadas, o que nos revela que há um problema em uma função de Log. Como se trata de uma versão release não há muita informação da pilha, que pode fazer parte de uma stack modificada (otimização de código). Portanto, tudo que vier é lucro. Como variáveis.&lt;/p&gt;
&lt;p&gt;Demos sorte e é possível ver o que tem na variável de format, a mais importante de uma função de log estilo printf, pois geralmente é ela a responsável pelas dores de cabeça infernais.&lt;/p&gt;
&lt;p&gt;Através dessa string é possível buscar no código usando grep, vim ou até o Visual Studio. Com isso reduzimos nosso escopo de busca ao mínimo.&lt;/p&gt;
&lt;p&gt;E voilà! Temos uma chamada de log que teoricamente teria que passar uma string C, mas não passa nada. Isso quer dizer que a função de printf irá procurar na pilha pelo endereço de uma string, mas irá encontrar um endereço aleatório. Lendo esse endereço, que tem ótimas chances de ser inválido, ele irá capotar. Para dores de cabeças mais intensas, ele irá capotar aleatoriamente (ou na máquina do chefe, o mais provável).&lt;/p&gt;
&lt;p&gt;E assim terminamos mais uma sessão simples e rápida de debug. Quer dizer, simples e rápida para quem tem 20 anos de experiência nessas coisas. Os estagiários devem ter ficado de cabelos em pé.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como Apagar o Prompt do seu Programa Windows</title>
  <link>http://www.caloni.com.br/como-apagar-o-prompt-do-seu-programa-windows/</link>
  <pubDate>2018-01-23</pubDate>
  
  <guid>http://www.caloni.com.br/como-apagar-o-prompt-do-seu-programa-windows/</guid>
  <description>&lt;p&gt;Geralmente se cria um projeto console/prompt quando há a necessidade de interfacear com o usuário com o uso da tela preta, saída padrão, etc. E no caso do Windows também há a possibilidade de criar um programa Win32 onde não há prompt, pois a função do programa ou é ser invisível ou criar, sabe como é, janelas. Mas nenhum dos dois possibilita ambos ao mesmo tempo. Este snippet permite que você faça isso.&lt;/p&gt;
&lt;p&gt;Para isso funcionar você criar um projeto console no Visual Studo. Essa opção está no Linker, System, Heap Reserve Size.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Cmd e o encoding fake</title>
  <link>http://www.caloni.com.br/cmd-e-o-encoding-fake/</link>
  <pubDate>2017-12-26</pubDate>
  
  <guid>http://www.caloni.com.br/cmd-e-o-encoding-fake/</guid>
  <description>&lt;p&gt;Qualquer um que já tenha mexido no prompt de comandos do Windows sabe que ele permite você escolher qual code page utilizar para enviar e receber comandos. O Windows é todo em UTF-16, mas as saídas podem vir de qualquer programa com qualquer encoding. A missão do cmd.exe é usar o encoding escolhido pelo usuário para exibir os caracteres na tela. Vamos supor que nós criemos uma pasta com acentos no nome (pelo Explorer para não ter erro):&lt;/p&gt;
&lt;p&gt;Agora através de um cmd.exe podemos observar como esse nome acentuado aparece:&lt;/p&gt;
&lt;p&gt;Note como o &amp;quot;a&amp;quot; acentuado com til aparece perfeitamente. Também note que o codepage utilizado é o 437.&lt;/p&gt;
&lt;p&gt;Até aí tudo bem, certo?&lt;/p&gt;
&lt;p&gt;Não! Não! Não!&lt;/p&gt;
&lt;p&gt;O codepage 437 não possui ã. Nem õ.&lt;/p&gt;
&lt;p&gt;Isso, meus amigos, é chamado tecnicamente na área de &amp;quot;muito louco&amp;quot;.&lt;/p&gt;
&lt;p&gt;Curioso a respeito disso, resolvi observar a saída padrão do cmd.exe, para ver o que diabos vem como resultado. Para isso desenvolvi um simples output redirector tabajara:&lt;/p&gt;
&lt;p&gt;Simples, bonito e prático. Quando executamos Redirector.exe ele executa um cmd.exe, com a diferença que a saída dele vai parar no arquivo cmd.log, que podemos observar com um BareTail da vida.&lt;/p&gt;
&lt;p&gt;Opa, opa, opa!&lt;/p&gt;
&lt;p&gt;O til sumiu!&lt;/p&gt;
&lt;p&gt;Se formos analisar os bytes que vieram de saída, vamos constatar que o byte referente ao ã foi enviado para a saída padrão como o byte 0x61, ou 97 em decimal. No codepage 437 (e em qualquer derivado da tabela ASCII, na verdade) o byte 97 é representado como &amp;quot;a&amp;quot;, simplesmente, sem til.&lt;/p&gt;
&lt;p&gt;Isso quer dizer que ao receber um &amp;quot;ã&amp;quot; o cmd.exe o reinterpreta como &amp;quot;a&amp;quot;, mesmo estando sob o encoding 437. Esse é o resultado de um prompt user friendly que quer seu amigo.&lt;/p&gt;
&lt;p&gt;Se analisarmos a memória do cmd.exe veremos que ele armazena as coisas em UTF-16, como qualquer programa Windows nativo unicode.&lt;/p&gt;
&lt;p&gt;E com isso constatamos que não necessariamente no Windows, What You See Is What You Get. Ou, em termos mais filosóficos, What You See Is Not What I Get.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Se você não precisa de classe você não precisa de classe</title>
  <link>http://www.caloni.com.br/se-voce-nao-precisa-de-classe-voce-nao-precisa-de-classe/</link>
  <pubDate>2017-12-17</pubDate>
  
  <guid>http://www.caloni.com.br/se-voce-nao-precisa-de-classe-voce-nao-precisa-de-classe/</guid>
  <description>&lt;p&gt;Nos últimos dias me deparei com o seguinte (pseudo-)código:&lt;/p&gt;
&lt;p&gt;Dentro de MyClass a seguinte estrutura:&lt;/p&gt;
&lt;p&gt;Então eu me pergunto: qual a função da classe em um código desses?&lt;/p&gt;
&lt;p&gt;Bjarne Stroustrup desde o começo, em seu livro The C++ Programming Language, sugere que C++ não é uma linguagem unicamente orientada a objetos, mas multi-paradigmas. Hoje, em 2017, ela é uma linguagem genérica e até funcional. Na época poderia ser usada como orientada a objetos, mas também como estruturada e imperativa comum. O goto funciona até hoje.&lt;/p&gt;
&lt;p&gt;Então o erro no código acima é supor mecanicamente que como é C++ precisa ter classe. Não. O código não precisa ter uma classe. No entanto, seu código precisa ter classe. Entendeu?&lt;/p&gt;
&lt;p&gt;Ter classe é para poucos. É para programadores que se preocupam com a relação entre funcionalidade, estilo, arquitetura e todos os inúmeros elementos que tornam um código perfeito. Para ser perfeito, um código precisa levar em conta tantos elementos que apenas um programador acordado, obsessivo, fora da matrix, conseguiria observar o que deve ser feito.&lt;/p&gt;
&lt;p&gt;Uma pequena sugestão:&lt;/p&gt;
&lt;p&gt;É a melhor solução? Não. Só uma ideia para tornar o código simples de entender, enxuto para manter, com apenas o modelito básico. Tem até um map para evitar encher de ifs. Mas não precisaria se você tem meia-dúzia de funções.&lt;/p&gt;
&lt;p&gt;E note que eu disse funções, não classe. E é possível ter classe sem classes.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>C&#43;&#43; Moderno Arranca os Cabelos por Você (std::move e classes simples).</title>
  <link>http://www.caloni.com.br/cpp-arranca-os-cabelos-por-voce/</link>
  <pubDate>2017-09-26</pubDate>
  
  <guid>http://www.caloni.com.br/cpp-arranca-os-cabelos-por-voce/</guid>
  <description>&lt;p&gt;Um dos últimos posts no grupo CCPPBR do Thiago Adams chama mais uma vez a atenção para a complexidade infinita que linguagens como C++ estão preferindo tomar. Esta é a geração que irá sofrer as dores de compatibilidade com o passado mais que todas as outras que virão.&lt;/p&gt;
&lt;p&gt;Isso porque mudanças pontuais que vão sendo aplicadas na linguagem e biblioteca, como move semantics, não cabe mais em exemplos de livrinhos de C++ para iniciantes da década de 90:&lt;/p&gt;
&lt;p&gt;Neste singelo exemplo, que está errado by design, a classe X não se preocupa em proteger-se de cópias simples. Mas o programador também não se protege da ignorância e usa std::move como se ele magicamente movesse referências const, o que é absurdo.&lt;/p&gt;
&lt;p&gt;A questão, porém, não é sobre qual é o problema no código, mas os aspectos de design de C++ que podem levar futuros programadores a se depararem com o mesmo problema em versões multicamadas de complexidade. Este é um exemplo óbvio, mas até quando será?&lt;/p&gt;
&lt;p&gt;Esta crítica pode levar (pelo menos) para dois diferentes caminhos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;O funcionamento do std::move não é intuitivo e pode levar a erros semânticos (&amp;quot;se usar o move estou movendo referências&amp;quot;); programador não conhece o funcionamento por completo.&lt;/li&gt;
&lt;li&gt;Em C++ o esforço de manter uma classe é muito maior hoje do que em 98/03 (&amp;quot;tomar cuidado com reference, const reference, rvalue reference...&amp;quot;); isso concordo; as mudanças são bem-intencionadas, mas a linguagem é velha com alguns esqueletos que podem começar a balançar.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++, assim como o Brasil, desde o começo nunca foi para amadores. Hoje em dia ele é impossível. Ouço galera falar que está ficando lindo, mas, francamente, está virando é um ninho de cobras. Mantenedores de bibliotecas, se não estão já arrancando os cabelos, deveriam começar.&lt;/p&gt;
&lt;p&gt;Mas talvez com C++ 17+ os cabelos passem a cair sozinho...&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Ativando Ubuntu No Windows 10</title>
  <link>http://www.caloni.com.br/ativando-ubuntu-no-windows-10/</link>
  <pubDate>2017-08-29</pubDate>
  
  <guid>http://www.caloni.com.br/ativando-ubuntu-no-windows-10/</guid>
  <description>&lt;p&gt;Pensei que o Ubuntu já estivesse na Windows Store disponível para qualquer gamer instalar (não sei por que um gamer faria isso). Mas não. Ainda é necessário fazer os passos de desenvolvedor expert de Windows para ativar esta opção.&lt;/p&gt;
&lt;p&gt;Primeiro, vá nas configurações e ative o Developer Mode:&lt;/p&gt;
&lt;p&gt;Depois vá em Adicionar/Remover Programas e ative o Windows Subsystem for Linux (Beta):&lt;/p&gt;
&lt;p&gt;Reinicie a máquina, abra o prompt de comando, digite bash e enter. Ele irá perguntar se quer instalar o Ubuntu, diga que sim, e depois de um tempo já terá o melhor dos dois mundos: o melhor ambiente gráfico com o melhor ambiente de programação.&lt;/p&gt;
&lt;p&gt;Cywgin quem?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Migrando Imagens Para Imgur</title>
  <link>http://www.caloni.com.br/migrando-imagens-para-imgur/</link>
  <pubDate>2017-07-28</pubDate>
  
  <guid>http://www.caloni.com.br/migrando-imagens-para-imgur/</guid>
  <description>&lt;p&gt;Depois de migrar meus blogues para o Hugo decidi deixar o repositório mais magro migrando as imagens para um serviço de imagens. O imgur me pareceu uma solução simples com uma interface rápida (e uma API Python). Para realizar essa tarefa você vai precisar das ferramentas de sempre: grep, sed, python, vim. E lá vamos nós.&lt;/p&gt;
&lt;p&gt;Meu primeiro passo foi realmente limpar a pasta de imagens, eliminando as que não estavam sendo usadas. A pasta de imagens ficou se acumulando por anos, e muitas imagens foram sendo carregadas através dos Wordpress da vida e plugins que deram resize nas imagens, gerando várias cópias no processo. Tudo inútil e dispendioso.&lt;/p&gt;
&lt;p&gt;O principal problema de subir tudo para o imgur é que os nomes dos arquivos irão mudar e perder a referências usadas no texto. Para conseguir renomear os arquivos dentro dos artigos é necessário conectar no serviço do imgur e através dele obter o nome original do arquivo, disponível na propriedade name:&lt;/p&gt;
&lt;p&gt;Executando este script será possível gerar um log no formato nome-original-do-arquivo =&amp;gt; id-da-imagem-usado-pelo-imgur. O ID deles também é usado para link direto da imagem, de onde virá o comando sed que vai substituir nos artigos os nomes originais pelo link do imgur:&lt;/p&gt;
&lt;p&gt;Lembrar de apagar o all.md. Ele só foi usado para gerar a saída mais simples do grep.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Forma Mais Simples De Depurar Processos Antes Do Logon</title>
  <link>http://www.caloni.com.br/forma-mais-simples-de-depurar-processos-antes-do-logon/</link>
  <pubDate>2017-07-27</pubDate>
  
  <guid>http://www.caloni.com.br/forma-mais-simples-de-depurar-processos-antes-do-logon/</guid>
  <description>&lt;p&gt;No post anterior sobre debug eu havia me focado mais na depuração de processos remotos no Visual Studio 2003 de maneira convencional. Aqui eu vou abordar o assunto de uma maneira menos convencional: usando o Visual Studio 2017 mais novo e depurando uma DLL (C++) que é carregada por um serviço antes do logon no Windows 7.&lt;/p&gt;
&lt;p&gt;Em primeiro lugar, como vimos anteriormente, a ponta server do depurador é um programa que você executa com alguns parâmetros e ele fica escutando em uma porta. Simples assim. Para que isso funcione antes do logon é necessário instalar esse programa como um serviço. Tanto no caso de depuradores mais antigos (msvCmon) quando nos mais novos (msvSmon) há sempre um executável com alguns parâmetros passados via linha de comando.&lt;/p&gt;
&lt;p&gt;O depurador do Visual Studio mais novo fica em sua pasta de instalação Program Files, etc, Microsoft Visual Studio, 2017, Enterprise, Common7, IDE, Remote Debugger ou derivados. Dentro dessa pasta há subpastas para cada arquitetura, x64 ou x86. É essa pasta que deve ser copiada para a máquina que será depurada. Se você estiver depurando um processo 32 bits, use o x86; do contrário, vá de x64.&lt;/p&gt;
&lt;p&gt;No caso do msvsmon, se executado com /? (padrão entre programas Windows) ele abre um pequeno help com a ajuda necessária para executar os parâmetros corretos. No caso o comando maroto é o seguinte:&lt;/p&gt;
&lt;p&gt;E para transformar em um serviço podemos usar o NSSM, já visto em outros artigos.&lt;/p&gt;
&lt;p&gt;Isso cria um serviço de start automático que irá iniciar o debugger na ponta server quietinho, sem janelas, só escutando e esperando o Visual Studio atachar.&lt;/p&gt;
&lt;p&gt;Para este exemplo vamos usar um programa console que será convertido, assim como o msvsmon, em serviço, e uma DLL que ele carrega, chamando dois métodos; um de start, outro de stop. Nosso objetivo aqui é começar a depurar a DLL logo em seu início, na chamada do start.&lt;/p&gt;
&lt;p&gt;As funções de start e stop não fazem nada, apenas imprimem um passou-por-aqui:&lt;/p&gt;
&lt;p&gt;Todo o projeto está no GitHub para baixar e compilar você mesmo.&lt;/p&gt;
&lt;p&gt;Depois de copiar Service.exe e DLL.dll para a máquina-alvo (e não se esquecer de instalar as dependências) instalar da mesma forma com que foi instalado o msvsmon:&lt;/p&gt;
&lt;p&gt;Agora ache o IP da máquina-alvo e vá em Debug, Attach to Process (Ctrl+Alt+P) no Visual Studio, modo remoto e digite o IP.&lt;/p&gt;
&lt;p&gt;Lembre-se de iniciar o serviço.&lt;/p&gt;
&lt;p&gt;Após esse teste podemos modificar a DLL para aguardar por um depurador:&lt;/p&gt;
&lt;p&gt;Depois que houver o attach você irá continuar a execução. Portanto, coloque um breakpoint logo depois. E depois que isso funcionar já é possível iniciar sua depuração antes da tela de login. Os serviços executarão, e sua DLL estará aguardando um debugger ser atachado. Se houver necessidade é possível deixar esse modo de espera configurável, por timeout, etc.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>CppTests</title>
  <link>http://www.caloni.com.br/cpptests/</link>
  <pubDate>2017-07-25</pubDate>
  
  <guid>http://www.caloni.com.br/cpptests/</guid>
  <description>&lt;p&gt;Iniciei um novo projeto no GitHub que tem por objetivo ser minha prancheta de trabalhos para minha palestra no próximo encontro ccpp. Há uma infinitude de coisinhas novas na linguagem C++, fora as adições à biblioteca STL, mas que devem passar despercebidas da maioria dos programadores, que está mais é querendo terminar seus próprio projetos. Enquanto alguns conceitos, sintaxes e métodos não se solidificam, vale a pena dar uma espiada no futuro?&lt;/p&gt;
&lt;p&gt;Depende.&lt;/p&gt;
&lt;p&gt;Dei uma olhada nas últimas modificações adicionadas no Visual Studio 2017 (versão 15.3 preview 1, mas o último lançado é o preview 5), e há muitos elementos IMHO supérfluos, mas que tendem a ser integrados aos poucos (I hope).&lt;/p&gt;
&lt;p&gt;A lista que achei interessante (com seu projeto):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;binary_literals_test. Perfumaria muito bem-vinda de uma linguagem feita para trabalhar também baixo nível.&lt;/li&gt;
&lt;li&gt;constexpr_test. Um teste que alguém fez na nossa lista ccpp do Telegram e que possui uma particularidade interessante (mais abaixo).&lt;/li&gt;
&lt;li&gt;for_range_generic_test. Ainda em teste, mas me parece a forma definitiva de iterar entre elementos em C++; completamente genérico.&lt;/li&gt;
&lt;li&gt;generic_lambdas_test. E por falar em genérico, este lambda tem muito a ver com programação funcional.&lt;/li&gt;
&lt;li&gt;has_include_test. Uma maneira elegante (apesar do nome feio) de ir migrando projetos/libs aos poucos.&lt;/li&gt;
&lt;li&gt;initializer_list. Só demonstrando o que já é velho (mas que ainda não comentei no blogue).&lt;/li&gt;
&lt;li&gt;nodiscard_test. Essa é uma das features mais curiosas para escrita de código robusta.&lt;/li&gt;
&lt;li&gt;sfinae_test. O SFINAE é um dos pilares do C++, e ele vem melhorando cada vez mais.&lt;/li&gt;
&lt;li&gt;static_assert_test. O que estava faltando que no Boost é macaco velho.&lt;/li&gt;
&lt;li&gt;user_defined_literals_test. Mais uma perfumaria; essa é bonitinha; para uso acadêmico.&lt;/li&gt;
&lt;li&gt;variable_templates_test. Mais algo já velho, que demonstro aqui com minha superlib de log.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A otimização no if através do uso da palavra-chave constexpr possibilita a criação de diferentes instâncias da chamada que não contém o if, mas um dos dois branches dependendo do tipo ser integral ou não.&lt;/p&gt;
&lt;p&gt;Para que a compilação dessa opção funcione no Visual Studio 2017 15.3 é necessário inserir o parâmetro /std:c++latest nas opções do projeto em C/C++, Command Line, Additional Options.&lt;/p&gt;
&lt;p&gt;Todos (ou a maioria) deles ainda está em teste. Acabei de baixar o preview 5, conforma um dos membros da ML dos MVPs C++ me informou que saiu quentinha do forno. Em breve novidades.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Debugger remoto do Visual Studio</title>
  <link>http://www.caloni.com.br/debugger-remoto-do-visual-studio/</link>
  <pubDate>2017-06-13</pubDate>
  
  <guid>http://www.caloni.com.br/debugger-remoto-do-visual-studio/</guid>
  <description>&lt;p&gt;Então você está quebrando a cabeça para descobrir por que seu código não faz o que deveria fazer? Então você é desses que acha que é melhor ficar imaginando com um bloquinho de papel na mão do que colocar logo a mão na massa e ver exatamente o código passando pelo processador? Talvez você mude de ideia ao ver como é ridiculamente fácil depurar código em uma máquina remota, seja uma VM ou a máquina do cliente. Neste post vou ensinar a maneira mais antiga e a mais nova que conheço de usar o depurador do Visual Studio. Vamos usar a versão 2003 e a versão 2017 RC.&lt;/p&gt;
&lt;p&gt;Há muito tempo atrás eu falei sobre o depurador remoto do C++ Builder, na época a ferramenta que eu mais utilizava para programar. Hoje disparado é o Visual Studio, já faz mais de uma década. Desde o VS2003 tem sido muito simples depurar remotamente. Tão simples que eu realmente esqueci que talvez algumas pessoas não saibam o quanto é útil essa ferramenta no dia-a-dia.&lt;/p&gt;
&lt;p&gt;É possível depurar qualquer executável, tendo seu código-fonte ou não. A diferença é que sem código você terá que olhar o assembly e se for compilado como release você pode olhar o código mas ele não fará muito sentido em alguns momentos (onde estão minhas variáveis locais?). O melhor dos mundos, é claro, é depurar um executável que você tenha os símbolos, o código e esteja compilado em debug. Daí o código irá falar com você da maneira mais fácil.&lt;/p&gt;
&lt;p&gt;É simples de achar essa opção no projeto em qualquer Visual Studio. Vá nas opções do projeto, Linker e irá encontrar em algum lugar sobre a geração do PDB. Não tenha medo de explorar as opções do projeto. Elas refletem como o XML do projeto muda (sim, é um XML). Se estiver querendo saber exatamente como ele muda, use um controle de fonte e vá experimentando.&lt;/p&gt;
&lt;p&gt;Para depurar pelo Visual Studio 2003 há um programa chamado msvcmon.exe que deve ser copiado e executado na máquina-alvo. Ele é um executável que pode ser copiado para qualquer lugar. Junto dele devem estar duas DLLs: a natdbgdm.dll e a natdbgtlnet.dll. Se você tiver o VS2003 instalado deve achar esses arquivos em algum lugar, ou no pior dos casos no CD de instalação. Por via das dúvidas sempre há um link amigo na internet para ajudar alguém a achar o que precisa.&lt;/p&gt;
&lt;p&gt;Copiados esses arquivos na máquina-alvo é necessário copiar também o executável. Afinal de contas, ele irá executar remotamente! O arquivo PDB, no entanto, você só precisa guardar com você. Lembre-se que toda recompilação em Debug altera de maneira significativa o PDB, então não recompile seu projeto enquanto estiver depurando. Se for fazê-lo, troque o executável na máquina-alvo.&lt;/p&gt;
&lt;p&gt;A primeira execução de toda ferramenta, seu help, irá nos mostrar o seguinte no msvcmon:&lt;/p&gt;
&lt;p&gt;Minhas opções favoritas são -tcpip -anyuser -timeout -1, o que libera o acesso a qualquer usuário direto por TCP/IP e o timeout da execução é infinito. All access no limits =)&lt;/p&gt;
&lt;p&gt;Agora no Visual Studio 2003 vá em Debug, Processes (ou Ctrl+Alt+P para os íntimos) e escolha a opção de Transport como TCP/IP, digite o IP... explore sua ferramenta, poxa!&lt;/p&gt;
&lt;p&gt;Depois de conectar remotamente por essa janela o console do msvcmon irá mostrar que usuário se logou:&lt;/p&gt;
&lt;p&gt;Para configurar o início da depuração remota pelo próprio projeto você terá que ir nas opções de debug dele e mexer em Remote Settings. Para começar os problemas é sempre bom lembrar que projetos compilados como debug precisam das DLLs de runtime do Visual Studio que sejam debug. Mas você já sabe disso.&lt;/p&gt;
&lt;p&gt;Depois que tudo isso estiver OK é só iniciar seus processos remotamente em modo de depuração ou atachar pela primeira janela que vimos.&lt;/p&gt;
&lt;p&gt;Agora você deve estar se perguntando: &amp;quot;mas esse VS é muito velho! e os mais novos?&amp;quot;&lt;/p&gt;
&lt;p&gt;Bom, desde o VS 2010 e até o VS2017 RC essa ferramenta está disponível na pasta de instalação, mudou um pouco de cara e você pode encontrar procurando por &amp;quot;remote&amp;quot;. No Caso do VS mais novo que tenho em mãos aqui, o 2017 RC, existe já uma pasta pronta para copiar e colar na máquina-alvo, em Common7, IDE, Remote Debugger. Há duas pastas disponíveis: x86 e x64. Dependendo do tipo de compilação que deseja realizar (e de qual o seu executável) copie uma das duas, rode o executável da pasta e apenas configure.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como acessar submódulos no git inacessíveis?</title>
  <link>http://www.caloni.com.br/submodules-locais-no-git/</link>
  <pubDate>2017-05-28</pubDate>
  
  <guid>http://www.caloni.com.br/submodules-locais-no-git/</guid>
  <description>&lt;p&gt;Quando projetos remotos usam submodules é possível que algum deles seja acessível apenas através de chaves criptográficas. Isso exige que os sub-projetos necessários para fazer funcionar seu projeto podem estar fora do seu alcance e acesso, o que irá gerar durante seus comandos pull recursivos erros de ssh (publickey access).&lt;/p&gt;
&lt;p&gt;A solução é ler a documentação e descobrir que é possível editar o arquivo .git/config para mudar a url de um submódulo inacessível pela forma do .gitmodules. Eis um exemplo de arquivo config dentro do .git:&lt;/p&gt;
&lt;p&gt;Você pode localmente alterar o endereço ssh deste submodule para algo que todos têm acesso ou só você tem acesso, como uma pasta local ou o endereço https:&lt;/p&gt;
&lt;p&gt;Note que isso não irá interferir em nada no repositório localizado remotamente do projeto. Dessa forma diferentes membros da equipe podem usar diferentes formas de acessar um submódulo.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>SystemRescueCD: um CD cheio de ferramentas Linux para desenvolvedores e suporte</title>
  <link>http://www.caloni.com.br/systemrescuecd-um-cd-cheio-de-ferramentas/</link>
  <pubDate>2017-05-28</pubDate>
  
  <guid>http://www.caloni.com.br/systemrescuecd-um-cd-cheio-de-ferramentas/</guid>
  <description>&lt;p&gt;Há diversas distros Linux capazes de bootar via CD e com uma penca de ferramentas. Conheci há alguns anos uma delas: a SystemRescueCd: um disco de recuperação de HDs com diversas ferramentas embutidas. Dentro dele pode ser inserido outras ferramentas que achar interessante, e o mais importante, desenvolver através do próprio CD suas ferramentas.&lt;/p&gt;
&lt;p&gt;A modificação do CD pode ser feita bootando com ele mesmo, seguinto o tutorial da própria SystemRescueCd. No entanto, para facilitar o uso, é possível utilizá-lo em um ambiente virtualizado (criar uma VMWare que boote pelo CD, por exemplo, e depois instalar no HD virtual).&lt;/p&gt;
&lt;p&gt;Outra opção interessante é montar outras partições partindo do próprio CD. Ao bootar com o CD da SystemRescue, após ter acesso ao terminal pela primeira vez, detecte e formate o HD Linux usando a ferramenta fdisk. Dentro da ferramenta use as opções padrão e crie uma particão Linux. Ao final, escreva com &#39;w&#39;, formate a partição (ex: mkfs.ext4) e a partição já deverá estar disponível no próximo boot.&lt;/p&gt;
&lt;p&gt;Para formatar uma partição Windows é possível realizar o mesmo procedimento, mas trocar o tipo de partição para Windows FAT32. Com isso a partição estará disponível para ser montada tanto na máquina virtual quanto na real.&lt;/p&gt;
&lt;p&gt;Desligue a VM. A partir do Windows, monte o HD Windows e formate a partição criada. Ou, se a partição ainda não foi criada é só criar pelo Gerenciador de Discos do Windows.&lt;/p&gt;
&lt;p&gt;Obs.: Apenas a VM ou a máquina real podem utilizar o HD de uma vez. Portanto, para copiar arquivos para o HD virtualizado é necessário desligar a VM antes.&lt;/p&gt;
&lt;p&gt;Seguindo o tutorial do SystemRescueCD (&amp;quot;Step-01: Mount the working partition&amp;quot;), vamos montar a partição Linux na pasta /mnt/custom.&lt;/p&gt;
&lt;p&gt;Em seguida extraia os arquivos atuais do CD para a pasta custom (essa operação pode demorar alguns minutos):&lt;/p&gt;
&lt;p&gt;Após a conclusão dessa operação, os arquivos customizados poderão ser encontrados em /mnt/custom/customcd/files/bin&lt;/p&gt;
&lt;p&gt;Para copiar os arquivos novos, monte a partição Windows e copie de uma pasta para outra. Já existe uma pasta em mnt chamada windows que pode ser alvo da montagem. Abaixo os comandos necessários para atualizar um possível script:&lt;/p&gt;
&lt;p&gt;Voilá! Agora que os arquivos já foram atualizados é hora de regerar um novo ISO do CD. Para isso, executar o seguinte script do RescueCD (&amp;quot;Step-10: Create the new ISO image&amp;quot;); esse comando pode demorar alguns minutos:&lt;/p&gt;
&lt;p&gt;Após a conclusão do comando o novo ISO deverá estar no diretório /mnt/custom/customcd/isofile/ com a data/hora atual. Copie este arquivo para a partição Windows para ter acesso ao ISO na máquina real:&lt;/p&gt;
&lt;p&gt;Desligue a máquina virtual e volte a montar o HD na máquina real. O ISO do novo CD estará disponível.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Forma simples de baixar atualizações remotamente de um cliente para um servidor</title>
  <link>http://www.caloni.com.br/forma-simples-de-baixar-atualizacoes-remotamente-de-um-cliente-para-um-servidor/</link>
  <pubDate>2017-03-23</pubDate>
  
  <guid>http://www.caloni.com.br/forma-simples-de-baixar-atualizacoes-remotamente-de-um-cliente-para-um-servidor/</guid>
  <description>&lt;p&gt;A forma mais simples e rápida para subir um servidor de arquivos é usar o file server embutido do python:&lt;/p&gt;
&lt;p&gt;Para que não seja necessário instalar o Python no servidor é possível transformar essa chamada em um executável, com todas suas dependências embutidas:&lt;/p&gt;
&lt;p&gt;Esse script pode ser compilado pela ferramenta py2exe, instalável pelo próprio Python. É necessário criar um arquivo setup.py na mesma pasta do script e através desse script gerar uma pasta dist com o script &amp;quot;compilado&amp;quot; e pronto para ser executado.&lt;/p&gt;
&lt;p&gt;Pelo prompt de comando executar o seguinte comando que irá gerar a pasta dist:&lt;/p&gt;
&lt;p&gt;Uma vez gerada a pasta, renomear para fileserver e copiar no servidor em qualquer lugar (ex: pasta-raiz). Executar de qualquer pasta que se deseja tornar acessível via browser ou qualquer cliente http:&lt;/p&gt;
&lt;p&gt;Para testar basta acessar o endereço via browser.&lt;/p&gt;
&lt;p&gt;Do lado cliente há ferramentas GNU como curl e wget para conseguir baixar rapidamente qualquer arquivo via HTTP. Para máquinas com Power Shell disponível há um comando que pode ser usado:&lt;/p&gt;
&lt;p&gt;Porém, caso não seja possível usar o Power Shell o pacote básico do wget do GnuWin32, de 2MB, já consegue realizar o download.&lt;/p&gt;
&lt;p&gt;E assim com poucas linhas de código já é possível iniciar um client/servidor via http que fornece arquivos de atualização. A própria versão do pacote e detalhes podem estar disponíveis na mesma pasta.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>qt5.natvis</title>
  <link>http://www.caloni.com.br/qt5-natvis/</link>
  <pubDate>2017-03-15</pubDate>
  
  <guid>http://www.caloni.com.br/qt5-natvis/</guid>
  <description>&lt;p&gt;A estratégia que utilizei em meu último artigo sobre Qt para expandir o tipo QString no depurador não existe mais no VS2017 RC. O arquivo autoexp.dat foi extirpado e em seu lugar foi deixado os já ativos arquivos natvis, que podem ser usados de forma global ou por usuário.&lt;/p&gt;
&lt;p&gt;Existe um arquivo pronto circulando pela net chamado qt5.natvis. Alguns funcionam, outros não. As strings estão funcionando no meu depois que eu adaptei este arquivo com as dicas do help do qt.&lt;/p&gt;
&lt;p&gt;Se você é admin de sua máquina, basta copiar este arquivo em %programfiles(x86)%, Microsoft Visual Studio, 2017, Enterprise, Common7, Packages, Debugger, Visualizers. Se for um usuário mané, em %USERPROFILE%, Documents, Visual Studio 2017, Visualizers.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Entrando na zona com Windows</title>
  <link>http://www.caloni.com.br/entrando-na-zona-com-windows/</link>
  <pubDate>2017-03-14</pubDate>
  
  <guid>http://www.caloni.com.br/entrando-na-zona-com-windows/</guid>
  <description>&lt;p&gt;&lt;strong&gt;Update 2019-03-20: Adicionando programa para fazer tela cheia no Windows e retirados detalhes que não uso mais.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Um artigo anterior havia dado umas dicas de como transformar o Vim em uma ferramenta para toda obra, com isso limitando as distrações quando se está em um computador, e com isso facilitando a entrada e a permanência no estado de fluidez de produtividade que conhecemos como &amp;quot;flow&amp;quot;, ou estar na zona. Agora é a vez do Windows.&lt;/p&gt;
&lt;p&gt;O Windows 10 já vem com atalhos pré-instalados assim que você loga nele. Tem browser, navegador de arquivos, notícias, e uma caralhada de coisas inúteis que ficam se mexendo na tela, chamando sua atenção, distraindo sobre o que é mais importante.&lt;/p&gt;
&lt;p&gt;Mas é possível arrancar tudo isso e deixar na barra de tarefas pinado apenas as coisas realmente vitais para o uso do computador de trabalho, geralmente o terminal, o navegador (pesquisa, emails, etc) e o editor (não necessariamente o Vim).&lt;/p&gt;
&lt;p&gt;O terminal do Windows, o Command Prompt, ou cmd para os íntimos, sofreu algumas mudanças ultimamente. Entre elas há a transparência, o que o tornou cool, e a tela cheia (atalho Alt+Enter), o que o tornou ideal como ferramenta de navegação para programadores (melhor do que o explorer, que virou um penduricalho de atalhos inúteis também). Você pode ativá-lo já entrando na tela cheia e com o code page de sua preferência (o meu é 65001, que é o utf8) usando esse pequeno programa:&lt;/p&gt;
&lt;p&gt;Os comandos do git são muito verbose. Duas letras já seriam suficiente (o Windbg manipula seu programa com apenas uma...). Para otimizar a digitação no git crie uns aliases em seu HOME.gitconfig:&lt;/p&gt;
&lt;p&gt;Agora, através dos atalhos Win+1, 2, 3... pode-se abrir e alternar entre os aplicativos principais do seu dia-a-dia, que devem ficar &amp;quot;pinados&amp;quot; na barra de tarefas. Os meus atualmente são três: terminal (1 cmd), editor (2 vim) e browser (3 chrome). Não é necessário colocar coisas como Visual Studio, já que minha navegação é feita rapidamente pelo terminal para o projeto que irei mexer. Com isso o foco fica restrito a apenas uma coisa: o que você tem que fazer hoje? =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Atalhos no terminal do Linux/Unix</title>
  <link>http://www.caloni.com.br/atalhos-no-terminal-do-linux-unix-cygwin/</link>
  <pubDate>2017-02-27</pubDate>
  
  <guid>http://www.caloni.com.br/atalhos-no-terminal-do-linux-unix-cygwin/</guid>
  <description>&lt;p&gt;Há pouca coisa que você pode fazer para manipular a linha de comando que está digitando em um terminal do Windows. Isso faz sentido. O terminal da Microsoft é apenas um resquício do MS-DOS, que foi herdado pelas inúmeras versões do Windows para que desenvolvedores e suporte pudessem executar alguns comandos não disponíveis pelo clique de um mouse. Já no Unix a história é inversa. Durante tantas décadas sendo usado, o sistema Unix, hoje, em sua mais nova reencarnação, Linux, foi acumulando diferentes teclas de atalho para conseguirmos refazer, desfazer e fazer melhor a montagem dos comandos digitados na linha de comando. Um sistema bash padrão já deve ter implementado o mínimo que você precisa para sobreviver na linha de comando. Aparentemente esse é um conhecimento tão bem divulgado pela comunidade que ninguém se dá ao trabalho de escrever um artigo sobre isso. Eu fiz algumas pesquisas uns tempos atrás e cheguei na seguinte lista, que tem muito mais do que eu preciso, e que seria bom aprender, nem que fosse aos poucos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + r&lt;/strong&gt; - navigate previous commands&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + a&lt;/strong&gt; - go to the start of the command line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + e&lt;/strong&gt; - go to the end of the command line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + k&lt;/strong&gt; - delete from cursor to the end of the command line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + u&lt;/strong&gt; - delete from cursor to the start of the command line&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + w&lt;/strong&gt; - delete from cursor to start of word (i.e. delete backwards one word)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + y&lt;/strong&gt; - paste word or text that was cut using one of the deletion shortcuts (such as the one above) after the cursor&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + xx&lt;/strong&gt; - move between start of command line and current cursor position (and back again)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alt + b&lt;/strong&gt; - move backward one word (or go to start of word the cursor is currently on)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alt + f&lt;/strong&gt; - move forward one word (or go to end of word the cursor is currently on)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alt + d&lt;/strong&gt; - delete to end of word starting at cursor (whole word if cursor is at the beginning of word)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alt + c&lt;/strong&gt; - capitalize to end of word starting at cursor (whole word if cursor is at the beginning of word)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alt + u&lt;/strong&gt; - make uppercase from cursor to end of word&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alt + l&lt;/strong&gt; - make lowercase from cursor to end of word&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alt + t&lt;/strong&gt; - swap current word with previous&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + f&lt;/strong&gt; - move forward one character&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + b&lt;/strong&gt; - move backward one character&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + d&lt;/strong&gt; - delete character under the cursor&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + h&lt;/strong&gt; - delete character before the cursor&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + t&lt;/strong&gt; - swap character under cursor with the previous one&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + l&lt;/strong&gt; - clean the screen (history back)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + z&lt;/strong&gt; - put in background (fg restores it)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + c&lt;/strong&gt; - cancel current command&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ctrl + d&lt;/strong&gt; - exit the current shell&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>O velho problema do project out of date do Visual Studio</title>
  <link>http://www.caloni.com.br/o-velho-problema-do-project-out-of-date-do-visual-studio/</link>
  <pubDate>2017-02-20</pubDate>
  
  <guid>http://www.caloni.com.br/o-velho-problema-do-project-out-of-date-do-visual-studio/</guid>
  <description>&lt;p&gt;Acho que todo mundo já passou por isso. Você compila todo o projeto bonitinho e no final, ao depurar, ele faz aquela velha pergunta: &amp;quot;o projeto está desatualizado: deseja compilar novamente?&amp;quot;. Mas como assim? Eu acabei de compilar, não faz nem cinco segundos. Está quentinho, saiu do forno agora.&lt;/p&gt;
&lt;p&gt;Quando vem aquela fatídica mensagem do Visual Studio indicando que algo de errado não está certo: &amp;quot;This project is out of date. Would you like to build it?&amp;quot; (again?)&lt;/p&gt;
&lt;p&gt;Às vezes o Visual Studio cria umas esquisitices que se perpetuam por todas as versões. Isso tem algum sentido. Funciona mais ou menos assim a lógica do &amp;quot;project out of date&amp;quot;: se existir algum arquivo cuja data/hora eu não consigo verificar eu considero que o projeto está desatualizado. Por que? Pode ser que esse arquivo tenha que ser gerado automaticamente. Pode ser que houve erro de acesso. Pode ser várias coisas, mas ainda assim faz sentido.&lt;/p&gt;
&lt;p&gt;Exceto quando o arquivo realmente não existe.&lt;/p&gt;
&lt;p&gt;E isso é bem comum de acontecer em um projeto com algum refactory. Você acabou movendo alguns arquivos compartilhados entre projetos, mas em algum desses projetos o arquivo ainda está sendo apontado para o path errado, onde ele não mais existe. No entanto, por se tratar de um arquivo não-necessário para a compilação (ex: um header) não há erros na compilação. Apenas nessa detecção do Visual Studio.&lt;/p&gt;
&lt;p&gt;O problema é que não existe nenhuma dica do que está errado em condições normais de temperatura e pressão. Para conseguiu olhar mais detalhes temos que ir em Tools, Options e configurar mais saída para o build. Pelo menos como detailed. Isso fica em Options, Project and Solutions, Build and Run.&lt;/p&gt;
&lt;p&gt;A partir daí teremos mais saída na janela de output do build. Logo no começo (talvez pela equipe do VS saber que isso é bem comum) há uma dica de quais arquivos exige o rebuild (você pode fazer isso apenas clicanco em build do projeto que sempre acusa como out of date):&lt;/p&gt;
&lt;p&gt;Depois de detectado o arquivo faltante, é só removê-lo ou atualizar o path. Esse erro não deve mais acontecer e agora você só precisa compilar uma vez e sair depurando.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Visualizando QString no Visual Studio</title>
  <link>http://www.caloni.com.br/visualizando-qstring-no-visual-studio/</link>
  <pubDate>2017-02-20</pubDate>
  
  <guid>http://www.caloni.com.br/visualizando-qstring-no-visual-studio/</guid>
  <description>&lt;p&gt;O Qt não é um framework que pode apenas ser usado no QtCreator. Através de um projeto bem configurado pelo CMake, por exemplo, é possível ter um projeto que pode ser compilado e depurado tanto nas ferramentas do Qt quanto no Visual Studio. No entanto, na hora de depurar algumas coisas são difíceis de fazer. Por exemplo: como olhar o conteúdo de uma QString?&lt;/p&gt;
&lt;p&gt;O Visual Studio utiliza um mecanismo que lembra os comandos bizarros que se usa no WinDbg, mexendo com registradores e tal. Através dessa combinação é possível dizer para o depurador como interpretar determinados tipos de objetos. Ele já vem obviamente pronto para std::string, CString (ATL) e deveria vir com QString, de tão famosa que é. Mas a versão do Visual Studio 2015 não vem. O jeito então é editar diretamente o arquivo onde ficam esses padrões.&lt;/p&gt;
&lt;p&gt;O nome do arquivo é autoexp.dat e ele fica em uma pasta no estilo Program Files, Microsoft Visual Studio, Common7, Packages, Debugger. É melhor você retirar ele dessa pasta antes de sobrescrevê-lo para não ter erro de acesso. Ao abri-lo verá que no começo há vários comentários que explicam como é o funcionamento desse padrão.&lt;/p&gt;
&lt;p&gt;Felizmente (e também obviamente) o pessoal do Qt já fez uma entrada na wiki que explica como fazer para interpretar corretamente uma QString. Eles mesmos admitem que a coisa ficou difícil desde a última versão (Qt 5), mas ainda assim é possível. E, se tudo falhar, ainda é possível usar a janela de Watch:&lt;/p&gt;
&lt;p&gt;Mas não foi o caso dessa vez. Tudo funcionou perfeitamente assim que incluí os valores da Wiki logo no começo da sessão Visualizer.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Palestra: como criar moedas digitais em casa com C&#43;&#43; (kick-off)</title>
  <link>http://www.caloni.com.br/palestra-como-criar-moedas-digitais-em-casa-com-cpp-kick-off/</link>
  <pubDate>2017-02-19</pubDate>
  
  <guid>http://www.caloni.com.br/palestra-como-criar-moedas-digitais-em-casa-com-cpp-kick-off/</guid>
  <description>&lt;p&gt;Esta palestra tem como objetivo ensinar o que são moedas digitais, como o bitcoin, e cada passo necessário o algoritmo e implementação para torná-la real. Será utilizado C++ como a linguagem-base e o foco está mais na implementação do que na matemática ou no algoritmo. Assim como foi criado o bitcoin, o importante a aprender é como unir diferentes tipos de conhecimento e tecnologia em torno de um objetivo único, simples e prático.&lt;/p&gt;
&lt;p&gt;A partir da criação da moeda surge a necessidade de facilitar o seu uso, um problema recorrente em todas as mais de 700 moedas digitais existentes no mercado e no laboratório, incluindo o bitcoin. Após a palestra teremos uma discussão de como levar a tecnologia ao usuário comum.&lt;/p&gt;
&lt;p&gt;Para nossa moeda digital utilizaremos um sistema simples, rápido e prático para subir informações na memória de um nó (server) e repassar essas informações para outros nós, o tiodb. Este projeto mantém contêineres STL na memória da maneira mais enxuta possível e eles são acessíveis através do protocolo mais simples possível utilizando uma gama de linguagens (C, C++, Python, .NET).&lt;/p&gt;
&lt;p&gt;A primeira coisa é compilar o projeto tiodb, que irá disponibilizar alguns binários em sua saída:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;tio.exe&lt;/strong&gt; é o executável central cuja instância mantém contêineres na memória;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;InteliHubExplorer.exe&lt;/strong&gt; é uma interface simples para navegar por esses contêineres;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tioclient.dll&lt;/strong&gt; é a biblioteca dinâmica que pode ser usada por clientes para acessar o tio.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Podemos rodar o tio deixando ele usar os parâmetros padrão ou alterar número da porta e outros detalhes. Vamos executar da maneira mais simples:&lt;/p&gt;
&lt;p&gt;OK, tio rodando e ativo. Podemos navegar já pelos seus contêineres usando o InteliHubExplorer:&lt;/p&gt;
&lt;p&gt;Por convenção os contêineres seguem um padrão de nomes que se assemelha a uma hierarquia de diretórios, e os nomes que começam com underline são internos/reservados. O contêiner meta/sessions, por exemplo, contém uma lista simples das conexões ativas deste nó.&lt;/p&gt;
&lt;p&gt;A partir do servidor funcionando é possível criar novos contêineres e mantê-los, adicionando, atualizando e removendo itens. A partir dessas modificações outros clientes podem receber notícias dessas modificações e tomar suas próprias decisões.&lt;/p&gt;
&lt;p&gt;Vamos criar e popular um contêiner inicial de transações com  um GUID zerado, e a partir dele vamos adicionando novas &amp;quot;transações&amp;quot;. Também iremos permitir o monitoramento dessas transações.&lt;/p&gt;
&lt;p&gt;Após executar esse código passando o argumento &amp;quot;--build&amp;quot; e atualizarmos o IntelihubExplorer poderemos ver o novo contêiner e seu conteúdo. É possível ler o código rodando o mesmo programa sem passar o argumento &amp;quot;--build&amp;quot;.&lt;/p&gt;
&lt;p&gt;Agora imagine que exista um cliente da tiocoin que está monitorando as transações deste servidor para verificar a partir de qual momento uma transação foi aceita (supondo que este contêiner possui as transações aceitas):&lt;/p&gt;
&lt;p&gt;Voilà! Agora temos um sistema inicial com um contêiner que irá manter os IDs de supostas transações de nossa moeda digital. Está compilando e está rodando, e em cima disso poderemos ir adicionando as funcionalidades.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Convertendo Windows de UEFI para MBR</title>
  <link>http://www.caloni.com.br/convertendo-windows-de-uefi-para-mbr/</link>
  <pubDate>2017-02-13</pubDate>
  
  <guid>http://www.caloni.com.br/convertendo-windows-de-uefi-para-mbr/</guid>
  <description>&lt;p&gt;Quando você pesquisa sobre isso no Google o que mais encontra é ferramentas &amp;quot;gratuitas&amp;quot; que prometem fazer a conversão ou algo do gênero. No entanto, há um procedimento simples em que o próprio Windows pode corrigir os problemas oriundos da conversão do boot UEFI/GPT. Depois, é claro, que você usar uma outra ferramenta esperta open-source =)&lt;/p&gt;
&lt;p&gt;Entre as diferentes distros do Linux há uma chamada SystemRescueCD que é cheia dos paranauê para manutenção de micros. Entre eles há uma ferramenta chamada testdisk que tem a &amp;quot;proeza&amp;quot; de sair buscando partições perdidas e reescrever o MBR (seja o código ou a tabela de partições). É uma ferramenta simples, interativa e ágil. É ela que deve ser usada para resgatar as partições da máquina após configurar a BIOS para voltar a bootar no modo legacy.&lt;/p&gt;
&lt;p&gt;Depois de feita essa manipulação é a vez do CD do Windows, que deverá estar em mãos porque o Windows simplesmente não irá mais bootar. A instalação feita através do modo UEFI não instala o BOOTMGR, o gerenciador de boots do Windows. Isso porque ele não é usado, já que é a partição UEFI que se torna responsável por gerenciar o boot dos SOs presentes.&lt;/p&gt;
&lt;p&gt;Mas isso não significa que essa instalação do Windows está perdida. Através de dois boots com o CD, ambos escolhendo o modo de restauração (Repair e Repair at Startup) é possível fazer com que o Windows ache o problema (o bootmgr faltando) e &amp;quot;conserte&amp;quot; a instalação.&lt;/p&gt;
&lt;p&gt;No primeiro boot o Windows irá achar um problema inicial na própria instalação, no segundo boot ele já encontra a instalação. E, acreditem só, ele descobre que o BOOTMGR está faltando!&lt;/p&gt;
&lt;p&gt;E a partir daí a partição UEFI se torna inútil, embora ainda exista no início do HD, já que o boot legacy usa o velho esquema de usar o código da MBR e a partir daí chamar a partição ativa, que agora será a Windows.&lt;/p&gt;
&lt;p&gt;Essa manipulação do boot pode dar algum trabalho, mas é gratuita e com todos os passos devidamente documentados. E não há mágica: reconstrução da MBR seguido de restauração de um SO pré-existente (Windows, no caso).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>UEFI: dê adeus à MBR</title>
  <link>http://www.caloni.com.br/uefi-de-adeus-a-mbr/</link>
  <pubDate>2017-02-09</pubDate>
  
  <guid>http://www.caloni.com.br/uefi-de-adeus-a-mbr/</guid>
  <description>&lt;p&gt;Após depurar a BIOS e a MBR, eis que surge a UEFI: os GUIDs para SOs instalados no seu HD. Quantas siglas, não é mesmo?&lt;/p&gt;
&lt;p&gt;A BIOS (Basic Input/Output System, Sistema Básico de Entrada e Saída) é o sistema-base que se comunica com o hardware diretamente e faz a ponte entre várias interrupções e o sistema operacional (se houver um). Uma das funções iniciais da BIOS era encontrar qual a MBR (Master Boot Record, Registro do Boot Mestre) válida para entregar o controle de um pedaço de código de 512 bytes (um pouco menos) cuja função clássica era procurar em uma tabela de quatro entradas dentro dela mesma qual o SO que está ativo. A partir daí o código da MBR passava o controle para a MBR da partição ativa, que deveria conter o bootstrap do sistema operacional (naquela época bootstrap significava outra coisa).&lt;/p&gt;
&lt;p&gt;Isso gerava várias confusões em um sistema multi-SO, algo que começou a se tornar constante depois que o Linux e o Windows de verdade (NT) veio à tona, com gerenciadores de boot no próprio SO que possibilitava que o Windows 98 conseguisse pular seu controle para um Windows NT ou 2000 e também para um Conectiva Linux. Quando as coisas davam errado era só pegar o CD de instalação de um desses e começar tudo de novo.&lt;/p&gt;
&lt;p&gt;Ou usar o Disk Editor, a famigerada ferramenta do Norton que já salvou a vida de muitos computadores aí afora. Eu me incluo na lista de salvadores durante o tempo que fiz a manutenção de um sistema de criptografia de HD. Usar o Disk Editor era basicamente navegar pelos bytes iniciais do HD principal para encontrar qual lógica do boot estava errada. Poderia ser um erro na tabela de partições ou um modo de endereçamento que não suportava partições muito longe do início (a tabela de partições era bem limitada; abaixo ela está selecionada).&lt;/p&gt;
&lt;p&gt;Com a UEFI (Unified Extensible Firmware Interface, Inteface de Firmware Extendido Unificado) a MBR e seus 500 bytes perdem sua vez e no lugar surge uma partição inteira, onde os SOs são organizados não por tipos de entrada, mas por GUIDs únicos (números muito grandes que em teoria não são repetidos nunca). Não há mais a chance de modificar os bytes iniciais do boot para poder realizar alguma manipulação mágica, como gerenciar os diferentes SOs. A UEFI foi feita para isso, e não apenas para SOs locais, mas qualquer tipo de extensão de firmware (o código que reside direto no hardware e manipula correntes e leds). Note como a tabela de partições em um ambiente EFI não possui entradas válidas, e o setor logo em seguida é o início de sua partição.&lt;/p&gt;
&lt;p&gt;A UEFI diz que há suporte ao modo antigo MBR. Isso é feito mantendo o primeiro setor disponível para escrita. Uma conversão possível seria editar a tabela de partições inserindo onde está a partição de um SO e inserindo um código padrão do MBR no lugar. A mudança do tipo de boot pode ser feito na BIOS (é o modo legado), mas se for trocada ela usará a MBR para bootar, então é necessário que ela esteja funcionando.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Pacotes perdidos do NuGet em projetos C&#43;&#43; no Visual Studio</title>
  <link>http://www.caloni.com.br/pacotes-perdidos-nuget-em-projetos-cpp-no-visual-studio/</link>
  <pubDate>2017-02-08</pubDate>
  
  <guid>http://www.caloni.com.br/pacotes-perdidos-nuget-em-projetos-cpp-no-visual-studio/</guid>
  <description>&lt;p&gt;É muito bom (para quem gosta) usar a IDE e viver feliz sem precisar se preocupar em digitar comandos estranhos no prompt. Porém, essa vida acaba quando ocorre o primeiro erro inexplicável, aquele tipo de erro que não importa onde você olhe, não há nada para olhar. Até você apelar para ferramentas de macho.&lt;/p&gt;
&lt;p&gt;Que nem hoje de manhã, quando fui inocentemente baixar uma versão limpa do tiodb e após baixar todos os pacotes do NuGet, o gerenciador de pacotes do Visual Studio (inclusive para C++, agora) acusou a falta do boost, sendo que ele havia acabado de baixá-lo.&lt;/p&gt;
&lt;p&gt;Os pacotes do projeto ficam todos na raiz do diretório da solução na sub-pasta packages. Observando o que foi baixado lá, verifiquei que a versão do boost estava ok: ele havia baixado a 1.61 como pedido, mas o erro dizia respeito justamente a um desses pacotes.&lt;/p&gt;
&lt;p&gt;O maior problema disso é que não há muitas opções na IDE que resolvam. O arquivo packages.config deveria manter essas dependências, o que de fato ele faz. As opções do projeto (as abinhas do Visual Studio onde ficam as configurações) não possuem nada relacionado ao NuGet.&lt;/p&gt;
&lt;p&gt;Então não tem jeito. Há algo de podre dentro desse projeto e o próprio Visual Studio não vai resolver. Grep nele!&lt;/p&gt;
&lt;p&gt;Note (e é preciso prestar atenção!) que o projeto server/tio/tioserver.vcxproj referencia a pasta packages como se ela existisse dentro do projeto. Porém, como já sabemos, ela existe na raiz da solution, que fica duas pastas &amp;quot;para trás&amp;quot;. Isso nos indica que talvez o NuGet ainda não esteja tão redondo e que um possível teste é mudar esses valores na mão e ver o que acontece.&lt;/p&gt;
&lt;p&gt;Recarregado o projeto no Visual Studio após a intervenção cirúrgica, tudo voltou a funcionar. A lição de hoje é: nunca confie completamente em uma IDE. Às vezes o bom e velho grep e o bom e velho editor de sua escolha podem resolver uma situação.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Android protobuf, mock configurável</title>
  <link>http://www.caloni.com.br/android-protobuf-mock-configuravel/</link>
  <pubDate>2017-02-06</pubDate>
  
  <guid>http://www.caloni.com.br/android-protobuf-mock-configuravel/</guid>
  <description>&lt;p&gt;A comunicação oferecida pelo Protocol Buffers, uma maneira otimizada de codificar mensagens em alto nível, é uma das formas mais ideais de realizar a ponte entre cliente e servidor quando se fala de aplicativos mobile. A solução já suporta inúmeras linguagens, desde C++ (a linguagem oficial) até Java, passando por Python e .NET. Um mesmo arquivo de definição pode ser usado entre diferentes tipos de tecnologia. Este artigo mostra o caminho das pedras para compilar o protobuf para Android e de quebra mostra como é fácil fazer um mock de servidor local em uma configuração local com o gerenciador de builds do Android.&lt;/p&gt;
&lt;p&gt;Antes de tudo é preciso saber que estou usando Windows. Provavelmente as coisas são mais simples no Linux, mas fazer o quê. De qualquer forma, a estrutura mantida pelo projeto do Protobuf para Visual Studio é boa, e compilei sem problemas a solução.&lt;/p&gt;
&lt;p&gt;Mas, você deve estar se perguntando: se é para Android, por que C++? Bom, uma vez que você baixou os fontes do protobuf é necessário gerar o compilador. Você poderia baixar um binário compilado, mas usar direto dos fontes garante que os unit tests estão todos alinhados e que não haverão problemas de versão.&lt;/p&gt;
&lt;p&gt;Os guias contidos nos READMEs espalhados pelo fonte, começando pelo primeiro exigido na página do GitHub, são muito bem explicados. Não deve ser nenhum problema segui-los, desde que se atente em colocar os caminhos necessários no path, como a localização do JDK (que pode ser o que vem no Android Studio, mesmo) e abrir um prompt com as variáveis de ambiente para a compilação via Visual Studio. Eu recomendo baixar uma versão estável entre as releases, e pode já baixar a 3 em diante, que contém um monte de features novas e legais.&lt;/p&gt;
&lt;p&gt;Depois de compilar o protoc e colocá-lo no devido lugar, há uma questão importante: a versão em Java usa um gerenciador de build do Apache que funciona muito naquelas para Windows, dando erro nos testes e na instalação. Minha solução foi simplesmente usar a segunda opção descrita no README: compilar o Descriptor.proto e com ele gerar todos os .java necessários para sua compilação. Com isso fica até mais simples montar no projeto Android uma solução mais enxuta, apenas com as classes necessárias (no meu caso, pelo menos o JsonFormat e dependências).&lt;/p&gt;
&lt;p&gt;A grande vantagem do Android Studio é que ele já escaneia os diretórios do projeto, sendo apenas necessário copiar os fontes e ele já integra no projeto. A partir daí os imports funcionam e ele compila tudo junto. Resolvido.&lt;/p&gt;
&lt;p&gt;Para a parte do mock eu recomendo usar o sistema de variáveis do Gradle. Ele mantém uma lista de variáveis em um formato específico no arquivo app/build.gradle:&lt;/p&gt;
&lt;p&gt;Você pode jogar direto o valor que deseja, mas há uma solução ainda mais elegante que usa um arquivo apartado chamado local.properties, onde é ideal não jogar no controle de fonte, e de onde todo desenvolvedor pode customizar. No caso de ServerMockData, ele pode ser um json com sua mensagem protobuf já certinha para uso, como se esses fossem os dados do server:&lt;/p&gt;
&lt;p&gt;Isso pode estar errado (parênteses demais), mas você entendeu a ideia. É possível jogar um json nesse arquivo e depois o Android e o Gradle irão jogá-lo diretament em uma classe estática, a BuildConfig:&lt;/p&gt;
&lt;p&gt;A partir dessa string é possível obter rapidamente a mensagem equivalente:&lt;/p&gt;
&lt;p&gt;DICA: O Android Studio tem um botão esperto em sua interface onde, depois de alterado o local.properties, é possível refazer o BuildConfig.&lt;/p&gt;
&lt;p&gt;E com isso podemos ter o protocol buffers e um sistema de mock simples e prático para a depuração e testes locais com nosso app que vai revolucionar o mundo =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Um commit por feature</title>
  <link>http://www.caloni.com.br/um-commit-por-feature/</link>
  <pubDate>2017-02-04</pubDate>
  
  <guid>http://www.caloni.com.br/um-commit-por-feature/</guid>
  <description>&lt;p&gt;Imagine que você vai começar a trabalhar em algo novo. Daí você baixa a última versão do branch de dev e começa a codar. Então chega um momento em que o primeiro, segundo, terceiro commits são necessários para manter a ordem em sua cabeça. &amp;quot;Fiz isso logo de manhã, testei algo diferente antes do almoço e de tarde fui incrementando a solução final até passar todos os testes.&amp;quot; Tudo bonito. Mas como fica na hora de subir essa bagaça pras pessoas verem?&lt;/p&gt;
&lt;p&gt;Vamos visualizar isso em commits. Você baixa a última versão do dev, começa a trabalhar e de duas uma:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Percebe que dá para resolver tudo em um commit só.&lt;/li&gt;
&lt;li&gt;Percebe que o buraco é mais embaixo; vou precisar de mais tempo e mais commits.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;No caso 1, a solução é simples e direta: faça as modificações, rode os testes locais e aplique o commit já no formato definido pela sua equipe (número do ticket, texto no idioma correto, detalhes nos parágrafos abaixo). Suba e mande para code review.&lt;/p&gt;
&lt;p&gt;Se a política de pull request estiver sendo usada, faça isso em um branch à parte, mas já mande para o reviewer aprovar o branch como se fosse um commit apenas e de preferência pronto para o rebase (o que não deve ser nem um problema se for uma mudança pontual).&lt;/p&gt;
&lt;p&gt;Quando mais de um commit é necessário é porque vai rolar a festa. Vários commits com texto e modificações temporárias podem ser feitos, e caso o trabalho vire a noite, é recomendado subir tudo para um branch temporário remoto (de preferência que já seja identificado pela equipe como o branch para determinado issue).&lt;/p&gt;
&lt;p&gt;Agora nós criamos uma bela duma bagunça, mas em um branch apartado e que ainda não foi enviado para pull requet ou inserido no branch de dev. Agora chega a hora de arrumar a casa. Para isso, como tudo no git, há várias maneiras, mas a mais direta é um rebase interativo (-i), onde você pega os commits e empacota tudo junto.&lt;/p&gt;
&lt;p&gt;(Obs.: se sua modificação demorou algum tempo é melhor atualizar o branch de dev para ver se há algo novo e fazer o merge com o branch de feature; o rebase daí não encontrará conflitos.)&lt;/p&gt;
&lt;p&gt;Nesse momento o git irá abrir o editor com os commits trabalhados. Você deverá escolher quais operações fazer com cada commit. Se o objetivo é empacotar tudo, geralmente é pick no primeiro e squash em todos os outros:&lt;/p&gt;
&lt;p&gt;Ao final da operação mais uma vez o git irá exibir o editor. Agora é hora de você escolher o texto bonitinho, formatadinho, do seu único commit que será usado no branch de dev. Em outras palavras, transformar isso:&lt;/p&gt;
&lt;p&gt;Nisso:&lt;/p&gt;
&lt;p&gt;Agora na hora de fazer o merge seu histórico estará redondo, sem ramificações e com o resultado final de seu hacking parecendo que foi feito bonito desde o começo (ah, vá):&lt;/p&gt;
&lt;p&gt;Esta é uma das inúmeras formas de trabalhar com o git de maneira individual sem atrapalhar seus colegas. Basicamente você pode escolher outras estratégias de commits e branchs locais, mas através do comando rebase -i é possível sempre reorganizar a bagunça em commits comportados, e dar a impressão que esses programadores são enviados divinos que modificam o fonte e acertam de primeira.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Warning de nível 4</title>
  <link>http://www.caloni.com.br/warning-de-nivel-4/</link>
  <pubDate>2017-01-17</pubDate>
  
  <guid>http://www.caloni.com.br/warning-de-nivel-4/</guid>
  <description>&lt;p&gt;Você já colocou aquele seu projeto favorito em /W4? Por padrão, o Visual Studio cria seus projetos com o nível de warnings e 3, porque o nível 4 é muito, muito chato. No entanto, algumas vezes ele serve para que seu código não fique apenas correto, mas bem documentado e apresentável. Vamos tentar?&lt;/p&gt;
&lt;p&gt;OK, este foi o nível 3 do tioserver, o projeto principal do tiodb, uma ferramenta para manter contêineres assináveis na memória e acessíveis via socket. Note que já existe um warning, mas vamos ignorar por enquanto. O objetivo aqui é descobrir quais os warnings mais comuns do projeto que você vai escolher. Vejamos o meu:&lt;/p&gt;
&lt;p&gt;Vamos ordenar e capturar apenas o código desses warnings para ver quantos ocorrem e quais os mais comuns:&lt;/p&gt;
&lt;p&gt;E a resposta é:&lt;/p&gt;
&lt;p&gt;Apenas quatro. Tão comuns que a maioria está até em ordem numérica e diz respeito a repetição de nomes em escopos diferentes, o que esconde os nomes do escopo anterior, mais amplo. O outro, o C4701, pode ser mais problemático, já que ele representa uma variável que potencialmente não foi inicializada, fonte comum daqueles erros de &amp;quot;como é que essa variável virou isso?&amp;quot;.&lt;/p&gt;
&lt;p&gt;Felizmente só temos em um ponto do código:&lt;/p&gt;
&lt;p&gt;A correção é simples: inicialize a droga das suas variáveis zero (ou determine qual o comportamento no caso else).&lt;/p&gt;
&lt;p&gt;Vamos dar uma olhada em um dos outros warnings:&lt;/p&gt;
&lt;p&gt;OK, isso é meio feio. A variável handle tinha acabado de ser criada logo antes da entrada do if. A não ser que sejam de fato variáveis distintas no código (apenas analisando a função inteira) elas poderiam ser reaproveitadas em apenas uma (até porque possuem o mesmo tipo). E se forem variáveis distintas... bem, coloque nomes distintos =)&lt;/p&gt;
&lt;p&gt;E aqui termina mais uma sessão de &amp;quot;e se eu abrir mais os warnings do meu código&amp;quot;. Espero que tenha aproveitado.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>ReadFile assíncrono pode ser síncrono quando você menos espera</title>
  <link>http://www.caloni.com.br/readfile-assincrono-pode-ser-sincrono-quando-voce-menos-espera/</link>
  <pubDate>2017-01-16</pubDate>
  
  <guid>http://www.caloni.com.br/readfile-assincrono-pode-ser-sincrono-quando-voce-menos-espera/</guid>
  <description>&lt;p&gt;Ano passado tive alguns problemas em um projeto que se comunicava com um dispositivo em firmware pela USB. Estávamos utilizando uma biblioteca open source do GitHub que parecia estar bem testada e mantida. Porém, não exatamente para nossos objetivos.&lt;/p&gt;
&lt;p&gt;O problema da lib hidapi era que a comunicação usb era feita de forma assíncrona. Isso no Windows é feito com a mesma função de I/O (ReadFile/WriteFile) só que passando um argumento opcional chamado de overlapped. Esse argumento é um ponteiro para uma estrutura que irá ser preenchida assim que o I/O for concluído. E quando é isso? Deve-se esperar pelo handle ser sinalizado (em outras palavras, dando um Sleep ou WaitForSingleObject neste handle).&lt;/p&gt;
&lt;p&gt;O funcionamento padrão via overlapped é bem simples: faça a operação de I/O (passando a estrutura) e verifique o retorno. Ele deve ser FALSE e o retorno do próximo GetLastError deve ser ERRORIOPENDING. Bom, descrevendo a operação ela não parece ser tão intuitiva. Mas funciona:&lt;/p&gt;
&lt;p&gt;A questão que nós encontramos nesse projeto apenas aconteceu porque após a operação de I/O assíncrona a thread responsável por retornar o resultado ficava em wait eterno ou dava timeout. Ambas as situações são normais e esperadas. Ficar aguardando para sempre um device acontece quando este simplesmente não responde com nenhum dado. E dar timeout acontece quando não queremos aguardar o device para sempre (WaitForSingleObject(handle, 1000), por exemplo, daria timeout depois de 1 segundo, ou 1000 milissegundos).&lt;/p&gt;
&lt;p&gt;O motivo da thread nunca retornar (ou dar timeout), porém, não estava em nenhuma dessas situações. Ao monitorar o tráfego usb se verificou que o device respondia em tempo hábil. O problema estava mais embaixo (ou mais em cima): a hidapi não se comportava conforme o MSDN mandava. Há uma situação não-mapeada nessa lib.&lt;/p&gt;
&lt;p&gt;Erros ao chamar a API do Win32 são comuns exatamente porque esta é uma lib arcaica, pouco intuitiva com diferentes tipos de exceções. No caso de uma operação assíncrona com overlapped, se você ler as tantas páginas da função ReadFile, por exemplo, vai acabar encontrando um adendo escondido no meio da documentação:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Synchronization and File Position If hFile is opened with FILE_FLAG_OVERLAPPED, it is an asynchronous file handle; otherwise it is synchronous. The rules for using the OVERLAPPED structure are slightly different for each, as previously noted. Note  If a file or device is opened for asynchronous I/O, subsequent calls to functions such as ReadFile using that handle generally return immediately, but can also behave synchronously with respect to blocked execution. For more information see &lt;a href=&#34;http://support.microsoft.com/kb/156932&#34;&gt;http://support.microsoft.com/kb/156932&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Este adendo possui a informação que ninguém ainda sabia porque... porque Microsoft.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If, on the other hand, an operation is completed immediately, then &amp;amp;NumberOfBytesRead passed into ReadFile is valid for the number of bytes read. In this case, ignore the OVERLAPPED structure passed into ReadFile; do not use it with GetOverlappedResult or WaitForSingleObject.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ou seja, em caso da função ReadFile (ou WriteFile) retornar TRUE em uma operação assíncrona/overlapped, isso quer dizer que a operação foi concluída com sucesso de forma síncrona, não sendo necessário aguardar o I/O ser concluído. Na verdade, é um pouco mais específico: o WaitForSingleObject não deve ser chamado. No nosso caso, ao chamá-lo, criávamos uma espera eterna, já que o I/O não seria mais sinalizado (porque deveria? a operação já foi concluída!).&lt;/p&gt;
&lt;p&gt;Uma colinha da M$ de como deve ser feito o tratamento:&lt;/p&gt;
&lt;p&gt;Após essa correção no projeto as coisas começaram a funcionar normalmente.&lt;/p&gt;
&lt;p&gt;A BitForge fez a alteração em um fork próprio da hidapi e enviou o pull request para os mantenedores oficiais da hidapi, a signal11. Esta é mais uma lição de que, em se tratando de I/O, as coisas difíceis que o kernel às vezes faz lá embaixo acabam refletindo aqui em cima. Às vezes até na própria API!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Entrando na zona com Vim</title>
  <link>http://www.caloni.com.br/entrando-na-zona-com-vim/</link>
  <pubDate>2017-01-05</pubDate>
  
  <guid>http://www.caloni.com.br/entrando-na-zona-com-vim/</guid>
  <description>&lt;p&gt;Se você é programador é bem provável que já tenha ouvido falar em [Flow] &lt;a href=&#34;https://en.wikipedia.org/wiki/Flow(psychology)&#34;&gt;1&lt;/a&gt; ou [The Zone] &lt;a href=&#34;https://hn.algolia.com/?query=the%20zone&#34;&gt;2&lt;/a&gt;. Se for leitor assíduo do Hacker News, então, nem se fala. De qualquer forma, uma das maneira mais produtivas do programador programar é entrar na famosa &amp;quot;zona&amp;quot;. É lá que muito de nós nascemos. Lembra a primeira vez que mexeu em um computador ou afim e ficou tão obcecado que não viu o tempo passar? Pois bem. Você esteve na zona. E estar nela é um bom lugar para trabalhar.&lt;/p&gt;
&lt;p&gt;Na zona, principalmente resolvendo problemas complexos, o importante é poder construir uma estrutura em sua mente com a ajuda de alguns aparatos, como um caderno de anotações, stickers, lousa ou seu editor preferido. Meu editor preferido para navegar (flow) por um código é sem sombra de dúvida o Vim, pois ele é apenas uma tela que preenche todo meu campo de visão e possui comandos em que eu consigo facilmente acessar o conteúdo que preciso relembrar. Quando estou obtendo o diagnóstico de um log, por exemplo, posso rapidamente ir construindo um modelo mental da solução navegando entre arquivos de log e código-fonte através de tags e buscas em regex.&lt;/p&gt;
&lt;p&gt;A primeira vantagem do Vim em relação a outros editores é sua capacidade de abrir arquivos grandes. Um log de 1GB pode ser um desafio para um Notepad da vida, e até para um Visual Studio, mas no Vim tudo que você precisa é de memória disponível. E mesmo que não tenha, o Windows se vira bem no gerenciamento de swap (ou Linux, tanto faz).&lt;/p&gt;
&lt;p&gt;Para navegar no código, existem duas técnicas que não necessitam de nenhum plugin. A primeira é a busca por regex, que pode ser feita com os comandos :vimgrep ou :grep, sendo que o primeiro busca em um padrão de arquivos (usando wildcard) e o segundo dentro dos buffers já abertos (útil se você já tiver uma sessão ativa; mais sobre isso depois).&lt;/p&gt;
&lt;p&gt;O bom é que, no caso de logs, se você buscar por expressões unívocas, isso já fica no histórico de seus comandos e você pode usar quando quiser para voltar para esses logs (ou se você for maluco e guardar de cabeça seus marks, pode criar um mark de vez).&lt;/p&gt;
&lt;p&gt;A segunda técnica de navegar no código é através das tags que são montadas pela ferramenta ctags. Ela é genérica o suficiente para suportar várias linguagens, mas pode ser usada até para qualquer sequência de palavras. Há plugins que realizam essa varredura do fonte automática, mas particularmente não gosto de encher meu Vim de plugins, sendo que o único que uso que me lembro é o MRU (porque o Vim ainda não suporta algo do gênero internamente). De qualquer forma, tudo que eu preciso fazer para atualizar as tags de um projeto é abrir o readme do projeto (que geralmente fica na pasta raiz) e rodar meu atalho.&lt;/p&gt;
&lt;p&gt;Isso vai gerar um arquivo ctags na pasta do projeto que será usada automaticamente para procurar pelas tags que eu preciso. O pulo do gato na verdade é o ponto-e-vírgula após o nome do arquivo ao setar a variável tags. Isso faz com que o Vim não busque apenas o arquivo tags na pasta atual, mas em toda hierarquia. Então se você estiver na pasta Projects\SomeProject\Folder1\Folder2\Folder3\File.cpp e tiver gerado o arquivo tags na pasta SomeProject para todo o projeto, ao usar o comando de busca de tag ele eventualmente vai abrir esse arquivo tags, pois ele vai procurando em Folder3, Folder2, Folder1 e cai em SomeProject.&lt;/p&gt;
&lt;p&gt;Como no Windows o atalho padrão do comando tag do Vim não funciona também preciso fazer uma pequena adaptação técnica (e de quebra já uso para navegar nos próximos resultados):&lt;/p&gt;
&lt;p&gt;Depois de dar uma olhada no log, encontrar os métodos que você precisa analisar, seu fluxo, etc, você terá um monte de buffers relevantes abertos nas linhas relevantes. Seria muito bom se tudo isso pudesse ser guardado em um estado para que você continue amanhã ou em sua próxima sessão de flow. Para isso existe o comando :mksession.&lt;/p&gt;
&lt;p&gt;O comando :source roda um script vim que possui comandos guardados. Ele é um arquivo texto semelhante ao vimrc.&lt;/p&gt;
&lt;p&gt;Basicamente é isso. Tudo o que você precisa em sua análise de fonte e de log se encontra na ponta de seus dedos. Não é necessário abrir nenhuma pasta nem terminal. Simplesmente navegue através do Vim para descobrir o problema e seja feliz em sua zona.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Vídeo: Usando clang no Visual Studio</title>
  <link>http://www.caloni.com.br/video-usando-clang-no-visual-studio/</link>
  <pubDate>2016-12-27</pubDate>
  
  <guid>http://www.caloni.com.br/video-usando-clang-no-visual-studio/</guid>
  <description>&lt;p&gt;Com o surgimento da infraestrutura LLVM, que possibilita a união entre diferentes ferramentas que suportam diferentes plataformas para o desenvolvimento de software, e o clang, um font-end para C/C++ que roda não só em UNIXes da vida, como também no Windows, como também no Visual Studio, tem sido uma vantagem para projetos que usam as novas features do C++ moderno, muitas ainda não implementadas no compilador da Microsoft, unir o útil (Visual Studio) ao agradável (C++ modernos via clang). Este vídeo tem como objetivo demonstrar como essa união é simples e fácil de ser realizada dentro do próprio Visual Studio. De quebra, vamos descobrir alguns problemas que podem ocorrer nessa união de toolsets e como corrigir.&lt;/p&gt;
&lt;p&gt;Este é um guia bem básico, mas atende os requisitos de quem quer começar a mexer com essas duas tecnologias (além de aficionados pelo novo C++ que está em desenvolvimento, mas não abre mão de uma IDE tão poderosa quanto o Visual Studio):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Criar um novo projeto clang no Visual Studio.&lt;/li&gt;
&lt;li&gt;Utilizar o projeto com um Console Win32 padrão e toolset Visual Studio.&lt;/li&gt;
&lt;li&gt;Implementar uma feature ainda não suportada pelo Visual Studio.&lt;/li&gt;
&lt;li&gt;Utilizar essa feature no Console Win32.&lt;/li&gt;
&lt;li&gt;Corrigir e entender problemas no meio do caminho.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/embed/dMY91ojS0tw&#34;&gt;https://www.youtube.com/embed/dMY91ojS0tw&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CLang&lt;/li&gt;
&lt;li&gt;LLVM&lt;/li&gt;
&lt;li&gt;C++ compiler support&lt;/li&gt;
&lt;li&gt;Fold expression&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>A Linguagem de Programação C&#43;&#43;: O Início</title>
  <link>http://www.caloni.com.br/a-linguagem-de-programacao-cpp-o-inicio/</link>
  <pubDate>2016-11-29</pubDate>
  
  <guid>http://www.caloni.com.br/a-linguagem-de-programacao-cpp-o-inicio/</guid>
  <description>&lt;p&gt;O livro-base sobre a linguagem C++ e como programar nela tem o nome pouco criativo &amp;quot;The C++ Programming Language&amp;quot;, e é de Bjarne Stroustrup, o criador da linguagem. Ele começou a desenhar a linguagem em 1979, quando ainda a chamada de &amp;quot;C com Classes&amp;quot;. Havia um problema a ser resolvido na época em que Stroustrup estava fazendo sua tese de doutorado. Havia linguagens muito boas em abstração como Simula -- como o novo conceito de Orientação a Objetos -- que carecia do mais importante na época: velocidade (só na época?). Já linguagens mais antigas como BCPL eram bem rápidas, mas eram tão simples que pareciam mais um Assembly glorificado. Havia, portanto, a necessidade de preencher a área de computação com alguma coisa bem no meio.&lt;/p&gt;
&lt;p&gt;Stroustrup não fez tudo do zero, nem fez tudo de uma vez. A primeira necessidade era apenas criar uma abstração já existente na linguagem C, mas que ainda não havia sido integrada à sintaxe: o contexto de uma estrutura, que se assemelha a uma proto-classe, ou para alguns já é até uma classe, pois possui membros e métodos:&lt;/p&gt;
&lt;p&gt;A grande sacada é que no meio de toda essa sintaxe de chamada de método havia a passagem de um parâmetro escondido, o this, que se referia à uma instância específica da classe: um objeto.&lt;/p&gt;
&lt;p&gt;Isso equivaleria a uma struct em C com funções que recebessem um this adaptado:&lt;/p&gt;
&lt;p&gt;Esse tipo de abstração nem é tão complicada assim. O ojetivo eram vários: conseguir proteger os membros de acesso indevido, abstrair o comportamento de um objeto. Com o tempo Stroustrup foi realmente criando algo de novo e muito mais difícil de se manter em C.&lt;/p&gt;
&lt;p&gt;Algo para um próximo post =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Quantos handles sua aplicação está abrindo?</title>
  <link>http://www.caloni.com.br/quantos-handles/</link>
  <pubDate>2016-11-29</pubDate>
  
  <guid>http://www.caloni.com.br/quantos-handles/</guid>
  <description>&lt;p&gt;Mesmo que você não programe em C/C++, mas programe para Windows (ex: .NET), sempre há a possibilidade de seu programa estar causando leaks de handles indefinidamente, o que não se traduz em aumento significativo de memória alocada para seu processo, mas é, sim, um problema a ser tratado.&lt;/p&gt;
&lt;p&gt;Como isso pode ser causado? Bom, em C/C++ sempre é mais simples de entender esses conceitos. Um código simples que se esquece de fechar o handle usando CloseHandle ou a função equivalente do recurso obtido já seria o suficiente. O último bug que eu encontrei em um código desses comete o clássico erro de sair no meio da função, deixando os recursos alocados:&lt;/p&gt;
&lt;p&gt;No exemplo acima quando as coisas dão certo elas também dão errado, já que o retorno do valor no meio da função evita que o HANDLE armazenado em hKey seja desalocado.&lt;/p&gt;
&lt;p&gt;E como fazer para descobrir esse tipo de leak?&lt;/p&gt;
&lt;p&gt;O HandleLeaker é apenas um exemplo de aplicação que realiza o leak de um handle por segundo. Ele tenta (e consegue) abrir um handle para seu próprio processo, e deixa o handle aberto (programas em Win32 API não são muito bons em RAII).&lt;/p&gt;
&lt;p&gt;O Perfmon(.msc) está aí no Windows já faz algumas versões (quase todas). Tudo que você precisa para executá-lo é executar o comando perfmon no diálogo de execução (Start, Run) ou encontrar o atalho para perfmon.msc. Na busca do Windows 8/10 também é possível encontrá-lo pelo nome.&lt;/p&gt;
&lt;p&gt;Ao executá-lo a primeira coisa que ele monitora é o processamento da máquina. Podemos eliminar ou esconder esse indicador direto na lista abaixo da ferramenta.&lt;/p&gt;
&lt;p&gt;Existem incontáveis contadores no Perfmon. Para o que precisamos vamos em Process e escolhemos o contador de Handles.&lt;/p&gt;
&lt;p&gt;Depois de um tempo o Perfmon irá exibir o histórico que determina para onde está indo o seu contador.&lt;/p&gt;
&lt;p&gt;Se os valores do seu contador estão fora da faixa do histórico é possível ajustar a escala nas propriedades.&lt;/p&gt;
&lt;p&gt;Se a frequência for muito menor do que um handle por segundo (isso acontece, principalmente com serviços que rodam por dias/semanas/meses), é possível mudar também pelas propriedades, mas gerais.&lt;/p&gt;
&lt;p&gt;A mudança que fizemos captura o dado monitorado de dez em dez segundos e realiza essa operação por 600 segundos (10 minutos), até repetir o gráfico de histórico.&lt;/p&gt;
&lt;p&gt;Outra forma de verificar como andam os handles da máquina é usando a já famosa ferramenta da SysInternals. Através das inúmeras colunas que ela fornece existe o contador de handles de cada processo, através do qual é possível verificar quais são os processos com mais handles abertos.&lt;/p&gt;
&lt;p&gt;Se seu programa for um handle hog, vai conseguir até ver esse leak acontecendo em tempo real (como o nosso programa mal-educado).&lt;/p&gt;
&lt;p&gt;E como encontrar o código-fonte responsável por esse leak? Mais detalhes em um próximo post.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Guardando senhas com Vim</title>
  <link>http://www.caloni.com.br/guardando-senhas-com-vim/</link>
  <pubDate>2016-10-05</pubDate>
  
  <guid>http://www.caloni.com.br/guardando-senhas-com-vim/</guid>
  <description>&lt;p&gt;Eu já sabia que havia um sistema de criptografia de arquivos no Vim. Isso pode ser útil para textos secretos, ou para enviar qualquer bobagem para outra pessoa que sabe de uma senha que só vocês conhecem. Porém, o método default de criptografia dele não me animava. O pkzip é usa um algoritmo fraco, e os inúmeros programas que quebram zips encriptados estão aí para demonstrar. Além do mais, o blowfish da versão 7 do Vim tem problemas em gerar seu salt que favorece ataques de força bruta tão baratos quanto um XOR. E é aí que entra em cena o Vim 8.&lt;/p&gt;
&lt;p&gt;A nova versão do meu editor favorito não apresenta o defeito do algoritmo blowfish anterior, ou apresenta, mas dessa vez fornece uma versão atualizada (claro que, por razões de compatibilidade, foram mantidos os algoritmos anteriores).&lt;/p&gt;
&lt;p&gt;O que eu gosto no modelo do Vim de encriptar arquivos é que eles são encriptados apenas na escrita, e na leitura o usuário deve digitar a senha. Se a senha não correponder ao que foi usado para encriptá-lo, não há mensagem de erro: o editor irá simplesmente exibir o lixo gerado pela sua senha errada. Isso gera uma situação vantajosa e uma perigosa.&lt;/p&gt;
&lt;p&gt;A vantajosa é que não há como automatizar um brute force em cima de arquivos encriptados pelo Vim, pois não há muitos sinais de que o arquivo foi desencriptado. Claro, por amostragem de texto é possível saber se a senha foi ou não satisfatória, mas a beleza está em não existir nada específico na estrutura do editor que diga se a senha foi ou não bem sucedida.&lt;/p&gt;
&lt;p&gt;A perigosa é que uma vez que você digite a senha errada, muito cuidado com o lixo que você verá no seu buffer. Se por força do hábito for salvar o conteúdo, poderá perder o conteúdo do arquivo original, que estava encriptado com uma senha que você conhecia, mas que agora foi salvo após ter sido desencriptado com a senha errada. Ou seja, não há como reaver o conteúdo original a não ser com muito suor.&lt;/p&gt;
&lt;p&gt;O mais prático de tudo é usar esse modelo de arquivo encriptado pelo Vim para salvar senhas. Um arquivo de senhas pode ser tão simples quando login/senha de todas as senhas que você deseja guardar, e tão bem protegido quanto a força de sua senha master. Nada mais, nada menos. De quebra, um arquivo pequeno cujo backup pode ser sincronizado instantaneamente na nuvem (usando Google Drive, Dropbox ou One Drive), ou até mantido em um controle de fonte (embora ele seja tratado como binário).&lt;/p&gt;
&lt;p&gt;Se você gostou desse modelo, seguem os comandos para pesquisar (:help comando):&lt;/p&gt;
&lt;p&gt;Este post foi inspirado em meu próprio uso do Vim, mas mais inspirado ainda depois de ler o artigo da invert.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Usando GVim com projetos do Visual Studio</title>
  <link>http://www.caloni.com.br/usando-gvim-com-projetos-do-visual-studio/</link>
  <pubDate>2016-09-18</pubDate>
  
  <guid>http://www.caloni.com.br/usando-gvim-com-projetos-do-visual-studio/</guid>
  <description>&lt;p&gt;A vida dos programadores C/C++ Windows -- e que geralmente precisam do Visual Studio -- está um abandono total. A configuração de make dos projetos sempre foi baseada no uso de makefiles, assim como no Unix, e por isso mesmo o uso da ferramenta nmake do SDK do Windows era a maneira padrão de se compilar e ver o resultado de dentro do Vim para projetos Windows. Com o advento do .NET, do Visual Studio 2003 e dos XMLs disfarçados como arquivos de projeto e solution, o uso do makefile foi paulatinamente abandonado, gerando diferentes versões de ferramentas -- todas incompatíveis -- para conseguir compilar um ou mais cpps e conseguir ver o resultado.&lt;/p&gt;
&lt;p&gt;Por isso mesmo é um assunto pouco explorado nos fóruns do Stack Overflow como configurar decentemente o comando :make do Vim para conseguir realizar o ciclor program-compile-debug que já era feito desde a época do Amiga OS (e conhecido no manual do Vim como Quickfix). Ninguém se dá ao trabalho de usar esse modelo torto.&lt;/p&gt;
&lt;p&gt;Houve um tempo que eu mesmo pesquisei algumas soluções, e caí no velho problema de tentar conviver com diferentes versões do Visual Studio. Deixei de lado o Vim por uns anos, e passei a usar o VsVim, um plugin que roda em várias versões do Visual Studio e utiliza o vimrc de sua instalação.&lt;/p&gt;
&lt;p&gt;Hoje voltei a fuçar esse problema e depois de algumas horas tentando entender qual a dinâmica que deve ser seguida, cheguei a dois usos legítimos do make no Visual Studio: o modo legado, através do devenv, e o modo comportado, que usa a ferramenta MsBuild para encontrar o projeto e a solution que devem ser compilados.&lt;/p&gt;
&lt;p&gt;A não ser que você coloque o path das ferramentas direto nos comandos (algo que não recomendo pois as coisas no Vim começam a ficar estranhas com paths com espaços, algo abundante no Windows) é preferível que você escolha qual devenv e qual msbuild deseja utilizar e definir isso na variável de sistema path. No meu exemplo estou usando o msbuild para qualquer Visual Studio acima do 2010 (como o 2015), pois já está padronizado, e como tenho projetos no VS2003 para manter, escolhi deixar o devenv.com com ele.&lt;/p&gt;
&lt;p&gt;Note que essa configuração, para ficar persistente, precisa ser definida através do Painel de Controle ou Propriedades do Sistema. Google for it.&lt;/p&gt;
&lt;p&gt;Depois de configurado, qualquer projeto deve ser compilável em 2003 pela linha de comando (através do devenv.com):&lt;/p&gt;
&lt;p&gt;Da mesma forma, projetos 2010+ devem usar o msbuild:&lt;/p&gt;
&lt;p&gt;Pois é. Tirando essa facilidade, as coisas no Vim para msbuild rodam particularmente bem. Basta alterarmos o makeprg da seguinte maneira:&lt;/p&gt;
&lt;p&gt;As opções específicas são para gerar o path completo, as barras invertidas são por causa dessa mania do Vim de dar pau quando tem espaço em tudo.&lt;/p&gt;
&lt;p&gt;A partir dessa configuração já é possível compilar um projeto estando em sua pasta:&lt;/p&gt;
&lt;p&gt;Para o Visual Studio 2003 (ou qualquer um usando o devenv.com) é necessário mudar esse comando:&lt;/p&gt;
&lt;p&gt;Sim, temos que escolher uma configuração (o msbuild já escolhe por você). E note que ele usa o arquivo atual (%) para compilar. Isso quer dizer que isso irá exigir do usuário de Vim abrir o sln ou o vcproj e executar o :make a partir daí. De qualquer forma, ele funciona também:&lt;/p&gt;
&lt;p&gt;Note que em nenhum dos casos erros conseguirão ser capturados para irmos direto no ponto do código-fonte onde ele está. Para isso funcionar, em nosso último passo, é necessário configurar o errorformat para que ele tenha um padrão que funcione com ambas as ferramentas. Depois de testar um pouco, cheguei nesse formato:&lt;/p&gt;
&lt;p&gt;Ele pega também os warnings, mas fazer o quê. Você não quer conviver com warnings em seu código pelo resto da vida, né? =)&lt;/p&gt;
&lt;p&gt;E para navegar na lista é como o resultado de comandos como :vimgrep. :cnext e :cprevious vão para frente e para trás na lista, sempre pulando para o ponto no código onde está o erro.&lt;/p&gt;
&lt;p&gt;Como deu pra perceber, para conseguir usar o msbuild e o devenv ao mesmo tempo você seria obrigado a trocar o makeprg sempre que precisasse. Para facilitar seu uso, nada como fazer um mapeamento de atalhos:&lt;/p&gt;
&lt;p&gt;Para alguém curioso para ver minhas configurações do Vim (quem quiser compartilhar também, fique à vontade), segue.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>unit-menos-menos</title>
  <link>http://www.caloni.com.br/unitmenosmenos/</link>
  <pubDate>2016-09-05</pubDate>
  
  <guid>http://www.caloni.com.br/unitmenosmenos/</guid>
  <description>&lt;p&gt;Fazer o setup inicial de testes unitários em seu projeto C++ pode ser algo enfadonho se você precisa baixar e compilar uma lib do Google ou do Boost. Há uma alternativa mais leve e bem direta, que um dia apareceu nesses CodeProject da vida, mas que hoje está, até onde eu vi, no GitHub.&lt;/p&gt;
&lt;p&gt;E como se faz para começar a montar os testes unitários? Bom, suponha que você tenha um projeto qualque que já compila, roda e faz alguma coisa de útil.&lt;/p&gt;
&lt;p&gt;Apenas crie um projeto do lado, console, ou copie e cole o projeto, mas use os arquivos-fonte do projeto original. Dessa forma ele irá compilar com os fontes que estão sendo modificados/compilados.&lt;/p&gt;
&lt;p&gt;Apenas se lembra de não incluir o módulo que contém o int main. Esse módulo deve ficar apartado do projeto principal.&lt;/p&gt;
&lt;p&gt;Depois basta incluir apenas um arquivo do projeto unit--, que é seu cpp principal.&lt;/p&gt;
&lt;p&gt;Com isso existirá um main lá dentro, definido em algum lugar. E tudo o que você precisa fazer é ir criando seus testes em outro arquivo fonte gerado para isso. O corpo e o formato dos unit cases é bem simples. Note que tudo que você fez para já sair testando seu projeto foi copiar um projeto já existente e inserir um módulo de outro projeto. Tudo compilando junto e já podemos fazer os primeiros testes do programa original (desde, claro, que ele seja testável, algo primordial):&lt;/p&gt;
&lt;p&gt;E assim por diante. O resultado é que quando você roda o executável de teste, ele execute toda a bateria e já te entregue todos os casos que você deseja testar, sem frescura:&lt;/p&gt;
&lt;p&gt;E voilà! Sistema de teste unitário pronto e rodando. Agora cada nova situação de erro ou que você precise validar, basta escrever um novo teste. Se esse projeto ir se tornando algo muito maior, a transição para testes unitários mais parrudos é apenas um regex. No momento, foque em codificar e testar muito bem o que está fazendo.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Vídeo: Resolvendo problemas em projetos desleixados</title>
  <link>http://www.caloni.com.br/video-resolvendo-problemas-em-projetos-desleixados/</link>
  <pubDate>2016-09-01</pubDate>
  
  <guid>http://www.caloni.com.br/video-resolvendo-problemas-em-projetos-desleixados/</guid>
  <description>&lt;p&gt;Quem nunca teve que mexer em um projeto cheio de bugs de compilação, péssima organização, documentação e nomes de funções, classes e argumentos? Que você acaba de baixar em sua máquina e ele não compila (e você não tem a mínima noção por quê). Que a equipe que trabalha com você ouviu falar do projeto, mas nunca arregaçou as mangas e organizou. Que tal fazer isso agora?&lt;/p&gt;
&lt;p&gt;Nesse vídeo eu exploro alguns dos erros mais comuns de projetos desleixados. Esses projetos em que o programador só se preocupa em entregar as coisas, e deixa os problemas de manutenção para o próximo trouxa que irá mexer com ele. Esse rapaz ou moça não usa a metologia PMF, que eu expliquei no artigo anterior. PMF quer dizer entregar as coisas com qualidade. Eles usam uma outra metodologia que também é simples, mas que traz gravíssimos problemas a médio e longo prazo (a despeito de ser divertida):&lt;/p&gt;
&lt;p&gt;Pra começar, projetos que não compilam ou cheio de warnings são um sinal de que há algo de pobre no reino do GitHub. Ou é algo feito nas coxas ou é um projeto mal mantido ou é fruto de programação instintiva, que não pensa nas consequências de seus atos.&lt;/p&gt;
&lt;p&gt;Depois, o sujeito usa headers com nomes complicados, inclui 2.653 headers diferentes (e duplicados) quando usa apenas dois, inclui headers do boost com nomes estranhos sem dar dica alguma de onde vieram. Cria funções que recebem s1 e s2 (e se chamam func2). Enfim, o pacote completo de desleixadas.&lt;/p&gt;
&lt;p&gt;E por último, mas não menos importante: INCLUI BINÁRIOS NO GIT! TEMPORÁRIOS!&lt;/p&gt;
&lt;p&gt;Pensando bem, meu exemplo fictício está bonito demais perto do que existe por aí. Bom, ele tem poucas linhas. É tudo questão de tempo e (des)empenho.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>DBAccess</title>
  <link>http://www.caloni.com.br/dbaccess/</link>
  <pubDate>2016-08-16</pubDate>
  
  <guid>http://www.caloni.com.br/dbaccess/</guid>
  <description>&lt;p&gt;Bancos de dados são uma dor de cabeça para o desenvolvedor acessar. Quase tão motivation killer que as configurações do .NET. Se for um programador em C++ para Windows, então, desista.&lt;/p&gt;
&lt;p&gt;O DBAccess é mais um dos códigos-fonte desenterrados dos meus backups. Esse eu usei já em vários projetos, porque é simples e rápido de usar.&lt;/p&gt;
&lt;p&gt;Sua função é abstrair a abertura de um banco de dados, sua execução e sua saída. Para isso ele cria uma interface simples que usa STL. Por debaixo dos panos, usa OLEDB, que abstrai qualquer coisa, só precisando de instalar o driver e aprender qual das 500 mil combinações é a string de conexão correta. Para não ter que usar outras funções para coisas simples como sqlite, foi incluído seu suporte (que é mais uma tradução entre interfaces), necessitando para seu uso daquele projeto do sqlite que contém um header e um .c (pelo jeito o pessoal desse projeto também gosta de simplificar as coisas).&lt;/p&gt;
&lt;p&gt;O código que trata o OLEDB é um pouco grande (umas 300 linhas) por conta da manipulação dos componentes COM. Porém, feito decentemente, faça uma vez e use um milhão (ainda falta fazer alguns unit tests, aliás).&lt;/p&gt;
&lt;p&gt;É um bom projeto para entender o uso da minha batidíssima biblioteca de parsear argumentos argv/argc (Args.cpp/h) e a mais batidíssima ainda biblioteca de Log, que utiliza variadic templates para se livrar da maldição dos crashs causados pela falta de tipagem do printf e derivados (em Log.cpp/h).&lt;/p&gt;
&lt;p&gt;Além disso, observe como o uso de interface permite que os headers específicos do que tem que ser feito (e.g. oledb.h, atlbase.h, msdasc.h, sqlite.h e até windows.h) não precisa necessariamente estar presente no header da interface (oledb.h), e como o uso de um factory em um método estático da interface permite que a junção das tecnologias envolvidas fique apenas no oledb.cpp. Dessa forma, para retirar ou acrescentar novas formas de comunicação com um banco de dados é muito simples.&lt;/p&gt;
&lt;p&gt;PS: A publicação do DBAccess foi inspirada na thread iniciada por Spagiari no nosso grupo C/C++.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Vídeo: Depurando código C&#43;&#43; no Visual Studio</title>
  <link>http://www.caloni.com.br/depurando-codigo-c-no-visual-studio/</link>
  <pubDate>2016-08-12</pubDate>
  
  <guid>http://www.caloni.com.br/depurando-codigo-c-no-visual-studio/</guid>
  <description>&lt;p&gt;Olá de novo. Este é o segundo vídeo da série &amp;quot;o que que eu tô fazendo no YouTube?&amp;quot;. Dessa vez abri o Visual Studio para depurar um código de 10 linhas com um bug absurdamente absurdo, mas que pode enganar muita gente. Há quem acredite que esse bug foi proposital, mas não foi. O importante é que ficou muito legal. Vamos ver?&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/embed/TpTNMj7ngc&#34;&gt;https://www.youtube.com/embed/TpTNMj7ngc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Pra começo de conversa, é importante ressaltar que este é um vídeo introdutório, para quem deseja começar a programar em C++, ou até para quem quer alguma dica de uso da IDE do Visual Studio. Já trabalhei algumas décadas (uma e meia) com a ferramenta, quando ainda se chamada Visual C++ e foi horrorosamente renomeada para Visual Studio .NET (arght!!!). Com o tempo fui me acostumando com a lerdeza cada vez mais crescente da ferramenta, acreditando piamente que um dia iriam transformar tudo em Java para ficar mais rápido.&lt;/p&gt;
&lt;p&gt;Acho que não foi o caso. De qualquer forma, o vídeo acima tem o potencial de funcionar em quase qualquer versão do Visual Studio. Portanto, não se acanhe se ainda está mexendo em projetinhos jurássicos com o .NET 2003 (eu estou, mas só abro em emergência). Tudo deve funcionar exatamente como está no vídeo.&lt;/p&gt;
&lt;p&gt;Ou não. Nesse caso, RTFM ou comente aqui =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Vídeo: Criando Projeto C&#43;&#43; Console no Visual Studio 2015</title>
  <link>http://www.caloni.com.br/video-criando-projeto-c-console-no-visual-studio-2015/</link>
  <pubDate>2016-08-04</pubDate>
  
  <guid>http://www.caloni.com.br/video-criando-projeto-c-console-no-visual-studio-2015/</guid>
  <description>&lt;p&gt;Esse vídeo é um experimento que estou fazendo para tentar começar a compartilhar conhecimento em vídeo. Para começar, acho que nada mais apropriado que criar um projeto novo no Visual Studio, não? Dúvidas, sugestões, críticas, todas bem-vindas. Compartilhem com aquele amigo que pensa em começar a programar (ainda mais se for em C++).&lt;/p&gt;
&lt;p&gt;Essa primeira tentativa saiu um pouco longa -- 10 minutos -- mas era para ser mais sucinto. Me perdi em alguns detalhes da estrutura do projeto, mas o objetivo era entrar um pouco mais a fundo, mesmo, abrindo os arquivos do Visual Studio &amp;quot;na mão&amp;quot; para ver o que tem dentro, e já dando dicas de como a depuração pode começar já na compilação.&lt;/p&gt;
&lt;p&gt;Espero que gostem. Se quiserem vídeos mais específicos, é só comentar logo abaixo. Dependendo do retorno -- ou não -- talvez em breve continuemos o projeto fazendo um básico de depuração.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Palestra: Stack Overflow</title>
  <link>http://www.caloni.com.br/palestra-stack-overflow/</link>
  <pubDate>2016-06-04</pubDate>
  
  <guid>http://www.caloni.com.br/palestra-stack-overflow/</guid>
  <description>&lt;p&gt;Há umas semanas (sim, estava enrolado para falar sobre isso) ministrei uma nova palestra lá em Sorocaba. Cheguei no meio de uma greve de ônibus, o que atrasou o evento em uma hora e me deu tempo de sobre para pensar nas desgraças que serão cidades próximas da capital crescendo desordenadamente graças às regulações estatais.&lt;/p&gt;
&lt;p&gt;Mas divago.&lt;/p&gt;
&lt;p&gt;A ideia da palestra foi do meu amigo Alan Silva (a.k.a. jumpi), e era para a SEMANA DA COMPUTAÇÃO E TECNOLOGIA -- mas nada tem a ver com computação, nem tecnologia, mas com oportunidade de emprego de estagiários para empresas corporativistas da área. O foco era sair da mesmisse que os representantes de R.H. fazem em falar de cultura, visão, valores e outras besteiras e falar um pouco mais de bits e bytes, algo que falta a essa geração.&lt;/p&gt;
&lt;p&gt;Meu público era muito, muito jovem, e foquei erroneamente em conceitos muito, muito antigos para eles, então não tenho muita certeza se fui útil. De qualquer forma, foi um prazer falar sobre engenharia da computação atrelado a ataque na pilha de execução (sim, um salto enorme para baixo, do R.H. para a placa de memória RAM).&lt;/p&gt;
&lt;p&gt;O conteúdo e a palestra está no GitHub e a palestra em si pode ser vista logo abaixo; a apresentação do conteúdo está mais abaixo, e peço desculpas por não ter tido tempo de apresentar todo ele (mesmo com quase duas horas):&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.slideshare.net/slideshow/embedcode/key/qRb4TSKjnf8Wx&#34;&gt;http://www.slideshare.net/slideshow/embedcode/key/qRb4TSKjnf8Wx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PS: Ah, esqueci. Também fiz um vídeo para complementar o conteúdo da palestra. Segue:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/embed/kSKQQDTBRXQ?list=PLa0QVTprDkHBz6fjuzy4kU1iTLUnRWkeW&#34;&gt;https://www.youtube.com/embed/kSKQQDTBRXQ?list=PLa0QVTprDkHBz6fjuzy4kU1iTLUnRWkeW&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Um StackOverflow é definido pela escrita em uma região não autorizada de memória. Stack overflow, overrun, etc, não interessando a nomenclatura &amp;quot;oficial&amp;quot;, o importante aqui é como um bug de acesso à memória pode permitir acesso exclusivo a regiões de memória que não estariam disponíveis para um atacante se não fosse por esse bug.&lt;/p&gt;
&lt;p&gt;No exemplo do código deste projeto, um usuário fictício utiliza um código que possui controle de acesso, mas também possui um bug: ele escreve em uma região da memória inadvertidamente. Dessa forma, é possível explorar essa falha no código para escrever um novo endereço de retorno na pilha (stack), ganhando acesso, dessa forma, a código que não estaria disponível em situações normais de temperatura e pressão.&lt;/p&gt;
&lt;p&gt;Para explorar esse tipo de falha, primeiro devemos entender a execução do código na arquitetura que se pretende atacar, além de alguns conceitos específicos do sistema operacional alvo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UML: Mundo real aplicado a engenharia.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Programação: Codificação do mundo real.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Assembly: Ponte entre ser humano e máquina.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1&#39;s e 0&#39;s: Codificação lógica do computador.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Impulsos elétricos: Voltamos para o mundo real.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qubit: Voltamos para a Matrix.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(&amp;quot;IBM disponibiliza computador quântico para público&amp;quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mais abstrações: Memória Virtual, Threads, I/O.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Movimentação de memória (mov, lea)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cálculos matemáticos (add, div)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Meta-comandos (push, pop, ret, jmp)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Registradores (e[abcd]x, [bs]sp, eip)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Endereço Virtual ([Kernel|User] Space)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Endereço Físico (RAM, ROM, Storage, placas)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qual o sentido de apontar para a próxima instrução?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;R: Saber onde continuar a execução.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Demo: Chamada de função.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Demo: Retorno de função.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qual o sentido de existir uma stack?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;R: Conseguir chamar funções.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Demo: Chamada de função.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Demo: Passagem de argumentos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Demo: Retorno de função.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Escalonamento de threads&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Virtualização da memória&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Controle de acesso&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Paginação&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Plug and Play&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows NT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dave Cutler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;xBox One&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hypervisor&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thread: Uma ilusão satisfatória.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fibers, Co-Routines, Cores, Pipe Line, Branch Prediction.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Computação Quântica: Hackeando o Universo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python, F#, Lambdas C++11, Métodos, Função Virtual.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bloco de memória chama... Outro bloco de memória&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[[[C]]]]decl e Std(?)call (M$).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Demo: Função em C sendo chamada.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Demo: Função da Microsoft sendo chamada.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ou: Porque o printf precisa ser cdecl.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Page Tables, PTEntries, Page Fault, Memory Map.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Demo: Process Explorer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2 bits: Quatro possibilidades.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Read-Only Memory, Execute Memory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ah, vamos para o BAR: Base Address Randomization.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Demo: Ver se isso funciona, mesmo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ESP Verification.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Buffer overrun.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;0xCCCCCCCCCCCCCCCCCCCCC&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Rank and File</title>
  <link>http://www.caloni.com.br/rank-and-file-code-jam/</link>
  <pubDate>2016-04-16</pubDate>
  
  <guid>http://www.caloni.com.br/rank-and-file-code-jam/</guid>
  <description>&lt;p&gt;Passou o Round 1A do Code Jam, e para variar, fui muito mal, só respondendo a primeira questão. A segunda me fez ficar pensando um tempo desproporcional sobre como encaixar as diferentes linhas e colunas para achar a linha restante.&lt;/p&gt;
&lt;p&gt;Basicamente, o problema pede que, dado um quadrado de tamanho N, e 2*N-1 linhas fornecidas (que podem ser linhas ou colunas), imprimir a Nésima linha. A regra das linhas é que ela possui números crescentes.&lt;/p&gt;
&lt;p&gt;Bom, não consegui chegar numa solução para o problema errado (encaixar as linhas), mas fui, como sempre, dar uma espiada nas respostas dos competidores, em especial a do primeiro colocado. O grande barato de competições como essa é aprender com a inteligência e genialidade dos outros. Para mim, esse é um exemplo de genialidade:&lt;/p&gt;
&lt;p&gt;Obs.: O código está higienizado, pois esse pessoal usa bastante macros, etc.&lt;/p&gt;
&lt;p&gt;A solução basicamente decide isolar duas questões: achar os números que faltam nas sequência e imprimi-los na ordem. Para o primeiro, varre todas as sequências sinalizando qual deles tem a quantidade ímpar (ou seja, não está representado em todas as linhas e colunas, pois do contrário seria par). Depois ele resolve a segunda questão simplesmente imprimindo os números ímpares encontrados, já na ordem (no array de valores possíveis).&lt;/p&gt;
&lt;p&gt;Simples, rápido, eficiente. E correto.&lt;/p&gt;
&lt;p&gt;É esse tipo de coisa que faz valer a pena uma competição dessas.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Testando sistema de postagem</title>
  <link>http://www.caloni.com.br/testando-sistema-de-postagem/</link>
  <pubDate>2016-04-10</pubDate>
  
  <guid>http://www.caloni.com.br/testando-sistema-de-postagem/</guid>
  <description>&lt;p&gt;Bom, depois de criar um script para basicamente apenas escrever o texto dos filmes que assisto e buscar uma imagem agradável para meu finado blogue de Cinema, o próximo passo foi portar esse mesmo método para meus dois outros blogues: o da minha empresa, a BitForge e esse aqui. O processo envolve algo a mais: buscar as imagens usadas (que muitas vezes não é só uma). Porém, nada mais que isso.&lt;/p&gt;
&lt;p&gt;O problema mesmo é publicar nas redes sociais. Um detalhe típico do funcionamento dessas redes bem apontou o blogger veterano Hossein Derakhshan, que ficou preso por seis anos e descreveu a mudança que a web sofreu nesse pouquíssimo tempo para a história, mas muitíssimo para a internet. De acordo com ele, postar apenas links não farão muito efeito, mesmo que você seja um escritor conhecido (o caso dele). Para fazer efeito, você precisa de imagens. Pessoas gostam de imagens. De gatinhos, melhor ainda.&lt;/p&gt;
&lt;p&gt;Porém, qual imagem que pode ser usada para um blogue técnico e que chame a atenção?&lt;/p&gt;
&lt;p&gt;No Cine Tênis Verde fica fácil achar uma imagem, pois filmes são formados por elas (cerca de 170 mil delas, se for um filme de duas horas). Aqui no Blogue do Caloni, tenho que me limitar a abstrações e metáforas.&lt;/p&gt;
&lt;p&gt;O que muitas vezes tem funcionado, como minha série Básico do Básico:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Binário&lt;/li&gt;
&lt;li&gt;Tipos&lt;/li&gt;
&lt;li&gt;Ponteiros&lt;/li&gt;
&lt;li&gt;Assembly&lt;/li&gt;
&lt;li&gt;Programação&lt;/li&gt;
&lt;li&gt;Depuração&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;De qualquer forma, posso continuar utilizando o título do artigo como base para minha pesquisa.&lt;/p&gt;
&lt;p&gt;Postar no Twitter é algo relativamente fácil. O script abaixo faz isso com dois pés no joelho:&lt;/p&gt;
&lt;p&gt;Já postar no Facebook é mais ou menos uma tortura. As chaves de acesso costumam expirar, e para conseguir uma que não expira este tutorial é femonenal, pois economiza muito, muito tempo de pesquisa.&lt;/p&gt;
&lt;p&gt;Curiosamente, o código para postar é muito semelhante ao do Twitter, até mais simples, talvez:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Crash no Windows Explorer</title>
  <link>http://www.caloni.com.br/crash-no-windows-explorer/</link>
  <pubDate>2016-03-01</pubDate>
  
  <guid>http://www.caloni.com.br/crash-no-windows-explorer/</guid>
  <description>&lt;p&gt;Quem nunca se deparou com um sistema Windows em que o Explorer travasse ou crashasse de vez em quando? O problema com esse tipo de problema (recursividade...) é que ele pode ocorrer por infinitos motivos. Tão infinitos quanto os shell extensions, aquelas DLLs irritantes que são carregadas automaticamente por todo processo explorer.exe, e que portanto podem gerar infinitas maneiras de travar seu shell.&lt;/p&gt;
&lt;p&gt;Um que estava me incomodando já há algum tempo era um deadlock que acabava em restart do Explorer (isso é automático no Windows 10). Para verificar o que era, antes configurei a geração de dumps automática para que qualquer novo crash gerasse um arquivo de dump para eu analisá-lo. Só passou algumas horas para ter algo que pudesse trabalhar: um dump pode ser analisado pelo Visual Studio (qualquer versão) ou depuradores como WinDbg (do pacote Debugging Tools for Windows). Como análise exploratório, apenas o Visual Studio é suficiente, pois ele pode exibir coisas como os módulos carregados pelo processo e a pilha de chamadas da thread faltosa.&lt;/p&gt;
&lt;p&gt;No caso do dump que eu estava analisando, verifiquei que a thread que gerou o travamento continha uma DLL da NVidia. Essa DLL, de acordo com o AutoRuns, estava cadastrada no registro como um Context Menu Handler para o shell. Depois de desativá-la e iniciar uma nova instância do Explorer foi possível verificar que a DLL não estava mais sendo carregada pelo processo.&lt;/p&gt;
&lt;p&gt;E &amp;quot;magicamente&amp;quot; o travamento não aconteceu nos próximos dias =).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Exportando repositórios antigos do Bazaar para Git</title>
  <link>http://www.caloni.com.br/exportando-repositorios-antigos-do-bazaar-para-git/</link>
  <pubDate>2016-01-27</pubDate>
  
  <guid>http://www.caloni.com.br/exportando-repositorios-antigos-do-bazaar-para-git/</guid>
  <description>&lt;p&gt;Enquanto estudava sobre controle de fontes distribuído, experimentei e usei os projetos Mercurial e Bazaar, precursores desse modelo que funcionavam bem em Windows. Havia o Git, mas por conta da sua evolução assimétrica, o ambiente da Microsoft havia ficado para trás.&lt;/p&gt;
&lt;p&gt;Hoje com o Git sendo praticamente o mainstream das conversões do SubVersion, e funcionando razoavelmente bem em ambientes Windows (64 ou 32), sobraram apenas os repositórios do Mercurial e do Bazaar. Na verdade, mais do Bazaar, pois eu havia migrado já do Hg pelo Bazaar possuir algo que hoje o Git emula, mas antes era um diferencial no projeto da Canonical: detecção de rename completo (com histórico e tudo). Isso para refatoração era vital, e suporte à refatoração pesada era o que eu precisava no momento.&lt;/p&gt;
&lt;p&gt;Agora é hora de manter esse histórico vivo, mas convertido para o que todos usam.&lt;/p&gt;
&lt;p&gt;A primeira coisa a ser feita é converter o repositório. Depois de convertido, como todas as operações estarão no universo Git, há uma de entradas no StackOverflow para nos ajudar a reunir os repositórios em um só, meu objetivo, já que o Git é mais leve e mais versátil nesse quesito.&lt;/p&gt;
&lt;p&gt;No Windows, nas últimas versões do Bazaar o comando fast-export não estava mais funcionando. Parado desde 2012, não há previsão de correções. No entanto, para essa operação, a versão 2.4.2 atendeu bem. O comando é um pouco diferente, mas ele é rápido e rodou sem problemas em conjunto com o fast-import do Git.&lt;/p&gt;
&lt;p&gt;É óbvio que nem tudo serão mil maravilhas. Eu, por exemplo, encontrei um problema com case-sensitive que me deu algumas dores de cabeça:&lt;/p&gt;
&lt;p&gt;O Git gera um arquivo de report onde estão as informações do ocorrido. Uma forma de contornar esse tipo de problema é primeiro exportar para um arquivo e editá-lo (corrigindo o case, por exemplo):&lt;/p&gt;
&lt;p&gt;Note que talvez você precise de um editor que suporte arquivos gigantescos (como o Vim) e precise se debruçar sobre merges com arquivos com mesmo nome e diferentes cases. Isso que dá manter projetos com refactoring pesado.&lt;/p&gt;
&lt;p&gt;Por fim, faça a conversão para todos os .bzr que tiver e haverá um .git com todo o histórico desses anos usando Bazaar. O próximo passo é montar o histórico de todos eles em apenas um repositório (se assim desejar). Segue uma série de comandos que pode ajudar para usar em uma batch:&lt;/p&gt;
&lt;p&gt;Você pode chamar um a um em cima de um repo novo:&lt;/p&gt;
&lt;p&gt;Para conseguir ter acesso ao histórico dos arquivos movidos, basta usar a opção -all do log:&lt;/p&gt;
&lt;p&gt;Tive alguns problemas em rastrear o histórico utilizando a estratégia de fazer merge no mesmo branch. A solução que encontrei, embora não exatamente direta, foi realizar os merges em branches apartados primeiro, mover os arquivos (de preferência, usando o git, para que ele detecte o rename), aplicar o commit e realizar o merge com o master. Há uma vantagem nessa estratégia, além do log --follow funcionar melhor: mantenha os branches originais, além do ponteiro para remote. Dessa forma, depois de alguns anos, saberá de onde veio esse merge maluco.&lt;/p&gt;
&lt;p&gt;Depois de um tempo testando essa técnica, descobri que o Git se perde novamente e não encontra mais todos os logs, mesmo com --follow  mesmo movendo os arquivos. O meu problema está relacionado com mesmos paths dos arquivos em repositórios diferentes. Paciência.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Log de chamadas API direto do WinDbg</title>
  <link>http://www.caloni.com.br/log-de-apis-chamadas-direto-do-windbg/</link>
  <pubDate>2016-01-21</pubDate>
  
  <guid>http://www.caloni.com.br/log-de-apis-chamadas-direto-do-windbg/</guid>
  <description>&lt;p&gt;Há muito tempo atrás eu havia falado sobre como a ferramenta logger.exe, do Debugging Tools for Windows, poderia ser usada para gerar um arquivo de log com centenas de APIs detalhadas em sua chamada, como parâmetros de entrada, retorno e tempo. Bom, testando isso hoje, me veio à lembrança o artigo e também a constatação que o logger é muito instável. Tão instável que não consegui logar as APIs que desejava nas inúmeras tentativas que fiz. Isso em um Windows XP!&lt;/p&gt;
&lt;p&gt;Felizmente, as funções do logger também estão em uma DLL estilo plugin do próprio WinDbg, que pode ser chamada facilmente e que -- surpresa! -- internamente ao depurador funciona. Melhor ainda, não é necessário criar um processo para realizar o log, mas pode ser atachado em um processo já em execução, o que facilita bastante seu uso em serviços, por exemplo.&lt;/p&gt;
&lt;p&gt;Vamos testar aqui o log da nossa cobaia de plantão, o amigo Notepad (ou Bloco de Notas), exibindo um texto que demonstra com perfeição uma das minhas características mais bizarras: confundir expressões e frases prontas.&lt;/p&gt;
&lt;p&gt;Nota: Lembrando que estaremos testando em Windows XP 32 bits com um WinDbg igualmente 32 bits. Inicialmente comecei a testar a versão 64, mas ela também deu xabu. Aparentemente coisas periféricas do Debugging Tools nunca são muito bem testadas.&lt;/p&gt;
&lt;p&gt;O texto ainda não foi salvo em nenhum arquivo. Iremos salvá-lo, mas antes, vamos executar o WinDbg e ver como o Notepad realiza essa operação.&lt;/p&gt;
&lt;p&gt;A extensão/plugin que me referia é o Logexts.dll. Você pode instalar o log de API em um momento, habilitá-lo em outro, e até desabilitá-lo depois. Ou seja, é um processo ótimo para realizar inspeção pontual de chamadas API. Caso, claro, ele não exploda em um desses momentos.&lt;/p&gt;
&lt;p&gt;Depois de gerarmos o que precisamos, podemos desatachar do processo e analisar o resultado: um arquivo LGV. Para abrir esse arquivo existe uma outra ferramenta chamada logviewer. Para evitar procurar em dezenas de milhares de chamadas, há uma opção de filtrar com apenas o que queremos (no caso, CreateFile e WriteFile).&lt;/p&gt;
&lt;p&gt;Depois de filtrado, podemos abrir a linha que nos interessa para ver como o programa utilizou a API (quais parâmetros, o retorno, etc). Nesse caso, por exemplo, houve uma falha antes na abertura do mesmo arquivo, mas isso porque houve uma tentativa de abrir um arquivo que já existe (abertura com direito de apenas leitura). Essa chamada foi feita pela DLL do diálogo comum de abertura/salvamento de arquivo do Windows (comdlg32.dll), e não pelo notepad.exe.&lt;/p&gt;
&lt;p&gt;Como já havia dito no artigo original sobre o logview, você pode criar seu próprio header com as definições das funções de um módulo e o WinDbg graciosamente irá gerar um log de chamadas, incluindo medidas de performance. Esses dados abertos pelo logviewer podem ser exportados também para modo texto. E temos mais uma maneira de perfcounter chulé para eventualidades.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Templates em C no lugar de macros</title>
  <link>http://www.caloni.com.br/templates-em-c-no-lugar-de-macros/</link>
  <pubDate>2016-01-14</pubDate>
  
  <guid>http://www.caloni.com.br/templates-em-c-no-lugar-de-macros/</guid>
  <description>&lt;p&gt;A grande vantagem dos templates é manter o tipo de seus argumentos. Infelizmente, eles não existem na linguagem C, mas podem ser usados em construções C feitas com a linguagem C++, como ocorre com quem desenvolve device drivers para Windows.&lt;/p&gt;
&lt;p&gt;Imagine, por exemplo, a estrutura LISTENTRY.aspx), que é uma tentativa de generalizar não só o tipo de uma lista ligada, como seu posicionamento:&lt;/p&gt;
&lt;p&gt;A lógica por trás de LISTENTRY é que esse membro pode ser inserido em qualquer lugar da estrutura que representará um elemento. Ele pode estar realmente no meio do elemento, pois isso não importa, desde que você saiba voltar para o começo da estrutura. Isso é útil quando um elemento pode fazer parte de diferentes listas.&lt;/p&gt;
&lt;p&gt;OK, temos uma lista ligada cujo head está inicializado. Para inserir um novo item, podemos usar as rotinas InsertHeadList, AppendTailList, RemoveEntryList, PushEntryList, PopEntryList, etc. Enfim, uma infinidade de rotinas já cuidam disso para a gente.&lt;/p&gt;
&lt;p&gt;O que não temos é como acessar o elemento. Para isso usamos um truque bem peculiar na linguagem C, já disponível também em kernel:&lt;/p&gt;
&lt;p&gt;Basicamente a macro obtém a partir do endereço zero o offset do membro que é a entrada da lista ligada e subtrai esse ofsset do endereço do próprio campo, ganhando de brinde o tipo de sua estrutura. Usando a macro com nossa estrutura:&lt;/p&gt;
&lt;p&gt;Note que entry é o nome, literal, do membro na estrutura, e não há maneira possível com templates de obter isso. A solução? Usar um nome padronizado. O resultado final pode ser parecido com este:&lt;/p&gt;
&lt;p&gt;Em ação:&lt;/p&gt;
&lt;p&gt;&amp;quot;Nossa, tudo isso para substituir uma macro já consagrada no WDK??&amp;quot; Sim, nesse post o objetivo não ficou muito útil. É apenas uma ideia de substituição possível de ser feita em macros em geral. Pode ser bem documentada, usada há 30 anos, mas ainda é uma macro. Meu conselho: se funciona bem, use. Se vai fazer algo novo, tente sempre templates.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Gabaritos</title>
  <link>http://www.caloni.com.br/gabaritos/</link>
  <pubDate>2016-01-13</pubDate>
  
  <guid>http://www.caloni.com.br/gabaritos/</guid>
  <description>&lt;p&gt;Um template -- ou, como é na tradução da primeira edição de The C++ Programming Language, de Bjarne Stroustrup, aqui no Brasil: gabarito -- é um molde que pode ser usado por diferentes tipos para traduzir o mesmo algoritmo, ou pelo menos a mesma intenção de algoritmo (por pela sobrecarga de operadores é possível que o comportamento de tipos diferentes pode ser diferente).&lt;/p&gt;
&lt;p&gt;Em C++, fazer uma função template é muito simples:&lt;/p&gt;
&lt;p&gt;Continuando nosso tema de fazer as mesmas coisas em C, templates não é tão simples, pois não existe de fato na linguagem. Templates são interpretados pelo compilador, que gera um esqueleto de algoritmo que é usado para preencher código de todos os tipos utilizados. Em C isso era feito usando macros. Porém, macros não fazem parte da linguagem C. É apenas uma ferramenta chamada pré-processador que substitui texto antes do programa ser compilado. É através do pré-processador que, por exemplo, os headers são incluídos em um código-fonte. Isso já foi explicado em um artigo bem velhinho, e mais recentemente em uma palestra.&lt;/p&gt;
&lt;p&gt;Eu não recomendaria usar macros em C++, assim como não recomendo em C. Porém, em C é a única opção para reciclar algoritmos de maneira estática. Exceto se você usar ponteiros de função, o que adiciona pouco overhead, mas se perde, assim como a técnica de macro, a informação dos tipos. A própria libc contém uma função, qsort, que é &amp;quot;genérica&amp;quot; através do uso de ponteiros sem tipo (void*) e ponteiro de função. A função ordena elementos de uma lista, mas para isso depende da função de comparação que é passada por parâmetro. Essa função recebe dois void* que deve comparar. Além disso, o leiaute na memória tem que ser fixo, contínuo, pois é assim que a função consegue mover os elementos. Ou seja, bem limitado.&lt;/p&gt;
&lt;p&gt;Dessa forma, não pretendo ensinar a usar &amp;quot;templates&amp;quot; em C, mas a usá-los em C++ com foco em C. Um amigo conhecido de vocês, o Fernando/DriverEntry, utilizou essa técnica com maestria em alguns códigos kernel-mode que ele desenvolveu, e é uma maneira válida de se aproveitar de uma linguagem mais &amp;quot;alto nível&amp;quot; como C++ em ambientes limitados como o código que trabalha com o S.O.. Como a API do kernel lida com abstrações em C, seus objetos necessariamente não são objetos no sentido C++, mas os famigerados &amp;quot;ponteiros opacos&amp;quot;.&lt;/p&gt;
&lt;p&gt;Mais sobre isso em um próximo post.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Classe, objeto, contexto, método, polimorfismo</title>
  <link>http://www.caloni.com.br/classe-objeto-contexto-metodo-polimorfismo/</link>
  <pubDate>2016-01-12</pubDate>
  
  <guid>http://www.caloni.com.br/classe-objeto-contexto-metodo-polimorfismo/</guid>
  <description>&lt;p&gt;No post anterior implementamos &amp;quot;métodos&amp;quot; em C usando ponteiros de função dentro de structs que eram passadas como parâmetro. Tudo isso embutido por um compilador que gera o que chamamos de instância de uma classe, ou objeto, em C++. Isso é possível graças ao contexto que é passado para uma função (que no caso de C++ é o operador implícito this, que sempre existe dentro de um método não-estático).&lt;/p&gt;
&lt;p&gt;Para objetos não-polimórficos, o C++ não precisa mudar essa tabela de funções que os objetos de uma classe contém. No entanto, quando há pelo menos um método virtual, surge a necessidade de se criar a famigerada vtable, ou seja, justamente uma tabela de ponteiros de função, que dependem da classe instanciada (base ou algumas das derivadas). Se uma classe derivada sobrescreve um método de alguma classe base, é o endereço desse método que irá existir na vtable. Já vimos isso há muito tempo atrás escovando os bits da vtable direto no assembly e na pilha.&lt;/p&gt;
&lt;p&gt;Como você deve imaginar, é possível também fazer isso em C. Basta mudar os endereços das variáveis do tipo ponteiro de função que estão na struct usada como contexto. Para ficar o mais próximo possível do &amp;quot;modo C++&amp;quot; de fazer polimorfirmo, podemos escrever hardcoded a tal vtable para os diferentes tipos de &amp;quot;classe&amp;quot;:&lt;/p&gt;
&lt;p&gt;A versão C ainda tem a vantagem de não precisar de uma vtable const (embora seja adequado em situações normais de temperatura e pressão). Os &amp;quot;métodos&amp;quot; poderiam mudar caso algum estado mudasse, alguma exceção fosse disparada, mantendo o mesmo contexto, mas um comportamento (vtable) diferente. Quem utiliza muito essa estratégia é o kernel do Windows, que mexe com estruturas que contém não apenas listas ligadas genéricas, mas funções de callback que não apenas o código da Microsoft precisa chamar, mas os próprios drivers de terceiros que se preocupam com bom comportamento e guidelines que tornam o SO rodando perfeitamente.&lt;/p&gt;
&lt;p&gt;O importante deste artigo é demonstrar como conceitos aparentemente complicados ou escondidos de uma linguagem como C++ podem ser compreendidos completamente utilizando apenas linguagem de alto nível no bom e velho C. Essa estratégia de descer camadas de abstração, como verá, funciona para linguagens de mais alto nível, como C# ou Java, pois ambas são implementadas em linguagens como C++. No fundo, engenharia de software é um universo multi-camadas transitando pela última camada que conhecemos -- a física. Pelo menos a última camada que ainda conhecemos.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Classe, objeto, contexto, método</title>
  <link>http://www.caloni.com.br/classe-objeto-contexto-metodo/</link>
  <pubDate>2016-01-11</pubDate>
  
  <guid>http://www.caloni.com.br/classe-objeto-contexto-metodo/</guid>
  <description>&lt;p&gt;No post anterior falamos como a passagem de um endereço de uma struct consegue nos passar o contexto de um &amp;quot;objeto&amp;quot;, seja em C (manualmente) ou em C++ (automagicamente pelo operador implícito this). Trocamos uma propriedade desse &amp;quot;objeto&amp;quot; em C, mas ainda não chamamos um método.&lt;/p&gt;
&lt;p&gt;Hoje faremos isso.&lt;/p&gt;
&lt;p&gt;Isso é relativamente simples quando se conhece ponteiros de função, existentes tanto em C quanto em C++. Ponteiros de função são tipos que contém endereço de uma função com assinatura específica (tipo de retorno e de argumentos). Através de um ponteiro de função é possível chamar uma função e passar alguns argumentos. Como o contexto nada mais é que um argumento, será só passá-lo como parâmetro.&lt;/p&gt;
&lt;p&gt;No exemplo anterior não sabíamos como chamar um método de nosso &amp;quot;objeto&amp;quot; em C:&lt;/p&gt;
&lt;p&gt;Isso se torna fácil se tivermos uma nova &amp;quot;propriedade&amp;quot; na nossa struct que é um ponteiro para a função que queremos chamar.&lt;/p&gt;
&lt;p&gt;Parece muito trabalho para algo que é feito &amp;quot;automagicamente&amp;quot; em C++, certo? Certo. Porém, agora sabemos o que acontece por baixo dos panos em C++ e que pode ser feito em C (ainda que &amp;quot;na mão&amp;quot;). Você provavelmente nunca fará esse tipo de código em C para emular C++, mas o objetivo desse código é entender como funciona, por exemplo, a vtable do C++, que permite polimorfismo.&lt;/p&gt;
&lt;p&gt;Mas esse é assunto para outro post.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Classe, objeto, contexto</title>
  <link>http://www.caloni.com.br/classe-objeto-contexto/</link>
  <pubDate>2016-01-10</pubDate>
  
  <guid>http://www.caloni.com.br/classe-objeto-contexto/</guid>
  <description>&lt;p&gt;Para entender conceitos simples em C++, como métodos de uma classe, ajuda muito seguir o raciocínio dos programadores C e como eles lidavam com o tipo de problema que C++ resolve elegantemente implementando um novo compilador com uma nova linguagem.
Tomemos, por exemplo, métodos. Um método é uma função chamada dentro de um contexto. Qual o contexto? O objeto. Ou seja, uma instância específica de uma classe, que é um molde para se fazer alguma coisa.&lt;/p&gt;
&lt;p&gt;Para obter esse contexto, existe uma palavra-chave reservada dentro dos métodos que é o this, que está tão incrustado na linguagem que não precisa ser usado explicitamente: quando referenciamos alguma propriedade (ou um outro método) da classe, só pelo fato de estarmos dentro de um método o compilador já entende que se trata do mesmo objeto, ou mesmo contexto.&lt;/p&gt;
&lt;p&gt;E contexto nesse sentido nada mais é que um endereço na memória para alguma coisa que nos interessa. Tal qual uma função API do Windows -- tal qual FindFirstFile.aspx) -- que recebe ou retorna uma struct com o que precisamos, esse geralmente é o contexto procurado.&lt;/p&gt;
&lt;p&gt;No caso de nós, que escrevemos uma &amp;quot;classe&amp;quot;, o contexto é recebido &amp;quot;de fora&amp;quot;:&lt;/p&gt;
&lt;p&gt;Tal como uma struct que definimos, ela vira o contexto. Da mesma forma, um objeto de uma classe em C++ é esse contexto. Podemos fazer a mesma coisa em C, com o trabalho adicional de especificar o &amp;quot;this&amp;quot; (isto é, o ponteiro para o contexto/struct):&lt;/p&gt;
&lt;p&gt;Em um próximo post vamos ver como fazer para chamar MeuOutroMetodo a partir de uma estrutura em C.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como ser um hacker</title>
  <link>http://www.caloni.com.br/como-ser-um-hacker/</link>
  <pubDate>2015-11-18</pubDate>
  
  <guid>http://www.caloni.com.br/como-ser-um-hacker/</guid>
  <description>&lt;p&gt;Talvez as pessoas estejam com preguiça de ler. Talvez estejam apenas inundadas por tanta informação que temos hoje. Talvez seja apenas falta de foco pelas interrupções consecutivas de novos &amp;quot;espertofones&amp;quot; ou nossas redes sociais viciantes, pois oferecem muito a troco de nada.&lt;/p&gt;
&lt;p&gt;O fato é: se você precisa perguntar para alguém (no caso, eu) o que é preciso fazer para se tornar um hacker, algo como um guia passo-a-passo, eu vou encarar o desafio numa boa, pensar por alguns dias, semanas e talvez meses, e chegar à conclusão que a pessoa que precisa que alguém lhe ensine está percorrendo o caminho errado. Ela nunca vai aprender o suficiente para se tornar algo que possa ser chamado de hacker.&lt;/p&gt;
&lt;p&gt;E o que é hacker, que mal lhe pergunte? Há uma definição curta e simplista, há a definição do botão (que eu nunca mais vou me esquecer) e há o Jargon. O que é o Jargon? É um guia dos primórdios da web que contém tudo que você precisa saber sobre o jargão hacker. Duvida? Leia ele primeiro.&lt;/p&gt;
&lt;p&gt;Falar em jargão me faz lembrar do nostálgico e muito curioso (e que já falei em outros artigos) Barata Elétrica, o fanzine jurássico de Derneval Ribeiro que consistia em copy&amp;amp;paste de partes interessantes da rede, em inglês e português, e um pouco da cultura hacker na América do Sul (sobretudo Buenos Aires) e sobre a vivência de seu editor no ambiente uspiano. Derneval pode até não ser um &amp;quot;hacker de verdade&amp;quot; (só pra citar a falácia do escocês), mas ler o Barata Elétrica me deu não conhecimentos técnicos, mas muito sobre a nossa era da informação, como informação é vital hoje em dia, além de outros conceitos interessantes que nos fazem ficar atentos para privacidade, governos, política, economia, filosofia, etc. Acho que foi lá a primeira vez que tive contato com 1984, PGP, Mitnick. Enfim, curiosidade, piadas e um pouco do clima social que a web tinha (para mais disso, nada como saudoso mIRC...).&lt;/p&gt;
&lt;p&gt;Para quem pretende se tornar um hacker, já deve ficar claro que não existe receita de bolo, nem lista de conhecimentos desejáveis. Isso não e uma vaga para preenchimento de currículo. Isso é a vida real. Se existe uma receita, ela é vaga e de auto-ajuda:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Primeiro você aprende a gostar de viver de acordo com a definição abaixo.&lt;/li&gt;
&lt;li&gt;Viver é a busca incessante de conhecimento em todas as suas formas, uma autodescoberta e a busca da felicidade pessoal e instransferível, subjetiva e inalienável.&lt;/li&gt;
&lt;li&gt;Com base nisso, comece a aprender profundamente sobre tudo o que deseja, em todas as áreas, sobre qualquer assunto, pessoa, lugar.&lt;/li&gt;
&lt;li&gt;Repita o passo anterior até que a inescapável morte aconteça; o resto é mistério.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Parece meio poético e filosófico, mas não é. Se eu te disser que para ser hacker precisa aprende a crackear programas no Windows, fuçar no WinDbg e esmiuçar a API Win32, disassemblar códigos em binário com o IDA e usar no percurso todas as ferramentas, sistemas operacionais, linguagens de programação e conhecimentos periférios necessários, vai ser apenas uma descrição pessoal que não te levará à satisfação que talvez você deseja nessa jornada. Se sua única satisfação será poder dizer que é um hacker, sinto muito, isso é inútil. Você não está procurando viver por si mesmo, mas se auto-promover sem conhecimento de causa do que realmente a palavra significa. Esqueça o assunto e vá ler um livro. Ou melhor dizendo, vá navegar em sua rede social favorita...&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Indexando símbolos com rapidez</title>
  <link>http://www.caloni.com.br/indexando-simbolos-com-rapidez/</link>
  <pubDate>2015-10-28</pubDate>
  
  <guid>http://www.caloni.com.br/indexando-simbolos-com-rapidez/</guid>
  <description>&lt;p&gt;Trabalhar com inúmeros projetos de diferentes clientes e diferentes binários pode ser uma loucura. Quando o mundo é Windows, algumas medidas precisam ser padronizadas para evitar a perda de informação durante todo o processo de desenvolvimento, testes, deploy e manutenção.&lt;/p&gt;
&lt;p&gt;A respeito do deploy e manutenção, um dos principais é manter o código sempre atualizado, limpo e asseado, além de estar dentro de pelo menos um controle de fonte, de preferência distribuído (Mercurial, Git, Bazaar).&lt;/p&gt;
&lt;p&gt;Porém, voltando ao mundo Windows, os fontes não são apenas a única fonte de preocupação e zelo. Os binários também são importante. Binários eu digo os EXEs, DLLs geradas, além dos seus símbolos (PDBs), que contém o mapa entre aquele monte de 1s e 0s e o código-fonte de onde ele saiu.&lt;/p&gt;
&lt;p&gt;Nós da BitForge costumamos pelo menos indexar binários com fonte, através dos resources do binário. Como isso é feito? Basicamente editando o arquivo RC na parte da versão do binário e inserindo o hash do commit usado para gerar aquele binário. Com isso qualquer binário produzido possui seu pai (&amp;quot;use the source, Luke!&amp;quot;). Usamos um script em Python muito simples e muito eficaz para isso, que indexa .NET e C++ (através do Visual Studio, mas não está com muitas amarras de ambiente):&lt;/p&gt;
&lt;p&gt;Quando algum binário parar na máquina de algum cliente em algum lugar do universo, basta olhar para os detalhes pelo Windows Explorer, e ele estará lá.&lt;/p&gt;
&lt;p&gt;Através desses códigos em hexa podemos capturar o commit exato de onde saiu o binário. Tudo, é claro, confiando no procedimento de toda a equipe: apenas gerar um binário a partir de um commit publicado. Você também pode exibir a versão dos binários em uma pasta através das colunas do Windows Explorer.&lt;/p&gt;
&lt;p&gt;Outro detalhe de binários é que eles vivem sendo sobrescritos. Todo &amp;quot;Project, Build&amp;quot; sobrescreve o binário anterior, que pode ter sido justamente o enviado para o cliente. Se o cliente não possuir nenhum procedimento de armazenamento de versões dos binários gerados (às vezes ele nem precisa, essa é nossa função) não há como obter os símbolos de binários que podem gerar problemas futuros (todo software tem bug).&lt;/p&gt;
&lt;p&gt;Para resolver isso, o mínimo que se deve fazer é super-simples e nada difícil: crie uma pasta em algum lugar, nomeie essa pasta seu servidor de símbolos, a cada novo binário que será entregue, indexe o binário e os seus símbolos. Como? Com o &amp;quot;Debugging Tools for Windows&amp;quot;.aspx), como dizia um amigo meu, é mamão com açúcar:&lt;/p&gt;
&lt;p&gt;Essa e outra técnicas de indexar fontes e binário você pode ver no meu projeto, artigo, palestra e vídeo de demonstração. Se você for cego, ainda tem a vantagem da áudio-narração do vídeo. Brincadeira, ainda não temos isso.&lt;/p&gt;
&lt;p&gt;Com o poder do Windows Explorer, desde o Windows 95 podemos otimizar nossas tarefas nos baseando na extensão dos arquivos que estamos lidando. No caso do indexador de símbolos, eu simplesmente utilizo uma batch que contém exatamente a linha acima (com a diferença de %1 no lugar de MINHA-PASTA-COM-BINÁRIOS) que eu chamo direto do Explorer através de um comando que inseri no registro. Eis o comando:&lt;/p&gt;
&lt;p&gt;Você pode seguir o passo-a-passo dessas linhas e gerar seu próprio registro. Após feito isso, surgirá um novo comando para qualquer DLL que você clicar com o outro botão do mouse. Você também pode gerar o mesmo comando para EXEs, bastando realizar o mesmo passo-a-passo na pasta exefile em vez de dllfile.&lt;/p&gt;
&lt;p&gt;Procedimentos como esse devem ser uma coisa simples, não difícil. Programadores e pessoas são preguiçosas, e precisam de algum incentivo. E nesse caso, o incentivo é: o que você vai fazer quando der um crash com um binário que você não sabe de onde veio nem qual fonte foi usado para compilá-lo? Pois é.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>É o fonte, idiota!</title>
  <link>http://www.caloni.com.br/e-o-fonte-idiota/</link>
  <pubDate>2015-09-12</pubDate>
  
  <guid>http://www.caloni.com.br/e-o-fonte-idiota/</guid>
  <description>&lt;p&gt;Saiu um artigo recente no The Old New Thing (thanks Strauss pelo tuíte) que fala sobre não misturar runtimes do C de diferentes versões do compilador (especialmente se essas versões estão separadas pelo tempo em nada mais nada menos que dezenove anos!). Concordo. Aliás, a cultura Microsoftiana do uso de binários carece em C/C++ de um fundamento que facilite o reúso e compartilhamento de código exatamente por essa incompatibilidade inerente de uma biblioteca, se não em constante evolução, em constante aprimoramento pontual (como a STL). Como compartilhar código cujo fonte esteja indisponível e cujas bibliotecas sejam incompatíveis porque o projeto não é atualizado há dois pares de anos? Fiz uma vez um artigo explicando como usar a LIBC nativa do sistema operacional (nem sei se isso funciona ainda, provavelmente não). No entanto, essa é uma solução sub-ótima para um problema latente.&lt;/p&gt;
&lt;p&gt;É por isso que nesse caso a cultura Linux de compartilhamento do código-fonte acaba por ser a mais flexível e melhor adaptável à mudança dos tempos. Se você encontrou uma LIB que pode te ajudar, baixe e compile usando o último compilador. Se o compilador não consegue mais gerar binário sem gerar erros antes, configure os parâmetros de compilação como eram na época que a LIB foi gerada. A runtime do C (e de qualquer outro framework) que será usado é o da sua máquina. Afinal de contas, é o que faz mais sentido, não? Por que hoje existem diferentes conjuntos de DLLs de runtime de diferentes versões do Visual Studio instalados em sua máquina? Por que os instaladores precisam se preocupar em compartilhar essas DLLs corretamente?&lt;/p&gt;
&lt;p&gt;Questões de um passado remoto que voltam a bater à porta sempre que a Microsoft resolve lançar um novo Visual Studio. E isso irá se tornar cada vez mais constante, já que versões com começo e fim bem-definidos são um conceito também antigo, quando comprávamos pela licença de uma versão específica do programa. E hoje, no modelo de assinaturas, como fica?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O Estranho Caso do PDB Mal-Aformado</title>
  <link>http://www.caloni.com.br/o-estranho-caso-do-pdb-mal-formado/</link>
  <pubDate>2015-08-19</pubDate>
  
  <guid>http://www.caloni.com.br/o-estranho-caso-do-pdb-mal-formado/</guid>
  <description>&lt;p&gt;Era uma vez, há 13 anos atrás, um tal de Visual Studio .NET, que iria trazer a felicidade para nós, meros mortais usuários de programinhas em C com ponteiro pra lá e ponteiro pra cá. Agora a Microsoft traria para o pessoal do &amp;quot;baixo nível&amp;quot; a mais nova novidade do verão: uma IDE lenta, bugada e... bonita?&lt;/p&gt;
&lt;p&gt;Bem, para os que estavam acostumados com o Visual C++ 6.0, nada foi mais incômodo do que esperar carregar o programa de manhã para conseguir finalmente compilar. Ajustadas as expectativas, os projetos foram aos poucos migrados para aquela nova forma de configurar EXEs, DLLs, LIBs e OCXs.&lt;/p&gt;
&lt;p&gt;E eis que alguém, muito provavelmente eu mesmo, naquele momento de inspiração, criei a seguinte configuração para a geração dos PDBs, os símbolos para depurar programas no Windows. C/C++, Output File, Program Database File Name = &amp;quot;$(IntDir)/$(ProjectName).pdb&amp;quot;.&lt;/p&gt;
&lt;p&gt;Faz sentido, não? Afinal de contas, o PDB costuma ter o nome do projeto, e ele já está setado até em outro lugar para gerar com o mesmo nome. Nada de novo no front. Em Linker, Debugging, Generate Program Database File vemos &amp;quot;$(OutDir&amp;quot;$(ProjectName).pdb&amp;quot;.&lt;/p&gt;
&lt;p&gt;Até aí tudo bem. Aliás, tudo ficou muito bem por estranhos 13 anos. Até que alguém decidiu migrar para o já não tão novo Visual Studio 2013, onde tudo correu muito bem por algumas horas... talvez 13. Até que a depuração de repente parou de funcionar.&lt;/p&gt;
&lt;p&gt;Será o benedito? Ou o co-piloto?&lt;/p&gt;
&lt;p&gt;Pesquisando nos fóruns da vida, antro dos desesperados, achei/lembrei de um comando muito útil no WinDbg que não apenas diz se os símbolos estão &amp;quot;mismatch&amp;quot;, ou seja, os símbolos ou o PDB não está combinando com o EXE, mas também por quê.&lt;/p&gt;
&lt;p&gt;Bom, para saber se está mismatch é aquela fórmula de bolo:&lt;/p&gt;
&lt;p&gt;Para saber o que está errado, o famigerado !IToldYouSo&lt;/p&gt;
&lt;p&gt;Mano, como assim?!?!? Eu acabei de compilar esse binário, eu já apaguei 15 vezes as pastas de Debug e Release, eu já rebootei mais do que o Windows me obriga a rebootar por causa das falhas de segurança.&lt;/p&gt;
&lt;p&gt;Pois, então, desesperançado, crio um projeto novo para comparar as configurações, e voltamos 13 anos atrás, naquele fatídico dia, e entendo por que o nome do PDB temporário não é igual. Bom, na verdade não entendo, mas intuo que tenha alguma relação:&lt;/p&gt;
&lt;p&gt;E, de fato. Solução? Copie as configurações usuais do &amp;quot;novo&amp;quot; Visual Studio comparando com o velho.&lt;/p&gt;
&lt;p&gt;Abaixo a chamada do suporte em inglês, se alguém achar o mesmo problema em algum fórum e quiser &amp;quot;espalhar a palavra&amp;quot;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Just got stuck in the same problem, but in a C++ source that has 13 years, where its first solution was in VS 2003. Comparing the Project Properties in C/C++, Output Files, Program Database File Name, I found out that the project was pointing to the same file path that Linker, Debugging, Generate Program Database File, when the normal situation is to generate a vc120.pdb. Comparing with a new project, the &amp;quot;right&amp;quot; value can&#39;t be $(OutDir)$(TargetName).pdb (ou ProjectName), but $(IntDir)vc$(PlatformToolsetVersion).pdb. That solved the problem. I hope solve another one&#39;s problem as well =)
Minha próxima tarefa, aparentemente, é ver como sendo sócio da BitForge e da Intelitrader, e mesmo tendo já atualizado meu perfil MVP há anos, continuo sendo funcionário da UOL Diveo/Broker =/&lt;/p&gt;
&lt;/blockquote&gt;
</description>
</item>

     
        <item>
  <title>Você sabe o que está usando no seu código?</title>
  <link>http://www.caloni.com.br/voce-sabe-o-que-esta-usando-no-seu-codigo/</link>
  <pubDate>2015-07-28</pubDate>
  
  <guid>http://www.caloni.com.br/voce-sabe-o-que-esta-usando-no-seu-codigo/</guid>
  <description>&lt;p&gt;Quando se mexe com C++ em múltiplos fontes logo vem aquela bagunça do versionamento e do compartilhamento de código. LIBs, DLLs, COMs (de Component Object Model, da Microsoft). É difícil a partir de um binário saber quais os fontes envolvidos em sua construção, a não ser que você os amarre através de um sistema automatizado de build onde todos os binários devem ser obrigatoriamente compilados (e suas dependências, claro).&lt;/p&gt;
&lt;p&gt;Porém, há maneiras mais descentralizadas de se trabalhar. Alguém poderia simplesmente colocar a versão em cada CPP e atualizá-la, assim como comentários de histórico, toda vez que alguma mudança for feita:&lt;/p&gt;
&lt;p&gt;OK, esse já é um modelo interessante, embora totalmente descartável se você já usa um sistema de build atrelado a um controle de fonte, já que você automaticamente já terá um número mágico para relacionar seus binários: o revno de seu commit (ou seus commits, no caso de mais de um repositório).&lt;/p&gt;
&lt;p&gt;Uma versão um pouco mais... &amp;quot;binária&amp;quot;, seria inserir uma string no próprio fonte com essa versão, e talvez até o nome de seu módulo/lib/etc:&lt;/p&gt;
&lt;p&gt;static const char* LIBVERSION = &amp;quot;minhalib 0.0.1&amp;quot;;&lt;/p&gt;
&lt;p&gt;Dessa forma, por pior que seja a situação do controle de seus binários, sempre haverá a possibilidade de procurar a string lá dentro.&lt;/p&gt;
&lt;p&gt;Ops, esqueci que nesses compiladores modernos o que você não usa não será incluído no binário final. Isso quer dizer que se quisermos que essas strings de identificação de dependências apareça no binário compilado precisamos pelo menos dar a impressão de que ele esteja sendo usado:&lt;/p&gt;
&lt;p&gt;Agora uma variável estática do módulo deverá ser inicializada como um objeto da classe Using e irá jogar em uma variável estática dentro do construtor. Se ela será usada fica a dúvida do compilador, que deixa tudo como está. Ou seja, ganhamos nossa string no binário:&lt;/p&gt;
&lt;p&gt;Uma solução mais genérica pode ser aplicada utilizando as famigeradas macros e...&lt;/p&gt;
&lt;p&gt;O quê?!?!?!??! VOCÊ DISSE MACROS?!???!? TÁ MALUCO??!??!&lt;/p&gt;
&lt;p&gt;Sim. Macros. São inofensivas se você usar direito.&lt;/p&gt;
&lt;p&gt;E se reclamar vai ter goto.&lt;/p&gt;
&lt;p&gt;A ideia é que qualquer pedaço de código, seja um conjunto de CPPs que você chama de LIB, ou um CPP que você compila em diferentes projetos (talvez em cópias diferentes ainda sendo usadas), ou até aquela função-chave, ou classe-chave. Na verdade, quando eu digo pedaço de código, é pedaço mesmo. Está livre para você imaginar e rotular o que quiser. Depois você consegue dar uma geral no resultado:&lt;/p&gt;
&lt;p&gt;Com esse simples mecanismo que não gasta mais do que algumas chamadas de assembly no início da lib (antes do main) e o espaço ocupado na memória pelas strings somadas (menos de 1KB, provavelmente) você tem em suas mãos uma poderosa ferramenta de análise de como os binários estão sendo gerados pela sua equipe remota, ou por qual configuração foi usada na máquina de build para gerar aquela DLL com aquele problema antigo, ou porque algo que funcionava parou de funcionar e nada foi mexido (isso nunca acontece, não é mesmo?).&lt;/p&gt;
&lt;p&gt;O código dessa brincadeira está no meu repositório de samples do GitHub.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Logs em serviços (e outras coisas)</title>
  <link>http://www.caloni.com.br/logs-em-servicos-e-outras-coisas/</link>
  <pubDate>2015-06-05</pubDate>
  
  <guid>http://www.caloni.com.br/logs-em-servicos-e-outras-coisas/</guid>
  <description>&lt;p&gt;Já uso logs há muito tempo. Me lembro muito bem que quando programava em BASIC o &amp;quot;passou por aqui&amp;quot; já era útil. Depois de fazer muitas bibliotecas super-flexíveis de escrita em saídas diferentes, níveis configuráveis e uso do mais complexo ao mais banal, cheguei à seguinte conclusão:&lt;/p&gt;
&lt;p&gt;Vou tentar defender meu ponto de vista.&lt;/p&gt;
&lt;p&gt;Esse artigo do Dr. Dobbs explica de uma maneira bem completa como fazer uma lib de log leve e configurável. O que eu peguei desse exemplo foi a forma mais C++ de formatar as linhas, deixando para trás o estilão printf que depois de variadic templates já está datado.&lt;/p&gt;
&lt;p&gt;Por que eu acho a minha versão mais legal (não valendo falar que foi porque eu fiz):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;É mais simples ainda, tem poucas linhas e pode ser copiada sem peso na consciência. Pode até estar em um header que o overhead é mínimo.&lt;/li&gt;
&lt;li&gt;Não requer configuração de arquivo, debug output, named pipe, etc. Isso tem a ver com o uso de cada um. O próximo motivo explica melhor isso.&lt;/li&gt;
&lt;li&gt;Se for executado em um prompt já exibe as informações para serem filtradas; se for executado como um serviço encapsulo a saída.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Encapsular a saída e o comportamento de um serviço hoje em dia é algo banal. Há diversos programas que fazem isso para você, sendo desnecessário programar toda aquela parte de comunicação com o Windows. O cara do DriverEntry (vulgo o kernel-mode programmer motta-focka Fernando) fez um aplicativo que faz isso, que é simples de usar e continua funcionando no Windows 8.1. Atualmente uso um outro encontrado pelo igualmente fodástico Rodrigo Strauss: o Non Sucking Service Manager (seu nome já explica por que defendo utilizar o mínimo possível das firulas da Microsoft).&lt;/p&gt;
&lt;p&gt;Além de ser extremamente flexível e não ter falhado nas vezes que o utilizei, o NSSM consegue redirecionar a saída do aplicativo que encapsula como um serviço para um arquivo e rotacionar o arquivo por tamanho ou data (ou reexecução do serviço). Abaixo uma receitinha básica para configurar seu aplicativo:&lt;/p&gt;
&lt;p&gt;(para quem está se perguntando, 10485760 bytes são 10 MB.)&lt;/p&gt;
&lt;p&gt;Com essa forma de fazer serviços, há uma dupla vantagem:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Retirar todo o código para lidar com o Service Manager do Windows das suas mãos.&lt;/li&gt;
&lt;li&gt;Continuar tendo um aplicativo que roda pelo prompt e já imprime seu comportamento (e pode ser redirecionado também).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E ainda uma vantagem-bônus:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Você pode executar programas-filho que o redirect para o log vai funcionar do mesmo jeito.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Acho que cada um deve escrever no seu header o que achar melhor para depurar seus programas. No entanto, acho válido compartilhar quais são as informações que tem sido úteis para mim:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Depurando até o fim do mundo e de volta de novo: source server com GitHub</title>
  <link>http://www.caloni.com.br/depurando-ate-o-fim-do-mundo-e-de-volta-de-novo-source-server-com-github/</link>
  <pubDate>2015-05-26</pubDate>
  
  <guid>http://www.caloni.com.br/depurando-ate-o-fim-do-mundo-e-de-volta-de-novo-source-server-com-github/</guid>
  <description>&lt;p&gt;Semana passada fiquei sabendo que o vídeo da minha palestra &amp;quot;Depurando até o fim do mundo&amp;quot; do TDC 2014 estava disponível online. Resolvi assistir para ver se aprendia alguma coisa. A despeito do palestrante ser muito ruim, ele disse uma coisa interessante: com o Debugging Tools (WinDbg para os íntimos) seria possível além de indexar os símbolos (PDBs para os íntimos) usando o esquema de Symbol Server que a própria Microsoft adota usar algumas ferramentas embutidas para conseguir obter o fonte através de um símbolo indexado.&lt;/p&gt;
&lt;p&gt;E de onde viria esse fonte? Bom, a priori é necessário que exista algum controle de fonte para que as versões estivessem já &amp;quot;indexadas&amp;quot; nesse controle e fossem mapeados com strings internas no PDB. Através dessas strings o WinDbg ao analisar um crash dump ou até mesmo depurando um processo com o uso do PDB conseguiria baixar os fontes automagicamente desse controle de fonte, desde que ele estivesse acessível (na internet, na intranet da própria empresa, na rede, em um disco rígido externo ou na própria máquina do desenvolvedor que não quer se matar para conseguir obter a versão exatada dos fontes daquele binário).&lt;/p&gt;
&lt;p&gt;O detalhe que o palestrante (Caloni é o nome do sujeito) citou era que já existiam scripts prontos para realizar essa tarefa para os controles de fonte mais comuns, sendo que os mais comuns são: Source Safe (?????), CVS (????????) e, claro, Subversion! (?!?!?!?!??!??!?!).&lt;/p&gt;
&lt;p&gt;OK, pelo visto o pessoal da Microsoft mora em uma caverna ou não estão muito interessados em indexar os fontes para alguns controles de fonte que estão surgindo por aí, como Git sendo um exemplo aleatório.&lt;/p&gt;
&lt;p&gt;Já que o tal do Caloni disse que ainda não fizeram scripts para controles mais modernos. Nenhum descentralizado ainda está na lista. Os scripts são feitos em Perl, ou seja, estão disponíveis em uma linguagem um pouco mais fácil que .BAT. Ou talvez não. De qualquer forma, não parece muito difícil de entender a dinâmica do WinDbg e simplesmente gerar o que tem que gerar dentro dos PDBs.&lt;/p&gt;
&lt;p&gt;Pensando nisso, resolvi fazer uma primeira versão, em Python, de um script em que você passa alguns dados e ele processa seus PDBs. Depois você pode jogá-los em um Symbol Server e quando o WinDbg encontrá-lo através de um binário analisado, este irá conter o endereço no GitHub e um comando do Curl para baixá-lo, passando a exibi-lo imediatamente na tela do WinDbg. E nada mais lógico do que criar um repositório no GitHub para compartilhá-lo, certo?&lt;/p&gt;
&lt;p&gt;O funcionamento é muito simples, mas pede muitos parâmetros (recomendo criar um batch para armazená-los). Então vejamos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dbgtools é o caminho onde está o Debugging Tools for Windows;&lt;/li&gt;
&lt;li&gt;pdbpath é o caminho de onde devem ser pegos os PDBs, como um output da vida;&lt;/li&gt;
&lt;li&gt;projname é porque preciso do nome do projeto com escopo do usuário para compor a URL, e.g. Caloni/GitIndex;&lt;/li&gt;
&lt;li&gt;repo é o caminho do repositório local, pois o remoto eu já consigo pegar com o projname.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Um detalhe importante: o revno que será usado é o HEAD do repositório local. Sim, futuramente podemos adicionar esse argumento como opcional. Porém, no momento, coisas mais urgentes devem ser feitas. Uma delas é que estou usando a visualização raw do GitHub para conseguir pegar um único arquivo-fonte, e para isso uso a ferramenta curl. Ou seja, quem é de Windows vai precisar baixar uma de suas versões e deixar no path do sistema. Quem não é de Windows... o que você está fazendo com um PDB, rapaz?&lt;/p&gt;
&lt;p&gt;Como esse ainda é um projeto muito cru, mas gostaria de compartilhar com vocês (pois algo muito cru é melhor que nada), deixei diversos batchs de teste para ficar mais claro o funcionamento do srcsrv. Há um doc muito bom (er... ou mais ou menos) sobre o seu funcionamento na pasta srcsrv (chama-se srcsrv.doc). Usei algumas informações de lá para conseguir fazer a coisa funcionar. Se quiser me ajudar no projeto, tiver alguma dúvida, sugestão de melhoria/evolução, vamos conversar! Esse projeto será muito útil para mim no futuro, e espero que seja muito útil para outras pessoas, também.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Analisando erros pelo filtro do File Monitor</title>
  <link>http://www.caloni.com.br/analisando-erros-pelo-filtro-do-file-mon/</link>
  <pubDate>2015-05-06</pubDate>
  
  <guid>http://www.caloni.com.br/analisando-erros-pelo-filtro-do-file-mon/</guid>
  <description>&lt;p&gt;As ferramentas da SysInternals fazem a gente economizar um tempo considerável na resolução de problemas. Não que elas sejam indispensáveis. Tudo que elas fazem é encurtar o caminho entre a análise de um bug e sua resolução, o que acaba sendo muito se considerarmos que programação é 20% codificação e 80% transpiração. Ela é um atalho para muitas coisas, desde achar uma ordem de includes no header errada durante a compilação ou descobrir que por que um processo morreu durante o login.&lt;/p&gt;
&lt;p&gt;Curiosamente ambos os exemplos que citei são de uma mesma ferramenta: Process Monitor, ou carinhosamente procmon. Ele é um filho de duas ferramentas hoje extintas, FileMon e RegMon (acho que não preciso explicar o que ambas faziam). Todas são baseadas em drivers que escutam eventos do sistema operacional e um aplicativo que mastiga essa informação e as filtra de diferentes e criativas formas. Vamos utilizá-lo depurando um instalador muito sacana.&lt;/p&gt;
&lt;p&gt;A SoSo Company é uma empresa criada na China e que possui programadores muito bons. Eles são altamente especializados em fazer instaladores, e nas horas vagas ainda fritam pastéis de frango (ou &amp;quot;flango&amp;quot;, como os nativos costumam chamar). Porém, alguma coisa está acontecendo com uma nova versão do instalador que está dando erro ao rodar o aplicativo após atualizado.&lt;/p&gt;
&lt;p&gt;Isso só acontece em algumas máquinas, na maioria delas tudo funciona perfeitamente. Tanto que esse erro só foi encontrado depois de centenas máquinas terem sido atualizadas. E o primeiro a descobrir esse erro foi um cliente muito importante para a Soso. Entre as máquinas desse cliente muito importante, o erro foi acontecer justamente na máquina do CEO da empresa. (Qualquer semelhança com a vida real não é mera coincidência.)&lt;/p&gt;
&lt;p&gt;O analista Juquinha, do suporte técnico terceirizado na Índia sul-americana, foi chamado para dar uma olhada nesse problema. Como os chineses não confiam em um não-comedor de pastel de flango, Juquinha não terá acesso ao código-fonte do produto, mas poderá dar uma espiada no instalador. Ei-lo:&lt;/p&gt;
&lt;p&gt;Ahhh, bom. O instalador copia tudo e não verifica erro nenhum. Afinal de contas, o que pode dar errado, não é mesmo?&lt;/p&gt;
&lt;p&gt;Vamos agora dar uma olhada no código do aplicativo, coisa que nosso analista não terá a oportunidade.&lt;/p&gt;
&lt;p&gt;O produto é constituído de três binários: myapp.exe, myanotherapp.exe e mydll.dll. Os dois executáveis usam a DLL (no bom sentido). Cada um deles chama a DLL para realizar algumas operações.&lt;/p&gt;
&lt;p&gt;Na DLL há apenas uma função exportada: Version1. Quer dizer, na versão sendo atualizada foi criada uma nova função, a Version2. Vejamos a versão final:&lt;/p&gt;
&lt;p&gt;Como já vimos, o instalador da SoSo não está muito preocupado em capturar erros. Haja o que houver, o mundo continua maravilhoso. Porém, depois da atualização esse erro explodiu na máquina do diretor. E agora?&lt;/p&gt;
&lt;p&gt;Sem saber muito bem o que fazer, mas com a possibilidade de testar a situação em uma nova máquina (de outro diretor), Juquinha resolveu rodar novamente o instalador, mas dessa vez com a companhia do ProcMon.&lt;/p&gt;
&lt;p&gt;Depois disso, para efeito de comparação, rodou o instalador em uma máquina qualquer onde a atualização funciona.&lt;/p&gt;
&lt;p&gt;Dica: Quando for comparar muitos eventos (ex: milhares), em vez de olhar um por um é mais fácil exportar para um CSV e deixar um comparador como o [WinMerge}(http://winmerge.org/) fazer o serviço. No entanto, para comparar muitas informações, algumas colunas precisam ser eliminadas, como o horário de execução dos eventos e o PID dos processos.&lt;/p&gt;
&lt;p&gt;E voilà! Parece que alguém está bloqueando a atualização de mydll, embora myapp conseguisse ser atualizado (logo concluímos que não é ele).&lt;/p&gt;
&lt;p&gt;Agora, se Juquinha é um analista de nível 1, ele precisará compartilhar suas descobertas com outras pessoas da equipe. Para isso, basta duplo-clicar em um evento e usar o botão de cópia. O resultado será um texto com todas as informações necessárias para uma análise aprofundada.&lt;/p&gt;
&lt;p&gt;OK, mas onde está o problema? Bom, aqui começa a pesquisa, mas se você já programou para Windows API já há algum tempo sabe que alguém abriu esse arquivo antes com um modo de compartilhamento incompatível com uma escrita (que é o que o nosso instalador tenta fazer). Para saber quem é o culpado, mais uma ferramenta da SysInternals vem a calhar: Process Explorer (eu ia dizer handle.exe, mas ele não funcionou em meus testes).&lt;/p&gt;
&lt;p&gt;Através da opção de menu Find, Find Handle or DLL o culpado se mostrou mais próximo do que imaginávamos. O myanotherapp.exe fica bloqueando a dll no momento da atualização! Na verdade, o grande culpado foi mesmo o programador desse instalador, que sequer tem ideia das centenas de erros que podem ocorrer durante uma instalação/atualização. Azar do suporte técnico desse produto =/&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Convenção de Chamada</title>
  <link>http://www.caloni.com.br/convencao-de-chamada/</link>
  <pubDate>2015-04-20</pubDate>
  
  <guid>http://www.caloni.com.br/convencao-de-chamada/</guid>
  <description>&lt;p&gt;Pergunta de um leitor:&lt;/p&gt;
&lt;p&gt;Resposta do Autor: Por que C é zoado :P&lt;/p&gt;
&lt;p&gt;OK, a verdade é que não existem (existiam?) muitas regras de sintaxe a serem respeitadas na linguagem pelo compilador. Antigamente, se não fosse colocado nenhum tipo de retorno era como se ele fosse int por default. Da mesma forma, se não colocar parâmetros vale tudo. É como se fossem os três pontinhos do printf. Afinal, você não ia querer ficar repetindo os parâmetros no .c e no .h, não é mesmo :D&lt;/p&gt;
&lt;p&gt;Isso me lembra também que havia a declaração &amp;quot;arcaica&amp;quot; da linguagem (já era arcaica antes mesmo do padrão de 1998 sair):&lt;/p&gt;
&lt;p&gt;Sim, sua suposição a respeito do vaargs faz todo sentido. E não, os parâmetros não são inutilizados justamente porque a função chamada pode fazer o que quiser que no retorno o chamador limpa a pilha (e o chamador sabe como ele empilhou os parâmetros-extra).&lt;/p&gt;
&lt;p&gt;O padrão de chamada da linguagem (lembra disso?) é cdecl. Isso quer dizer que o chamador é que &amp;quot;limpa a sujeira&amp;quot; depois da chamada. Isso é o que permite o &amp;quot;milagre&amp;quot; do printf (oooohhh ooohh oooooohhhh... sons de anjos cantando) receber n argumentos.&lt;/p&gt;
&lt;p&gt;Só vai dar problema se definir outro padrão de chamada ou se a função chamada mexer no que não devia (se esperar outros tipos ou número de argumentos, por exemplo).&lt;/p&gt;
&lt;p&gt;Agora que sabemos disso, o comportamento do valist nem deve parecer tão mágico assim. Na verdade, apenas saber que a pilha é onde estão todas as variáveis locais e os endereços de retorno das funções é o suficiente para explorar essa área de memória.&lt;/p&gt;
&lt;p&gt;Porém, o uso canônico na linguagem C e a forma mais educada de navegar nos parâmetros extras é usando o header stdarg.h. Isso porque C é uma linguagem independente de plataforma, e a priori não temos a mínima ideia de como os dados estão estruturados no computador. Essa visão das variáveis locais e etc é apenas algo que sabemos sobre a arquitetura PC (8086) porque já brincamos demais de assembly e seus registradores.&lt;/p&gt;
&lt;p&gt;Uma versão de quem já manja dos internals da arquitetura onde está programando e não se importa com portabilidade poderia simplesmente caminhar pela pilha a partir do endereço de argc.&lt;/p&gt;
&lt;p&gt;Repetindo: isso não é bonito, apesar de simpático. No entanto, se o objetivo é explorar a arquitetura, fique à vontade para navegar pela pilha a partir do endereço das variáveis locais.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Guia de alocação (nos clientes)</title>
  <link>http://www.caloni.com.br/guia-alocacao-nos-clientes/</link>
  <pubDate>2015-03-04</pubDate>
  
  <guid>http://www.caloni.com.br/guia-alocacao-nos-clientes/</guid>
  <description>&lt;p&gt;Se você trabalha com T.I. (nem precisa ser programação) e mora em São Paulo (ou qualquer outro lugar com pessoas paranoicas) então talvez em algum momento da sua carreira teve que ficar alocado (como uma memória que contém um vírus) em algum de seus clientes (ou da empresa onde trabalha/ou). Usando seus apetrechos pessoais dentro de uma mochila para zarpar no final do dia sem deixar rastros.&lt;/p&gt;
&lt;p&gt;Não é muito elegante deixar seus logins, seu perfil, seus favoritos e histórico no navegador que está usando, além de ser uma falha de segurança, já que trocar a senha de um perfil no Windows é procedimento natural &lt;del&gt;, além da própria segurança do SO deixar a desejar em alguns momentos&lt;/del&gt;. Por isso, segue algumas dicas que tenho usado e recomendo para quem também é essa memória corrompida, nem que seja por pouco tempo.&lt;/p&gt;
&lt;p&gt;O TrueCrypt está aposentado graças ao Bit Locker. No entanto, ele ainda pode ser uma mão na roda. E portátil. Basta carregar seu executável e seus drivers em algum lugar e executar e poderá criar um novo volume facilmente.&lt;/p&gt;
&lt;p&gt;Dentro desse volume devidamente encriptado com uma senha forte (ou talvez uma chave forte portátil) e algoritmos escolhidos fortes é possível colocar uma miríade de coisas. Eu gosto, por exemplo, de manter meus arquivos do Dropbox/Google Drive/One Drive dentro dele, escolhendo um drive fixo (adicionando aos favoritos). O jeito que meu DropBox se comporta é dar erro quando o volume não está montado, sendo que eu sou obrigado a me lembrar de montar o drive antes de começar a sincronização de arquivos de outros lugares que eu confio (meu notebook, por exemplo). Não que tenha nada muito relevante, mas a ideia é não deixar um rastro sequer, certo?&lt;/p&gt;
&lt;p&gt;Por fim, outra possibilidade para o navegador é também usá-lo a partir do drive encriptado. Existem versões portáteis do Firefox e Google Chrome. O Chrome funciona razoavelmente bem, perdendo alguns logins de vez em quando. Mas, ei, perder logins não é exatamente um problema de segurança, certo?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Origem do tipo char</title>
  <link>http://www.caloni.com.br/origem-do-tipo-char/</link>
  <pubDate>2015-01-26</pubDate>
  
  <guid>http://www.caloni.com.br/origem-do-tipo-char/</guid>
  <description>&lt;p&gt;Programadores C e C++, preparem-se para explodir as cabeças!&lt;/p&gt;
&lt;p&gt;No princípio... não, não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados srs. dos Laboratórios Bell, K. Thompson e D. Ritchie, criaram uma linguagem chamada B. E B era bom.&lt;/p&gt;
&lt;p&gt;O bom de B estava em sua rica expressividade. Sua gramática extremamente simples. Tão simples que o manual da linguagem consistia de apenas 30 páginas. Isso é menos do que as 32 palavras reservadas de C.&lt;/p&gt;
&lt;p&gt;As instruções eram definidas em termos de if&#39;s e goto&#39;s e as variáveis eram definidas em termos de um padrão de bits de tamanho fixo -- geralmente a word da plataforma -- que utilizada em expressões definiam seu tipo; esse padrão de bits era chamado rvalue.&lt;/p&gt;
&lt;p&gt;Como esse padrão de bits nunca muda de tamanho, todas as rotinas da biblioteca recebiam e retornavam sempre valores do mesmo tamanho na memória. Isso na linguagem C quer dizer que o char da época ocupava tanto quanto o int. Existia inclusive uma função que retornava o caractere de uma string na posição especificada:&lt;/p&gt;
&lt;p&gt;Sim! Char era uma função, um conversor de &amp;quot;tipos&amp;quot;. No entanto a própria variável que armazenava um char tinha o tamanho de qualquer objeto da linguagem. Esse é o motivo pelo qual, tradicionalmente, as seguintes funções recebem e retornam ints em C:&lt;/p&gt;
&lt;p&gt;Links interessantes para filólogos de plantão:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dennis Ritchie Home Page&lt;/li&gt;
&lt;li&gt;BCPL Reference Manual by Martin Richards&lt;/li&gt;
&lt;li&gt;Users&#39; Reference to B by Ken Thompson&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Por que o Visual Studio gera executáveis mutantes</title>
  <link>http://www.caloni.com.br/por-que-o-visual-studio-gera-executaveis-mutantes/</link>
  <pubDate>2015-01-11</pubDate>
  
  <guid>http://www.caloni.com.br/por-que-o-visual-studio-gera-executaveis-mutantes/</guid>
  <description>&lt;blockquote&gt;
&lt;p&gt;Esse é um post antigo que encontrei no meio dos meus emails de 2006, mas que contém uma boa dica para quem já entendeu o passo-a-passo da compilação, mas ainda tem sérios problemas quando os projetos ficam gigantes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Essa é a segunda vez que encontro esse mesmo problema. Como acredito que outras almas podem estar sofrendo do mesmo mal, coloco aqui uma breve descrição de como o VC8 faz para gerar um executável que, mesmo não dependendo das DLLs de runtime, não são executados em sistemas que suportam a interpretação do &amp;quot;.manifest&amp;quot;. De canja, um pequeno programa que exibe a lista dos programas instalados no sistema.&lt;/p&gt;
&lt;p&gt;Primeiro, precisamos de um solution que contenha um projeto console e uma LIB. O projeto console deve usar a LIB para fazer alguma coisa. No exemplo abaixo, estarei listando os programas instalados no Windows (os mostrados no painel de controle através da opção &amp;quot;Adicionar/remover programas&amp;quot;.&lt;/p&gt;
&lt;p&gt;Observação importante: para ignorar todas as estripulias da versão Debug, todos os testes foram compilados em Release.&lt;/p&gt;
&lt;p&gt;Primeiramente, modifico a configuração padrão dos dois projetos para não depender da DLL de runtime do VC. Isso está em Project, Properties, C/C++, Code Generation, Runtime Library. Depois executo em uma máquina virtual sem as runtimes do VC8 instaladas:&lt;/p&gt;
&lt;p&gt;Perfeito. Exatamente o que eu queria: um executável console que não dependesse de DLL nenhuma exceto as que já estão instaladas em um Windows ordinário.&lt;/p&gt;
&lt;p&gt;Agora, vamos imaginar que esse é um daqueles projetos enormes de 5 * 10 ^ 42 de linhas (obs: dramatização) e que meu aplicativo console está linkado com cerca de 3 * 10 ^ 666 de LIBs. E uma delas (a library do exemplo) está com a configuração original, ou seja, com a dependência da DLL de runtime. E ela usa a STL. Provavelmente o aplicativo console não irá compilar, mas isso não é problema, pois estamos acostumados a colocar a msvcrt.lib na lista de LIBs ignoradas, pois em muitos outros casos (que não vale a pena discutir aqui) esse workaround é válido. E tudo volta a funcionar. Quer dizer, linkar:&lt;/p&gt;
&lt;p&gt;O sistema no pode executar o programa especificado.&lt;/p&gt;
&lt;p&gt;Tudo bem, meu executável não é mutante ainda. Mas agora vamos trocar a chamada da nossa função que usa STL por uma função que não usa:&lt;/p&gt;
&lt;p&gt;Agora sim, a mutação fez efeito! Temos um aplicativo que não depende da DLL de runtime, mas que no meio das n LIBs que ele utiliza existe uma configurada com a dependência. Ignorando a msvcrt.lib e um warning na compilação encontramos uma mensagem de erro um tanto exdrúxula.&lt;/p&gt;
&lt;p&gt;Até agora, a maneira que eu tenho utilizado para rastrear esse problema é não ignorar a msvcrt e ir tirando as dependências das LIBs pouco a pouco, até que ocorra o erro de símbolo duplicado. Algo assim:&lt;/p&gt;
&lt;p&gt;Se você tiver realmente 3 * 10 ^ 666 de LIBs, boa sorte =).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Entendendo a Compilação</title>
  <link>http://www.caloni.com.br/entendendo-a-compilacao/</link>
  <pubDate>2015-01-04</pubDate>
  
  <guid>http://www.caloni.com.br/entendendo-a-compilacao/</guid>
  <description>&lt;p&gt;Fiz alguns slides a pedido dos organizadores do TDC 2014, já que a palestra que ministrei com esse tema foi para ajudar meu amigo-sócio Rodrigo Strauss que não havia preparado nenhum slide a respeito.Felizmente eu já havia explicado alguns conceitos-chave para quem programa em C/C++ e precisa -- eu disse: PRECISA -- conhecer todo o passo-a-passo que leva o seu código-fonte a gerar um executável com código de máquina pronto para rodar.&lt;/p&gt;
&lt;p&gt;Como havia explicado anteriormente, existem três processos principais e clássicos (pode haver mais, dependendo do compilador, ambiente, etc) na formação de um código de máquina a partir de arquivos-fontes escritos em C ou C++ (ou ambos, são intercambiáveis). São eles: preprocessamento, compilação e linkedição.&lt;/p&gt;
&lt;p&gt;O preprocessamento é um trocador de textos. No máximo há macros, em que é possível passar argumentos (no formato texto). Exemplos são include, ifdef e define.&lt;/p&gt;
&lt;p&gt;A compilação é o núcleo da linguagem. Regras de sintaxe e gramática são validadas aqui pelo compilador. Cada compilação bem-sucedida recebe uma unidade de tradução e cospe um arquivo-objeto, que ainda não é executável, mas que já passou pela validação da linguagem.&lt;/p&gt;
&lt;p&gt;Por fim, a linkedição junta todos os arquivos-objeto, procurando ligar os nomes das funções e variáveis referenciadas um pelo outro. Os nomes externos são importantes neste passo para que o linker encontre as lacunas que precisa para consertar os saltos e assim gerar o executável final, que pode ser um programa com uma função main ou uma biblioteca dinâmica carregada por outro programa compilado seguindo esses três passos.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Houaiss Para *</title>
  <link>http://www.caloni.com.br/houaiss-para/</link>
  <pubDate>2014-10-25</pubDate>
  
  <guid>http://www.caloni.com.br/houaiss-para/</guid>
  <description>&lt;p&gt;O projeto Houaiss2Babylon, iniciado há mais de 6 anos, já devia estar ultrapassado. Porém, cada vez mais pessoas compartilham seus usos e desusos do que foi um dia uma base de dados ofuscada e presa a apenas uma interface Windows. Agora, além de já ter sido convertido para Kindle, em Python e agora através do nodejs para o MySql!&lt;/p&gt;
&lt;p&gt;O jornalista e programador Arthur da Paz desenvolveu esta última novidade no programa e gentilmente compartilhou conosco direto no repositório original do HouaissParaBabylon, colaborando felizmente para que esse nome perdesse um pouco mais do sentido (Babylon já está meio ultrapassado, não?). Além disso ele encontrou a solução para um bug que invertia a ordem de apresentação das Rubricas, cujos detalhes ele explica nos comentários do post sobre a última versão.&lt;/p&gt;
&lt;p&gt;Muito obrigado ao Da Paz e a todos que colaboram e compartilham melhorias para esse projeto. Um dicionário não é nada sem as pessoas que o utilizam.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Shareando Ponteiros</title>
  <link>http://www.caloni.com.br/shareando-ponteiros/</link>
  <pubDate>2014-09-03</pubDate>
  
  <guid>http://www.caloni.com.br/shareando-ponteiros/</guid>
  <description>&lt;p&gt;Apesar de ter palestrado algumas vezes sobre Boost e STL nunca escrevi muito sobre esses assuntos aqui. O tamanho dessas bibliotecas assusta um pouco. Mas temos que começar de algum lugar.&lt;/p&gt;
&lt;p&gt;E por isso eu gostaria de saber de você, programador miserável, que passou poucas e boas nesses dez anos de padrão 98 brincando com templates quando eles ainda estavam em beta: se fosse para melhorar um aspecto da sua vida de código C++, qual seria? Qual é aquela coisa que te atormenta como insetos vidrados no seu monitor noite adentro?&lt;/p&gt;
&lt;p&gt;Se eu fosse você reponderia: alocação de memória e ponteiros. E portanto vamos matar dois coelhos com um template só usando smart pointers, que desalocam memória quando não precisamos mais dela e mantém os ponteiros gerenciados.&lt;/p&gt;
&lt;p&gt;&amp;quot;Ah, mas tem que usar uma biblioteca bizarra com milhões de dependências e que vai quebrar todo o fonte aqui da empresa. Sem contar que vai ter que passar de novo pelos unit tests, vai dar erro de compilação, a LIB XPTO não funciona sem dar três pulinhos virado para a cafeteira e...&amp;quot;&lt;/p&gt;
&lt;p&gt;Cada caso é um caso, existe o melhor dos mundos e o pior. Mas (quase) todos têm solução. Mesmo que tudo que você tenha disponível seja um barbante e um clipe, podemos tentar alguma mágica/gambiarra/adaptação técnica. Vamos ver os casos mais comuns:&lt;/p&gt;
&lt;p&gt;Um cenário perfeito para começar. A única coisa que você precisa fazer em seus novos projetos e refatorações é incluir um único cabeçalho:&lt;/p&gt;
&lt;p&gt;E pronto! Se abriu um mundo mágico onde as alocações serão compartilhadas entre funções sem se perder quem deleta o quê. Não precisa nem checar se o ponteiro é nulo, basta alocar direto e jogar para dentro do nosso mais novo smart pointer da STL:&lt;/p&gt;
&lt;p&gt;E pronto: você nunca mais vai precisar se preocupar com quem deleta o ponteiro, nem quantas cópias desse ponteiro andam por aí. O sharedptr da STL, assim como a versão que já tem faz um tempo no boost, mantém um contador de referência para cada cópia do objeto que mantém o mesmo ponteiro &amp;quot;dentro de si&amp;quot;. Só quando esse contador chegar a zero, ou seja, não há mais ninguém referenciando essa região da memória, o ponteiro é deletado.&lt;/p&gt;
&lt;p&gt;O std::sharedptr funciona desde o SP1 do Visual Studio 2010. Sem Service Pack ou em versões mais antigas pode haver disponível no namespace tr1, resquício de quando esse novo padrão ainda estava em definição.&lt;/p&gt;
&lt;p&gt;Vou imaginar que você usa o Visual Studio 2003, um dos primeiros da safra &amp;quot;.NET&amp;quot;, que, mais uma vez, NÃO TEM QUALQUER RELAÇÃO COM C++ .NET.&lt;/p&gt;
&lt;p&gt;Bem, nesse caso, &amp;quot;welcome... to the desert... of the double&amp;quot;:&lt;/p&gt;
&lt;p&gt;Pois é, 37 erros. Depois perguntam por que as pessoas ficam com medo de programar em C++...&lt;/p&gt;
&lt;p&gt;Porém, a correção é mais simples do que parece: baixar o boost e trocar o nome do namespace.&lt;/p&gt;
&lt;p&gt;ATENÇÃO! Nos meus testes a única versão funcionando com o VS2003 foi a 1.47. Mas já é alguma coisa&lt;/p&gt;
&lt;p&gt;Não existe situação difícil que não possa piorar. Porém, mesmo nesse caso ainda há algo a se fazer, já que smart pointer utilizam mecanismos existentes na linguagem C++ desde os primórdios (ou bem próximo disso). Tudo que você precisa para criar seu próprio sharedptr é do construtor padrão, do destrutor padrão, do construtor de cópia e dos operadores de atribuição e ponteiro. E, claro, não se esqueça de usar template se for permitido. Se não for, a coisa complica, mas não se torna impossível.&lt;/p&gt;
&lt;p&gt;E é isso. A lição de hoje é: quem quer, arruma um jeito. Quem não quer, uma desculpa.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O novo &#39;como não dar step into&#39; do Visual Studio 2012/13</title>
  <link>http://www.caloni.com.br/o-novo-como-nao-dar-step-into-do-visual-studio-201213/</link>
  <pubDate>2014-08-01</pubDate>
  
  <guid>http://www.caloni.com.br/o-novo-como-nao-dar-step-into-do-visual-studio-201213/</guid>
  <description>&lt;p&gt;Toda vez que instalo um Visual Studio novo e começo a depurar sempre surge a necessidade de fazê-lo calar a boca nos step intos da STL, Boost, ATL e coisas que sei que não vai dar pau. (Obviamente, quando dá pau, preciso ir no disassembly e cutucar a STL para ela me entregar qual o problema com o meu contêiner.)&lt;/p&gt;
&lt;p&gt;Nas edições antigas da IDE (até o 2010) existia uma configuração no registro para isso. Desde o Visual Studio 2012 isso mudou, e agora existe um arquivo em %programfiles(x86)%\Microsoft Visual Studio 11(ou12).0\Common7\Packages\Debugger\Visualizers chamado default.natstepfilter (gostei do detalhe do &amp;quot;nat&amp;quot;: &amp;quot;nat thou step into, little bestard!&amp;quot;). Ele é um XML que já vem preenchido com algumas opções interessante:&lt;/p&gt;
&lt;p&gt;Podemos simplesmente adicionar mais duas opções para o parzinho STL/Boost:&lt;/p&gt;
&lt;p&gt;A boa nova, pelo menos para o Visual Studio 2013, é que agora é possível, se quisermos, entrar nas funções que serão ignoradas:&lt;/p&gt;
&lt;p&gt;Eu não sei qual vai ser a próxima novidade do step into, mas para mim, já está bem ótimo.&lt;/p&gt;
&lt;p&gt;(Fonte da informação: Andy Pennell&#39;s Blog).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Integrando BitBucket/GitHub com Trello</title>
  <link>http://www.caloni.com.br/integrando-bitbucketgithub-com-trello/</link>
  <pubDate>2014-07-22</pubDate>
  
  <guid>http://www.caloni.com.br/integrando-bitbucketgithub-com-trello/</guid>
  <description>&lt;p&gt;Eu nem acredito que estou escrevendo sobre desenvolvimento web, mas como foi algo que me fez dedicar algumas horas do meu fim-de-semana, e não encontrei facilmente uma solução já feita, acredito que pode ser útil para mais alguém que usa Trello e GitHub (ou BitBucket).&lt;/p&gt;
&lt;p&gt;Mas o que é Trello? Basicamente é um TodoList feito da maneira mais inteligente possível: uma lista de listas de listas! Os espaços, ou desktops, onde você organiza suas tarefas são chamados de Boards. Em cada board vivem L listas, e em cada lista vivem C cards. Cada card pode conter comentários, histórico de mudanças, labels, checklists, due dates e todas as tranqueiras que geralmente existe em uma lista de tarefas. É um sistema online, desenvolvido pela empresa do Joel Spolsky (o mesmo do excelente blogue de programador Joel on Software (ou em português, e que contém algo que eu adoro em sistemas web: atalhos!&lt;/p&gt;
&lt;p&gt;A ideia que tive foi usar os webhooks dos saites de repositórios de fontes para permitir comentar dentro dos cards o commit que foi feito, sua mensagem e o linque para o commit. OK, mas por que não usar o sistema de issues dos já feitos pra isso GitHub e BitBucket? Ele já faz isso muito melhor. De fato. Porém, fica espalhado pelos repositórios, e não é sempre que uma tarefa envolve código (comprar pão, por exemplo). Além do mais, praticamente qualquer serviço desses oferece hooks para a integração de outros projetos/serviços, então se um dia nascer mais um sistema de controle de fonte ou mais um saite que organiza essas tralhas haverá um hook e consequentemente mais uma adaptação do meu código PHP.&lt;/p&gt;
&lt;p&gt;E por que PHP? Bom, PHP é uma linguagem fácil de mexer (se parece com C, mas é um script) e praticamente qualquer servidor web do universo, mesmo o mais baratinho, vem com o pacote Apache + PHP (e geralmente uma base MySql). Dessa forma, é uma solução que pode ser implantada fácil e rapidamente.&lt;/p&gt;
&lt;p&gt;Vamos começar pelo mais difícil que o resto vai fácil: comentar pela API do Trello. Sua API é beta, assim como sua documentação, então tive arrancar significado inexistente em seu help, mas acabou funcionando. Como qualquer API web, você precisa de uma chave, segredo e a permissão do usuário. Com essa permissão é possível comentar em todas as boards que esse usuário específico tem acesso.&lt;/p&gt;
&lt;p&gt;Pelo menos a parte de geração de chave/segredo é simples. Depois disso, mesmo nessa página já é possível conseguir uma chave de acesso para o seu usuário.&lt;/p&gt;
&lt;p&gt;Por fim, para fazer o código que irá comentar dentro de um card no Trello, basta usar dois ou três métodos que lidam com enviar coisas pela web (não me pergunte mais que isso):&lt;/p&gt;
&lt;p&gt;As informações AQUIVAISUACHAVE e AQUIVAISEUTOKENDEACESSO você já obteve no linque de geração de key/secret. Já o IDDOCARD é algo que depende de em qual lista seu card está, mas felizmente também existe um shortlink único e imutável para cada card no sistema:&lt;/p&gt;
&lt;p&gt;Basta usar o ID em Base64-ou-o-que-o-valha no lugar de IDDOCARD que já estamos OK. Depois que este código conseguir ser executado, basta ter acesso à internet que ele irá escrever &amp;quot;Hello, World&amp;quot; no cartão referenciado:&lt;/p&gt;
&lt;p&gt;Muito bem. Primeira parte da missão concluída.&lt;/p&gt;
&lt;p&gt;Como o GitHub é um dos serviços de repositório de fontes mais famoso, vamos torná-lo nosso caso de sucesso. Basicamente você deve ir no seu repositório do coração (essa é a parte ruim: se você tem mais de um coração, vai ter que repetir esse mesmo procedimento para todos os outros repositórios dos seus outros corações), Settings, Webhooks &amp;amp; Services.&lt;/p&gt;
&lt;p&gt;Lembre-se de colocar seu código PHP em um servidor visível na web. Lembre-se também de usar o método de envio urlencoded do payload para simplificar seu tratamento. Para simplificar ainda mais o processo, coloque qualquer coisa no segredo (não validaremos neste post, mas #ficadica de segurança se você não quer que outros acessem seu PHP inadvertidamente).&lt;/p&gt;
&lt;p&gt;Pois bem. No código que irá receber o payload do GitHub precisamos de duas coisas: saber qual a estrutura que vai ser recebida e como localizar o id do card onde iremos enviar a informação. Nesse caso, mais uma vez, para simplificar, vamos procurar pelo próprio linque permanente do cartão na mensagem do commit. Aliás, doS commitS (sendo um push, é provável que o evento seja gerado com diversos commits aninhados).&lt;/p&gt;
&lt;p&gt;Agora é só testar. Posso pegar esse mesmo artigo e comitá-lo no repositório do blogue usando o linque único do card da tarefa de escrever este artigo. Ou seja, aqui é Inception na veia, mermão!&lt;/p&gt;
&lt;p&gt;O que vai deixar você perplexo é entender como esse texto está sendo comitado antes mesmo de eu comitar este texto ;).&lt;/p&gt;
&lt;p&gt;E o negócio é rápido, viu?&lt;/p&gt;
&lt;p&gt;A única coisa que muda no caso do BitBucket é a tela onde deve ser inserido seu webhook (método POST, sempre) e a estrutura JSon que é enviada. De lambuja, eis o que deve ser feito com esse payload:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Se iterando com os pseudo-ponteiros: uma breve introdução</title>
  <link>http://www.caloni.com.br/se-iterando-com-os-pseudo-ponteiros-uma-breve-introducao/</link>
  <pubDate>2014-06-24</pubDate>
  
  <guid>http://www.caloni.com.br/se-iterando-com-os-pseudo-ponteiros-uma-breve-introducao/</guid>
  <description>&lt;p&gt;Como já vimos algumas vezes, a STL não prima por interfaces intuitivas, preferindo abstrações que criem um leque de ferramentas genéricas para tratamento uniformizado de coleções de dados através de algoritmos. O problema disso é que novos programadores da linguagem terão que aprender uma maneira nova de lidar com problemas baseada na percepção dos criadores do padrão na época em que foi lançado de como seria a evolução da ciência da computação nos próximos anos. Muitos dos conceitos ali abordados realmente se tornaram padrão de facto, mas na briga pela expansão da linguagem quem perdeu por muito tempo foi o próprio desenvolvedor, que teve que se contentar com uma lista de algoritmos genéricos parcialmente compilado.&lt;/p&gt;
&lt;p&gt;Dito isto, a abstração dos iteradores é a coisa mais linda do mundo.&lt;/p&gt;
&lt;p&gt;Os dois únicos conceitos que é preciso se lembrar para sempre quando se trata de iteradores é que ele:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Um iterador se comporta como um ponteiro opaco.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O final de um contêiner está sempre um elemento além do último.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Um ponteiro pode ser iterador, mas não o contrário!&lt;/p&gt;
&lt;p&gt;Tudo que um ponteiro faz de útil em C/C++ foi emprestado para a STL usar em seus contêiners, e tudo em que ele é prejudicial tentou ficar de fora. E o que um ponteiro faz de útil?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Um ponteiro pode apontar para elementos sem conhecermos sua posição.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Podemos incrementar ou decrementar ponteiros para caminhar em listas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dois ponteiros podem ser subtraídos para sabermos a distância entre dois elementos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Da mesma forma, operações como cópia, movimentação, ordenação, caotização, pode ser feito usando dois ponteiros/iteradores de dois contêiners distintos, desde que algumas regras básicas sejam seguidas, como um iterador deve sempre apontar para algo válido (ou disponibilizar alguma abstração que insira novos elementos em um contêiner menor). Veremos essas regras em um próximo post sobre o tema. Apontarei para ele aqui.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Dando cabo do WinDbg</title>
  <link>http://www.caloni.com.br/dando-cabo-do-windbg/</link>
  <pubDate>2014-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/dando-cabo-do-windbg/</guid>
  <description>&lt;p&gt;Na semana passada falei sobre a ideia de comentar algumas mudanças entre o Windows XP e o novo mundo Vista/7/8/ que fizeram com que adaptássemos algum código que obviamente não funcionaria mais. Falamos sobre a famigerada GINA (ou famiGINADA), e agora apenas vou comentar brevemente sobre o sistema de boot, que também mudou.&lt;/p&gt;
&lt;p&gt;Na verdade, pouca coisa mudou, mas foi o suficiente para dar problemas na hora de usar o WinDbg. Tradicionalmente, o boot era gerenciado no Windows através de um arquivo localizado na raiz da partição ativa (configuração da MBR) chamado bootini. Dentro dele temos uma estrutura semelhante a um .INI (duh), onde a informação que vemos lá podia ser configurada nas configurações do Computador no Windows XP.&lt;/p&gt;
&lt;p&gt;Hoje em dia esse arquivo nem existe mais, o que pode dar um friozinho na barriga (&amp;quot;caramba, não vai mais bootar!!&amp;quot;). Agora, para sistemas baseados em BIOS há uma pasta Boot na raiz e um arquivo chamado bcd. Para os mais moderninhos, baseados em EFI, ele fica na partição EFI. Ah, EFI é Extensible Firmware Interface, e faz parte da especificação da UEFI (Universal blá blá blá), mais ou menos um padrão que define como deve ser feita a comunicação entre hardware e sistema operacional.&lt;/p&gt;
&lt;p&gt;Para a edição desse novo arquivo (ou partição) é necessário que seja usada a ferramenta BCDEdit no Windows. É ela que agora configura qual partição está ativa e, mais importante para escovadores de bits, qual pode ser depurada pela porta serial através do WinDbg.&lt;/p&gt;
&lt;p&gt;Porta serial? Mas que coisa antiga, hein? Pois é, muita coisa mudou desde o Windows Vista, mas algumas coisas precisam permanecer... compatíveis.&lt;/p&gt;
&lt;p&gt;Mas... se você precisar:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Eles querem que a GINA vá embora: três posts sobre evolução Windows</title>
  <link>http://www.caloni.com.br/eles-querem-que-a-gina-va-embora-tres-posts-sobre-evolucao-windows/</link>
  <pubDate>2014-06-11</pubDate>
  
  <guid>http://www.caloni.com.br/eles-querem-que-a-gina-va-embora-tres-posts-sobre-evolucao-windows/</guid>
  <description>&lt;p&gt;Fui convidado pela Fernanda Saraiva do programa de MVPs da Microsoft Brasil a falar sobre alguma história a respeito da evolução do Windows e como isso impactou minha experiência profissional. Pesquisando em meu próprio blogue fui capaz de lembrar não apenas de uma, mas de três mudanças técnicas que fizeram com que eu e minha &amp;quot;equipe&amp;quot; da época (geralmente mais alguém, no máximo) matássemos alguns neurônios tentando descobrir novas maneiras do sistema fazer o que já fazia no Windows XP. Irei compartilhar uma por vez no que tem sido o meu post semanal que eu apelidei carinhosamente de Post da Terça. Já faz mais de um mês que consigo publicar pelo menos na terça algo de novo, e espero manter esse ritmo.&lt;/p&gt;
&lt;p&gt;A primeira mudança técnica entre o Windows XP para o Windows Vista/7/8 que me lembro e que mais fez diferença para o sistema que mantínhamos com certeza foi a retirada da guerreira GINA, ou a Graphical Identification aNd Autentication, a gina.dll da Microsoft que implementava a mundialmente famosa tela de logon do Windows NT/2000/XP:&lt;/p&gt;
&lt;p&gt;Seja no formato Home Computer (a telinha de boas vindas) ou no tradicional &amp;quot;Pressione Ctrl+Alt+Del&amp;quot; do Windows NT ¿ quando a máquina está no domínio ¿ quem gerencia essa tela é o processo de sistema iniciado a partir do WinLogon.exe. O WINLOGON carrega a nossa amiga gina.dll que é quem realiza a autenticação dos usuários.&lt;/p&gt;
&lt;p&gt;Se você, programador de médio nível, quisesse implementar sua própria autenticação de usuários ¿ como a Novell possuía, diga-se passagem ¿ era necessário editar um valor no registro entrando a sua GINA personalizada. Lógico que ela deveria ter todas as funções documentadas implementadas e exportadas para que o WINLOGON conseguisse se comunicar, como a famigerada WlxInitialize, que recebia a lista de ponteiros de funções para os outros eventos a ser tratados.&lt;/p&gt;
&lt;p&gt;Com a vinda do Windows Vista, o WINLOGON continuou gerenciando as sessões e autenticações dos usuários, mas para evitar que a GINA monopolizasse novamente os métodos de autenticação, e com a vinda de métodos concorrentes ¿ como retina e impressão digital ¿ a Microsoft desevolveu uma nova interface chamada de Credential Provider. A implementação dessa interface não sobrescreveria novamente a &amp;quot;GINA&amp;quot; da vez, mas daria apenas uma alternativa para o logon tradicional com login e senha.&lt;/p&gt;
&lt;p&gt;O problema que nossa equipe enfrentou era que toda a autenticação do sistema dependia da manipulação dos eventos da GINA através da nossa GINA. Com ela colocada de escanteio, os logins parariam de funcionar.&lt;/p&gt;
&lt;p&gt;Depois de uma análise rápida foi constatado que não seria mais possível bloquear o login completamente, uma vez que existiam pelo menos duas alternativas de login que vieram com a instalação do Vista, e o fato de instalar mais uma apenas faria com que essa terceira alternativa não funcionasse, mas o usuário não estaria mais obrigado a &amp;quot;passar por nós&amp;quot;.&lt;/p&gt;
&lt;p&gt;A solução foi capturar detalhes do login através das fases subsequentes do login, incluindo a subida do shell (UserInit). Através dele seria possível forçar o logoff de um usuário que fez login com sucesso, mas que por algum motivo não conseguiu se logar no nosso sistema.&lt;/p&gt;
&lt;p&gt;Nem sempre o que estava rodando já há anos é a solução mais bonita. Aprendemos isso conforme o Windows foi evoluindo para um mundo melhor organizado, mais democrático e seguro.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>SS</title>
  <link>http://www.caloni.com.br/ss/</link>
  <pubDate>2014-06-03</pubDate>
  
  <guid>http://www.caloni.com.br/ss/</guid>
  <description>&lt;p&gt;Uma das coisas mais cretinas e difíceis para os iniciantes em C++ é conseguir formatar strings de maneira fácil, rápida e indolor. Infelizmente, a biblioteca de printf da linguagem C está fechada para reforma, pois ela é extremamente error-prone e não-intuitiva. Porém, se a printf é não-intuitiva, o que dizer &amp;lt; &amp;lt; daqueles &amp;lt;&amp;lt; sinais &amp;lt;&amp;lt; de &amp;lt;&amp;lt; flechinhas apontando para cout? Bem melhor, não?&lt;/p&gt;
&lt;p&gt;A resposta é, pra variar, depende. Se você combinar com seu cérebro que o operador de shift que você aprendeu em C para cout não tem a mesma semântica, OK. No fundo eu acredito que os criadores dessa sobrecarga de operador pensaram sinceramente que hoje em dia quase ninguém conhece os operadores de shift binário, então tudo bem reaproveitá-lo de uma maneira mais miguxa.&lt;/p&gt;
&lt;p&gt;Porém, isso depende da maneira com que você usa streams C++. Vai haver momentos de sua vida que você vai se questionar por que tiraram todo o controle, a elegância e simplicidade de um bom printf, quando os homens eram homens e sabiam configurar jumpers para instalar a nova placa EISA.&lt;/p&gt;
&lt;p&gt;A questão dos streams fica mais complicada quando precisamos realizar atividades corriqueiras no código, como retornar uma string formatada, ou até mesmo transformar um inteiro em string.&lt;/p&gt;
&lt;p&gt;Já pensou termos que criar uma função dessas sempre que quisermos converter números em string? Ou pior, ter que fazer o que fizemos dentro dessa função: declarar um ostringstream (um cout com buffer interno de string), usá-lo como cout e obter seu buffer interno através do método str. Tudo isso para converter um número para string.&lt;/p&gt;
&lt;p&gt;Quando uma tarefa muito comum exige mais de dois passos para ser realizada é de bom tom criarmos algum código reutilizável, certo? Um código que trará de uma vez por todas a solução final!&lt;/p&gt;
&lt;p&gt;O código acima serve bem ao nosso propósito de formatar strings em uma linha como um cout, mas retornar uma string no lugar. Ele é simples, ele é direto, ele tem defeitos que não vem ao caso (como não suportar endl), mas pode ser usado de maneira... simples e direta!&lt;/p&gt;
&lt;p&gt;OK, o código de exemplo foi idiota, mas você pegou a ideia. Tudo que precisamos fazer para reutilizar essa pequena classe é definí-la (ss() resolve) e usá-la. Seu conversor de string retorna o buffer interno de ostringstream para nós como num passe de mágica.&lt;/p&gt;
&lt;p&gt;Obs.: Com certeza deve existir uma centena de bibliotecas que implementam algo do gênero, só que melhor. Essa é a típica fica isolante para continuar trabalhando.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Desmontando o Aulete Digital</title>
  <link>http://www.caloni.com.br/desmontando-o-aulete-digital/</link>
  <pubDate>2014-05-27</pubDate>
  
  <guid>http://www.caloni.com.br/desmontando-o-aulete-digital/</guid>
  <description>&lt;p&gt;Este post não estará mais disponível devido ao mau uso de pessoas que se aproveitaram das minhas explicações didáticas a respeito do funcionamento da versão Desktop do dicionário e, agindo de má-fé, começaram a baixar a base de dados indiscriminadamente, fazendo com que o serviço que é disponibilizado gratuitamente aos usuários tivesse que ser desligado. É uma lástima que isso tenha ocorrido, e peço desculpas às pessoas que prejudiquei direta ou indiretamente.&lt;/p&gt;
&lt;p&gt;É condenável esse tipo de &amp;quot;ataque&amp;quot; a um serviço que é disponibilizado gratuitamente. Meu artigo teve apenas fins didáticos e não tem por objetivo o uso ilegal de uma ferramenta tão útil aos seus usuários.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Estruturas VS Classes: fight!</title>
  <link>http://www.caloni.com.br/estruturas-vs-classes-fight/</link>
  <pubDate>2014-05-20</pubDate>
  
  <guid>http://www.caloni.com.br/estruturas-vs-classes-fight/</guid>
  <description>&lt;p&gt;Uma dúvida besta e importante ao mesmo tempo que muitos iniciantes em C++ possuem é saber qual a diferença entre um objeto declarado como class e um objeto declarado como struct. A causa dessa dúvida é uma linguagem que se derivou de outra (C) que não possuía classes, e portanto criou a palavra-chave class para &amp;quot;ficar bonito&amp;quot;, pois, na prática, não muda muita coisa. Tomemos como exemplo o código mais simples de todos:&lt;/p&gt;
&lt;p&gt;Ele compila e roda sem problemas:&lt;/p&gt;
&lt;p&gt;&amp;quot;Estruturalmente&amp;quot; falando, MinhaEstrutura e MinhaClasse são idênticas, pois são os detalhes de sintaxe que diferem, e diferem pouco. Abrindo o jogo, a única diferença que poderá ser sentida em usar um ou outro é que structs possuem seus membros públicos por padrão e classes possuem seus membros privados por padrão. Apenas isso. O resto, nada muda.&lt;/p&gt;
&lt;p&gt;Isso pode ser visto quando adicionamos um construtor para nossos tipos de teste:&lt;/p&gt;
&lt;p&gt;Antes não havia problemas para MinhaClasse porque o construtor padrão criado para ela é público por default. Porém, explicitando no código um construtor e deixando sua privacidade ligada por padrão temos esse erro que NÃO ocorre em MinhaEstrutura.&lt;/p&gt;
&lt;p&gt;Mas, então, posso criar todas minhas classes usando a palavra-chave struct?&lt;/p&gt;
&lt;p&gt;Isso mesmo! Nada lhe obriga tecnicamente a usar class. Porém, assim como nada lhe obriga a usar uma linha para cada comando na linguagem ¿ afinal, todos poderiam estar na mesma linha separados por ponto-e-vírgula ¿ o uso da palavra struct para classes no sentido de &amp;quot;objetos que possuem inteligência, métodos, herança, polimorfismo e outras firulas&amp;quot; não se enquadra nas boas práticas dos programadores C++.&lt;/p&gt;
&lt;p&gt;Geralmente uma struct é uma forma de concatenar tipos primitivos e só. Algumas liberdades além disso geralmente são permitidas, mas desencorajadas, como um construtor que inicia os membros da struct com valores-default.&lt;/p&gt;
&lt;p&gt;E, por que não, uma sobrecarga do operador de stream para imprimirmos diretamente os valores de MinhaEstrutura para a saída com apenas um comando?&lt;/p&gt;
&lt;p&gt;Enfim, não há nenhum limite que se aplica à uma struct além do bom senso. A criação da palavra class não foi por falta do que fazer. Ela diz claramente que estamos definindo um objeto que contém usos mais adequados à orientação a objetos de C++ do que a programação estruturada de C, e vice-versa. É uma forma de tornar o código mais legível, mas nada do outro mundo. Sabemos, no final das contas, que o compilador trata as duas (quase) da mesma maneira.&lt;/p&gt;
&lt;p&gt;Qual será a próxima batalha épica? Você escolhe!&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=zn7-fVtT16k&#34;&gt;https://www.youtube.com/watch?v=zn7-fVtT16k&lt;/a&gt;&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>50 Anos de BASIC</title>
  <link>http://www.caloni.com.br/50-anos-de-basic/</link>
  <pubDate>2014-05-13</pubDate>
  
  <guid>http://www.caloni.com.br/50-anos-de-basic/</guid>
  <description>&lt;p&gt;Minha primeira linguagem de programação foi o BASIC. Aprendi durante minhas frequentes visitas à biblioteca lendo livros dos anos 80. Na verdade, eu não me lembro muito bem por que diabos resolvi aprender a programar, já que eu estava mais interessado em entender como um computador funciona. Por que? Não sei bem ao certo, parece que já nasci com um chip embutido que foi ativado quando comecei a tender muito para o lado de humanas ao iniciar a faculdade de Letras... um chip salvador!&lt;/p&gt;
&lt;p&gt;Enfim, um dos melhores livros que já li na minha vida não foi um cheio de letras, mas muito mais figuras: a Introdução Ilustrada à Computação, de Larry Gonick. Ele foi traduzido e publicado no Brasil pela Itautec e é um clássico absoluto sobre a história da computação, explicada de uma maneira que até um leigo completo conseguiria entender. E quando eu digo &amp;quot;computação&amp;quot; não estou me referindo a noções vagas sobre como o computador processa a entrada e gera saída. O ilustrador Larry Gonick fez um excelente trabalho em capturar a essência de cada inventor da história ¿ como Alan Turing, John Von Newmann, Charles Babbage e Ada Lovelace ¿ e cada conceito básico aplicado à invenção do computador, desde saldos condicionais (Lovelace), lógica booleana (George Boole), codificação binária e, pasmem... flip-flops!&lt;/p&gt;
&lt;p&gt;Enfim, depois de explicar tudo isso e mais um pouco, no seu último capítulo ainda há uma pequena introdução ao BASIC que vinha instalado nas máquinas daquela época. Bem rústico, mas capaz de enviar comandos para a máquina e executá-los. Não aprendi todos os comandos nesse livro, mas ele foi minha porta de entrada para leituras mais &amp;quot;densas&amp;quot;, que me fizeram evoluir de uma calculadora capenga (meu primeiro programa!) para um emulador do jogo Genius, com direito a efeitos sonoros, cores configuráveis e gravação de recordes, tudo no próprio executável (na época um .COM, onde isso era possível). Esse foi meu primeiro programa com mais de 1000 linhas que eu me lembro (e com mais de 10 GOTOs e GOSUBs, também).&lt;/p&gt;
&lt;p&gt;A modalidade mais popular do BASIC quando me interessei pelo assunto rodava no Windows 95 e se chamada QuickBASIC, ou QBasic, já em sua clássica versão 4.5. Passei longas horas com aquela tela de fundo azul na madrugada corrigindo erros, anotando detalhes no papel, refazendo a lógica mentalmente, até conseguir resolver o problema. Podia ser qualquer problema, pois ele viraria inevitavelmente a diversão da noite. Podia até ser um detalhe de implementação de uma função específica embutida: o F1 funcionava e era bem rápido.&lt;/p&gt;
&lt;p&gt;O BASIC é uma linguagem fácil de aprender, não tem muitos limites e seria a minha escolha para ensinar programação para crianças caso ainda não tivessem inventado Python. Ela tem o tipo de sintaxe que você pode literalmente sair programando. Uma linha de código já imprime alguma coisa na tela. A lógica do fluxo de execução é simples, e os GOTOs ajudam a ilustrar como funciona. A depuração é sem frescuras, e os erros de tantos saltos sem nó, para variar, é do programador. Se vira, agora, com tanta SUB!&lt;/p&gt;
&lt;p&gt;Os puristas irão dizer que o aprendiz precisa ser educado de acordo com as novas tendências de programação estruturada, orientada a objetos, ou 100% funcional. Porém, eles esquecem que a programação aprendida por autodidatas como eu não era algo que podia-se chamar trabalho. Ninguém imaginava naquela época, naquela idade, fazer algo tão divertido e ser pago para isso. Exatamente, divertido. Uma linguagem precisa ser divertida para que o programador se interesse em conversar através dela com a máquina. É óbvio que, quando amadurecer, enxergará as óbvias limitações de uma linguagem imperativa como BASIC e irá passar para algo mais elaborado, seja Pascal, Java, C, C++. Não importa. A ambição técnica e perfeccionista do programador, enquanto não o engole, torna qualquer linguagem divertida. E no começo, onde erros de compilação e a falta de ponto-e-vírgula pode desanimar qualquer um, BASIC tinha esse espírito selvagem de &amp;quot;faço tudo o que quiser nessa linguagem até virar homem e programar em C&amp;quot; (ou Assembly).&lt;/p&gt;
&lt;p&gt;Por tudo isso, e por muito mais, parabéns pelos seus 50 anos de vida, minha linguagem favorita para me fazer lembrar que programar pode ser divertido e despretensioso. BASIC, você é um amigão!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Poker Face</title>
  <link>http://www.caloni.com.br/poker-face/</link>
  <pubDate>2014-05-06</pubDate>
  
  <guid>http://www.caloni.com.br/poker-face/</guid>
  <description>&lt;p&gt;O segundo round da segunda fase do Code Jam passou nesse sábado. Disléxico que sou, consegui fazer apenas 8 pontos ¿ como todo mundo ¿ no teste small do problema B, que envolvia apenas dois loops aninhados (a versão large fica para outro post). Na verdade, estou aqui para expressar minha gratidão ao campeonato por ter aprendido mais uma bela lição vendo o código do primeiro colocado do primeiro round, vulgo Kaizero, um coreano que deu uma solução simples, rápida e prática para um problema de probabilidade tão error-prone que até os juízes do Google deram uma lambuja de alguns testes errados (sem contar que houve apenas a categoria small), e me fez pensar em quantas vezes pensamos em demasiado tentando encontrar a solução perfeita para algo que simplesmente... não precisa.&lt;/p&gt;
&lt;p&gt;Basta um hack e commit.&lt;/p&gt;
&lt;p&gt;O problema reza que existem dois algoritmos para embaralhar uma sequência numérica (de 0 a N): o bom e o ruim. Ambos traçam um loop do iníco ao fim pegando aleatoriamente um elemento da lista e trocando de lugar com o elemento que está sendo varrido no momento.&lt;/p&gt;
&lt;p&gt;A diferença entre o bom e o ruim é que o bom pega aleatoriamente apenas os elementos DEPOIS do elemento que está sendo varrido, enquanto o algoritmo ruim pega qualquer um dos elementos SEMPRE. Isso aparentemente e intuitivamente não parece interferir na aleatoriedade do embaralhamento, mas se levarmos ao extremo de embaralhar repetidas vezes somando a lista resultante percebemos uma tendência gritante do algoritmo ruim em manter o ordenamento inicial, ou pelo menos na média sempre tender para números menores no início e números maiores no fim, como pode ser visto nesse teste que fiz, gerado pelo Excel:&lt;/p&gt;
&lt;p&gt;O que eu tentei fazer durante meu fim-de-semana retrasado e o feriado foi encontrar um detector de aleatoriedade (aliás, encontrei um bem interessante chamado ent), tanto &amp;quot;na mão&amp;quot; quanto pesquisando. O que eu não imaginava foi que o teste que eu tinha feito no início usando uma simples planilha Excel era a solução óbvia (naquelas de é óbvio só depois que você vê). E foi essa a solução adotada por Kaizero.&lt;/p&gt;
&lt;p&gt;O que ele basicamente faz é acumular os resultados de três milhões de embaralhamentos feitos pelo algoritmo ruim e inferir através dos resultados que metade é bom e metade é ruim. O ruim fica do lado desbalanceado da sequência.&lt;/p&gt;
&lt;p&gt;Tão óbvio, tão simples, tão elegante.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Que geleia de mocotó</title>
  <link>http://www.caloni.com.br/que-geleia-de-mocoto/</link>
  <pubDate>2014-04-29</pubDate>
  
  <guid>http://www.caloni.com.br/que-geleia-de-mocoto/</guid>
  <description>&lt;p&gt;A primeira bateria de problemas da segunda fase do Code Jam me mostrou o porquê do seu nome: meu cérebro ficou feito geleia (ha ha ha). Não consegui resolver nenhum problema a tempo, mas não culpo o C++, que passei a usar para essa fase. É burrice aliada a pressão. Duas horas e meia para entender um problema é o tipo de coisa que me deixa pensando mais no tempo do que no problema. Tenho que melhorar isso.&lt;/p&gt;
&lt;p&gt;De qualquer forma, esse final de semana que passou foi dedicado a resolver o primeiro problema e quem sabe escrever um post a respeito. Imagino que todos tenham acesso ao enunciado e aos casos de teste, mas, por via das dúvidas, aqui vai uma descrição adaptada:&lt;/p&gt;
&lt;p&gt;Você é um fazendeiro hi-tech com uma vaca que tem um tablet. Não especifica se esse cowblet é um iPad, mas é uma possibilidade, já que como nenhum plugue parece encaixar nas tomadas de sua fazenda, é muito provável que você seja um Applemaníaco com um monte de gadgets que precisam de conversor vindos direto do eBay.&lt;/p&gt;
&lt;p&gt;Através do eBay também veio um engenheiro chinês cuja missão é resolver esse gato que o Sr. Fazendeiro fez em sua fazenda. Tudo que ele precisa fazer é girar gigantescos switches (ou disjuntores) que invertem a polaridade binária de cada um dos pino dos conectores das tomadas. Quando um plugue de dispositivo e uma tomada possuem a mesma configuração de bits é possível conectá-los. O objetivo final é que todos os N plugues conectem nas N tomadas depois de virados Y switches, sendo que quanto menos switches melhor (afinal, eles são gigantescos, e o chinês supõe-se que seja pequeno).&lt;/p&gt;
&lt;p&gt;O primeiro pensamento do programador preguiçoso (go, horse, go!) manda que usemos a velha força bruta e testemos todas as combinações possíveis de disjuntores, peguemos o com menor número de bits setados (inicialmente, todos estão em 0) e zás! Porém, o caso de teste tamanho large pressupõe que o limite de pinos das tomadas pode chegar a 40, o que seria responsável por nada mais nada menos que 2^40 combinações diferentes, ou 1.099.511.627.776 para ser exato. Isso dá mais de 1 trilhão! Mesmo que nosso código seja extremamente rápido e demore apenas um milissegundo para cada combinação, serão mais de 34 anos desperdiçados, que poderiam estar melhor investidos minerando bitcoins.&lt;/p&gt;
&lt;p&gt;Dessa forma, temos que traçar uma solução baseada nas combinações entre as tomadas e plugues, que, pelos limites da versão large dos casos de teste, podem ter a quantidade de 150, o que dá 150 * 150 = 22500 combinações de XOR.&lt;/p&gt;
&lt;p&gt;Sim, de XOR. O XOR aqui pode ser usado para detectarmos qual a combinação de switches precisamos para que cada tomada encaixa em cada dispositivo. Esse é o nosso conjunto universo de giros de disjuntores. Com esse conjunto em mãos fica fácil saber quais combinações são possíveis de encaixar todos os dispositivos: basta contar!&lt;/p&gt;
&lt;p&gt;Observação: note que retirei o wrapper costumeiro dos exercícios do Code Jam para não poluir demais o exemplo com código. E, na verdade, essa parte do código está compartilhada com todas as soluções (reuse!).&lt;/p&gt;
&lt;p&gt;O que aprendi dessa pequena aventura foi: não importa o quanto um problema pareça fácil, anotar em um pedaço de papel é o caminho mais curto entre a mente e o código.&lt;/p&gt;
&lt;p&gt;Que venha a segunda bateria de problemas!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>2048 motivos para não programar</title>
  <link>http://www.caloni.com.br/2048-motivos-para-nao-programar/</link>
  <pubDate>2014-04-24</pubDate>
  
  <guid>http://www.caloni.com.br/2048-motivos-para-nao-programar/</guid>
  <description>&lt;p&gt;Pronto, posso programar em paz. O jogo 2048 é uma lástima para todos os trabalhadores intelectuais que dependem de suas mentes para produzir algo que preste. Ele gerou mais posts no Hacker News do que a moda dos bitcoins (talvez não) e mais projetos no GitHub do que a busca para a cura do câncer (talvez não). Obviamente que este post vai gerar mais um gist Python para minha coleção.&lt;/p&gt;
&lt;p&gt;Não sou fã de jogos, e dos poucos que participei logo parei (exceções honrosas: Portal e Portal 2, esses malditos). Posso dizer o mesmo de 2048, a versão de uma espécie de jogo já conhecido feita pelo italiano Gabriele Cirulli em um fds para descobrir se seria capaz de fazê-lo. Ele o fez e de brinde também fez o índice de produtividade mundial desabar.&lt;/p&gt;
&lt;p&gt;Houve pelo menos dois projetos de I.A. para resolver o problema, que consiste em dobrar números múltiplos de 2 em um quadrado 4 x 4 até que se consiga o quadrado com o valor 2048 (e além). O artigo de Nicola Pezzotti, An Artificial Intelligence for the 2048 game, explica o mais efetivo deles, de autoria de Robert Xiao (eu acho). O programa desenvolvido por Xiao otimiza o tabuleiro do jogo guardando-o em um inteiro de 64 bits, deixando 4 bits para cada casa, mais que o suficiente para que seja armazenada a potência de 2 localizada no quadrado (o limite fica sendo de 2  16, ou 65536). Ao rodar a versão executável console ele imprime cada posição do tabuleiro em um formato &amp;quot;fácil&amp;quot; de ser lido.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Move #69, current score=584
 1356
 0051
 0012
 0000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Como pode-se perceber, cada número diferente de zero contém a potência de dois que ocupa a casa (1 é igual a 2, 5 é igual a 2 elevado a 5, que é igual a 32, e assim por diante). Para alinhar corretamente o tabuleiro os números estão impressos em hexadecimal, ou seja, os valores válidos vão de 0 a f (15).&lt;/p&gt;
&lt;p&gt;A estratégia do programa de IA é ordenar as casas em um lado e, assim que acumular valores o suficiente, consolidar tudo na última casa. Nem sempre isso é possível, pois uma virada de jogo pode deixar a casa com o maior valor no meio de um dos lados. Nesse caso, é interessante ver como a I.A. se sai, já que com apenas uma execução ela foi até 8192 e mais um 4096. Dá-lhe, computador!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Geleia de Código</title>
  <link>http://www.caloni.com.br/geleia-de-codigo/</link>
  <pubDate>2014-04-15</pubDate>
  
  <guid>http://www.caloni.com.br/geleia-de-codigo/</guid>
  <description>&lt;p&gt;Não costumo participar de campeonatos de programação por alguns motivos vagos: é perda de tempo (não ganho nada com isso), sou um péssimo programador (ou pasteleiro), dá preguiça (esse é o mais válido) e por aí vai o mimimi. Dessa forma, sempre passei ileso de eventos como o atual Google Code Jam, que pretende levar a categoria de código ofuscado para um novo patamar.&lt;/p&gt;
&lt;p&gt;No entanto, esse ano apareceram dois motivos que me levaram a gastar cinco minutos de paciência com as historinhas bestas da equipe do Google. Primeiro o Python, que desde 2013 tem renovado em mim a sensação que programar ainda é divertido (e que o pessoal da Microsoft e do padrão C++ tinham tirado de mim há muito tempo com seus compiladores cada vez mais complexos/lentos e as IDEs que demoram o tempo do cafezinho para abrir). Segundo o que move o mundo: a concorrência. Minha digníssima esposa, levada por alguns pontos-extra na faculdade (uma iniciativa até que louvável do professor), resolveu participar da primeira fase (a classificação desta fase também dava pontos).&lt;/p&gt;
&lt;p&gt;O fato é que depois desses cinco minutos eu simplesmente não consegui parar até o minuto final das 23 horas (horário de Brasília) de domingo, quando o tempo-limite esgotou. O aspecto mais divertido do Code Jam é que há liberdade total para a ferramenta que você pretende usar: linguagens de programação, Excel, uma calculadora ou apenas seu cérebro. Você recebe uma &amp;quot;missão&amp;quot; e um arquivo de entrada e precisa cuspir um arquivo de saída de acordo com a missão. Apenas isso. O resto fica por conta da criatividade dos codadores e gambiarreiros de plantão.&lt;/p&gt;
&lt;p&gt;Todos os exercícios levam em consideração um arquivo de entrada que possui em sua primeira linha o número de testes que serão feitos e em seguida um número determinado de linhas e parâmetros, geralmente divididos por espaço. O primeiro problema, por exemplo, apenas considerava a suposição de cartas em pequeno truque de mágica e recebia como entrada a disposição dessas cartas junto com a escolha da fileira que o participante dizia onde estava a carta escolhida.&lt;/p&gt;
&lt;p&gt;O segundo exercício já envolvia um jogo bem divertido em que o jogador ficava clicando em cookies como se não houvese amanhã. Esse deu um pouco mais de trabalho, mas foi mais divertido que o primeiro.&lt;/p&gt;
&lt;p&gt;Já o terceiro... o terceiro passa. Vamos para o quarto, um dos mais instigantes, pois envolve duas regras distintas de um jogo e a otimização das melhores estratégias para ambos. Isso consumiu bem mais tempo que os outros dois iniciais, pois lembro de ter me isolado por uma hora para conseguir colocar tudo na cabeça.&lt;/p&gt;
&lt;p&gt;Já o terceiro foi um fracasso total. Tentei de todas as maneiras resolver o impasse de descobrir qual disposição de um jogo de campo minado poderia ser resolvido em apenas um clique (parece o jogo oposto do viciado clicador de cookies), mas falhei miseravelmente. E desconfio o porquê. Primeiro entendo que meu perfeccionismo me impediu de realizar uma checagem padrão para exceções já conhecidas (quando há apenas uma linha ou coluna, quando há apenas um espaço sem minas, etc). Eu pensei: se o Google fez esse problema, ele deve ter bolado alguma solução genérica que independa de ifs. Bom, não que eu saiba. Depois de terminado o tempo dei uma olhada em algumas soluções dos competidores e não achei nenhuma solução que usasse algum algoritmo maluco e genérico (não achei nenhum indiano, contudo).&lt;/p&gt;
&lt;p&gt;Eis a solução porca e mal-resolvida (alguns pontos do códido foram feitos depois de ver o código de outrem):&lt;/p&gt;
&lt;p&gt;Não, eu não usei o Google para descobrir a lógica por trás do problema. Vai que os caras ficam monitorando quem fica fazendo pesquisas. E, não, tampouco usei o Bing. Não sou masoquista a esse ponto.&lt;/p&gt;
&lt;p&gt;PS: Bom, estou na próxima fase. Veremos o que o futuro nos espera. Esse programador foi fisgado pelo campeonato de pastéis.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Lambda: o Retorno!</title>
  <link>http://www.caloni.com.br/lambda-o-retorno/</link>
  <pubDate>2014-04-08</pubDate>
  
  <guid>http://www.caloni.com.br/lambda-o-retorno/</guid>
  <description>&lt;p&gt;Na última vez que foi abordado o tema &amp;quot;lambda na ferida&amp;quot; falamos brevemente sobre como C++ agora permite criar funções dentro de funções. Hoje vamos apenas falar que aquela construção bizarra que criamos fica ainda mais bizarra se precisarmos retornar alguma coisa dessa função ou usá-la mais de uma vez.&lt;/p&gt;
&lt;p&gt;O padrão do lambda é supor que sua função embutida e enlatada não precisa retornar nada, o que torna a sintaxe mais simples: é um void AlgumaCoisa(argumentos). No entanto, para algoritmos como o findif isso não funciona, então é necessário retornar algo. E, no caso de findif, chamá-lo mais de uma vez pode ser feito facilmente criando uma variável lambda:&lt;/p&gt;
&lt;p&gt;O tipo de retorno que colocamos através de uma flechinha é obrigatória? De fato, não. Se eu omiti-la vai funcionar do mesmo jeito porque o único ponto de saída da minha função retorna um bool.&lt;/p&gt;
&lt;p&gt;Esses compiladores estão ficando cada vez mais espertos.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>A moda agora é levar lambda na função</title>
  <link>http://www.caloni.com.br/a-moda-agora-e-levar-lambda-na-funcao/</link>
  <pubDate>2014-03-28</pubDate>
  
  <guid>http://www.caloni.com.br/a-moda-agora-e-levar-lambda-na-funcao/</guid>
  <description>&lt;p&gt;A nova moda de programar C++ nos últimos anos com certeza é usar lambda. Mas, afinal, o que é lambda? Bom, pra começar, é um nome muito feio.&lt;/p&gt;
&lt;p&gt;O que esse nome quer dizer basicamente é que agora é possível criar função dentro de função. Não só isso, mas passar funções inteiras, com protótipo, corpo e retorno, como parâmetro de função.&lt;/p&gt;
&lt;p&gt;Isso significa que finalmente os algoritmo da STL vão ser úteis e não um &amp;quot;pain in the ass&amp;quot;.&lt;/p&gt;
&lt;p&gt;Por exemplo, antes, tínhamos que fazer o seguinte malabarismo para mexer com arrays/vetores/listas:&lt;/p&gt;
&lt;p&gt;Imagine que para cada interação devíamos criar uma função que manipulasse os elementos do vetor.&lt;/p&gt;
&lt;p&gt;Uma alternativa que costumava utilizar era a de roubar na brincadeira e criar um tipo dentro da função (permitido) e dentro desse tipo criar uma função (permitido):&lt;/p&gt;
&lt;p&gt;Apesar disso gerar INTERNALCOMPILERERROR em muitos builds com o Visual Studio 2003 (e o rápido, mas anos noventa, Visual Studio 6) na maioria das vezes o código compilava e rodava sem problemas. No entanto, deixava um rastro sutil de gambi no ar...&lt;/p&gt;
&lt;p&gt;Agora isso não é mais necessário. Desde o Visual Studio 2010 (que eu uso) a Microsoft tem trabalhado essas novidades do padrão no compilador, e aos poucos podemos nos sentir mais confortáveis em usar essas modernices sem medo. Por exemplo:&lt;/p&gt;
&lt;p&gt;&amp;quot;Caraca, mas o que é esse código alienígena?&amp;quot;, diria alguém como eu alguns anos atrás (talvez até meses). Bom, nada vem de graça em C++ e dessa vez houve algumas mudanças meio drásticas na sintaxe para acomodar o uso dessa lambida inline.&lt;/p&gt;
&lt;p&gt;E não é só isso. Tem muito mais esquisitices de onde veio essa.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Houaiss para Babylon em Python!</title>
  <link>http://www.caloni.com.br/houaiss-para-babylon-em-python/</link>
  <pubDate>2014-02-27</pubDate>
  
  <guid>http://www.caloni.com.br/houaiss-para-babylon-em-python/</guid>
  <description>&lt;p&gt;O Fabio Montefuscolo expandiu mais ainda o acesso do conversor Houaiss para Babylon implementando uma versão em Python, uma linguagem que estou aprendendo a adorar. Tudo é mais simples, rápido e direto em Python, e o código que ele escreveu utiliza todo esse potencial:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Real Programmers Don&#39;t Use Java</title>
  <link>http://www.caloni.com.br/real-programmers-dont-use-java/</link>
  <pubDate>2014-02-20</pubDate>
  
  <guid>http://www.caloni.com.br/real-programmers-dont-use-java/</guid>
  <description>&lt;p&gt;When I was a newbie (and a wanna-be) I enjoyed reading &amp;quot;Real Programmers Don&#39;t Use Pascal&amp;quot;, a satiric text that influenced and encouraged me into the path of &amp;quot;C/C++ enlightenment&amp;quot;, most even than K&amp;amp;R&#39;s book. Since then I thought that being a &amp;quot;Real Programmer&amp;quot; was something close to everything one needs to know to get (hard) things done (quickly). Being a &amp;quot;Quiche Eater&amp;quot; was, in couterpart, comparable to nothing. Real Programmers solve real problems! Quiche Eaters are losers who study the academic concepts of computer science and never do a damn useful and/or working program (maybe you know some guy like this).&lt;/p&gt;
&lt;p&gt;Jokes apart, the spirit of the text can also be used by those who already find them very good programmers and believe no longer have to grow professionally. The times my ego inflates I still remember that my code use child APIs and an operating system that is a joke. I also remember that there are some people out there designing a starship that will leave the orbit of the Solar System!&lt;/p&gt;
&lt;p&gt;On the other hand, many people that just got out of CS course still find programming a difficult matter. This text reminds us that life was difficult 20, 40, 70 years ago, when engineers and programmers were the same person and when you didn&#39;t know that what you were doing could put millions at risk in a project.&lt;/p&gt;
&lt;p&gt;Hence, the Real Programmer live in the past. And he always will be worthier than young folks, because he knows how to solve that blue screen problem that nobody else does. As I always say, paraphrasing an illustrious figure in Brazilian television, who is afraid to open Visual Studio and is eternally designing the software instead does not go very far: &amp;quot;who knows to do, do it right way!&amp;quot; .&lt;/p&gt;
&lt;p&gt;Here follows a brief summary of the original text adapted to the current times and with my prejucided view of thinking about it. If you wish to use your politically correct piece of mind and criticize me, be my guest!&lt;/p&gt;
&lt;p&gt;Languages. Remember: the need to invent more languages/resources to do your job is to remind yourself about your own incompetence to invent such excuse. You are one of those who says &amp;quot;every problem has a specific tool&amp;quot; or something like that. In other words: an inefficient programmer. Don&#39;t you see that everything you need is C. If C won&#39;t do, then assembly will. If none of them, then is isn&#39;t worth doing.&lt;/p&gt;
&lt;p&gt;Structured Programming. It is the first and last paradigm to be applied. After all, Object Orientation is another excuse to not program. They are more abstractions that, once you are a dead weight, you are unable to solve a problem using just functions and variables. No, you need classes, inheritance, templates and whatever the hell that will transform your simple and straight code into a magical horn of plenty that will only impress others at the futility and complexity of the solution.&lt;/p&gt;
&lt;p&gt;Data structure. Another great concept to fool yourself. Today are many who enslave us to weird SQL layouts and weird frameworks that do all the work. We all know that the only really useful to know the structure is the array. The rest are variants of the same theme: queues and stacks.&lt;/p&gt;
&lt;p&gt;Operating system. Mac and Windows are just toys and Linux is a video game that takes more work to set up than playing. The programmer actually uses something like mainframes or other beta operating system, which are too weird and can make a real mess in the hands of those who have not read the WHOLE manual. And knowing all known major kernel bugs and its location by heart at the time of booting is vital.&lt;/p&gt;
&lt;p&gt;Tools. If you depend on an IDE that have Code Completion and other fancy stuff or any other editor that depends on your favorite 17,459 plugins installed, then you are not a Real Programmer. A Real Programmer actually use what he have on hand at the time, like notepad, hexdump or even some beeps . The tool is no limit to one that can really code.&lt;/p&gt;
&lt;p&gt;Debugging. Are you saying that you need the source code in order to debug? So you do not have a clue of what the program does. Just a few glances at call stack and the registers can make a Real Programmer solve a bug that Quiche Eaters would not get after analyzing those charts with boxes inside UML and use cases for months.&lt;/p&gt;
&lt;p&gt;The Real Programmers Work is certainly not doing trivial databases to trivial programs that access SQL with trivial queries. Neither are those horrible websites with PHP/Apache and scripts and more scripts written by kids. No, sir. These are programs that deal with the OS in a more intimate way (HD encryption, file system drivers, critical communication services, etc.), or are programs that do something really useful (compilers, the operating system itself). Or maybe those programs that deal directly with hardware (complex microcontrollers, robots, ships, medical devices, etc.).&lt;/p&gt;
&lt;p&gt;The Fun of every Real Programmer is actually chat with friends (about programming), read something (about programming) and watch intelligent movies (about programming or people who have some kind of intellectual challenge to solve &amp;quot;the hard way&amp;quot;). Is there anything more fun than that?&lt;/p&gt;
&lt;p&gt;And, finally, in their Natural Habitat, we can find pages and pages of assembly code scattered around the table, a computer locked by a remote kernel debugging serial cable, some notes in hex on a piece of paper, a few dozen browser pages openned about the behavior of functions in BIOS SATA HDDs with 500 GB working on RAID4, coffee (of course), chips, stains on the carpet. When there&#39;s nothing to do the environment is pretty tidy and one cannot notice the presence of Real Programmers in sight.&lt;/p&gt;
&lt;p&gt;And the Future of Real Programmer? Well, C may even be dying. But so what? It seems C++ supports pointers as well. The rest of the useless abstractions like classes and inheritance may be totally ignored. The basics will always exist. Forget versions with multiple inheritance and enigmatic concepts. Be a (wo)man!&lt;/p&gt;
&lt;p&gt;The real, happy, final truth is: regardless of how much more the world becomes &amp;quot;managed&amp;quot; behind frameworks and programmers who prefer to &amp;quot;do projects&amp;quot; behind their office packages and use cases, when problems pop up, some bug murky life threatening useful for a project, a Real Programmer will be there to save the day, because only a programmer really knows how to do his job well done and have a good night of sleep knowing that everything will just be OK.&lt;/p&gt;
&lt;p&gt;If it doesn&#39;t, there will be always a Real Programmer to save the day.&lt;/p&gt;
&lt;p&gt;&amp;quot;As long as there are ill-defined goals, bizarre bugs, and unrealistic schedules, there will be Real Programmers willing to jump in and Solve The Problem, saving the documentation for later. Long live FORTRAN!&amp;quot;&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>removeif até remove, só que diferente</title>
  <link>http://www.caloni.com.br/remove_if-ate-remove-so-que-diferente/</link>
  <pubDate>2014-01-21</pubDate>
  
  <guid>http://www.caloni.com.br/remove_if-ate-remove-so-que-diferente/</guid>
  <description>&lt;p&gt;A surpresa de hoje foi descobrir (vejam só) que o removeif, como todo algoritmo da STL, deve ser olhado de perto antes de usado. Nesse caso em específico porque, apesar do nome, a função NÃO remove elementos, mas os sobrescreve.&lt;/p&gt;
&lt;p&gt;Imagine uma função que usa removeif para remover todas as idades de potenciais lolitas:&lt;/p&gt;
&lt;p&gt;Ou até sua contraparte usando um array C:&lt;/p&gt;
&lt;p&gt;Um uso trivial pode não cuspir um resultado trivial, ou seja, os elementos não serão removidos como se espera:&lt;/p&gt;
&lt;p&gt;Isso ocorre porque o comportamento do removeif é copiar todos os elementos que retornem false (não remova) e pular elementos que retornem true (remova). No entanto, o tamanho do contêiner, e consequentemente seu ponteiro end(), permanecem o mesmo.&lt;/p&gt;
&lt;p&gt;De acordo com o saite cplusplus.com, o algoritmo STL é previsível, simples, e por isso mesmo sujeito a otimizações do compilador:&lt;/p&gt;
&lt;p&gt;Para obtermos qual seria o &amp;quot;novo end()&amp;quot;, precisamos obter esse valor do retorno de removeif. Com base nisso, podemos alterar o tamanho do contêiner ajustado:&lt;/p&gt;
&lt;p&gt;Esse C++... intuitivo como nunca!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>BovespaBacktesting</title>
  <link>http://www.caloni.com.br/bovespabacktesting/</link>
  <pubDate>2014-01-08</pubDate>
  
  <guid>http://www.caloni.com.br/bovespabacktesting/</guid>
  <description>&lt;p&gt;Eu não sou apenas um programador: sou um especulador. Ou, para quem ficou com medo, um investidor. Ficou bonito, agora? Trocando em miúdos, isso quer dizer que muitas vezes aposto na bolsa de valores, aquela onde as pessoas ganham e perdem dinheiro loucamente. Porém, assim como faço com minha carreira de desenvolvedor, não deixo de estudar e aprimorar minhas habilidades. Tirando alguns anos de estudo com livros de finanças, economia e contabilidade, foi com base nisso que eu fiz uma série de scripts que realiza operações de backtesting nos papéis da Bovespa.&lt;/p&gt;
&lt;p&gt;Backtesting é uma maneira dos especuladores terem uma noção de quão bom ou ruim é sua estratégia de compra e venda. É uma maneira profissional de se aproximar do mercado caótico das ações. Basicamente um backtesting simula o que o especulador faria na vida real com um histórico razoável de variação de preços das ações que pretende operar. Se esse monte de palavras novas neste blogue está te deixando com medo, recomendo dar uma passada no Senhor Mercado (lá você irá também aprender mais sobre técnicas de backtesting).&lt;/p&gt;
&lt;p&gt;Vamos supor que minha ideia de estratégia seja comprar quando o preço de uma determinada ação estiver na metade do seu topo histórico e vender quando ele estiver no dobro do momento da compra. Uma estratégia bem tosca, mas se fizer dinheiro, quem liga para vaidade? Outra estratégia mais refinada usa médias móveis para estabelecer pontos de compra e venda dependendo da tendência do mercado. Qual das duas dá mais dinheiro? Existem duas maneiras de saber: a dolorosa e a indolor. A dolorosa seria sacar uma grana do banco e começar a operar em sua corretora favorita seguindo ambas as estratégias e ver qual te deixou mais rico e qual te levou à falência. A indolor seria baixar o histórico de preços dos papéis que está interessado em usar essas estratégias e rodar uma simulação que opere seguindo ambas as estratégias e descubra qual é a perdedora. Qual você preferiria?&lt;/p&gt;
&lt;p&gt;OK, esse assunto já está ficando bem monótono para quem acompanha um blogue de programação. Vamos ao código!&lt;/p&gt;
&lt;p&gt;O projeto que mantenho no GitHub possui algumas ideias que gostaria de compartilhar com todos que estão interessados em realizar um backtesting, independente de sua estratégia. A primeira delas seria de onde baixar o histórico de preços de maneira simples e barata. Eu recomendo e uso o software Grafix, que consegue baixar as informações diretamente do saite da Bovespa e realizar os ajustes necessários para montar e exibir as informações. Com base no banco de dados do Grafix é que o BovespaBacktesting (meu projeto) importa as informações que ele precisa. Ele irá importar apenas os códigos que estiverem em uma lista disponível no arquivo data/filterCodes relativo de onde o script estiver rodando. Esse arquivo é apenas texto com um código por linha.&lt;/p&gt;
&lt;p&gt;A partir dessa importação é possível realizar queries com as variações diárias, semanais e mensais dos preços dos ativos conhecidos (a mesma lista de código). A própria lista de ativos conhecidos está disponível através de uma função, tornando a iteração simples e direta.&lt;/p&gt;
&lt;p&gt;Com essas informações de preço é possível aplicar qualquer tipo de indicador. O BovespaBackteting possui apenas os mais usuais, mas basta implementar a lógica de tratamento em Python, o que não deve consumir nem muito tempo nem muitos neurônios, pois com o histórico disponível tudo fica mais fácil.&lt;/p&gt;
&lt;p&gt;As funções-macro calculam trades (operações) a partir de alguns parâmetros definidos no código ou por parâmetros. As versões do BovespaBacktesting foram variando nesse sentido. Ainda não há uma maneira saudável de comparar diversas estratégias, pois o que eu tenho feito basicamente é alterar alguns parâmetros, rodar o backtesting e exportar para um CSV (função já disponível).&lt;/p&gt;
&lt;p&gt;Já existem algumas firulas caso você esteja pensando em uma estratégia em que seja viável viver de operar, como cálculo de salário e a inclusão de variáveis que levem em conta que parte do dinheiro ganho será usado. Ainda é um código bem tosco, mas funciona e pode ser o ponto de entrada de quem deseja conhecer mais sobre o mercado de ações e como os profissionais conseguem tirar dinheiro deste grande cassino.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Uma nova linguagem</title>
  <link>http://www.caloni.com.br/uma-nova-linguagem/</link>
  <pubDate>2013-12-04</pubDate>
  
  <guid>http://www.caloni.com.br/uma-nova-linguagem/</guid>
  <description>&lt;p&gt;Tenho que me atualizar. Faz um tempo (anos) em que deixei de lado esse mundo &amp;quot;frescurento&amp;quot; de C++2030 e me foquei única e exclusivamente em resolver problemas da melhor forma possível com o que a linguagem já tinha a oferecer em uma implementação estável de compilador e bibliotecas.&lt;/p&gt;
&lt;p&gt;Agora o mundo está mudando. Para quem é do Universo Windows/Microsoft, a empresa do Uncle Bill vem liberando algumas versões interessantes do seu compilador (VS2012, 2013 e agora o CTP), cada vez mais próxima de um C++11/14 100% compliance. Não acredito que cheguem lá, mas o fato de estarem empenhados indica para a indústria e seus clientes que há uma demanda sendo atendida. Não é mais frescurite de acadêmicos. Algumas features ultra-novas começam a ser usadas e permitidas em projetos.&lt;/p&gt;
&lt;p&gt;Estamos falando de uma nova linguagem que se forma com um novo ritmo. O padrão C++11 demorou &amp;quot;apenas&amp;quot; 2 anos para cair em nossas linhas de comando, há um patch já confirmado para o ano que vem e já existem menções para um novo release em 2017. Para o programador C++ que se acostumou a contar as evoluções em décadas, um novo ritmo se impõe. Não há tempo para cristalização de conceitos. O boost já nos forneceu isso por todos esses anos e hoje ele é reconhecidamente a versão alpha que precisávamos.&lt;/p&gt;
&lt;p&gt;Veremos o que o futuro cada vez mais presente nos reserva.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Ponto Flutuante Afundando</title>
  <link>http://www.caloni.com.br/ponto-flutuante-afundando/</link>
  <pubDate>2013-11-07</pubDate>
  
  <guid>http://www.caloni.com.br/ponto-flutuante-afundando/</guid>
  <description>&lt;p&gt;Quando armazenamos valores monetários em doubles seus cálculos conseguem manter a precisão e na maioria das vezes o ajuste de precisão funciona. Porém, encontrei alguns casos onde a subtração de dois valores fazia &amp;quot;perder&amp;quot; um centavo (ou comparações exatas) justamente pela limitação da precisão do ponto flutuante. Nesse exemplo os valores são 2.358,93 - 1.386,93, que em uma conta de padaria (mas correta) dá 972,00 (até a Calc do Windows e o Excel funcionam), mas pelo Visual Studio 2010 chega perto, mas erra o alvo:&lt;/p&gt;
&lt;p&gt;Isso ocorre porque sua representação dentro da variável double é diferente de 272.0 do outro double. Depurando vemos mais claramente:&lt;/p&gt;
&lt;p&gt;Ou seja, quando fazemos a subtração de d2 em d1, nossa precisão raspa um pouquinho e escapa pela beirada:&lt;/p&gt;
&lt;p&gt;Na comparação com o valor redondo aparece a falha, mas note que isso não ocorre com os outros valores d1 e d2, já que o armazenamento adquire o mesmo formato:&lt;/p&gt;
&lt;p&gt;Há uma forma de arredondamento já disponível no C99 (mas não no Visual Studio 2010) que pode ser útil para esses casos. A única coisa que é preciso fazer é arredondar os valores antes do cálculo:&lt;/p&gt;
&lt;p&gt;É uma decisão arbitrária essa de arredondar para cima, mas se for adotada em todo o sistema (e já fazendo parte de um padrão, no caso, o C99), não deverão existir problemas de interpretação de cálculos entre os componentes.&lt;/p&gt;
&lt;p&gt;O mercado financeiro agradece =).&lt;/p&gt;
&lt;p&gt;UPDATE: Não estou de acordo com o armazenamento de valores monetários em doubles em vez de inteiros pelo simples motivo que não há moedas no sistema financeiro com unidades que se dividem ad infinitum. Por consequência, existe sempre uma unidade básica e indivisível (que no caso do Brasil é o centavo de real). Ou seja, como o objetivo é contar o total dessas unidades que não se dividem, o uso de inteiros é brainless.&lt;/p&gt;
&lt;p&gt;UPDATE: Existe uma discussão exatamente sobre isso no Grupo C/C++ Brasil, que recomendo a leitura, o que me levou a escrever o post. Particularmente, sigo o raciocínio do Pedro Lamarão.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Depuração na nuvem com o novo Visual Studio</title>
  <link>http://www.caloni.com.br/depuracao-na-nuvem/</link>
  <pubDate>2013-04-01</pubDate>
  
  <guid>http://www.caloni.com.br/depuracao-na-nuvem/</guid>
  <description>&lt;p&gt;Uma das novidades do futuro Visual Studio pouco comentada ainda em fóruns por seu caráter sigiloso e ainda em testes (mas que pode facilmente ser observada pela engenharia reversa dos binários do Visual C++) é a possibilidade de depurar trechos de código &amp;quot;na nuvem&amp;quot;, ou seja, dentro dos gigantescos servidores de clusters de serviços de escalabilidade da Amazon, do Google e, claro, da Microsoft.&lt;/p&gt;
&lt;p&gt;Já é conhecido que será possível inserir comentários no código-fonte com o formato @nickname e incluir na listagem de bugs o estilo das #hashtags para que programadores vinculados à sua rede social possam enxergar referências a outros programadores e verificar o Developer TrendTopics, como um #blame-joel-on-software. Porém, o que poucos sabem, é que será também possível depurar as APIs de redes sociais em tempo real. Ou seja, caso seja usado o método Twitter::Tweet(), logo após o retorno da chamada será possível aguardar por uma resposta dos usuários envolvidos:&lt;/p&gt;
&lt;p&gt;Ou seja, logo será possível além de perder horas navegando em saites de rede social perder também horas depurando os comentários e respostas das pessoas nessas redes direto do Visual Studio. É a Microsoft pensando nos programadores que gostam de perder tempo se envolver com pessoas (ainda que virtuais) e discussões acaloradas sobre tópicos irrelevantes e absurdos (ainda que virtuais).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>eXtreme Go Horse</title>
  <link>http://www.caloni.com.br/extreme-go-horse/</link>
  <pubDate>2012-09-27</pubDate>
  
  <guid>http://www.caloni.com.br/extreme-go-horse/</guid>
  <description>&lt;p&gt;O Go Horse Power (GHP) foi criado por um blogue hoje extinto. As premissas dessa nova metodologia de desenvolvimento era que o projeto fosse feito da maneira mais rápida possível.&lt;/p&gt;
&lt;p&gt;Contudo, eles não contavam com a versão turbinada do desleixo humano.&lt;/p&gt;
&lt;p&gt;A eXtreme Go Horse (XGP) é o suprassumo das metodologias do mercado brasileiro de desenvolvimento. Quem nunca trabalhou em uma empresa gerida por essas regras? (Bom, pelo menos XGH pelo jeito tem até controle de fonte, algo que era até meio raro uns anos atrás):&lt;/p&gt;
&lt;p&gt;1- Pensou, não é XGH&lt;/p&gt;
&lt;p&gt;XGH não pensa, faz a primeira coisa que vem à mente. Não existe segunda opção, a única opção é a mais rápida&lt;/p&gt;
&lt;p&gt;2- Existem três formas de se resolver um problema&lt;/p&gt;
&lt;p&gt;Estas são: a correta, a errada e a XGH, que é igual à errada, só que mais rápida. XGH é mais rápido que qualquer metodologia de desenvolvimento de software que você conhece (Vide Axioma 14).&lt;/p&gt;
&lt;p&gt;3- Quanto mais XGH você faz, mais precisará fazer&lt;/p&gt;
&lt;p&gt;Para cada problema resolvido usando XGH, mais uns 7 são criados. Mas todos eles serão resolvidos da forma XGH. XGH tende ao infinito.&lt;/p&gt;
&lt;p&gt;4- XGH é totalmente reativo&lt;/p&gt;
&lt;p&gt;Os erros só existem quando aparecem.&lt;/p&gt;
&lt;p&gt;5- XGH vale tudo, só não vale dar o toba&lt;/p&gt;
&lt;p&gt;Resolveu o problema? Compilou? Commit e era isso.&lt;/p&gt;
&lt;p&gt;6- Commit sempre antes de update&lt;/p&gt;
&lt;p&gt;Se der merda, a sua parte estará sempre correta.. E seus colegas que se fodam.&lt;/p&gt;
&lt;p&gt;7- XGH não tem prazo&lt;/p&gt;
&lt;p&gt;Os prazos passados pelo seu cliente são meros detalhes. Você SEMPRE conseguirá implementar TUDO no tempo necessário (nem que isso implique em acessar o BD por um script malaco)&lt;/p&gt;
&lt;p&gt;8- Esteja preparado para pular fora quando o barco começar a afundar¿&lt;/p&gt;
&lt;p&gt;Ou coloque a culpa em alguém ou algo. Pra quem usa XGH, um dia o barco afunda. Quanto mais o tempo passa, mais o sistema vira um monstro. O dia que a casa cair, é melhor seu curriculum estar cadastrado na APInfo, ou ter algo pra colocar a culpa&lt;/p&gt;
&lt;p&gt;9- Seja autêntico, XGH não respeita padrões&lt;/p&gt;
&lt;p&gt;Escreva o código como você bem entender, se resolver o problema, commit e era isso&lt;/p&gt;
&lt;p&gt;10- Não existe refactoring, apenas rework&lt;/p&gt;
&lt;p&gt;Se der merda, refaça um XGH rápido que solucione o problema. O dia que o rework implicar em reescrever a aplicação toda, pule fora, o barco irá afundar (Vide Axioma 8)&lt;/p&gt;
&lt;p&gt;11- XGH é totalmente anárquico&lt;/p&gt;
&lt;p&gt;A figura de um gerente de projeto é totalmente descartável. Não tem dono, cada um faz o que quiser na hora que os problemas e requisitos vão surgindo (Vide Axioma 4)&lt;/p&gt;
&lt;p&gt;12- Se iluda sempre com promessas de melhorias&lt;/p&gt;
&lt;p&gt;Colocar TUDO no código como uma promessa de melhoria ajuda o desenvolvedor XGH a não sentir remorso ou culpa pela cagada que fez. É claro que o refactoring nunca será feito (Vide Axioma 10)&lt;/p&gt;
&lt;p&gt;13- XGH é absoluto, não se prende à coisas relativas&lt;/p&gt;
&lt;p&gt;Prazo e custo são absolutos, qualidade é totalmente relativa. Jamais pense na qualidade e sim no menor tempo que a solução será implementada, aliás¿ não pense, faça!&lt;/p&gt;
&lt;p&gt;14- XGH é atemporal&lt;/p&gt;
&lt;p&gt;Scrum, XP¿Tudo isso é modinha. O XGH não se prende às modinhas do momento, isso é coisa de viado. XGH sempre foi e sempre será usado por aqueles que desprezam a qualidade&lt;/p&gt;
&lt;p&gt;15- XGH nem sempre é POG&lt;/p&gt;
&lt;p&gt;Muitas POG¿s exigem um raciocínio muito elevado, XGH não raciocina (Vide Axioma 1).&lt;/p&gt;
&lt;p&gt;16- Não tente remar contra a maré&lt;/p&gt;
&lt;p&gt;Caso seus colegas de trabalho usam XGH para programar e você é um coxinha que gosta de fazer as coisas certinhas, esqueça! Pra cada Design Pattern que você usa corretamente, seus colegas gerarão dez vezes mais código podre usando XGH.&lt;/p&gt;
&lt;p&gt;17- O XGH não é perigoso até surgir um pouco de ordem&lt;/p&gt;
&lt;p&gt;Este axioma é muito complexo, mas sugere que o projeto utilizando XGH está em meio ao caos. Não tente por ordem no XGH (Vide Axioma 16), é inútil e você pode jogar um tempo precioso no lixo. Isto fará com que o projeto afunde mais rápido ainda (Vide Axioma 8). Não tente gerenciar o XGH, ele é auto suficiente (Vide Axioma 11), assim como o caos.&lt;/p&gt;
&lt;p&gt;18- O XGH é seu brother, mas é vingativo&lt;/p&gt;
&lt;p&gt;Enquanto você quiser, o XGH sempre estará do seu lado. Mas cuidado, não o abandone. Se começar um sistema utilizando XGH e abandoná-lo para utilizar uma metodologia da moda, você estará fudido. O XGH não permite refactoring (vide axioma 10), e seu novo sistema cheio de frescurites entrará em colapso. E nessa hora, somente o XGH poderá salvá-lo.&lt;/p&gt;
&lt;p&gt;19- Se tiver funcionando, não rela a mão&lt;/p&gt;
&lt;p&gt;Nunca altere, e muito menos questione um código funcionando. Isso é perda de tempo, mesmo porque refactoring não existe (Vide Axioma 10). Tempo é a engrenagem que move o XGH e qualidade é um detalhe desprezível.&lt;/p&gt;
&lt;p&gt;20- Teste é para os fracos&lt;/p&gt;
&lt;p&gt;Se você meteu a mão num sistema XGH, é melhor saber o que está fazendo. E se você sabe o que está fazendo, vai testar pra que? Testes são desperdício de tempo, se o código compilar, é o suficiente.&lt;/p&gt;
&lt;p&gt;21- Acostume-se ao sentimento de fracasso iminente&lt;/p&gt;
&lt;p&gt;O fracasso e o sucesso andam sempre de mãos dadas, e no XGH não é diferente. As pessoas costumam achar que as chances do projeto fracassar utilizando XGH são sempre maiores do que ele ser bem sucedido. Mas sucesso e fracasso são uma questão de ponto de vista. O projeto foi por água abaixo mas você aprendeu algo? Então pra você foi um sucesso!&lt;/p&gt;
&lt;p&gt;22- O problema só é seu quando seu nome está no Doc da classe&lt;/p&gt;
&lt;p&gt;Nunca ponha a mão numa classe cujo autor não é você. Caso um membro da equipe morra ou fique doente por muito tempo, o barco irá afundar! Nesse caso, utilize o Axioma 8.&lt;/p&gt;
&lt;p&gt;Este texto foi copiado daqui e daqui. Não existem donos conhecidos do XGH (já devem ter morrido de desgosto). Fiquei com medo de não encontrar mais essa metologia, que é pouco divulgada e muito útil.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Minha palestra do TDC 2012</title>
  <link>http://www.caloni.com.br/minha-palestra-do-tdc-2012/</link>
  <pubDate>2012-07-21</pubDate>
  
  <guid>http://www.caloni.com.br/minha-palestra-do-tdc-2012/</guid>
  <description>&lt;p&gt;Duas semanas atrás rolou a trilha C++ do TDC 2012, que contou com além da minha presença com a dos já conhecidos Fernando Roberto (DriverEntry), Rodrigo Strauss (1Bit), etc. Uma novidade: meu colega e programador .nerd Gabriel Guilherme também participou em uma palestra sobre um assunto que acredito que deveria ser mais promovido: interop. Afinal de contas, o poder de C++ não seria nada se não houvesse motivos práticos para usá-lo. Entre esses motivos, construir soluções com linguagens mais acessíveis é um deles.&lt;/p&gt;
&lt;p&gt;Na minha palestra foquei no conteúdo dos meus dois artigos sobre um fictício Patch de Emergência (parte 1 e parte 2  from Wanderley Caloni&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>GetTickCount não é um gerador de IDs únicos</title>
  <link>http://www.caloni.com.br/gettickcount-nao-e-um-gerador-de-ids-unicos/</link>
  <pubDate>2012-06-25</pubDate>
  
  <guid>http://www.caloni.com.br/gettickcount-nao-e-um-gerador-de-ids-unicos/</guid>
  <description>&lt;p&gt;Muitas vezes uma solução intuitiva não é exatamente o que esperamos que seja quando o código está rodando. Gerar IDs únicos, por exemplo. Se você analisar por 5 minutos pode chegar à conclusão que um simples GetTickCount, que tem resolução de clock boa e que se repete apenas depois de 50 dias pode ser um ótimo facilitador para gerar IDs exclusivos durante o dia.&lt;/p&gt;
&lt;p&gt;Porém, nada como código para provar que estamos errados:&lt;/p&gt;
&lt;p&gt;O motivo do GetTickCount retornar números iguais remete tanto ao fato que o espaço de tempo entre uma execução e outra pode ser muito pequeno quanto ao fato de várias threads podem ser executadas efetivamente ao mesmo tempo em ambientes de dois ou mais cores.&lt;/p&gt;
&lt;p&gt;Já o motivo do InterlockedIncrement funcionar sempre é porque aqui estamos usando uma solução de incremento atômico, ou seja, usamos a mesma base contadora e incrementamos ela em uma operação que não pode ocorrer ao mesmo tempo com outra thread.&lt;/p&gt;
&lt;p&gt;O que aprendemos aqui? Que por mais que seja intuitiva uma solução, nunca podemos nos basear nas nossas falhas cabeças. Um computador está aí não apenas para ser mais rápido, mas para ser assertivo em nossas elucubrações. Nesse sentido, é o nosso companheiro vulcaniano.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Novos atalhos aprendidos no Vim</title>
  <link>http://www.caloni.com.br/novos-atalhos-aprendidos-no-vim/</link>
  <pubDate>2012-06-09</pubDate>
  
  <guid>http://www.caloni.com.br/novos-atalhos-aprendidos-no-vim/</guid>
  <description>&lt;p&gt;Sempre é bom reler as referências e tentar melhorar o que já está bom. No momento minha inspiração é o excelente Vim: From Essentials to Mastery, uma coleção de slides bem-humorada que a cada releitura fornece dicas importantes para aprimorar o dia-a-dia com um dos editores mais poderosos do planeta.&lt;/p&gt;
&lt;p&gt;A lista abaixo é pessoal e, como disse Bram Moolenar, &amp;quot;You should not try to learn every command an editor offers. That would be a complete waste of time. Most people only need to learn 10 to 20 percent of the commands for their work. But it¿s a different set of commands for everybody.&amp;quot;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;C-W&amp;gt;&amp;lt;C-W&amp;gt;&lt;/code&gt; Alterna entre janelas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;C-W&amp;gt;-c&lt;/code&gt; Fecha a janela atual.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;C-W&amp;gt;-o&lt;/code&gt; Fecha todas as janelas menos a atual.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:ball&lt;/code&gt; Abre todos os buffers em janelas distintas.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g &amp;lt;C-G&amp;gt;&lt;/code&gt; Conta linhas, palavras, etc, no texto todo ou na seleção atual.&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Meus repositórios no GitHub</title>
  <link>http://www.caloni.com.br/meus-repositorios-no-github/</link>
  <pubDate>2012-06-04</pubDate>
  
  <guid>http://www.caloni.com.br/meus-repositorios-no-github/</guid>
  <description>&lt;p&gt;Depois de vacilar por alguns meses, incentivado pelo meu amigo Chico Pimenta, resolvi experimentar o tal do GitHub, e consequentemente o sistema de controle de fontes distribuído Git, que antes era meio exclusivo do Linux (continua meio sendo, mas com suporte um pouco melhor para Windows).&lt;/p&gt;
&lt;p&gt;Com isso, dei uma pequena lida no livro de introdução e comecei a migrar meus fontes perdidos num canto do HD. O que notei de vantagem com relação a outros DRCSs foi que é muito fácil e rápido criar branches e que a comunicação remota e os commits são feitos de uma maneira mais organizada e estruturada, além da própria estrutura interna do repositório ser muito simples de entender: um bando de arquivos compactados cujo nome é o hash do que ele contém.&lt;/p&gt;
&lt;p&gt;Meus  repositórios estão armazenados em alguns branches que distribuí de acordo com o uso/importância:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OpenSource. Projetos de fonte aberto que mantenho/ive e que poderiam se perder se alguém não fizesse backup (como o mouse tool ou regmon).&lt;/li&gt;
&lt;li&gt;Samples. Códigos de exemplo, de palestras e de testes feitos para escrever os artigos do blogue cujo autor vos fala.&lt;/li&gt;
&lt;li&gt;Caloni. Os códigos que fazem algo de útil, como o Houaiss2Babyulon, CopiaExata e DayToDay.&lt;/li&gt;
&lt;li&gt;Book. Um projeto em estado de larva sobre escrever um livro de engenharia reversa. Já possui um índice básico. Sugestões são bem-vindas.&lt;/li&gt;
&lt;li&gt;DriverEntry. Códigos do curso de desenvolvimento de drivers que estou fazendo com o Fernando, da DriverEntry Company. Recomendo!&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Problemas comuns no WinDbg e suas soluções</title>
  <link>http://www.caloni.com.br/problemas-comuns-no-windbg-e-suas-solucoes/</link>
  <pubDate>2012-05-27</pubDate>
  
  <guid>http://www.caloni.com.br/problemas-comuns-no-windbg-e-suas-solucoes/</guid>
  <description>&lt;p&gt;Depois de uma agradável manhã e tarde acompanhando o curso de desenvolvimento de drivers do meu amigo Ferdinando voltei para a casa para brincar um pouco mais com o mundo kernel e voltar a encontrar problemas com o WinDbg &amp;amp; Cia que há mais ou menos 1 ano atrás não tinha.&lt;/p&gt;
&lt;p&gt;Pesquisando por um problema específico envolvendo PDBs reencontrei o blogue do Ken Johnson, MVP Microsoft e analista por profissão e diversão, é conhecido por suas excelentes contribuições no mundo da depuração de sistema (notadamente WinDbg). Existe um post específico que ele escreveu para economizar tempo com problemas que ocorrem de vez em quando em uma sessão ou outra de depuração, mas nunca paramos tempo o suficiente para resolver.&lt;/p&gt;
&lt;p&gt;Além de outros, ele lista alguns que particularmente já aconteceram comigo ou com colegas de depuração:&lt;/p&gt;
&lt;p&gt;O WinDbg demora um tempo absurdo para processar o carregamento dos módulos e está usando tempo máximo de processamento em apenas uma CPU.&lt;/p&gt;
&lt;p&gt;Isso ocorre porque existem breakpoints ainda  não resolvidos. Resolva deixando apenas esses tipos de breakpoints que são absolutamente necessários, pois cada vez que um módulo é carregado o depurador precisa fazer o parser de cada um deles para verificar se ele já consegue resolve-lo.&lt;/p&gt;
&lt;p&gt;Às vezes, porém, existe algum lixo nos workspaces carregados por ele que permanecem mesmo depois de apagarmos todos os breakpoints inúteis ou reiniciar o sistema. Em último caso, sempre podemos apagar o workspace do registro, em HKCU\Software\Microsoft\Windbg\Workspaces.&lt;/p&gt;
&lt;p&gt;O WinDbg continua demorando décadas para analisar o carregamento, mas agora nem consome tanta CPU assim.&lt;/p&gt;
&lt;p&gt;Isso ocorre porque na cadeia de paths para procurar por símbolos existe algum endereço de rede/internet errado que faz com que ele tenha que caminhar em falso diversas vezes. Esse e outros erros de símbolos sempre poderão ser analisados através do universal !sym noisy, que imprime todo tipo de informação útil do que pode dar errado durante um .reload explícito (eu digitei) ou implícito (lazy reload).&lt;/p&gt;
&lt;p&gt;O WinDbg continua recusando carregar um símbolo que eu sei que existe e sei que é válido.&lt;/p&gt;
&lt;p&gt;Talvez ele exista, mas por algum motivo foi copiado corrompido para o symbol server. Mais uma vez, !sym noisy nele e deve acontecer algum erro de EPDBCORRUPT. Nesse caso, apague o PDB culpado e tente de novo.&lt;/p&gt;
&lt;p&gt;E, como brinde, um grande aliado da produtividade: como evitar que o WinDbg bloqueie seu PDB enquanto você precisa constantemente recompilar seu driver:&lt;/p&gt;
&lt;p&gt;Fonte: Blog do Nynaeve.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Sobrecarga de função às avessas</title>
  <link>http://www.caloni.com.br/sobrecarga-de-funcao-as-avessas/</link>
  <pubDate>2012-05-20</pubDate>
  
  <guid>http://www.caloni.com.br/sobrecarga-de-funcao-as-avessas/</guid>
  <description>&lt;blockquote&gt;
&lt;p&gt;Navegando pelo Archive.org, que possibilita viajar no tempo e encontrar coisas enterradas que seria melhor deixar por lá, consegui encontrar um post que se perdeu na dobra espaço-temporal entre o old-fashioned Caloni.com.br (com direito à velha joaninha psicodélica, desenho do meu amigo t@z) e o finado CThings. No final, consegui matar a marmota, chegar a 80 milhas por hora e voltar para o presente. Enjoy it!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Alguém já se perguntou se é possível usar sobrecarga de função quando a diferença não está nos parâmetros recebidos, mas no tipo de retorno? Melhor dizendo, imagine que eu tenha o seguinte código:&lt;/p&gt;
&lt;p&gt;É um uso sensato de sobrecarga. Mas vamos supor que eu queira uma sintaxe mais intuitiva, com o retorno sendo atribuído à variável:&lt;/p&gt;
&lt;p&gt;Voltando às teorias de C++, veremos que o código acima NÃO funciona. Ou, pelo menos, não deveria. Só pelo fato das duas funções serem definidas o compilador já reclama:&lt;/p&gt;
&lt;p&gt;Correto. O tipo de retorno não é uma propriedade da função que exclua a ambigüidade. Apenas a assinatura pode fazer isso (que são os tipos dos parâmetros recebidos pela função).&lt;/p&gt;
&lt;p&gt;Pois bem. Não podemos fazer isso utilizando funções ordinárias. Então o jeito é criar nosso próprio &amp;quot;tipo de função&amp;quot; que dê conta do recado:&lt;/p&gt;
&lt;p&gt;Pronto. Agora podemos &amp;quot;chamar&amp;quot; a nossa função criando uma nova instância e atribuindo o &amp;quot;retorno&amp;quot; a wstring ou à nossa GUID struct:&lt;/p&gt;
&lt;p&gt;Uma vez que criamos um novo tipo, e considerando que este tipo é, portanto, diferente dos tipos wstring e GUID já existentes, devemos simplesmente converter nosso novo tipo para cada um dos tipos de retorno desejados:&lt;/p&gt;
&lt;p&gt;E isso conclui a solução meio esquizofrênica de nossa sobrecarga às avessas:&lt;/p&gt;
&lt;p&gt;Eis o fonte completo:&lt;/p&gt;
&lt;p&gt;Voltando à pergunta original: penso que, com criatividade e C++, nada é impossível =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Consumo abusivo de memória</title>
  <link>http://www.caloni.com.br/consumo-abusivo-de-memoria/</link>
  <pubDate>2012-05-19</pubDate>
  
  <guid>http://www.caloni.com.br/consumo-abusivo-de-memoria/</guid>
  <description>&lt;p&gt;Era um belo dia em um ambiente de processamento fictício de filas fictícias e threads fictícias. Eis um belo código com filas, threads e processamentos feitos em stop-motion:&lt;/p&gt;
&lt;p&gt;Se olharmos de perto o processamento e a memória consumida por esse processo, veremos que no início existe um boom de ambos, mas após um momento de pico, o processamento praticamente pára, mas a memória se mantém:&lt;/p&gt;
&lt;p&gt;Depois de pesquisar por meus tweets favoritos, fica fácil ter a receita para verificarmos isso usando nosso depurador favorito: WinDbg!&lt;/p&gt;
&lt;p&gt;windbg -pn MemoryConsumption.exe&lt;/p&gt;
&lt;p&gt;Achamos onde está a memória consumida. Agora precisamos de dicas do que pode estar consumindo essa memória. Vamos começar por listar os chunks alocados por tamanho de alocação:&lt;/p&gt;
&lt;p&gt;O Top 3 é de tamanhos conhecidos pelo código, de 1024 a 1024 + QUEUESSIZE - 1. O de tamanho 1037, por exemplo, possui 0x25e5 blocos alocados. Vamos listar cada um deles:&lt;/p&gt;
&lt;p&gt;A listagem do depurador nos dá o endereço onde o chunk foi alocado no heap e o endereço devolvido para o usuário, onde colocamos nossas tralhas. Através de ambos é possível trackear a pilha da chamada que alocou cada pedaço de memória. Isso, claro, se previamente tivermos habilitado essa informação através do GFlags.aspx):&lt;/p&gt;
&lt;p&gt;Dessa forma temos onde cada memória foi alocada, o que nos dará uma informação valiosa, dependendo qual o tipo de problema estamos tentando resolver.&lt;/p&gt;
&lt;p&gt;Outra informação relevante é o que está gravado na memória, que pode nos dar insights de que tipo de objeto estamos lidando:&lt;/p&gt;
&lt;p&gt;Não é o caso, mas vamos supor que fosse um objeto/tipo conhecido. Poderíamos simplesmente &amp;quot;importar&amp;quot; o tipo diretamente do PDB que estamos para modelar a memória que encontramos em volta. Mais detalhes em outro artigo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CreateThread.aspx). Cria uma nova linha de execução.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WaitForMultipleObjects.aspx). Pode aguardar diferentes linhas de execução terminarem.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;std::list. Lista na STL para inserir/remover objetos na frente e atrás (ui).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Initialize.aspx), Enter.aspx) e LeaveCriticalSection.aspx). Uma maneira simples de criar blocos de entrada atômica (apenas uma thread entra por vez).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;memset. Se você não sabe usar memset, provavelmente não entendeu nada desse artigo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Coletando dumps automaticamente</title>
  <link>http://www.caloni.com.br/coletando-dumps-automaticamente/</link>
  <pubDate>2012-05-17</pubDate>
  
  <guid>http://www.caloni.com.br/coletando-dumps-automaticamente/</guid>
  <description>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Default value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DumpFolder&lt;/td&gt;
&lt;td&gt;[1]&lt;/td&gt;
&lt;td&gt;REGEXPANDSZ&lt;/td&gt;
&lt;td&gt;%LOCALAPPDATA%\CrashDumps&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DumpCount&lt;/td&gt;
&lt;td&gt;[2]&lt;/td&gt;
&lt;td&gt;REGDWORD&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DumpType&lt;/td&gt;
&lt;td&gt;[3]&lt;/td&gt;
&lt;td&gt;REGDWORD&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CustomDumpFlags&lt;/td&gt;
&lt;td&gt;[4]&lt;/td&gt;
&lt;td&gt;REGDWORD&lt;/td&gt;
&lt;td&gt;[5]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Chave: HKEYLOCALMACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1] The path where the dump files are to be stored. If you do not use the default path, then make sure that the folder contains ACLs that allow the crashing process to write data to the folder.For service crashes, the dump is written to service specific profile folders depending on the service account used. For example, the profile folder for System services is %WINDIR%\System32\Config\SystemProfile. For Network and Local Services, the folder is %WINDIR%\ServiceProfiles.&lt;/li&gt;
&lt;li&gt;[2] The maximum number of dump files in the folder. When the maximum value is exceeded, the oldest dump file in the folder will be replaced with the new dump file.&lt;/li&gt;
&lt;li&gt;[3] Specify one of the following dump types: 0 = Custom dump, 1 = Mini dump, 2 = Full dump&lt;/li&gt;
&lt;li&gt;[4] The custom dump options to be used. This value is used only when DumpType is set to 0.The options are a bitwise combination of the MINIDUMP_TYPE enumeration values.&lt;/li&gt;
&lt;li&gt;[5] MiniDumpWithDataSegs or MiniDumpWithUnloadedModules or MiniDumpWithProcessThreadData.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fonte: MSDN (Collecting User-Mode Dumps).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Header Inútil</title>
  <link>http://www.caloni.com.br/header-inutil/</link>
  <pubDate>2012-03-27</pubDate>
  
  <guid>http://www.caloni.com.br/header-inutil/</guid>
  <description>&lt;p&gt;O Visual Studio é uma ótima ferramenta para depurar rapidamente programas sendo desenvolvidos e para o resto usamos Vim. No entanto, a versão 2010 do ambiente (ainda não testei a 2011 beta) possui um pequeno deslize com sua árvore de dependências que não chega a prejudica o desenvolvedor, mas o deixa com um bug atrás da orelha.&lt;/p&gt;
&lt;p&gt;Vamos supor que você crie seu super-projeto ZeroMQ e no meio dele acabe evoluindo uma nova forma de vida inútil e descartável, que aqui iremos chamar de HeaderInutil e seu fiel companheiro CppInutil:&lt;/p&gt;
&lt;p&gt;OK. Ele não está fazendo nada, mas e daí? Compilo meu projeto normalmente e depuro ele como se nada estivesse acontecendo.&lt;/p&gt;
&lt;p&gt;------ Rebuild All started: Project: ZeroMasQueCoisaProj, Configuration: Debug Win32 ------
Build started 27/03/2012 11:40:32.
PrepareForClean:
Deleting file &amp;quot;Debug\ZeroMasQueCoisaProj.lastbuildstate&amp;quot;.
InitializeBuildStatus:
Creating &amp;quot;Debug\ZeroMasQueCoisaProj.unsuccessfulbuild&amp;quot; because &amp;quot;AlwaysCreate&amp;quot; was specified.
ClCompile:
stdafx.cpp
ZeroMasQueCoisaProj.cpp
CppInutil.cpp
Generating Code...
Manifest:
Deleting file &amp;quot;Debug\ZeroMasQueCoisaProj.exe.embed.manifest&amp;quot;.
LinkEmbedManifest:
ZeroMasQueCoisaProj.vcxproj -&amp;gt; c:...\Debug\ZeroMasQueCoisaProj.exe
FinalizeBuildStatus:
Deleting file &amp;quot;Debug\ZeroMasQueCoisaProj.unsuccessfulbuild&amp;quot;.
Touching &amp;quot;Debug\ZeroMasQueCoisaProj.lastbuildstate&amp;quot;.&lt;/p&gt;
&lt;p&gt;Build succeeded.&lt;/p&gt;
&lt;p&gt;Time Elapsed 00:00:00.73
========== Rebuild All: 1 succeeded, 0 failed, 0 skipped ==========&lt;/p&gt;
&lt;p&gt;&#39;ZeroMasQueCoisaProj.exe&#39;: Loaded &#39;C:...\Debug\ZeroMasQueCoisaProj.exe&#39;, Symbols loaded.
&#39;ZeroMasQueCoisaProj.exe&#39;: Loaded &#39;C:\Windows\SysWOW64\ntdll.dll&#39;, Cannot find or open the PDB file
&#39;ZeroMasQueCoisaProj.exe&#39;: Loaded &#39;C:\Windows\SysWOW64\kernel32.dll&#39;, Cannot find or open the PDB file
&#39;ZeroMasQueCoisaProj.exe&#39;: Loaded &#39;C:\Windows\SysWOW64\KernelBase.dll&#39;, Cannot find or open the PDB file
&#39;ZeroMasQueCoisaProj.exe&#39;: Loaded &#39;C:\Windows\SysWOW64\msvcr100d.dll&#39;, Symbols loaded.
The program &#39;[5212] ZeroMasQueCoisaProj.exe: Native&#39; has exited with code 0 (0x0).&lt;/p&gt;
&lt;p&gt;Show.&lt;/p&gt;
&lt;p&gt;Mas o que acontece se eu precisar no momento do refactory (que deve, sim, existir) eu decidir remover meus arquivos inúteis?&lt;/p&gt;
&lt;p&gt;Continuo compilando normalmente o projeto, mas na hora de depurar...&lt;/p&gt;
&lt;p&gt;Mas o que ocorre? Eu acabei de compilar o projeto! E se eu compilar novamente e pressionar F5, ele continua apresentando o mesmo problema!&lt;/p&gt;
&lt;p&gt;OK, não estou admitindo aqui o famigerado Rebuild All. Se você mantém projetos com mais de 200 arquivos, acho que deve repensar seus conceitos ao usar Rebuild All para tudo nessa vida.&lt;/p&gt;
&lt;p&gt;Acontece que existe uma árvore de dependências que o Visual Studio mantém para saber se seu projeto foi atualizado com tudo que tem mais de novo no que diz respeito ao File System, mas às vezes se esquece de checar o FS com o que está na solution. Por conta disso, o HeaderInutil e o CppInutil continuam dentro da árvore de dependência como zumbis.&lt;/p&gt;
&lt;p&gt;O que pode ser feito nesse caso (além do que os personagens de The Walking Dead costumam fazer) é configurar o arquivo devenv.exe.config (presente em %programfiles(x86)%\Microsoft Visual Studio 10.0\Common7\IDE) e adicionar as seguintes linhas após a seção configSections. (Esses passos estão descritos no blogue da equipe do VC.)&lt;/p&gt;
&lt;p&gt;Depois de modificar o arquivo, reinicie o Visual Studio e tente novamente apertar F5 no mesmo projeto, mas com o DebugView aberto.&lt;/p&gt;
&lt;p&gt;Como um amigo meu diria: &amp;quot;AHÁ!!&amp;quot;. Descobrimos o culpado.&lt;/p&gt;
&lt;p&gt;A solução? Nesse caso não tem jeito: dar um clean no projeto e build novamente para que o VS reconstrua a árvore de dependências. Porém, agora sabemos por que precisamos do Rebuild All. Não é RebuildAllMania.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>RValue é o novo LValue</title>
  <link>http://www.caloni.com.br/rvalue-e-o-novo-lvalue/</link>
  <pubDate>2012-01-11</pubDate>
  
  <guid>http://www.caloni.com.br/rvalue-e-o-novo-lvalue/</guid>
  <description>&lt;p&gt;As grandes discussões filosóficas que participei durante meu estudo da linguagem C, e mais tarde de C++, muitas vezes convergiam para o significado místico daquela figura que nós da gramática da linguagem conhecemos como lvalue, ou l-value, ou left-value. Enfim, a definição de uma expressão que representa um lugar na memória e, portanto, pode ocupar o lado esquerdo de uma atribuição/cópia/passagem de argumentos qualquer. Porém, os &amp;quot;grandes&amp;quot; embates daquela época hoje parecem brincadeira de criança, como a diferença sutil entre ++x e x++ ou convergência de tipos em templates.&lt;/p&gt;
&lt;p&gt;Agora o buraco é mais embaixo. Agora temos referências r-value.&lt;/p&gt;
&lt;p&gt;Agora o mundo mudou.&lt;/p&gt;
&lt;p&gt;Foi necessário que mudasse. C++, conhecido internacionalmente como a vanguarda das linguagens, mesmo mantendo sua fama de alta performance, precisava voltar às suas origens performáticas de qualquer forma. O Criador da linguagem e seus seguidores estavam cientes: cópia de strings é uma coisa muito, muito má. Imperfect forwarding (direcionamento imperfeito?) é algo ainda pior, pois é mais sutil.&lt;/p&gt;
&lt;p&gt;Todos concordam, então, que a mudança é necessária. Nem todos concordam, contudo, com o preço a ser pago. As coisas começam a ficar cada vez mais difíceis de entender, e agora, com r-values vindo à superfície, o universo de criaturas bizarras volta a mostrar as caras.&lt;/p&gt;
&lt;p&gt;Desde o começo de meus estudos em C++ tenho admirado a linguagem com um certo distanciamento. Enquanto a linguagem C continua sendo o supra-sumo das linguagens de médio-nível, C++ continua sendo uma abominação cujos detalhes muitos preferem esquecer. Mas esquecer tem se tornado cada vez mais difícil frente às adaptações técnicas que a linguagem vem sofrendo.&lt;/p&gt;
&lt;p&gt;No caso de Rvalues, se antes existia uma discussão interminável sobre sua inclusão no novo padrão, agora existem discussões acerca do que tudo isso significa. Existe até um ótimo guia (thanks to pepperchico) sobre as principais mudanças de conceitos, feito para simplificar o entendimento. Mas ele mesmo é exageradamente complexo para o programador médio. É de forçar a barra, mesmo. É pedir demais.&lt;/p&gt;
&lt;p&gt;No próximo dia 28, sábado, nos reuniremos em mais um evento C++ organizado pelo Grupo C/C++ Brasil e pelos agora dois MVPs do Brasil, o veterano Fabio Galuppo e o novato Rodrigo Strauss (meu amigo, mas acima de tudo muito bem-vindo ao cargo). Estou na lista de palestrantes e conversarei com vocês sobre as otimizações que o famigerado RValue deve trazer à mesa. Espero conseguir entender um pouco mais sobre essa criatura fantástica até lá.&lt;/p&gt;
&lt;p&gt;Se o Cebolinha for um programador C++, deve estar se debatendo nesse momento.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ Rvalue References Explained&lt;/li&gt;
&lt;li&gt;A Brief Introduction to Rvalue References&lt;/li&gt;
&lt;li&gt;Want Speed? Pass by Value&lt;/li&gt;
&lt;li&gt;MSDN Community: C++ Renaissance, São Paulo - SP.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Faça sua incrição!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Depuração de emergência com receita de bolo no WinDbg</title>
  <link>http://www.caloni.com.br/depuracao-de-emergencia-receita-de-bolo/</link>
  <pubDate>2011-10-18</pubDate>
  
  <guid>http://www.caloni.com.br/depuracao-de-emergencia-receita-de-bolo/</guid>
  <description>&lt;p&gt;Continuando o papo sobre o que fazer para analisar rapidamente um crash no servidor com o pacote WinDbg, na maioria das vezes a exceção lançada pelo processo está diretamente relacionada com um acesso indevido à memória, o que tem diversas vantagens sobre problemas mais complexos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Possui localização precisa de onde ocorreu a violação, incluindo o nome do arquivo e a linha do código;&lt;/li&gt;
&lt;li&gt;Não corrompe a pilha ou, se corrompe, não chega a afetá-la a ponto da thread ficar irreconhecível;&lt;/li&gt;
&lt;li&gt;A thread que contém a janela de crash é a culpada imediata, então basta olhar a pilha.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Resumindo: basta olhar a pilha! Mas, para isso ser efetivo, precisaremos do PDB do executável que gerou o crash, pois através dele é possível puxar a tal localização da violação de acesso. Isso quer dizer que se você mantiver o executável, e DLL também é executável, juntinho com seu PDB, ou pelo menos facilmente localizável, sua vida será muito mais fácil e florida. Também significa que poderá começar a beber cerveja mais cedo.&lt;/p&gt;
&lt;p&gt;Mesmo que em alguns momentos-surpresa apareça uma ou outra tela indesejada.&lt;/p&gt;
&lt;p&gt;O comando mais útil na maioria desses casos é mostrar a pilha no modo verbose, usando o comando kv seguido de enter. Porém, antes disso, precisamos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ajeitar o path dos símbolos;&lt;/li&gt;
&lt;li&gt;Recarregar o PDB do executável suspeito;&lt;/li&gt;
&lt;li&gt;Mostrar a pilha de todas as threads até descobrir a culpada.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Todos esses comandos podem ser vistos abaixo. São, respectivamente, .symfix, .reload e novamente o kv, com a diferença de que para todas threads.&lt;/p&gt;
&lt;p&gt;Ops! Um pequeno desvio do curso. Estamos rodando um processo de 32 bits dentro de um SO 64 bits, no exemplo um Windows 7. Isso pode acontecer e é bom saber o que fazer nesse caso. Seguimos com os comandos .load wow64exts e .effmach x86, que irá carregar a extensão de wow64 do depurador e iniciar a tradução da stack para 32 bits.&lt;/p&gt;
&lt;p&gt;Nosso depurador favorito acusa uma pilha que contém a função WerpReportFault. Nessa mesma thread a última linha conhecida nossa está no arquivo crashonserver.cpp:13. E essa situação, caro leitor, é dez por cento de tudo o que você precisa saber sobre WinDbg para resolver, mas que já resolve noventa por cento dos casos que irá encontrar em produção. Belo custo-benefício, não?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Coders at Work: Reflections on the Craft of Programming</title>
  <link>http://www.caloni.com.br/coders-at-work/</link>
  <pubDate>2011-10-14</pubDate>
  
  <guid>http://www.caloni.com.br/coders-at-work/</guid>
  <description>&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Personally I have never believed that it is possible to be a good coder without being a good programmer nor a good programmer without being a good designer, communicator, and thinker.&amp;quot; - Jamie Zawinski&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Como Joel e Atwood disseram, a leitura de Coders At Work é tão útil quanto ler o código dos outros, só que em um estilo mais condensado, que se aproveita das décadas de experiência dessa gente para aprimorarmos nossos processos de desenvolvimento e, muitas vezes, a forma de pensarmos sobre software.&lt;/p&gt;
&lt;p&gt;No meu estilo de leitura circular, adaptada do brilhante (maluco?) método de Dmitry Vostokov, as coisas vão mais devagar, e estou apenas no início do livro, tendo passado por Jamie Zawinski (desenvolvedor da equipe original do Netscape), Brad Fitzpatrick (criador do Live Journal) e terminado recentemente Douglas Crockford. O artigo de Joel sobre Zawinski demonstra seu apreço pelo codificador pensante, ou aquele que faz as coisas acontecerem e não fica preso eternamente na armadilha da arquitetura. Eu acredito que as seguintes passagens do livro demonstram seu pensamento melhor do que se eu fosse tentar traduzi-los, começando por Jamie Zawinski:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Personally I have never believed that it is possible to be a good coder without being a good programmer nor a good programmer without being a good designer, communicator, and thinker. (...) Start converting it into the bad one until it stops working. That&#39;s primary tool of reverse engineering. (...) Your competitor&#39;s six-month 1.0 has crap code and they&#39;re going to have to rewrite it in two years but, guess what: they can rewrite it because you don&#39;t have a job anymore. (...) The design process is definitely an ongoing thing; you never know what the design is until the program is done. So I prefer to get my feet wet as early as possible; get something on the screen so I can look at it sideways.(...) I&#39;ve noticed that one thing that separates good programmers from bad programmers is that good programmers are more facile at jumping between layers of abstraction they can keep the layers distinct while making changes and choose the right layer to make changes in. (...) I think one of the most important things, for me anyway, when building something from the ground up like that is, as quickly as possible, getting the program to a state that you, the programmer, can use it. Even a little bit. Because that tells you where to go next in a really visceral way. (...) I don&#39;t want to be a mathematician but I&#39;m not going to criticize someone who is a mathematician. It&#39;s weird that people often confuse those two pursuits. People who are into very theoretical computer science are thought of in this same way as people who are shipping desktop applications. And they don&#39;t really have a lot to do with each other. (...) Then there was another book that everybody thought was the greatest thing ever in that same period&#39;Design Patterns&#39;which I just thought was crap. It was just like, programming via cut and paste. Rather than thinking through your task you looked through the recipe book and found something that maybe, kinda, sorta felt like it, and then just aped it. That&#39;s not programming; that&#39;s a coloring book. (...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;De certa forma, o mesmo pragmatismo pode ser observado em Douglas Crockford, que utiliza o método de leitura de código tanto na entrevista por candidatos (&amp;quot;traga-me o código que tem orgulho de ter escrito e explique-o pra mim&amp;quot;) quanto no dia-a-dia do projeto, para que todos entendam e aproveitem a evolução do projeto como um todo, além de constituir, na minha visão, uma das melhores dicas de auto-management que uma equipe de programadores poderia ter.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One of the things I&#39;ve been pushing is code reading. I think that is the most useful thing that a community of programmers can do for each other&#39;spend time on a regular basis reading each other&#39;s code. There&#39;s a tendency in project management just to let the programmers go off independently and then we have the big merge and then we have the big merge and if it builds then we ship it and we&#39;re done and we forget about it. One of the consequences of that is that if you have weak or confused programmers you&#39;re not aware of their actual situation until much too late. And so the risks to the project, that you&#39;re that you&#39;re going to have to build with stuff that&#39;s bad and the delays that that causes, that&#39;s unacceptable. The other thing is that you may have brilliant programmers on the project who are not adequately mentoring the other people on the team. Code reading solves both of those problems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Can you talk a bit about how you conduct a code reading?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;At each meeting, someone&#39;s responsible for reading their code, and they&#39;ll walk us through everything, and the rest of us will observe. It&#39;s a really good chance for the rest of the team to understand how their stuff is going to have to fit with that stuff.
We get everybody around the table; everybody gets a stack of paper. We also blow it up on the screen. And we all read through it together. And we&#39;re all commenting on the code as we go along. People say, &#39;I don&#39;t understand this comment,&#39; or, &#39;This comment doesn&#39;t seem to describe the code.&#39; That kind of stuff can be so valuable because as a programmer you stop reading your own comments and you&#39;re not aware that you&#39;re misdirecting the reader. Having the people you work with helping to keep your code clean is a huge service&#39;you find defects that you never would&#39;ve found on your own.
I think an hour of code reading is worth two weeks of QA. It&#39;s just a really effective way of removing errors. If you have someone who is strong reading, then the novices around them are going to learn a lot that they wouldn&#39;t be learning otherwise, and if you have a novice reading, he&#39;s going to get a lot of really good advice.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So if you don&#39;t clean up every seventh cycle you may be faced with the choice of whether or not to do a big rewrite. How do you know when, if ever, it&#39;s time for a big rewrite?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Generally the team knows when it&#39;s time. Management finds out a lot later. The team is getting beat up pretty regularly, making too many pretty regularly, making too many bugs; the code&#39;s too big, it&#39;s too slow; we&#39;re falling behind. They know why. It&#39;s not because they became stupider or lazier. It&#39;s because the code base is no longer serving the purpose that it needs to.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Esse pequeno trecho da entrevista de Brendan Eich, de Coders at Work, revela parte das frustações que os programadores de linha de frente sofrem com os ambientes de depuração, muitas vezes aquém dos desafios atuais. Sinceramente, não sinto isso em meu dia-a-dia, e acho o Visual Studio um excelente depurador com interface (mas que perde feio para o WinDbg em casos mais hardcore). Porém, fica a percepção curiosa do criador do JavaScript.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Proofs are hard. Most people are lazy. Larry Wall is right. Laziness should be a virtue. So that&#39;s why I prefer automation. Proofs are something that academics love and most programmers hate.&amp;quot; - Brendan Eic&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SGI:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Diagnosing it was hard because it was timing-sensitive. It had to do with these machines being abused by terminal concentrators. People were hooking up a bunch of PTYs to real terminals. Students in a lab or a bunch of people in a mining software company in Brisbane, Australia in this sort of &#39;70s sea of cubes with a glass wall at &#39;70s sea of cubes with a glass wall at the end, behind which was a bunch of machines including the SGI two-processor machine. That was hard and I&#39;m glad we found it. These bugs generally don&#39;t linger for years but they are really hard to find. And you have to sort of suspend your life and think about them all the time and dream about them and so on. You end up doing very basic stuff, though. It&#39;s like a lot of other bugs. You end up bisecting&#39;you know &#39;wolf fence.&#39; You try to figure out by monitoring execution and the state of memory and try to bound the extent of the bug and control flow and data that can be addressed. If it&#39;s a wild pointer store then you&#39;re kinda screwed and you have to really start looking at harder-to-use tools, which have only come to the fore recently, thanks to those gigahertz processors, like Valgrind and Purify.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ferramentas de Depuração Avançadas:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Instrumenting and having a checked model of the entire memory hierarchy is big. Robert O&#39;Callahan, our big brain in New Zealand, did his own debugger based on the Valgrind framework, which efficiently logs every instruction so he can re-create the entire program state at any point. It&#39;s not just a time-traveling debugger. It&#39;s a full database so you see a data structure and there&#39;s a field with a scrogged value and you can say, &#39;Who wrote to that last?&#39; and you get the full stack. You can reason from effects back to causes. Which is the whole game in debugging. So it&#39;s very slow. It&#39;s like a hundred times slower than real time, but there&#39;s hope.
Or you can use one of these faster recording VMs&#39;they checkpoint only at system call and I/O boundaries. They can re-create corrupt program states at any boundary but to go in between those is harder. But if you use that you can probably close in quickly at near real time and then once you get to that stage you can transfer it into Rob&#39;s Chronomancer and run it much slower and get all the program states and find the bug.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Depuradores da Indústria:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Debugging technology has been sadly underresearched. That&#39;s another example where there&#39;s a big gulf between industry and academia: the academics are doing proofs, sometimes by hand, more and more mechanized thanks to the POPLmark challenge and things like that. But in the real world we&#39;re all in debuggers and they&#39;re pieces of shit from the &#39;70s like GDB.
Yeah. So I use GDB, and I&#39;m glad GDB, at least on the Mac, has a watch-point facility that mostly works. So I can watch an address and I can catch it changing from good bits to bad bits. That&#39;s pretty helpful. Otherwise I&#39;m using printfs to bisect. Once I get close enough usually I can just try things inside GDB or use some amount of command scripting. But it&#39;s incredibly weak. The scripting language itself is weak. I think Van Jacobson added loops and I don&#39;t even know if those made it into the real GDB, past the FSF hall monitors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Multithreading:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;But there&#39;s so much more debugging can do for you and these attempts, like Chronomancer and Replay, are good. They certainly changed the game for me recently. But I don&#39;t know about multithreading. There&#39;s The multithreaded stuff, frankly, scares me because before I was married and had kids it took a lot of my life. And not everybody was ready to think about concurrency and all the possible combinations of orders that are out there for even small scenarios. Once you combine code with other people&#39;s code it just gets out of control. You can&#39;t possibly model the state space in your head. Most people aren&#39;t up to it. I could be like one of these chestthumpers on Slashdot&#39;when I blogged about &#39;Threads suck&#39; someone was saying, &#39;Oh he doesn&#39;t know anything. He&#39;s not a real man.&#39; Come on, you idiot. I got a trip to New Zealand and Australia. I got some perks. But it was definitely painful and it takes too long. As Oscar Wilde said of socialism, &#39;It takes too many evenings.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;E isso é tudo que guardarei deste livro. Talvez o revisite daqui a algumas décadas para comparar os novos tempos que viveremos.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In the real world one big split is between people who use symbolic debuggers and people who use print statements. - Peter Seibe&lt;/p&gt;
&lt;/blockquote&gt;
</description>
</item>

     
        <item>
  <title>Cuidado com variáveis temporárias</title>
  <link>http://www.caloni.com.br/cuidado-com-variaveis-temporarias/</link>
  <pubDate>2011-07-26</pubDate>
  
  <guid>http://www.caloni.com.br/cuidado-com-variaveis-temporarias/</guid>
  <description>&lt;p&gt;Um dos problemas que a linguagem C++ possui para seus iniciantes é o de não deixar muito explícito partes do seu comportamento, principalmente as partes que lidam com ponteiros/referências e o jogo da vida dos objetos. Às  vezes a coisa fica de tal como complexa que fica até difícil explicar o porquê das coisas.&lt;/p&gt;
&lt;p&gt;Por exemplo, vejamos o singelo caso de alguém que precisa formatar uma saída de erro e para isso escolheu um stringstream:&lt;/p&gt;
&lt;p&gt;Quando chamamos func, ele lança uma exceção que é capturada no main que, por sua vez, formata uma stream e obtém sua string (através do método str) e através dessa string obtém o ponteiro da string em C puro (através do método cstr). Porém, a mensagem resultante na saída-padrão de erro não era o esperado:&lt;/p&gt;
&lt;p&gt;Depurando diretamente, vemos que a stream, de fato, contém o que esperávamos. O único elemento errante é justamente o ponteiro obtido através da chamada dupla de métodos.&lt;/p&gt;
&lt;p&gt;O porquê isso ocorre só fica óbvio quando vemos a ajuda (ou a assinatura) da função str da classe stringstream:&lt;/p&gt;
&lt;p&gt;Ora, a função str retorna uma cópia do objeto string usado internamento pelo buffer de nossa string stream. Duas coisas ocorrem em qualquer cópia de um objeto retornada por uma função:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A cópia do objeto original e seu desacoplamento (óbvio).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A construção de um objeto baseado no original e que, após o fim da expressão onde foi chamado o método, é destruído.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Uma vez que a chamada a str termina, é entregue uma instância de uma string que contém a string original que está sendo usada pela string stream para a expressão da chamada, que geralmente vem seguida de uma cópia:&lt;/p&gt;
&lt;p&gt;A variável buf no exemplo acima será, portanto, a terceira string usada aqui até então. Ao final da expressão, a string intermediária retornada por str é automaticamente destruída, por se trata de uma cópia temporária para obedecer a sintaxe de retorno da função.&lt;/p&gt;
&lt;p&gt;Agora, o que acontece se, na cópia temporária, é feita uma operação para obter seu ponteiro interno usado para armazenar sua string estilo C?&lt;/p&gt;
&lt;p&gt;Obviamente ele fica inválido após o fim da expressão!&lt;/p&gt;
&lt;p&gt;Vamos ver em câmera lenta:&lt;/p&gt;
&lt;p&gt;Nada como assembly fresquinho para refrescar os conceitos de C++ por baixo dos panos.&lt;/p&gt;
&lt;p&gt;Após uma enxurrada de programadores gerenciáveis perguntarem qual seria, então, a solução ideal, segue o snipet mais explicitado:&lt;/p&gt;
&lt;p&gt;Outro leitor sugeriu fazer toda a chamada em uma única instrução, economizando em expressividade e ainda evitando a destruição da variável temporária criada ao chamar str.&lt;/p&gt;
&lt;p&gt;Particularmente, gosto de instruções simples que me permitam ver claramente o que está acontecendo de forma simples pelo depurador (até porque sei que o compilador irá otimizar tudo no final em versão Release, ainda mais se estiver quebrado em instruções simples). Porém, toda solução que evita o uso da variável temporária após a execução do método str é válida.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Depuração de emergência</title>
  <link>http://www.caloni.com.br/depuracao-de-emergencia/</link>
  <pubDate>2011-07-26</pubDate>
  
  <guid>http://www.caloni.com.br/depuracao-de-emergencia/</guid>
  <description>&lt;p&gt;O programa está rodando no servidor do cliente, que é acessível por sessão remota do Windows, mas de repente ele capota. Existem aí duas possibilidades fora o debug remoto (que, nesse caso, não é possível):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Analisar um dump gerado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Depurar localmente o problema.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Para a primeira opção, basta abrir o Gerenciador de Tarefas, localizar o processo e gerar o dump através do menu de contexto.&lt;/p&gt;
&lt;p&gt;Com o dump e o Windbg em mãos, basta analisá-lo. Porém, se o seu processo é 32 bits e o servidor é 64 bits (geralmente é), o dump gerado será de 64 bits, EMBORA seja de um process 32. Ou seja, ao abri-lo, o sistema vai mostrar as threads de manipulação do SO para sistemas 32 (todos com o nosso amigo wow64cpu).&lt;/p&gt;
&lt;p&gt;Após esse último passo, siga para o último passo desse tutorial. Ou escolha a segunda opção:&lt;/p&gt;
&lt;p&gt;Para depurar localmente, supondo que seja um executável simples, você precisa dos seguintes itens:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pasta do WinDbg copiado (a Debugging Tools instalada pelo SDK, ou sua pastinha particular guardada no PenDrive).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Símbolos dos binários envolvidos (em sincronia com os binários que iremos analisar).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fontes da compilação dos binários (a versão exata seria ideal; grave o revno do controle de fonte pra facilitar).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Os fontes, no caso de uma conexão por Terminal Server, podem ser disponibilizados através do mapeamento de drives entre as máquinas. Os símbolos, no entanto, por serem usados extensivamente pelo WinDbg, é recomendável que estejam locais na máquina depurada, pois do contrário você terá que tomar uma quantidade excessiva de cafés para executar meia-dúzia de instruções.&lt;/p&gt;
&lt;p&gt;Supondo que temos tudo isso, só precisamos executar alguns passos básicos para o setup:&lt;/p&gt;
&lt;p&gt;Por último, execute o seguinte comando na tela de comandos do WinDbg:&lt;/p&gt;
&lt;p&gt;E boa sorte =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Novo branch para projetos do Caloni.com.br</title>
  <link>http://www.caloni.com.br/novo-branch-para-projetos-do-caloni-com-br/</link>
  <pubDate>2011-05-29</pubDate>
  
  <guid>http://www.caloni.com.br/novo-branch-para-projetos-do-caloni-com-br/</guid>
  <description>&lt;p&gt;Reestruturei meus projetos caseiros e coloquei todos em um branch no repositório do Assembla. A partir dele começarei a reestruturas os códigos de exemplo do saite, o deve facilitar o acesso. Para usuários do Bazaar, como eu, basta puxar o branch usando seu endereço:&lt;/p&gt;
&lt;p&gt;Para os usuários do Subversion, ou qualquer outro controle de fonte que consiga ler um branch feito em SVN, google for it.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Comparando strings no WinDbg</title>
  <link>http://www.caloni.com.br/comparando-strings-no-windbg/</link>
  <pubDate>2011-05-22</pubDate>
  
  <guid>http://www.caloni.com.br/comparando-strings-no-windbg/</guid>
  <description>&lt;p&gt;O WinDbg fornece aos programadores diversos meios (muitos redundantes) de comparar valores inteiros em quaquer lugar da memória, em qualquer tamanho (8, 16, 32, 64 bits). Porém, quando precisamos comparar strings, que todos sabem ser uma sequência de bytes de tamanho arbitrário (se for em C, até o zero terminador).&lt;/p&gt;
&lt;p&gt;Uma solução simples e rápida é comparar os 4 primeiros bytes de uma string, ou os 4 primeiros bytes que diferem de uma lista grande.&lt;/p&gt;
&lt;p&gt;Por exemplo, imagine o seguinte código que abre todos os arquivos da pasta de sistema:&lt;/p&gt;
&lt;p&gt;Queremos colocar um breakpoint no momento em que o arquivo shell32.dll estiver sendo aberto. Para isso, devemos nos atentar para os parâmetros passados para a função CreateFile.&lt;/p&gt;
&lt;p&gt;Temos que nos atentar para o padrão de bits após esse path. Vamos dar uma olhada por dentro da string.&lt;/p&gt;
&lt;p&gt;O nome do arquivo começa no offset 16+4 = 20, ou 14 em hexa. Dessa forma, podemos capturar o padrão de bits da seguinte maneira:&lt;/p&gt;
&lt;p&gt;Para nos certificarmos que é realmente esse o padrão, e para já montarmos nosso próprio padrão para o shell32.dll, vamos alocar um pedaço de memória e verificar se a sequência de bits está correta.&lt;/p&gt;
&lt;p&gt;Ótimo. Os padrões bateram, então podemos colocar um breakpoint condicional partindo do padrão de bits do nome do arquivo que precisamos.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Sem reflection</title>
  <link>http://www.caloni.com.br/sem-reflection/</link>
  <pubDate>2011-05-18</pubDate>
  
  <guid>http://www.caloni.com.br/sem-reflection/</guid>
  <description>&lt;p&gt;Em C++ não temos (ainda) a possibilidade de listarmos, por exemplo, a lista de métodos de um determinado tipo, a fim de chamá-lo pelo nome em tempo de execução. Algo assim:&lt;/p&gt;
&lt;p&gt;OK, foi apenas um exemplo tosco de como seria um reflection em C++.&lt;/p&gt;
&lt;p&gt;Porém, existem algumas maneiras de contornar esse problema. A solução, é claro, depende de qual problema você está tentando resolver.&lt;/p&gt;
&lt;p&gt;Vamos supor, por exemplo, que você queira cadastrar funções para serem chamadas de maneira uniforme pelo prompt de comando. Vamos chamar nossa classe tratadora de CommandPrompt.&lt;/p&gt;
&lt;p&gt;Internamente, para armazenar as funções de acordo com o nome dado, basta criarmos um mapeamento entre esses dois tipos e fazemos a amarração necessária para o método principal de parseamento:&lt;/p&gt;
&lt;p&gt;Essa solução não é exatamente um reflection, mas apenas parte do que o verdadeiro reflection possibilita. Existem outras funcionalidades, como traits, que a STL já consegue se virar razoavelmente bem, por exemplo.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Houaiss 1.3</title>
  <link>http://www.caloni.com.br/houaiss-1-3/</link>
  <pubDate>2011-04-28</pubDate>
  
  <guid>http://www.caloni.com.br/houaiss-1-3/</guid>
  <description>&lt;p&gt;Os problemas relacionados com acesso negado durante a conversão/construção do dicionário foram corrigidos na novíssima versão disponível no GitHub.&lt;/p&gt;
&lt;p&gt;Erroneamente imaginando que a falta de acesso tinha alguma coisa a ver com a escrita de arquivos no disco, ou até mesmo com a execução de processos, descobri depurando (o bom e velho depurador) que a origem do acesso negado estava na função AssignProcessToJobObject.aspx). Misteriosamente, no Windows 7, ao chamar essa função ocorre esse erro, independente da execução ser como administrador ou não.&lt;/p&gt;
&lt;p&gt;Como já está se tornando tradição de uns tempos pra cá, a solução veio de um artigo do Stack Overflow, cuja melhor solução foi exatamente a que eu segui: inserir o manifesto do UAC e usar a flag CREATEBREAKAWAYFROMJOB.&lt;/p&gt;
&lt;p&gt;Agora é só esperar pelo próximo bug =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Bazaar com Subversion</title>
  <link>http://www.caloni.com.br/bazaar-com-subversion/</link>
  <pubDate>2011-03-23</pubDate>
  
  <guid>http://www.caloni.com.br/bazaar-com-subversion/</guid>
  <description>&lt;p&gt;Para pessoas que ficaram viciadas em commits curtos e todo o histórico do fonte na própria máquina, foi uma surpresa descobrir que com o uso do plugin bzr-svn (já incluso no pacote de instalação), consigo ainda utilizar o Bazaar, mesmo que agora esteja trabalhando com um branch do Subversion.&lt;/p&gt;
&lt;p&gt;Na verdade, melhor ainda: o bzr-svn baixa o SVN trunk com todo o histórico na máquina local, como se fosse um branch do próprio Bazaar, e permite a criação de branches desconectados para pequenos commits e o merge final para o servidor SVN.&lt;/p&gt;
&lt;p&gt;E o melhor de tudo: não há segredo. Tudo que precisa fazer é instalar o Bazaar e fazer um get/co com o endereço do branch SVN que o plugin se vira sozinho para detectar que se trata do Subversion. (Se for um branch protegido, o usuário e senha serão pedidos durante o processo).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Houaiss no Kindle</title>
  <link>http://www.caloni.com.br/houaiss-no-kindle/</link>
  <pubDate>2011-03-22</pubDate>
  
  <guid>http://www.caloni.com.br/houaiss-no-kindle/</guid>
  <description>&lt;p&gt;O blogue de José Ribeiro Pena Neto, aparentemente recém-criado, conseguiu utilizar minha solução de conversão do dicionário Houaiss para Babylon em algo mais incrívei ainda: converter, em alguns passos, a base de dados do Houaiss para o Amazon Kindle.&lt;/p&gt;
&lt;p&gt;De uma maneira simples e efetiva, ele cita o passo-a-passo para a conversão da base Houaiss para o formato Babylon e, a partir disso, reconverter para o formato usado pelo gratuito e multiplataforma Stardict.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Loucuras multithreading</title>
  <link>http://www.caloni.com.br/loucuras-multithreading/</link>
  <pubDate>2011-03-18</pubDate>
  
  <guid>http://www.caloni.com.br/loucuras-multithreading/</guid>
  <description>&lt;p&gt;Estava eu depurando um sistema cliente/servidor com um tantão de threads e me veio à cabeça na volta pra casa como que um programador iniciante entenderia aquela bagunça de dar F10 em uma função e cair no meio de outra, dar outro F10 na outra e voltar pra primeira.&lt;/p&gt;
&lt;p&gt;Loucura, não?&lt;/p&gt;
&lt;p&gt;Nem tanto. O multithreading de um sistema operacional está aí pra isso. O que ocorre, no caso de depurações em uma única IDE, é que os breakpoints temporários que são definidos ao usar o comando de step into/over podem ser ativados em paralelo, simultaneamente.&lt;/p&gt;
&lt;p&gt;Mas confesso que, de vez em quando, depurar múltiplas threads fica parecendo coisa de maluco.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Base64</title>
  <link>http://www.caloni.com.br/base64/</link>
  <pubDate>2011-03-09</pubDate>
  
  <guid>http://www.caloni.com.br/base64/</guid>
  <description>&lt;p&gt;No meio dos meus artigos pendentes, encontrei esse, de Luiz Rocha, que fala sobre a dificuldade de entender o que seria Base64:&lt;/p&gt;
&lt;p&gt;Não é a primeira pessoa que pede informações sobre algo específico demais para explicar (para isso existe a Wikipedia e o Google, não?). No meio da minha escrita, percebi que já havia escrito sobre os fundamentos do conhecimento por trás da criação do Base64, conhecimento esse, acredito eu, todo programador que quer sair do lugar com os próprios pés deve ter.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Básico do básico: assembly&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Básico do básico: binário &amp;lt;-- Luiz, você está procurando por esse!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Básico do básico: tipos&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Básico do básico: ponteiros&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Bônus:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Como ofuscar strings&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Passagem por valor e emails com anexo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Como funcionam as strings&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;REALMENTE para iniciantes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Configurando seus projetos no Visual Studio&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Como criar uma LIB no Visual Studio&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Acredito que tudo que um programador precisa saber é o básico. O problema é que esse básico cresce a cada ano, mas, de qualquer forma, continua sendo necessário voltar às raízes de vez em quando, e se existe algo que ele nunca deve esquecer, é isso.&lt;/p&gt;
&lt;p&gt;Até porque na programação, 90% não se cria, se copia.&lt;/p&gt;
&lt;p&gt;Imaginemos o cenário para a criação do Base64:&lt;/p&gt;
&lt;p&gt;Alguns meios de comunicação, notadamente envio de e-mails e a navegação web, por incrível que pareça, trabalham em um protocolo totalmente em modo texto. É até fácil de entender, pois quando essas tecnologias nasceram as limitações de velocidade e estabilidade das conexões permitiam apenas o envio de texto puro de uma ponta a outra.&lt;/p&gt;
&lt;p&gt;Isso quer dizer que, na prática, os anexos de um e-mail e as imagens de uma página trafegam, pelo protocolo definido, em modo texto.&lt;/p&gt;
&lt;p&gt;Como isso é possível?&lt;/p&gt;
&lt;p&gt;A solução não é tão obscura quanto possa parecer. Se um programador médio tivesse esse problema e nenhuma solução existisse ainda, ele faria o que sempre fez para resolver problemas desse tipo: codificar a mensagem na forma permitida. Isso já é feito com o próprio texto, que é apenas uma interpretação de tabelas de caracteres.&lt;/p&gt;
&lt;p&gt;Tudo que é necessário fazer é o contrário, mas usando a mesma lógica: montar uma tabela de caracteres válidos e traduzir para um conteúdo binário, sendo que todas as combinações possíveis devem caber nessa tabela.&lt;/p&gt;
&lt;p&gt;A forma mais básica binária de comunicação é um byte, constituído por 8 bits, que combinados darão 2^8 entradas em nossa tabela, que precisaria de 256 caracteres diferentes. Como isso ultrapassa o limite dos protocolos que estamos lidando, que em sua maioria utilizam a tabela ascii básica, que possui 128 posições, sendo que algumas posições não possuem caracteres imprimíveis, decidiu-se usar o múltiplo anterior: 64 posições, o que nos dá a chance de codificar 6 bits de cada vez (2^6).&lt;/p&gt;
&lt;p&gt;Esse padrão de codificação se chama Base64. Se quiser mais detalhes, basta ler a RFC, que é pequena e muito simples de se ler.&lt;/p&gt;
&lt;p&gt;Agora, como codificar essa solução? Só entendendo o básico, é claro.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Projeto DayToDay</title>
  <link>http://www.caloni.com.br/projeto-daytoday/</link>
  <pubDate>2011-03-03</pubDate>
  
  <guid>http://www.caloni.com.br/projeto-daytoday/</guid>
  <description>&lt;p&gt;O DayToDay é um projetinho que criei para fazer tracking das minhas atividades diárias. Eu o criei há mais de 6 anos, e provavelmente se tivesse pensado em como isso seria útil para as pessoas compartilharem suas ideias e limitasse o número de caracteres para 140, estaria rico hoje.&lt;/p&gt;
&lt;p&gt;O &amp;quot;conceito&amp;quot; é bem simples: executo o programa, ele exibe um campo texto para digitar o que estou fazendo, digito enter ou clico no botão de OK e ele fecha. O que eu digitei cai em um arquivo texto com o mesmo nome do programa.&lt;/p&gt;
&lt;p&gt;Algumas &amp;quot;features&amp;quot; avançadas que é bom saber:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ele gera o arquivo texto em UNICODE. Na época em que eu digitava em russo, isso era importante.&lt;/li&gt;
&lt;li&gt;Ele já gera suas anotações com data e hora.&lt;/li&gt;
&lt;li&gt;Você pode gerar um atalho para chamá-lo rapidamente e definir um diretório de trabalho diferente: o arquivo será gerado no diretório de trabalho especificado, e não onde está o executável.&lt;/li&gt;
&lt;li&gt;Existe uma versão em .NET que fiz na época que estudava C#. Felizmente eu perdi esse projeto.&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>VTable</title>
  <link>http://www.caloni.com.br/vtable/</link>
  <pubDate>2011-03-01</pubDate>
  
  <guid>http://www.caloni.com.br/vtable/</guid>
  <description>&lt;p&gt;Acho que na breve história desse blogue nunca contei a história do vtable. No máximo fizemos um hookzinho nos métodos de um componente COM. Mas só.&lt;/p&gt;
&lt;p&gt;Não encontro uma analogia simples, assim, de cabeça. Então vou contar no cru, mesmo. Talvez seja até mais divertido.&lt;/p&gt;
&lt;p&gt;A vtable foi um mecanismo criado para implementar o polimorfismo em C++ quando falamos de ponteiros para classes base cujos métodos virtuais foram sobrescritos por uma classe derivada.&lt;/p&gt;
&lt;p&gt;A coisa fica mais simples quando explicamos que em C++ você só paga pelo que usa. Se você declarar uma classe que não tenha nenhum método virtual, os objetos dessa classe não precisarão de uma vtable. No entanto, você não conseguirá sobrescrever um método dessa classe através de uma derivada:&lt;/p&gt;
&lt;p&gt;No exemplo acima, a chamada feita em func irá chamar o método da classe C, mesmo que a classe D tenha sobrescrito esse método. O programador semi-experiente deve pensar &amp;quot;lógico, ela não é virtual!&amp;quot;, e está certo, assim como qualquer pessoa que decora essas formulazinhas de vestibular.&lt;/p&gt;
&lt;p&gt;Para criarmos polimorfismo de verdade, precisamos declarar o método em C como virtual:&lt;/p&gt;
&lt;p&gt;Agora sim, a chamada em func irá ser para D::method.&lt;/p&gt;
&lt;p&gt;Pergunte para o programador semi-experiente em C++ por que as coisas são assim e provavelmente ele irá falar algo sobre vtable, mesmo que não saiba exatamente como ela funciona.&lt;/p&gt;
&lt;p&gt;A vtable é uma tabela que guarda o endereço dos métodos virtuais de uma classe. Se uma classe derivada sobrescrever um ou mais métodos de sua classe base, ela terá uma outra vtable com os endereços dos métodos &amp;quot;corrigidos&amp;quot;.&lt;/p&gt;
&lt;p&gt;Dessa forma, algo um pouco diferente ocorre na chamada c-&amp;gt;method() quando estamos lidando com classes polimórficas: o início de um objeto dessa classe terá um ponteiro para a vtable de sua classe. Quando um método virtual é chamado, em vez do compilador gerar uma chamada estática para o endereço do método da classe cujo tipo estamos usando, ele irá redirecionar essa chamada para uma posição na vtable para onde esse objeto aponta. No caso de um objeto do tipo D, a entrada para method em sua vtable apontará não para C::method, mas para D::method, uma função com a mesma assinatura contida na classe base C e que, portanto, a sobrescreve.&lt;/p&gt;
&lt;p&gt;Façamos um pequeno teste para comprovar o que falamos. Vamos escancarar a chamada feita a partir de uma instância de D e a partir de uma instância de C. Nada que um WinDbg não resolva de braços cruzados:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Esse ponteiro vai até onde?</title>
  <link>http://www.caloni.com.br/esse-ponteiro-vai-ate-onde/</link>
  <pubDate>2011-01-17</pubDate>
  
  <guid>http://www.caloni.com.br/esse-ponteiro-vai-ate-onde/</guid>
  <description>&lt;p&gt;Brincando com obtenções e conversões de SIDs, tive uma pequena dificuldade de usar a função ConvertStringSidToSid, de Sddl.h. Seu objetivo é receber uma string-SID no formato usado pela ferramenta PsGetSid e retornar uma sequência de bytes de tamanho arbitrário, que é o SID como o sistema o enxerga. Como ela retorna apenas o ponteiro final, do tipo PSID, o que parece fácil pode se tornar tricky se quisermos copiar o SID binário para algum buffer na pilha, já que não sabemos o número de bytes no buffer de origem. Tudo que sabemos é que, após o uso, devemos desalocar essa memória retornada pela API com outra API: LocalFree.&lt;/p&gt;
&lt;p&gt;Ora, mesmo que não venhamos a escrever nessa memória de tamanho obscuro, não é de bom tom ler além da conta. Não há garantias que o que estiver após o SID é seguro. Pode até ser o final de uma página de  memória, por exemplo, e o seu programa capota por causa de um singelo &amp;quot;Memory could not be read&amp;quot;. Que coisa sem graça!&lt;/p&gt;
&lt;p&gt;[](/images/SXf7NsR.png)&lt;/p&gt;
&lt;p&gt;Sempre que me vejo com problemas desse tipo procuro informações primeiro  no próprio MSDN, segundo na cabeça e terceiro no Google. Nesse caso em  específico a cabeça deu um jeito, pois imaginei que houvesse alguma  forma de pegar o tamanho da memória alocada através das funções Local (se a API precisa de LocalFree para desalocar sua memória, é óbvio que  ela usou LocalAlloc para alocá-la, mesmo que não tenhamos o código-fonte  para comprovar).&lt;/p&gt;
&lt;p&gt;A partir de LocalHandle posso obter o HANDLE para a memória alocada localmente. Com esse handle a API me dá outra função, LocalSize, de onde posso obter o tamanho da memória previamente alocada através do seu handle. Isso é ótimo, pois em um primeiro momento pensei não haver saída, como nas funções de alocação em C e C++, por exemplo.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Dependência pedindo carona</title>
  <link>http://www.caloni.com.br/dependencia-pedindo-carona/</link>
  <pubDate>2011-01-04</pubDate>
  
  <guid>http://www.caloni.com.br/dependencia-pedindo-carona/</guid>
  <description>&lt;p&gt;Mesmo as vezes que você não queira, algumas dependências pedem carona e o compilador deixa entrar. Daí mesmo que você não use uma função API, ela acaba te atazanando a vida.&lt;/p&gt;
&lt;p&gt;Foi o caso da ToolHelp32 no Windows NT 4.&lt;/p&gt;
&lt;p&gt;Quando compilamos, cada CPP vira uma coleção de funções que serão usadas, mais tarde, pelo linker, para juntar a bagunça. Para mais detalhes dessa fascinante história, recomendo o fantástico artigo sobre Os diferentes erros na linguagem C, seção Linkedição.&lt;/p&gt;
&lt;p&gt;Para as dependências localizadas fora do executável final, por exemplo, as DLLs do sistema, o linker cria uma entrada no formato padrão de executável que adiciona essa dependência extra que será resolvida na hora do programa rodar, quando o loader do sistema operacional terá que fazer um linker on-the-fly, catando todas as DLLs e funções necessárias para colocar o bichinho no ar.&lt;/p&gt;
&lt;p&gt;Dessa forma, quando existirem unresolved externals fora do executável final, o responsável por dar o erro é o loader do sistema:&lt;/p&gt;
&lt;p&gt;Isso significa que o seu processo não poderá ser executado, pois faltam funções no ambiente que ele depende.&lt;/p&gt;
&lt;p&gt;Um recurso muito útil para ver essas funções é o Dependency Walker, meu amigo de infância:&lt;/p&gt;
&lt;p&gt;&amp;quot;Mas, Caloni, eu nem uso essa função! Como ela pode ser necessária?&amp;quot;&lt;/p&gt;
&lt;p&gt;Pois é. As coisas nem sempre acabam sendo como o esperado. Se você possuir uma LIB, por exemplo, e nela existirem duas funções, como abaixo, e você se limitar a usar em seu programa apenas a primeira, todas as dependências da segunda também irão parar no executável final.&lt;/p&gt;
&lt;p&gt;Acontece que o nosso amigo linker gera uma lista de dependências por módulo (CPP), e não por função. Dessa forma, tudo que vier é lucro.&lt;/p&gt;
&lt;p&gt;Só que às vezes é prejuízo, também. Quando usamos um SO da época do guaraná com rolha, como o Windows NT 4, por exemplo, não conseguimos usar um programa porque este possuía uma função moderninha nunca usada, mas que estava dentro de um CPP junto de uma função comportada, usando apenas APIs documentadas no primeiro papiro da Microsoft.&lt;/p&gt;
&lt;p&gt;Sempre existe. Nesse caso, migrarmos as funções moderninhas para um segundo CPP, recompilarmos a LIB e a dependência milagrosamente desaparecerá!&lt;/p&gt;
&lt;p&gt;Agora a aplicação poderá rodar em paz naquele que é, como diz meu amigo, um sistema operacional de ponta... da outra ponta!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Trabalhando em múltiplos ambientes</title>
  <link>http://www.caloni.com.br/trabalhando-em-multiplos-ambientes/</link>
  <pubDate>2010-12-27</pubDate>
  
  <guid>http://www.caloni.com.br/trabalhando-em-multiplos-ambientes/</guid>
  <description>&lt;p&gt;Existem diversas maneiras de se trabalhar com o Bazaar. Eu já havia definido como fazer na máquina de desenvolvedor para modificar o mesmo código-fonte em projetos paralelos, onde basicamente tenho um branch principal conectado no servidor (assim todo commit vai pra lá) e crio branches paralelos e desconectados para fazer quantos commits eu tenho vontade durante o desenvolvimento. Após todas as mudanças e testes básicos, atualizo o branch principal (com mudanças dos meus colegas) e faço o merge com o branch paralelo onde fiz todas as mudanças. Antes de subir com o commit final, ainda realizo um build de teste local, se necessário.&lt;/p&gt;
&lt;p&gt;Nos casos em que eu trabalho em casa (ou em outro ambiente), posso fazer basicamente a mesma coisa, só que meu branch paralelo é copiado para outra máquina:&lt;/p&gt;
&lt;p&gt;Geralmente o que faço depois é compactar a pasta gerada (se desejar, use uma senha forte nesse passo), fazer uma cópia para um PenDrive e descompactar na máquina que irei trabalhar.&lt;/p&gt;
&lt;p&gt;Terminado o trabalho naquela máquina, geralmente gero um branch novo (para limpar o diretório) e recompacto a solução, copio para o Pendrive, e descompacto na máquina da empresa. O resto do caminho é como se eu tivesse feito as modificações na própria máquina:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Patch de emergência 2</title>
  <link>http://www.caloni.com.br/patch-de-emergencia-2/</link>
  <pubDate>2010-11-09</pubDate>
  
  <guid>http://www.caloni.com.br/patch-de-emergencia-2/</guid>
  <description>&lt;p&gt;No artigo anterior fizemos um patch rapidinho na memória se aproveitando de um Sleep nojento que o código nos forneceu.&lt;/p&gt;
&lt;p&gt;E se não houvesse Sleep?&lt;/p&gt;
&lt;p&gt;As chances de estarmos escrevendo no momento em que a função está sendo executada são tremendas, de forma que não poderíamos sobrescrevê-la sem correr o risco de um crash.&lt;/p&gt;
&lt;p&gt;Uma solução alternativa para isso é alocar um novo pedaço de memória para a versão corrigida e trocar o endereço de chamada na função main.&lt;/p&gt;
&lt;p&gt;Antes de trocarmos o endereço dentro do main precisamos &amp;quot;consertar&amp;quot; a função copiada. Ela está usando as funções globais rand e printf, e as chamadas usam offsets relativos. Como agora a função está em outro offset, temos que reconstruir as chamadas:&lt;/p&gt;
&lt;p&gt;Agora a função está pronta para ser usada.&lt;/p&gt;
&lt;p&gt;É nessa parte que trocaremos o endereço o endereço 00401005 pela memória alocada. Note que essa escrita é muito rápida e o programa lê esse endereço por muito pouco tempo se compararmos com todas as intruções que são executadas. No entanto, essa escrita não é atômica, e mesmo que as chances sejam extremamente remotas, ainda assim pode haver uma colisão no acesso à essa parte.&lt;/p&gt;
&lt;p&gt;É salutar rezar por 10 segundos.&lt;/p&gt;
&lt;p&gt;E voilà! A partir do momento em que digitei o call seguido de enter, a função nova já começou a operar em cima do processo ainda rodando. Se quisermos voltar a função antiga, sem problemas:&lt;/p&gt;
&lt;p&gt;Não façam isso em casa, crianças ;)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Patch de emergência</title>
  <link>http://www.caloni.com.br/patch-de-emergencia/</link>
  <pubDate>2010-11-08</pubDate>
  
  <guid>http://www.caloni.com.br/patch-de-emergencia/</guid>
  <description>&lt;p&gt;Após um projeto muito bem sucedido, entregue no prazo e homologado em tempo recorde, você e sua equipe estão aproveitando suas devidas férias nas Bahamas, tomando água de coco na sombra de uma palmeira e apreciando a beleza natural da região. Ambas as belezas. =)&lt;/p&gt;
&lt;p&gt;Mas eis que liga o seu gerente para o celular vermelho que te entregou no caso de emergências críticas e te avisa que um problema crítico foi detectado em um serviço crítico: o detector de pares. Consegue ver o erro?&lt;/p&gt;
&lt;p&gt;Oh, meu Deus!&lt;/p&gt;
&lt;p&gt;Com toda a calma do mundo, você saca o seu netbook, baixa a versão homologada do controle de fonte e descobre facilmente o problema, gerando um patch e recompilando o projeto.&lt;/p&gt;
&lt;p&gt;Feliz da vida, avisa o seu chefe que a única coisa que precisam trocar é o serviço crítico. Parar, trocar o arquivo, reiniciar o serviço. Simples.&lt;/p&gt;
&lt;p&gt;Porém, ele lhe avisa que esse é um serviço crítico, que não pode parar por nenhum segundo sequer. A atualização terá que ser feita sem parar o ciclo ininterrupto de pares/ímpares chegando do gerador de números randômicos.&lt;/p&gt;
&lt;p&gt;Mais uma vez calmo da vida, você diz que isso é coisa de criança. Tudo que precisa fazer é atualizar a versão certa na memória. O arquivo poderá ser renomeado e, quando o serviço puder ser reiniciado, a versão nova será executada. Enquanto isso, o patch na memória bastará para corrigir o problema e não causar nenhum momento inoperante.&lt;/p&gt;
&lt;p&gt;Tudo que você precisa é abrir o processo pelo WinDbg, encontrar a versão defeituosa e substituir os bytes certos.&lt;/p&gt;
&lt;p&gt;Nota: O parâmetro -pv permite depurar um processo de forma não-invasiva, mas as threads serão suspensas. Já com -pvr podemos depurar de forma não-invasiva e ainda conseguir manter as threads do processo rodando.&lt;/p&gt;
&lt;p&gt;Analisando o disassembly da função nova e antiga podemos perceber que o tamanho delas não mudou (bom sinal), mas o uso dos registradores e a lógica interna teve uma alteração significativa (mau sinal):&lt;/p&gt;
&lt;p&gt;Podemos começar escrevendo a função nova da memória do processo de teste para um arquivo, e lendo em seguida para cima da função antiga. Só que para isso temos que nos certificar que os endereços que referenciam para fora da função sejam os mesmos. Nesse caso, felizmente, são.&lt;/p&gt;
&lt;p&gt;Em seguida iremos sobrescrever a função antiga no processo em execução. Para evitar crashes é vital que tenhamos certeza que a função não estará sendo executada nesse momento. No nosso caso basta aguardar a entrada na função Sleep da API, que dorme por 3 segundos, tempo suficiente para a atualização.&lt;/p&gt;
&lt;p&gt;Atualizada a função, apenas nos lembramos de renomear o arquivo antigo e atualizar o novo para evitar reativar o problema. Agora podemos voltar para a apreciação das belezas da natureza...&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Suporte técnico</title>
  <link>http://www.caloni.com.br/suporte-tecnico/</link>
  <pubDate>2010-11-05</pubDate>
  
  <guid>http://www.caloni.com.br/suporte-tecnico/</guid>
  <description>&lt;p&gt;Máquina com parte do registro corrompida, notadamente alguma sub-chave de HKEYCLASSESROOT. Resultado: ao rodar um script que abre uma segunda janela e tenta usar seu método focus é exibida a seguinte mensagem:&lt;/p&gt;
&lt;p&gt;Erro de automação? (&amp;quot;Mensagem do cliente - A classe não dá suporte para automação&amp;quot;)&lt;/p&gt;
&lt;p&gt;Abaixo um exemplo simples para ter uma ideia em JS:&lt;/p&gt;
&lt;p&gt;A primeira coisa que se faz nesse caso é pesquisar no Google por pessoas que já tiveram esse problema. A maioria dizia ser necessária registrar novamente as DLLs do navegador/shell, coisa que fizemos à exaustão e não resolveu o problema. Também imaginamos haver relação com a versão da SDocVw.dll que estava alocada na lista de assemblies .NET cacheados, o chamado GAC. Ou seja, já estávamos viajando geral.&lt;/p&gt;
&lt;p&gt;No meio dos procedimentos batidos que todos fazem a lista abaixo resume bem:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Restaurar instalação do Internet Explorer.&lt;/li&gt;
&lt;li&gt;Atualizar Internet Explorer.&lt;/li&gt;
&lt;li&gt;Rodar Windows Update.&lt;/li&gt;
&lt;li&gt;Registrar novamente DLLs do Shell (ShDocVw.dll, etc).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No meio das análises não-tão-batidas que foram feitas estavam os seguintes itens:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Log de operações pelo Process Monitor da abertura do browser até o erro.&lt;/li&gt;
&lt;li&gt;Dump gerado no momento da mensagem de erro.&lt;/li&gt;
&lt;li&gt;Comparação de registro exportado com máquina sadia.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nada parecia resolver o impasse, a não ser reinstalar o Windows, coisa que o cliente não queria. Dessa forma, A última tentativa não-enlouquecida de tentar descobrir a causa do problema foi usar uma VM e importar o registro exportado da máquina defeituosa.&lt;/p&gt;
&lt;p&gt;Que não revelou a anomalia.&lt;/p&gt;
&lt;p&gt;Partindo disso, imaginei que o que ocorria era que havia algo faltando no registro danificado, e não algo a mais. Dessa forma, realizei a seguinte operação:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exportei o registro da máquina saudável.&lt;/li&gt;
&lt;li&gt;Transformei a exportação em exclusão total das chaves.&lt;/li&gt;
&lt;li&gt;Importei ambos os registros no esquema &amp;quot;apaga tudo cria tudo de novo&amp;quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Problema reproduzido.&lt;/p&gt;
&lt;p&gt;Agora restava saber qual chave exata estava faltando e o que isso impactava no comportamento do browser.&lt;/p&gt;
&lt;p&gt;O registro exportado da VM possuía cerca de 30.000 linhas com chaves e sub-chaves. Se fosse feita a importação por partes, dividindo-se sempre pela metade e testando o acesso à página todas as vezes, teríamos no máximo que fazer uns 15 testes.&lt;/p&gt;
&lt;p&gt;Foi esse o procedimento seguido:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Criar snapshot com o estado inalterado do registro.&lt;/li&gt;
&lt;li&gt;Apagar metade do registro original exportado (máquina real).&lt;/li&gt;
&lt;li&gt;Arrastar metade do registro original e importá-lo (apaga chaves).&lt;/li&gt;
&lt;li&gt;Importar registro danificado do cliente (já na VM).&lt;/li&gt;
&lt;li&gt;Se deu erro de novo, repassar os passos 2 a 3.&lt;/li&gt;
&lt;li&gt;Se não deu erro, testar os passos 3 e 4 com a outra metade.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Essa série de passos foi reproduzida em menos de uma hora até chegarmos a apenas uma linha no registro:&lt;/p&gt;
&lt;p&gt;Que se revelou pertencer à DLL dispex.dll:&lt;/p&gt;
&lt;p&gt;&amp;quot;dispex.dll is a module that contains COM interfaces used by Visual Basic scripts&amp;quot;&lt;/p&gt;
&lt;p&gt;Pesquisando soluções de restauração achei esse KB que explica que existe um aplicativo chamado McRepair que teoricamente conserta a bagunça.&lt;/p&gt;
&lt;p&gt;Não conserta.&lt;/p&gt;
&lt;p&gt;Porém, ao usar o Method 1 (registrar novamente a DLL) o problema foi resolvido. Exportei o registro antes e depois da operação e por algum motivo a máquina do cliente estava com o GUID das interfaces IDispatchEx e IObjectIdentity adulteradas:&lt;/p&gt;
&lt;p&gt;Realizei o mesmo teste com nossa DLL que gerou o problema inicial e descobri que não houve mudanças nessa parte do registro por conta dela.&lt;/p&gt;
&lt;p&gt;Fica assim indefinida a origem do &amp;quot;corrompimento&amp;quot; dessa parte do registro, apesar de localizada.&lt;/p&gt;
&lt;p&gt;Esse artigo é pra mostrar que não é só de ifs e elses que vive um programador =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Então você ainda não usa controle de fonte?</title>
  <link>http://www.caloni.com.br/entao-voce-ainda-nao-usa-controle-de-fonte/</link>
  <pubDate>2010-11-02</pubDate>
  
  <guid>http://www.caloni.com.br/entao-voce-ainda-nao-usa-controle-de-fonte/</guid>
  <description>&lt;p&gt;Não há nada de errado nisso. Projetos robustos com uma equipe moderada ¿ 5 a 10 programadores ¿ precisam desse tipo de organização, e tornam a resolução dos problemas do dia-a-dia mais problemática sem esse controle. A questão reside para o programador solitário ou a equipe minúscula ¿ 2 a 4 programadores. Esses geralmente questionam o custo-benefício de terem o trabalho de configurar e manter mais um sistema. Além disso, isso implica em uma mudança de grandes proporções em cada membro da equipe: uma mudança cultural.&lt;/p&gt;
&lt;p&gt;Portanto, a primeira decisão que deve ser tomada pelo programador que quer mudar as coisas é instalar um controle de fonte moderno para seus projetos caseiros. Quando digo moderno, digo distribuído.Distribuído porque 1) é possível começar desde já com três comandos simples, 2) quando alguém copia a pasta do projeto está levando todo o histórico junto e 3) pastas duplicadas são branches distintos que podem interagir no futuro.&lt;/p&gt;
&lt;p&gt;Os três comandos simples não são nada do outro mundo: criar o repositório, adicionar arquivos e fazer commit.&lt;/p&gt;
&lt;p&gt;Dica: Um commit é uma maneira de dizer ao controle de fonte: &amp;quot;já modifiquei o que tinha pra modificar, então mande tudo que tenho de novo para o controle&amp;quot;.&lt;/p&gt;
&lt;p&gt;Tanto faz qual controle você pretende usar. No meu exemplo usarei o Bazaar, que é a ferramenta que uso no dia-a-dia com minha pequena equipe e serve bem para programadores solitários também. Basicamente para ter o Bazzar instalado basta baixá-lo, next next e finish.&lt;/p&gt;
&lt;p&gt;Marcar para usar o PATH pode ser uma boa pra quem é fã de linha de comando.&lt;/p&gt;
&lt;p&gt;Apesar de existirem firulas gráficas, gosto de usar o Bazaar na linha de comando porque faz você pensar direito antes de fazer commits, mas esteja livre para experimentar a maneira que achar melhor.&lt;/p&gt;
&lt;p&gt;Isso vale para qualquer projeto que você esteja trabalhando. Pela linha de comando, navegue até o diretório do projeto. Digite os comandos abaixo seguidos de enter:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;bzr init&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bzr add&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bzr commit -m &amp;quot;Primeiro commit no controle de fonte&amp;quot;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pronto! Você está oficialmente com seu projeto dentro de um controle de fonte.&lt;/p&gt;
&lt;p&gt;Os passos seguintes seguem o mesmo padrão, exceto o passo 1, que é substituído pelo seu trabalho:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;trabalho&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bzr add&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bzr commit -m &amp;quot;Comentário sobre modificação que fiz&amp;quot;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Basicamente, sim. É claro que um controle de fonte não se baseia apenas em commits. Existem arquivos a serem ignorados (os obj da vida) e eventualmente algum trabalho paralelo ou com mais programadores. No futuro poderá comparar versões diferentes do código. Porém, apenas seguindo essa simples receita acima você já pode se gabar de ter um controle de fontes confiável em seus projetos. Já estará se aproveitando desse controle no futuro, quando aprender mais sobre ele.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>FormatMessage para... dumies?</title>
  <link>http://www.caloni.com.br/formatmessage-para-dumies/</link>
  <pubDate>2010-10-26</pubDate>
  
  <guid>http://www.caloni.com.br/formatmessage-para-dumies/</guid>
  <description>&lt;p&gt;Já foi comentado em alguns círculos de ótimos programadores que a função da Win32 API FormatMessage é uma das criaturas mais bizarras já criadas.&lt;/p&gt;
&lt;p&gt;O objetivo da FormatMessage é formatar uma string, assim como sprintf, mas voltado mais a escrever uma descrição de um código de erro. Sendo assim ela é essencial para que o usuário não receba um número no lugar de uma explicação de por que a operação falhou.&lt;/p&gt;
&lt;p&gt;Os códigos de erro que ela se propõe a formatar podem ser os erros padrões descritos em winerror.h ou qualquer outro código cuja explicação esteja em algum módulo carregado pelo processo (DLL ou o próprio executável). Isso nos dá a liberdade de, por exemplo, criar uma DLL apenas com códigos e descrições dos erros dos nossos produtos.&lt;/p&gt;
&lt;p&gt;Para que seja criada a mensagem final, uma definição de mensagem é requirida como entrada, que pode vir do próprio chamador ou da já mencionada tabela de erros de algum módulo qualquer. No caso de querermos a descrição de um erro de sistema (em winerror.h, retornado por GetLastError ou similares) a definição da mensagem já está embutida no sistema, bastando para nós passarmos o código.&lt;/p&gt;
&lt;p&gt;É importante lembrar que, como estamos falando de uma descrição de erro, ou seja, de um texto, este pode vir em diversos idiomas, sendo que é nossa obrigação também definir para qual idioma desejamos traduzir nosso código de erro, sendo também nossa obrigação, no caso de mensagens específicas do nosso programa, fornecer o modelo da mensagem nos idiomas que formos suportar.&lt;/p&gt;
&lt;p&gt;O resto da função funciona mais ou menos como o sprintf, cuspindo a mensagem-modelo em uma saída formatada de acordo com os parâmetros de entrada.&lt;/p&gt;
&lt;p&gt;As flags do parâmetro dwFlags mudam radicalmente o funcionamento da rotina, o que me lembra de outra figura bizarra: o realloc da biblioteca padrão.&lt;/p&gt;
&lt;p&gt;No caso do FormatMessage, a variável dwFlags se divide em dois para especificar dois grupos de opções distintos. A parte maior contém as opções armazenadas tradicionalmente como um mapa de bits, enquanto o byte menos significativo define como será tratada a saída final, com respeito às novas linhas e qual será a largura máxima de uma linha na saída.&lt;/p&gt;
&lt;p&gt;O parâmetro mais polêmico é o que possui vários significados. No caso de lpSource, existem dois significados possíveis:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;FORMAT_MESSAGE_FROM_HMODULE. Ele é um HANDLE para um módulo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FORMAT_MESSAGE_FROM_STRING. Ele é um ponteiro para string.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Isso explica por que essas duas flags são exclusivas: ou uma ou outra. Mesmo que a flag FORMATMESSAGEFROMSYSTEM seja usada, a função tentará achar a definição da mensagem no módulo especificado por lpSource primeiro, antes de ir buscar nas tabelas do sistema.&lt;/p&gt;
&lt;p&gt;Chamado de dwMessageId, esse é o argumento onde podemos passar um código de GetLastError ou nossos próprios códigos de erro. Se já tivermos uma string em lpSource, no entanto, não faz sentido existir um código de erro.&lt;/p&gt;
&lt;p&gt;Para definir o idioma é usado o mesmo sistema de resources: monta-se uma DWORD com MAKELANGID que contém informações do idioma primário e secundário. Se quisermos usar o idioma padrão do sistema (99% dos casos) basta passarmos o retorno de MAKELANGID(LANGNEUTRAL, SUBLANGNEUTRAL).&lt;/p&gt;
&lt;p&gt;Mais um argumento polêmico. Se a flag FORMATMESSAGEALLOCATEBUFFER, lpBuffer não é um buffer, mas um ponteiro que será preechido com um endereço de memória alocada usando a função API LocalAlloc. Isso quer dizer que, após usar a mensagem formatada, devemos desalocar essa memória com LocalFree.&lt;/p&gt;
&lt;p&gt;Por outro lado, se o buffer for nosso, então seu tamanho deve ser especificado no próximo argumento, nSize.&lt;/p&gt;
&lt;p&gt;Só que nem o parâmetro que especifica o tamanho do buffer é simples, assim. Se for especificado a flag FORMATMESSAGEALLOCATEBUFFER, em vez de não fazer sentido esse argumento, ele significa o número MÍNIMO de caracteres que devem ser alocados, independente do tamanho da mensagem.&lt;/p&gt;
&lt;p&gt;Obs.: Lembre-se que são caracteres, e não bytes. Se estivermos programando em UNICODE o número de bytes dobra.&lt;/p&gt;
&lt;p&gt;Essa seria uma lista simples de argumentos valist que, para quem já fez funções ao estilo printf sabe muito bem usar. A lógica da função determina que os valores &amp;quot;%1&amp;quot;, &amp;quot;%2&amp;quot; e assim por diante dentro da definição de mensagem sejam trocados por estes argumentos.&lt;/p&gt;
&lt;p&gt;Se eles são strings terminadas em nulo (interpretação padrão), inteiros ou estruturas específicas, isso vai depender da mensagem que está sendo formatada, o que é outro if a ser lembrado na hora de formatar mensagens do sistema.&lt;/p&gt;
&lt;p&gt;Também é importante lembrar que, uma vez chamada a função, o conteúdo de valist não pode ser usado novamente se não for reinicializado com vaend seguido de vastart.&lt;/p&gt;
&lt;p&gt;Agora, se todo esse negócio de vasbrubles é muito complicado pra você, é possível passar um array de DWORDPTRs com o uso da flag FORMATMESSAGEARGUMENTARRAY.&lt;/p&gt;
&lt;p&gt;Se tudo der certo e você passar todos os argumentos certinhos, o retorno é o número de caracteres armazenados no buffer de saída, independente dele ter sido alocado dinamicamente ou não. Ah, sim, excluindo o nulo terminador.&lt;/p&gt;
&lt;p&gt;Se der errado a função retorna zero. É possível obter o erro através de GetLastError, o que muito provavelmente será 87 nas primeiras vezes que você usar essa função.&lt;/p&gt;
&lt;p&gt;Pensou que acabaria por aqui? E qual o significado das sequências de escape dentro da mensagem-modelo? O formato básico para inserção de um argumento segue o padrão %n!format-string!.&lt;/p&gt;
&lt;p&gt;Onde n é o número que identifica o argumento, como já vimos, e format-string é um espaço reservado para identificarmos o tipo do argumento e como ele aparecerá na mensagem de saída.&lt;/p&gt;
&lt;p&gt;Existe uma longa explicação sobre o uso de controladores de largura e precisão da saída formatada e sua localização na lista de argumentos, cujo número irá depender se estamos usando valist ou array de DWORDPTRs, sendo que alguns problemas podem surgir se repetirmos esses números de inserção. Em dois momentos da explicação o artigo seja a sugerir que seja usada a função StringCchPrintf, primeiro por que FormatMessage não suporta formatação de ponto flutuantes, e segundo, porque, mesmo que seja possível formatar valores de 64 bits, seria mais fácil se você usasse outra função.&lt;/p&gt;
&lt;p&gt;Ainda existe um uso específico para &amp;quot;%0&amp;quot;, que é evitar quebra de linha durante a formatação da mensagem, inclusive no final. Esse uso entra em conflito com o nosso flag quando este determina um número máximo de caracteres por linha.&lt;/p&gt;
&lt;p&gt;Ainda existe &amp;quot;de bônus&amp;quot; outras strings para preencher limitações que o próprio printf possui, como %%, %t, etc.&lt;/p&gt;
&lt;p&gt;Como os programadores habituados com ataques de stack overrun devem deduzir, uma mensagem-modelo mal intencionada pode conter sequências de inserção que não existem na formatação habitual, forçando o vazamento de bytes na string final, o que pode forçar ataques planejados. Como o próprio artigo diz, usar um código de erro arbitrário retornado por uma API qualquer e usar FormatMessage sem a flag FORMATMESSAGEIGNOREINSERTS pode levar a resultados desastrosos.&lt;/p&gt;
&lt;p&gt;Esse também é um bônus da MSDN, que te presenteia com exemplos de código tão fantasiosos quanto a própria função, veja o primeiro exemplo, por exemplo:&lt;/p&gt;
&lt;p&gt;Depois ele chega a reimplementar o exemplo usando valist, o que é muito interessante, mas... bom, deixa pra lá. Vamos fazer nosso próprio teste.&lt;/p&gt;
&lt;p&gt;Esse é o uso clássico: precisamos de uma descrição de um código de erro para o usuário; um código Win32. A chamada para esse tipo de uso pode ser encapsulada em uma função mais simples:&lt;/p&gt;
&lt;p&gt;Existem milhares de forma de usar essa função, como você deve ter percebido pelos parâmetros. Não seja tímido: se você conhece algum truquezinho esperto e quer compartilhar com os usuários da FormatMessage, essa é a hora!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Atualizando HouaissParaBabylon no saite</title>
  <link>http://www.caloni.com.br/atualizando-houaissparababylon-no-saite/</link>
  <pubDate>2010-10-22</pubDate>
  
  <guid>http://www.caloni.com.br/atualizando-houaissparababylon-no-saite/</guid>
  <description>&lt;p&gt;O último comentário no meu último artigo sobre o conversor Houaiss para Babylon me fez lembrar de algo muito importante: eu não atualizei o branch do saite com a última versão. Deve ser por isso que as pessoas estão tendo problemas com o uso do código. Resolvo isso já:&lt;/p&gt;
&lt;p&gt;Essa é a versão 1.2 descrita no meu último artigo sobre o projeto.&lt;/p&gt;
&lt;p&gt;De qualquer forma, qual não foi minha surpresa quando tentei recompilar o projeto e ocorreram erros no atlcom. Depois de uma breve pesquisa descobri que precisava rodar alguns &amp;quot;patches&amp;quot; para o include funcionar direito. Então, provavelmente, Willians, era esse o problema. Tente de novo.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Três em um</title>
  <link>http://www.caloni.com.br/tres-em-um/</link>
  <pubDate>2010-10-09</pubDate>
  
  <guid>http://www.caloni.com.br/tres-em-um/</guid>
  <description>&lt;p&gt;Que vergonha passar tanto tempo sem postar nada. Parece que não fiz nada que valesse a pena comentar por aqui.&lt;/p&gt;
&lt;p&gt;Na verdade, não fiz tanto, mesmo. Muitas mensagens do Outlook, gráficos UML e reuniões de alinhamento depois, sobrou um tempinho pra programar. Aprendi algumas coisas que tinha o desejo de saber há tanto tempo... Agora eu sei, quem diria, criar linques suspensos nas janelas Win32! Que novidade, não? Pois é, isso exige, de acordo com o SDK, algumas artimanhas pra fazer funcionar. Para quem está de Visual Studio 2008/2010 na mão basta seguir os passos seguintes.&lt;/p&gt;
&lt;p&gt;Definir que estamos programando para XP ou superior:&lt;/p&gt;
&lt;p&gt;Inserir suporte a linques na biblioteca de controles comuns:&lt;/p&gt;
&lt;p&gt;Usar o CreateWindow com a classe certa, fazer markup html dentro do título e cuidar das mensagens de click e enter no controle:&lt;/p&gt;
&lt;p&gt;Você que não está fazendo subclassing de janelas existe outra técnica que você pode utilizar: arrastar-e-soltar o controle do seu ToolBox. Qual é a graça?&lt;/p&gt;
&lt;p&gt; Outra coisa que aprendi foi como enviar mensagens ao usuário para impedir que este reinicie a máquina em momentos importantes:&lt;/p&gt;
&lt;p&gt;A partir do Vista temos uma nova API para fazer isso. E é muito simples:&lt;/p&gt;
&lt;p&gt;Quando ao receber a famigerada WMQUERYENDSESSION, basta retornar FALSE. O Windows faz o resto.&lt;/p&gt;
&lt;p&gt;PS: E com uma ajudinha do Windows Internals ainda fiquei sabendo que dá pra se colocar na frente da fila para receber essa mensagem.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como ofuscar strings</title>
  <link>http://www.caloni.com.br/como-ofuscar-strings/</link>
  <pubDate>2010-08-30</pubDate>
  
  <guid>http://www.caloni.com.br/como-ofuscar-strings/</guid>
  <description>&lt;p&gt;Já fiz ofuscamento e embaralhamento de dados acho que umas três ou quatro vezes. Dessa vez, parti para o batidíssimo esquema de fazer o pré-processamento de um header com defines que irão virar estruturas reaproveitadas por uma função padrão que desofusca e ofusca aquela tripa de bytes em algo legível: a string original.&lt;/p&gt;
&lt;p&gt;Vamos ver um exemplo:&lt;/p&gt;
&lt;p&gt;Conseguimos capturar os três elementos desse define (um descartável) por um simples scanf:&lt;/p&gt;
&lt;p&gt;A função scanf retorna o número de argumentos capturados. Então se a coisa funcionou é só comparar com 2.&lt;/p&gt;
&lt;p&gt;Depois de capturado, imprimimos na saída (o arquivo pós-processado) uma estrutura que irá conter nosso amigo embaralhado:&lt;/p&gt;
&lt;p&gt;Pronto. Agora o usuário da string precisa abri-la usando uma macro esperta que irá chamar uma função esperta para desofuscar a string e entregar o ponteiro de buffer devidamente &amp;quot;casteado&amp;quot;:&lt;/p&gt;
&lt;p&gt;Uma vez que a abertura se faz &amp;quot;inplace&amp;quot;, ou seja, a memória da própria variável da estrutura original é alterada, pode-se fechar a variável novamente, se quiser, após o uso.&lt;/p&gt;
&lt;p&gt;A GENERICSTRUCT do exemplo se trata apenas de um esqueleto para que todas as estruturas das 500 strings ofuscadas sejam entendidas a partir de um modelo. Sim, essa é uma solução usando linguagem C apenas, então não posso me dar ao luxo daqueles templates frescurentos.&lt;/p&gt;
&lt;p&gt;Como a string é ofuscada? Sei lá, use um XOR:&lt;/p&gt;
&lt;p&gt;Dessa forma abrir ou fechar a variável pode ser feito usando a mesma função.&lt;/p&gt;
&lt;p&gt;Alguém aí gostaria de uma explicação didática sobre o operador XOR?&lt;/p&gt;
&lt;p&gt;PS: Acho que, além das minhas palestras, meus artigos estão também parecendo um brainstorm.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Gerando dumps automatizados</title>
  <link>http://www.caloni.com.br/gerando-dumps-automatizados/</link>
  <pubDate>2010-08-26</pubDate>
  
  <guid>http://www.caloni.com.br/gerando-dumps-automatizados/</guid>
  <description>&lt;p&gt;Agora que a temporada das telas azuis passou estou às voltas com o nosso sistema de detecção de crashes, além de alguns dumps e logs pra relaxar de vez em quando.&lt;/p&gt;
&lt;p&gt;Fiquei impressionado com a simplicidade com que podemos capturar qualquer exceção que ocorra em um programa, independente da thread, e gravar um minidump com o contexto exato em que o problema ocorreu. O uso da função API SetUnhandledExceptionFilter aliado com a já citada na palestra MiniDumpWriteDump pode agilizar muito a correção de crashes triviais como Access Violation.&lt;/p&gt;
&lt;p&gt;A mágica é tão bela que resolvi gravar um vídeo do que ocorreu quando compilei e testei o programa abaixo. Note que o tamanho do arquivo de dump ficou em torno dos 10 KB, ridículos nessa era de barateamento de espaço.&lt;/p&gt;
&lt;p&gt;Espero com isso aliviar a carga pesada de A.V.s que sempre aparece quando menos se espera. Cuidar de toneladas de código legado exige algumas pitadas de automatização nos lugares certos. Como já dizia meu primeiro chefe: se a mente não pensa...&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Evento C&#43;&#43;</title>
  <link>http://www.caloni.com.br/evento-c/</link>
  <pubDate>2010-08-16</pubDate>
  
  <guid>http://www.caloni.com.br/evento-c/</guid>
  <description>&lt;p&gt;Esse fim-de-semana houve o tão falado evento C++, com a presença de dezenas de pessoas, algo que eu sinceramente não esperava. O bom desse evento foi saber que existem tantas pessoas interessadas em manter contato com quem gosta e pratica essa linguagem e também em saber que o nível técnico das palestras estão de alto para avançado.&lt;/p&gt;
&lt;p&gt;Infelizmente em nenhuma das duas palestras práticas (minha e do Fernando) houve participação interativa, e ninguém que eu saiba abriu meu pacote-surpresa com os dumps a serem analisados. De qualquer forma, minha palestra ficou bagunçada pelo excesso de conteúdo e falta de tempo, o que me fez dar boas risadas ao ouvir no twitter que minha palestra foi mais um brainstorm. A intenção não era essa, claro, mas meu claro despreparo para muito conteúdo gerou essa impressão. Espero que do pouco que consegui explicar alguém tenha achado utilidade.&lt;/p&gt;
&lt;p&gt;E, pelo jeito, futuramente irei aplicar essa mesma metodologia brainstorm em um videocast, que ainda não decidi como irei preparar. A ideia é analisarmos alguns dumps em conjunto e, para os que acompanharem online, a interatividade de perguntas &amp;amp; respostas.&lt;/p&gt;
&lt;p&gt;Mas enquanto isso não acontece vamos dar uma olhada no que tínhamos no pacote-surpresa.&lt;/p&gt;
&lt;p&gt;Como foi visto na palestra, uma pilha nesse estado demonstra claramente alguma variável que estourou e corrompeu o resto da pilha de chamadas. Na hora de voltar para a função chamadora, o endereço usado foi o endereço reescrito por lixo, e daí temos o &amp;quot;crash-pattern&amp;quot; Stack Trash.&lt;/p&gt;
&lt;p&gt;A thread ativa no momento do dump aguardava por outra thread. Listando todas as threads do processo temos a primeira e a segunda, que tenta entrar em um critical section. Quando vemos que aquele CS estava sendo bloqueado pela primeira thread vemos claramente se tratar de um dead lock.&lt;/p&gt;
&lt;p&gt;O disassemble da instrução inválida tenta escrever claramente em cima do endereço zerado (edx + eax). Dessa forma fica fácil saber que esse tipo de escrita não é permitido, constituindo nosso famosíssimo AV.&lt;/p&gt;
&lt;p&gt;Esse foi meio de brinde. Uma exceção de breakpoint (int 3, ntdll!DbgBreakPoint) lançada sem um depurador atachado implica em derrubamento do processo, pois é uma exceção como outra qualquer. O programador deve ter esquecido um DebugBreak ou algo que o valha no código de produção, que acabou sendo executado.&lt;/p&gt;
&lt;p&gt;Essa foi a DLL encontrada no cliente quando ocorreu o problema relatado na imagem, também em anexo. Isso foi demonstrado na palestra com a ajuda do meu script que carrega DLLs, além de um pouco de sorte. Podemos analisar esse caso com mais calma em outro artigo. Acho que já falei demais por aqui.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Foto dos melhores momentos</title>
  <link>http://www.caloni.com.br/foto-dos-melhores-momentos/</link>
  <pubDate>2010-08-12</pubDate>
  
  <guid>http://www.caloni.com.br/foto-dos-melhores-momentos/</guid>
  <description>&lt;p&gt;Mais um quebra-cabeças antes da nossa palestra, esse &amp;quot;baseado em fatos reais&amp;quot;.&lt;/p&gt;
&lt;p&gt;A história é a seguinte: o cliente instalou uma versão nova do produto em algumas máquinas que, ato contínuo, começaram a apresentar telas azuis constantemente. Como essas máquinas tinham que ser usadas pelos funcionários, a administradora rapidamente desinstalou essa versão buguenta, e logo em seguida pediu por uma correção.&lt;/p&gt;
&lt;p&gt;Até aí tudo bem. O problema maior era que ninguém havia capturado dump de nada.&lt;/p&gt;
&lt;p&gt;Por isso pedi encarecidamente por qualquer fragmento de tela azul (minidumps) que pudessem ainda estar nas máquinas afetadas. Dito isso, ela confessou que havia voltado a imagem padrão nesses equipamentos para que os funcionários pudessem voltar ao trabalho rapidamente. Só que sem dump eu não conseguiria trabalhar rapidamente.&lt;/p&gt;
&lt;p&gt;Mas eis que no dia seguinte ela me liga, comentando que um funcionário, empolgado (?) pela tela azul em sua máquina, havia tirado uma foto da mesma para &amp;quot;recordação&amp;quot;. Sem nenhuma cerimônia, então, pedi rapidamente que ela conseguisse essa foto para a minha coleção. A foto que ela me manda é exatamente a que está no início desse artigo (clique na foto para ampliá-la), apenas censurado o nome do driver, o que não vem ao caso. Assim que a recebi pude constatar o problema direto no código-fonte, corrigi-lo e enviar uma nova versão, que após alguns dias de testes se revelou bem sucedida.&lt;/p&gt;
&lt;p&gt;A questão é: como eu resolvi o problema? Como você teria procedido nessa situação?&lt;/p&gt;
&lt;p&gt;A resposta para esse enigma também contará pontos para nossa brincadeira com o livro Windows Internals, como foi explicado no artigo anterior. Vamos lá, Sherlock!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Não é minha culpa</title>
  <link>http://www.caloni.com.br/nao-e-minha-culpa/</link>
  <pubDate>2010-08-08</pubDate>
  
  <guid>http://www.caloni.com.br/nao-e-minha-culpa/</guid>
  <description>&lt;p&gt;Recebi a dica de meu amigo kernel-mode sobre o aplicativo NotMyFault, escrito como ferramenta do livro Windows Internals e que basicamente gera telas azuis para análise.&lt;/p&gt;
&lt;p&gt;Como os problemas gerados pela ferramenta são todos de kernel, resolvi escrever meu próprio conjunto de bugs para o pessoal da userland. E como nada na vida se cria, tudo se copia, tenho o orgulho de apresentar a vocês o NotMyFaultEither!&lt;/p&gt;
&lt;p&gt;Seu uso é bem simples. Escolha o problema, aperte a teclar &amp;quot;Fazer Bug&amp;quot; e pronto!&lt;/p&gt;
&lt;p&gt;O resultado pode variar dependendo do sistema operacional e da arquitetura (há versões 32 e 64 bits, ambas UNICODE). Um Access Violation no Windows Seven 64 bits, por exemplo, o processo pára de reponder.&lt;/p&gt;
&lt;p&gt;Após a análise do SO ele exibe uma tela onde é possível achar onde está o despejo de memória que podemos usar.&lt;/p&gt;
&lt;p&gt;Esse é um minidump (mdmp), que possui a pilha da thread faltosa e informações de ambiente. Podemos gerar um dump completo através do Gerenciador de Tarefas.&lt;/p&gt;
&lt;p&gt;No caso do Windows XP, podemos executar processo semelhante para gerar o dump através do aplicativo ProcDump, muito útil para preparar o material da minha palestra do próximo fim de semana.&lt;/p&gt;
&lt;p&gt;E por falar em palestra, criei um pacote-surpresa de alguns minidumps para análise. Se alguém tiver a curiosidade de já ir mexendo, ou de mexer na hora da apresentação, fique à vontade. Quem montar uma lista relacionando cada dump com o tipo de problema encontrado (não precisa estar completa) irá concorrer, no dia da palestra, à quarta edição do livro Windows Internals, de Mark Russinovich. É minha cópia pessoal, mas está bem novinho, visto que a original pesa pra caramba e consulto sempre o e-book.&lt;/p&gt;
&lt;p&gt;Estarei usando estes mesmos minidumps na palestra, junto dos dumps completos. Mas é claro que eu não iria deixar um despejo de memória completo pra vocês. Iria tornar as coisas muito fáceis ;)&lt;/p&gt;
&lt;p&gt;Portanto, junte suas grandes dúvidas para o grande dia e nos vemos lá.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Novas diferenças no Bazaar</title>
  <link>http://www.caloni.com.br/novas-diferencas-no-bazaar/</link>
  <pubDate>2010-08-04</pubDate>
  
  <guid>http://www.caloni.com.br/novas-diferencas-no-bazaar/</guid>
  <description>&lt;p&gt;Novidade incrível nas novas versões do Bazaar. Dando continuidade à sua versão boiola gráfica, agora é possível configurar quantos visualizadores de diferenças você quiser. Na hora de ver a diferença em algum código-fonte, você pode optar pelo enrustido embutido ou, no caso, o meu favorito, WinMerge.&lt;/p&gt;
&lt;p&gt;E por que o WinMerge é meu favorito? Porque você pode ignorar toda aquela discussão se devemos usar tabs ou três espaços para indentar o código. Cada um indenta como quer, na hora que mexer no código, que o WinMerge não vai nem ligar para essas diferencinhas (já que o compilador não liga). Ele até detecta blocos de código inteiros que foram movidos dentro do arquivo.&lt;/p&gt;
&lt;p&gt;Na hora de ver as diferenças no worktree podemos usar a velha opção de criar um alias para o WinMerge. Mas no meio de um log, podemos ativar tanto o view embutido quanto o de qualquer outra ferramenta que escolhermos.&lt;/p&gt;
&lt;p&gt;Vendo essas coisas fico imaginando como ainda tem gente que usa arquivos zip com data para armazenar versões de documentos diferentes. Tsc, tsc.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como achar o código-fonte sem símbolos</title>
  <link>http://www.caloni.com.br/como-achar-o-codigo-fonte-sem-simbolos/</link>
  <pubDate>2010-08-03</pubDate>
  
  <guid>http://www.caloni.com.br/como-achar-o-codigo-fonte-sem-simbolos/</guid>
  <description>&lt;p&gt;Continuo escovando bits. Dessa vez de forma mais nervosa. Se trata de um serviço que trava durante seu stop. Um colega muito esperto do suporte gerou um dump para mim, tornando as coisas mais fáceis. O problema era que não havia símbolos nem código-fonte que batessem exatamente com aquela compilação de 2004. Solução? Analisar as pilhas das threads restantes.&lt;/p&gt;
&lt;p&gt;É sabido que esse serviço responde requisições de milhares de máquinas em um período curto de tempo, então por isso a primeira coisa que me atentei foi verificar quantas threads haviam:&lt;/p&gt;
&lt;p&gt;São muitas.&lt;/p&gt;
&lt;p&gt;Analisar essa quantidade absurda de threads seria um saco. Além de inútil. Foi por isso deus inventou a função !uniqstack, que encontra automagicamente quais threads estão com a pilha duplicada.&lt;/p&gt;
&lt;p&gt;Muitas threads duplicadas. Isso quer dizer que podemos nos focar na pilha de uma delas. Basta pegar uma.&lt;/p&gt;
&lt;p&gt;Através das funções de RPC e OLE32 podemos concluir que se trata de uma chamada direta para uma interface COM. Bom, existem centenas de métodos e dezenas de interfaces nesse serviço, tornando mais fácil tentar desmontar a chamada inicial que o rpcrt4 faz ao nosso módulo.&lt;/p&gt;
&lt;p&gt;Nossa função é obtida em ebp+8. Podemos obter esse endereço pelo campo ChildEBP da função em questão.&lt;/p&gt;
&lt;p&gt;Note como a função compara algo com zero. Caso não seja zero ela continua. Caso contrário ela vai para um ponto que chama uma função interna e move um código de erro para um ponteiro recebido como parâmetro, o que é muito normal, se lembrarmos que as funções COM de um programa em C devem retornar o código da chamada no retorno (SOK) e o código de erro em um lResult da vida.&lt;/p&gt;
&lt;p&gt;O código retornado é 2Fh, e agora temos uma boa pista para encontrar a localização no fonte. A primeira coisa é encontrar o define responsável por esse erro, o que exige um pouco de familiaridade com o sistema, pois não se trata aqui de um código Windows.&lt;/p&gt;
&lt;p&gt;Ótimo. 2F, para os leigos (leigos? o que vocês estão fazendo aqui?), é 47 em decimal, exatamente nosso código listado acima. Com esse define podemos agora procurar no código-fonte e analisar todas as funções que retornam esse código em seu início. Para nossa sorte, existe apenas uma.&lt;/p&gt;
&lt;p&gt;Para confirmar que não estamos sonhando, podemos dar uma olhada no parâmetro passado para a função Log antes do código retornar. A memória deverá conter uma string idêntica a do código-fonte.&lt;/p&gt;
&lt;p&gt;E, agora sim, encontramos o culpado!&lt;/p&gt;
&lt;p&gt;Mais para a frente em minha análise consegui encontrar o objeto pelo qual todas as threads esperavam. Não tive tanta sorte, pois se tratava de um mutex, e mutexes não conseguem ser rastreados tão facilmente em user mode. Mas isso não vem ao caso. O que tentei descrever aqui foi mais ou menos o processo que você deverá seguir caso tenha que analisar um binário compilado em outras vidas. Espero que você tenha tanta sorte quanto eu.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Breakpoints promíscuos</title>
  <link>http://www.caloni.com.br/breakpoints-promiscuos/</link>
  <pubDate>2010-07-26</pubDate>
  
  <guid>http://www.caloni.com.br/breakpoints-promiscuos/</guid>
  <description>&lt;p&gt;Ontem falei sobre como &amp;quot;brincar&amp;quot; com os breakpoints promíscuos, ou seja, aqueles que topam qualquer processo. Isso&lt;/p&gt;
&lt;p&gt;é muito simples de se fazer:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Configure uma VM para bootar em kernel debug.&lt;/li&gt;
&lt;li&gt;Encontre um processo qualquer (vamos usar o notepad pra variar?).&lt;/li&gt;
&lt;li&gt;Reabra os símbolos de user mode nele.&lt;/li&gt;
&lt;li&gt;Defina um breakpoint em alguma DLL de user mode.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Como meus leitores são muito espertos foi partir para o momento após rodarmos um notepad.exe:&lt;/p&gt;
&lt;p&gt;O screenshot diz tudo:&lt;/p&gt;
&lt;p&gt;Agora a parte mais divertida: experimente com outro notepad, ou com o explorer =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Const e Volatile</title>
  <link>http://www.caloni.com.br/const-e-volatile/</link>
  <pubDate>2010-06-04</pubDate>
  
  <guid>http://www.caloni.com.br/const-e-volatile/</guid>
  <description>&lt;p&gt;Padrão C (ISO/IEC 9899:1990)&lt;/p&gt;
&lt;p&gt;Chamamos de qualificador de tipo as palavrinhas mágicas const e volatile. Na prática elas definem como uma determinada variável será usada e se comportará durante a vida do programa.&lt;/p&gt;
&lt;p&gt;Uma variável const não pode ser alterada pelo programa durante sua execução, apenas durante sua inicialização:&lt;/p&gt;
&lt;p&gt;No exemplo acima, o valor de pi não pode mais ser alterado. Só que repare que ele foi, em determinado momento, alterado com um valor constante: na sua inicialização. Isso quer dizer que pi:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;é uma variável no programa representada por um local na memória endereçável pelo programa;&lt;/li&gt;
&lt;li&gt;não é um define do pré-processador que irá virar uma constante literal (3.14, por exemplo).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Teoricamente a região da memória que contiver uma variável const pode ser qualificada pelo sistema operacional como somente-leitura, mas isso não é uma obrigação. É obrigação do compilador avisar sobre tentativas de alteração da variável no meio do programa, mas nem sempre é possível enxergar que a memória não é alterável. Dessa forma, resultados imprevisíveis podem ocorrer.&lt;/p&gt;
&lt;p&gt;Eu costumo usar variáveis const no lugar de defines. Além de ganhar na tipagem as constantes não precisam ser necessariamente globais, nem acessíveis por outros módulos. Um outro uso muito comum é criar variáveis locais que você sabe que não devem ser alteráveis por ninguém, como o tamanho de matrizes primitivas.&lt;/p&gt;
&lt;p&gt;O significado do volatile teoricamente muda de implementação para implementação, mas na prática é uma forma de definir uma variável que está sendo acessada por outros programas/threads/entidades espíritas que podem alterar o seu valor sem seu programa notar quando.&lt;/p&gt;
&lt;p&gt;O exemplo clássico da API Win32 é o InterlockedIncrement, que realiza operações atômicas em valores inteiros. Para fazer isso é necessário usar um recurso interno disponível pelo processador que irá modificar a memória sem intrusão de outras threads/processadores.&lt;/p&gt;
&lt;p&gt;Variáveis volatile geralmente interagem de alguma forma com o sistema em que rodam, e são representadas por ponteiros para memória retornada por esse sistema ou documentada como sendo de uso específico.&lt;/p&gt;
&lt;p&gt;É possível que exista uma variável que não pode ser modificada pelo seu programa, mas é modificada pelo sistema, de forma que ela é uma mutante!&lt;/p&gt;
&lt;p&gt;A definição de gsystemClock é de uma memória que não pode ser alterada; só que ela é, pelo sistema. Então a variável também é volatile. No entanto, independente de ser const ou volatile, o tipo nunca será alterado, apenas qualificado. São duas coisas diferentes na linguagem.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Enum</title>
  <link>http://www.caloni.com.br/enum/</link>
  <pubDate>2010-05-31</pubDate>
  
  <guid>http://www.caloni.com.br/enum/</guid>
  <description>&lt;p&gt;Padrão C (ISO/IEC 9899:1990)&lt;/p&gt;
&lt;p&gt;Uma enumeração faz duas coisas: define um novo tipo, parecido com um inteiro, e cria uma lista de constantes com nomes significativos. A definição técnica do tipo de um enum é mais complicada, mas basicamente ele é um novo int.&lt;/p&gt;
&lt;p&gt;Como funciona: definimos uma lista com cada elemento tendo um valor inteiro, geralmente único. Todos os nomes usados na lista passam a fazer parte do espaço de nomes atual e funcionam como constantes com o seu valor definido no início.&lt;/p&gt;
&lt;p&gt;Obs.: Os elementos que não possuem valor definido são definidos automaticamente como o valor do elemento anterior acrescidos de um. Se for o primeiro elemento, seu valor padrão é zero.&lt;/p&gt;
&lt;p&gt;Detalhe bizarro: você sabia que, apesar da vírgula ser usada para separar valores de enumeração, ela pode também terminar uma listagem? Por algum motivo exdrúxulo (se alguém quiser explicar), um valor de enumeração foi definido de tal forma que sempre poderá existir uma vírgula terminando ele:&lt;/p&gt;
&lt;p&gt;Geralmente usamos enumerações para definir valores únicos (tag) em um argumento de função, ou, mais moderno, como substituto daqueles antigos defines em C para mapas de bits. Nesse último caso não usamos o tipo da enumeração, pois ele pode conter apenas um valor único definido, e não um conjunto deles:&lt;/p&gt;
&lt;p&gt;Note que usamos uma enumeração nesse último caso para termos um nome significativo para uma flag, além desse nome fazer de fato parte dos nomes do programa, e não um define que, para o compilador, não existe.&lt;/p&gt;
&lt;p&gt;Como os tipos da enumeração passam a pertencer ao namespace atual, eles podem se misturar facilmente com todos os nomes daquele namespace. Dessa forma, é útil e bem organizado definir um prefixo para os nomes, que pode ser formado pelas iniciais do nome da enumeração, como no exemplo acima (fom = FileOpenMode).&lt;/p&gt;
&lt;p&gt;O surgimento do enum veio como evolução de uma prática já consagrada pelo uso na linguagem C, que eram as listas de valores constantes criados através de defines com algum prefixo em comum (FILESHARE, SWSHOW, etc). Portanto, sempre que se encontrar em uma situação para criar esse tipo de lista, a enumeração é o caminho atualmente ideal.&lt;/p&gt;
&lt;p&gt;Perguntado por um leitor sobre qual a diferença prática do último exemplo, onde temos praticamente o mesmo resultado entre usar defines e enumerações, imaginei que a mesma dúvida pode ter surgido para várias pessoas, porque é uma boa dúvida. Dá a entender que o autor deste artigo está se atentando a preciosismos da linguagem (e está mesmo!), mas à vezes as aparências enganam.&lt;/p&gt;
&lt;p&gt;Para ilustrar melhor fiz um mais elaborado. Aqui, estamos lendo pedaços de dados que tiveram que ser alinhados com alguma &amp;quot;gordura&amp;quot;.&lt;/p&gt;
&lt;p&gt;Aviso para os programadores mais calejados, eu omiti propositalmente os parênteses obrigatórios para qualquer define que tenha cálculos matemáticos, para ilustrar que muitas vezes o que vemos antes não é o que aparece depois.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Modificadores e qualificadores de tipo</title>
  <link>http://www.caloni.com.br/modificadores-e-qualificadores-de-tipo/</link>
  <pubDate>2010-05-28</pubDate>
  
  <guid>http://www.caloni.com.br/modificadores-e-qualificadores-de-tipo/</guid>
  <description>&lt;p&gt;@caloni poderia pensar em fazer um artigo sobre os modificadores de tipo em c? os mais complexo, acho eu: volatile, enum, union, extern, etc&lt;/p&gt;
&lt;p&gt;Uma coisa de cada vez: existem modificadores (ou qualificadores) de tipo e especificadores de tipo. Volatile e extern se encaixam na primeira categoria, enum e union na segunda. Veremos um pouco desses dois lados da linguagem em doses paliativas.&lt;/p&gt;
&lt;p&gt;Um modificador de tipo é opcional na definição de um tipo e deve estar sempre relacionado com a declaração de alguma variável. Ele determina, em termos gerais, qual será a função dessa variável. Ela pode ser modificada? Onde ela se encontra no programa? Como ela será modificada?&lt;/p&gt;
&lt;p&gt;Como exemplo rápido, temos abaixo uma variável que é atualizada pelo clock do processador e uma variável que não pode ser alterada após sua primeira atribuição:&lt;/p&gt;
&lt;p&gt;Fica meio óbvio que a primeira variável possui seu valor volátil, ou seja, muda conforme o tempo passa, e não depende do próprio código (pode mudar sem sua permissão). A segunda variável também tem um uso explícito, uma vez que o valor de pi nunca será alterado (não nesse Universo).&lt;/p&gt;
&lt;p&gt;Os especificadores de tipo possuem cada um sua peculiaridade. Os mais peculiares, que veremos nos próximos artigos, serão as enumerações e as construções bizarras de structs e unions.&lt;/p&gt;
&lt;p&gt;Aqui não é um compêndio teórico sobre a linguagem. Vamos falar particularmente da programação Windows, mas esteja livre para dar seus pitacos com respeito a outros sistemas operacionais e suas implementações igualmente exdrúxulas =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Analogicamente perfeito</title>
  <link>http://www.caloni.com.br/analogicamente-perfeito/</link>
  <pubDate>2010-05-19</pubDate>
  
  <guid>http://www.caloni.com.br/analogicamente-perfeito/</guid>
  <description>&lt;p&gt;É possível explicar tudo no mundo da informática através de analogias? Pela minha singela experiência de professor informal, eu acredito que sim. Durante esses dois anos, explanei diversos assuntos e, em todos eles, difíceis ou não, consegui um certo grau de sucesso graças ao uso de metáforas e parábolas.&lt;/p&gt;
&lt;p&gt;De memória (ou buscando no meu blogue) consigo lembrar alguns tópicos e a forma como os expliquei. Em alguns até fiz um artigo sobre o assunto:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ponteiros 16 bits: rua e número de uma casa.&lt;/li&gt;
&lt;li&gt;Typedefs: apelidos para nomes de pessoas.&lt;/li&gt;
&lt;li&gt;Depuração: a ciência médica de House.&lt;/li&gt;
&lt;li&gt;Passagem de argumentos por valor e por referência: e-mails com anexo e com linques.&lt;/li&gt;
&lt;li&gt;Ponteiros: armário de gavetas.&lt;/li&gt;
&lt;li&gt;Programadores: programadores de verdade não usam Java (brincadeira).&lt;/li&gt;
&lt;li&gt;Agendamento de threads: guichê de CPUs.&lt;/li&gt;
&lt;li&gt;Seções críticas: fila de threads dentro de uma sala.&lt;/li&gt;
&lt;li&gt;Funções com retorno booleano: o dedo polegar dos romanos.&lt;/li&gt;
&lt;li&gt;Pilha: uma pilha, só que de pratos e não bytes.&lt;/li&gt;
&lt;li&gt;Binário: bichos-preguiça contando com seus únicos dois dedos.&lt;/li&gt;
&lt;li&gt;Tipos: uma forma de bolo que só faz bolos com um único formato.&lt;/li&gt;
&lt;li&gt;Definições x declarações de variáveis: hardware e software; OK, podemos chamar esse de meta-analogia =)&lt;/li&gt;
&lt;li&gt;Depuração 2: séries de investigação forense como CSI.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Acredito ser essa a melhor forma de desmistificar esse pequeno mundinho que parece incompreensível aos outros mortais. Até porque tudo que é criado no mundo dos computadores são abstrações do mundo real, que por sua vez são abstrações da mente humana.&lt;/p&gt;
&lt;p&gt;É por isso que sempre digo que ciência da computação é uma arte-ciência da área de humanas.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Por que Long Pointer</title>
  <link>http://www.caloni.com.br/por-que-long-pointer/</link>
  <pubDate>2010-04-21</pubDate>
  
  <guid>http://www.caloni.com.br/por-que-long-pointer/</guid>
  <description>&lt;p&gt;Esse artigo continua a explicação sobre os typedefs arcaicos, já que ainda falta explicar por que diabos os ponteiros da Microsoft começam com LP. Tentei explicar para minha pupila que, por ser código dos anos 80, as pessoas usavam LP para tudo, pois os CDs ainda não estavam tão difundidos.&lt;/p&gt;
&lt;p&gt;Não colou. Então vou tentar explicar do jeito certo.&lt;/p&gt;
&lt;p&gt;Antigamente, as pessoas mandavam cartas umas para as outras. Carta, para você, caro leitor de quinze anos, era um e-mail implementado em hardware.&lt;/p&gt;
&lt;p&gt;Para mandar um e-mail, usamos o nome da pessoa e o domínio em que seu e-mail é endereçado, ex: &lt;a href=&#34;mailto:nome-da-pessoa@dominio.com.br&#34;&gt;nome-da-pessoa@dominio.com.br&lt;/a&gt;. Para mandar uma carta usamos duas informações básicas: o nome da rua e o número da casa.&lt;/p&gt;
&lt;p&gt;Consequentemente enviamos dois comandos ao carteiro: meu amigo, vá para a rua tal. Chegando lá, encontre o número 1065.&lt;/p&gt;
&lt;p&gt;Considere que estamos falando do mesmo bairro ou cidade, o que na minha analogia seria um computador e sua memória. Para enviar cartas para outros bairros em outras cidades (outros computadores em outras redes) teríamos que informar também outros dados, como nome da cidade e CEP.&lt;/p&gt;
&lt;p&gt;Nesse exemplo também podemos usar o Juquinha do bairro para entregar a carta e economizarmos 10 centavos.&lt;/p&gt;
&lt;p&gt;Agora, repare que interessante: em uma rua, cabem no máximo N casas. Se você tentar construir mais casas vai acabar invadindo o espaço de outra rua.&lt;/p&gt;
&lt;p&gt;E, já que estamos falando do endereço do destinatário, já podemos relevar que esse endereço constitui um ponteiro em nossa analogia. Se você está usando dois dados para informar o endereço, então estamos falando de um ponteiro longo, long pointer, ou LP!&lt;/p&gt;
&lt;p&gt;Na terminologia Intel para as plataformas 16 bits, a memória do computador era acessível através de segmentos (ruas) e offsets (números), que eram pedaços da memória onde cabiam no máximo N bytes. Para conseguir mais bytes é necessário alocar memória em outro segmento (outra rua).&lt;/p&gt;
&lt;p&gt;Os ponteiros que conseguiam fazer isso eram chamados de long pointers, pois podiam alcançar uma memória mais &amp;quot;longa&amp;quot;. Os ponteiros que apenas endereçavam o offset (número) eram chamados, em detrimento, short pointers, pois podiam apenas apontar para a memória do seu segmento (rua).&lt;/p&gt;
&lt;p&gt;Ora, se seu destinatário está na mesma rua que você, tudo que você tem a dizer ao Juquinha é: &amp;quot;Juquinha, seu moleque, entrega essa carta no número 1065, e vai rápido!&amp;quot;. Nesse caso você está usando um short pointer.&lt;/p&gt;
&lt;p&gt;Porém, no exemplo que demos, o destinatário está em outra rua. Se o Juquinha entregar a carta no número 1065, mas na rua errada, estará errando o destinatário. Por isso é que você deve usar um long pointer e falar para o Juquinha do segmento!&lt;/p&gt;
&lt;p&gt;&amp;quot;Juquinha, seu moleque safado, entrega essa carta no Segmento 0xAC89, Offset 0x496E. E vê se anda logo!&amp;quot;&lt;/p&gt;
&lt;p&gt;Essa frase era muito usada nos anos 80, com seus 16 bits e tudo mais.&lt;/p&gt;
&lt;p&gt;Com toda essa analogia, fica fácil perceber que o Windows não cabe em uma rua só. Seus aplicativos precisam de muitas ruas para rodar. Isso exige que todos seus ponteiros sejam long, pois do contrário o Juquinha estará entregando as cartas sempre nos endereços errados. Dessa forma, foi estipulado o typedef arcaico padrão para todos os tipos da API que usasse LP (Long Pointer) como prefixo:&lt;/p&gt;
&lt;p&gt;E é por isso que, historicamente, todos os ponteiros para os apelidos da API Win32 possuem sua contraparte LP.&lt;/p&gt;
&lt;p&gt;Com a era 32 bits (e mais atualmente 64 bits) os endereços passaram a ser flat, ou seja, apontam para qualquer lugar na memória. Se eu quisesse continuar minha analogia falaria que é o equivalente a uma coordenada GPS, também muito na moda, e que pode apontar para qualquer lugar do planeta. Eu, por exemplo, já trabalhei perto das coordenadas -23.563596,-46.653885, o que eu costumo dizer que fica bem próximo do Paraíso =).&lt;/p&gt;
&lt;p&gt;De uns anos pra cá, existem novos typedefs nos headers que permitem o uso dos apelidos Win32 apenas com um P inicial.&lt;/p&gt;
&lt;p&gt;A escolha é livre. Assim como com o typedef arcaico.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Typedef arcaico</title>
  <link>http://www.caloni.com.br/typedef-arcaico/</link>
  <pubDate>2010-04-20</pubDate>
  
  <guid>http://www.caloni.com.br/typedef-arcaico/</guid>
  <description>&lt;p&gt;A API do Windows geralmente prima pela excelência em maus exemplos. A Notação Húngara e o Typedef Arcaico são duas técnicas que, por motivos históricos, são usados a torto e a direito pelos códigos de exemplo.&lt;/p&gt;
&lt;p&gt;Já foi escrito muita coisa sobre os prós e contras da notação húngara. Já o typedef arcaico, esse pedacinho imprestável de código, ficou esquecido, e hoje em dia traz mais dúvidas na cabeça dos principiantes em C++ do que deveria. Para tentar desobscurecer os mitos e fatos, vamos tentar explicar o que significa essa construção tão atípica, mas comum no dia-a-dia.&lt;/p&gt;
&lt;p&gt;Vejamos um exemplo típico desse pequeno Frankenstein semântico:&lt;/p&gt;
&lt;p&gt;Bom, eu nem sei por onde começar. Talvez pelo conceito de typedef.&lt;/p&gt;
&lt;p&gt;Um typedef, basicamente, é um apelido. Você informa um tipo e define &amp;quot;outro tipo&amp;quot;.&lt;/p&gt;
&lt;p&gt;O tipo é tudo que fica entre o typedef e o novo nome, que deve ser um identificador válido na linguagem. Por exemplo, a empresa onde trabalho fez um typedef informal do meu nome:&lt;/p&gt;
&lt;p&gt;Se, futuramente, eu sair da empresa e entrar outro &amp;quot;Wanderley alguma-coisa&amp;quot;, será possível usar o apelido novamente, bastando alterar o typedef:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bom, &amp;quot;outro tipo&amp;quot; é forma de dizer. Isso é uma descrição errônea em muitos livros. De fato, o compilador enxerga o mesmo tipo com outro nome, daí chamarmos o typedef de apelido, mesmo.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tipos simples são fáceis de entender porque possuem seus símbolos no mesmo lugar:&lt;/p&gt;
&lt;p&gt;Já os tipos um pouco mais complicados permite alguma mudança aqui e acolá:&lt;/p&gt;
&lt;p&gt;Essa liberdade da linguagem, mesmo sendo um recurso útil, pode ser bem nocivo dependendo de quem olha o código:&lt;/p&gt;
&lt;p&gt;Em algumas formas da sintaxe, além de ser inevitável, gera bastante desconfiança:&lt;/p&gt;
&lt;p&gt;Antigamente, as structs eram construções em C que definiam um agregado de tipos primitivos (ou outras structs) e que poderiam gerar variáveis desse tipo em qualquer lugar, desde que informado seu nome e que se tratasse de uma struct:&lt;/p&gt;
&lt;p&gt;Para evitar toda essa digitação, os programadores usavam um pequeno truque criando um apelido para a estrutura, e usavam o apelido no lugar da struct (apesar de ambas representarem a mesma coisa).&lt;/p&gt;
&lt;p&gt;ou&lt;/p&gt;
&lt;p&gt;Com a definição da linguagem C++ padrão, e mais moderna, essa antiguidade foi removida, apesar de ainda suportada. Era possível usar apenas o nome do struct como seu tipo:&lt;/p&gt;
&lt;p&gt;Porém, isso vai um pouco além de quando a Microsoft começou a fazer código para seu sistema operacional. Naquela época, o padrão ainda estava se formando e existia mais ou menos um consenso de como seria a linguagem C++ (sem muitas alterações do que de fato a linguagem C já era). De qualquer forma, a linguagem C imperava bem mais que C++. Dessa forma, já era bem formada a ideia de como declarar uma struct: a forma antiga.&lt;/p&gt;
&lt;p&gt;Além do uso controverso do sublinhado para nomear entidades (que no padrão foi recomendado que se reservasse aos nomes internos da biblioteca-padrão) e do uso de MAÍUSCULASNONOME (historicamente atribuído a nomes definidos no pré-processador), o uso do typedef atracado a um struct era muito difundido. E ficou ainda mais depois que a API do Windows foi publicada com essas definições.&lt;/p&gt;
&lt;p&gt;Ora, do mesmo jeito que é feito há vinte anos: sem typedefs. O próprio paradigma da linguagem, independente de padrões de APIs, de sistemas operacionais ou de projetos específicos já orienta o programador para entender o que o espera na leitura de um código-fonte qualquer. Qualquer pessoa que aprendeu o básico do básico sobre ponteiros e structs consegue ler o código abaixo:&lt;/p&gt;
&lt;p&gt;Agora, para entender a forma antiga, ou você se baseou no copy&amp;amp;paste dos modelos Microsoftianos, ou seja, decoreba, ou você é PhD em Linguagem C/C++ e padrões históricos de linguagens legadas. Se não é, deveria começar o curso agora.&lt;/p&gt;
&lt;p&gt;Da mesma forma, o uso de uma estrutura simples de tipos mantém a lista de nomes do seu projeto limpa e clara. Compare o visualizador de classes em projetos Windows com algo mais C++ para ter uma ideia.&lt;/p&gt;
&lt;p&gt;É claro, essa é apenas uma sugestão. Existem vantagens em sua utilização. Existe alguma vantagem no modo antigo? Existe: a Microsoft usa, e talvez mais pessoas usem. Basta a você decidir qual deve ser o melhor caminho.&lt;/p&gt;
&lt;p&gt;De acordo com o leitor  Adriano dos Santos Fernandes, a obrigatoriedade do nome struct após seu nome continua valendo para a linguagem C padrão, assim como no compilador GCC ocorre um erro ao tentar omiti-la. Apenas na linguagem C++ essa obrigatoriedade não existe mais.&lt;/p&gt;
&lt;p&gt;Eu não fiz meus testes, mas confio no diagnóstico de nosso amigo. A maior falha do artigo, no entanto, é usar a linguagem C como base, quando na verdade ele deveria falar sobre o uso desses typedefs em C++. Esse erro também foi corrigido no original.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Using TodoList and Microsoft Project together</title>
  <link>http://www.caloni.com.br/using-todolist-and-microsoft-project-together/</link>
  <pubDate>2010-04-10</pubDate>
  
  <guid>http://www.caloni.com.br/using-todolist-and-microsoft-project-together/</guid>
  <description>&lt;p&gt;The next article about bits is still in the oven. Taking vacation (40 days) had drop me out of ideas! At the moment, I can explain the tips and tricks using  TodoList to manage my team and synchronize my tasks in a Microsoft Project timesheet.&lt;/p&gt;
&lt;p&gt;The reasons why I am using TodoList are kind of obvious: it does everything I need to organize my day to day tasks and it is portable. Meanwhile, the Project, besides not being portable (I need to carry on with me a 200 MB installer? And do install?) it uses a hard to change format and it was made to project the world, and not to be easily shared.&lt;/p&gt;
&lt;p&gt;So, let&#39;s go. Everything we need is a current edition of TodoList and Microsoft Project. The first thing we must to do é to export the tasks we want to a default CSV, using the columns we would like to import to Project:&lt;/p&gt;
&lt;p&gt;After that it comes the tricky thing, but not so much. We open the project to where we want to import the tasks and choose the option Open again, but this time we select our friend exported-tasks.CSV.&lt;/p&gt;
&lt;p&gt;Before we do import, we got to create a new column  that will keep the TodoList tasks IDs, to make sure that in the next imports we make we could merge datum together. So, create this column using a significant name.&lt;/p&gt;
&lt;p&gt;Now we can go on the import process. Imagining to be the first one, let&#39;s create a inicial map for this migration:&lt;/p&gt;
&lt;p&gt;The time we choose who is who in the columns list, we just need to setup which columns in Project are the counterpart for the columns in TodoList, and remember to allocate our special column ID.&lt;/p&gt;
&lt;p&gt;Just more a few Nexts and voilà! We got our tasks properly imported.&lt;/p&gt;
&lt;p&gt;But of course all this work would be useless if we had to (sigh) open the Project. To avoid this impure job, we keep on updating the project status in our tiny, tidy TodoList and, when we need, we just import the data again, but this time using a already saved map (follow the screenshots above) and setting our TodoList ID as the key. This way the tasks already present will be just updated, and the unknown tasks will be added. That&#39;s the most important trick in this post.&lt;/p&gt;
&lt;p&gt;After I researched all this, I just found out the Project won&#39;t be necessary anymore. Lucky me. Now, if you don&#39;t have such luck, you can use this post =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Houaiss Para Babylon!</title>
  <link>http://www.caloni.com.br/houaiss-para-babylon-12/</link>
  <pubDate>2010-04-08</pubDate>
  
  <guid>http://www.caloni.com.br/houaiss-para-babylon-12/</guid>
  <description>&lt;p&gt;Os últimos comentários de Henrique Esteves (quando havia seção de comentários no blogue) sobre o HouaissParaBabylon me fizeram dar mais uma fuçada nele e ver se tento deixá-lo compatível com o Houaiss 3. Foram apenas algumas horas e acho que resolvi os probleminhas relacionados com a troca do registro de instalação e o nome dos arquivos que armazenam os verbetes.&lt;/p&gt;
&lt;p&gt;Apenas para constar, segue a lista de artigos sobre este projeto:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Conversor de Houaiss para Babylon - parte 1&lt;/li&gt;
&lt;li&gt;Conversor de Houaiss para Babylon - parte 2&lt;/li&gt;
&lt;li&gt;Segunda versão do Houaiss2Babylon&lt;/li&gt;
&lt;li&gt;HouaissParaBabylon versão beta&lt;/li&gt;
&lt;li&gt;HouaissParaBabylon versão 1.1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Foi uma odisseia e tanto. E ainda está longe de ser perfeito. Contudo, fico feliz que muitas pessoas já tenham conseguido usá-lo com sucesso e com a qualidade técnica dos meus visitantes. O Henrique, por exemplo, teve que entender o processo interno que o programa faz para renomear os arquivos do dicionário e assim conseguir a conversão. Pessoas como essa faltam na equipe de suporte técnico de programadores de baixaria.&lt;/p&gt;
&lt;p&gt;Isso me faz lembrar que uma das motivações do programador, fora programar, é saber que os usuários usam seu programa. E saber que existem melhorias a ser feitas que vão ser úteis para esses usuários é muito legal. Por isso, continuem assim, caros usuários. E bom proveito!&lt;/p&gt;
&lt;p&gt;Obs.: Essa versão foi testada em um Windows XP com o Houaiss 3, Babylon 8 e o Babylon Builder mais atual.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Novidades no Windbg 7</title>
  <link>http://www.caloni.com.br/novidades-no-windbg-7/</link>
  <pubDate>2010-04-01</pubDate>
  
  <guid>http://www.caloni.com.br/novidades-no-windbg-7/</guid>
  <description>&lt;p&gt;Semestre que vem deve sair uma nova versão do nosso depurador favorito. Alguns atrasos e novas definições do projeto fizeram com que tivéssemos mais um ou dois releases da finada versão 6 antes da revolução que será o Depurador 2010.&lt;/p&gt;
&lt;p&gt;Entre as mudanças mais esperadas, e entre as mais inesperadas, encontramos essa pequena lista de novidades que, com certeza, deixarão o desenvolvedor de sistemas da Microsoft muito mais feliz:&lt;/p&gt;
&lt;p&gt;Hoje em dia é um trabalho um pouco tedioso encontrar qual dos drivers possuía a memória de endereço 0xB8915423, mas agora, juntando o interpretador de símbolos internos e o sistema de tooltips do Windbg, será possível passar o mouse sobre um endereço qualquer e ele mostrará imediatamente quem possui a memória, como ela foi alocada e qual seu conteúdo.&lt;/p&gt;
&lt;p&gt;Isso só é possível, é claro, com os símbolos corretamente carregados. Algo não muito difícil se você seguir as recomendações de John Robbins. E é uma mão na roda na hora de dar um feedback instantâneo para o suporte técnico quando der uma tela azul.&lt;/p&gt;
&lt;p&gt;Sim! Agora se o ddkbuild  estiver no path do WinDbg e você editar o código-fonte do seu driver durante a depuração (na próxima versão a visualização não será apenas read-only) e der um step-into, automaticamente o depurador irá perguntar se deseja recompilar o projeto. Depois de ativar o processo de build, através das conexões serial/firewire/usb-debug, a nova imagem irá parar diretamente na memória kernel da máquina target.&lt;/p&gt;
&lt;p&gt;Algumas ressalvas são colocadas pela equipe da Microsoft, no entanto. Se existirem mudanças que dizem respeito a alocação dinâmica de memória em nonpaged-pool, o Edit and Continue não será possível naquele momento, apenas depois do reboot.&lt;/p&gt;
&lt;p&gt;O último item, mais esotérico de todos, promete ser lançado a partir da versão 7.1:&lt;/p&gt;
&lt;p&gt;Resumidamente, é um !analyze mais esperto com o algoritmo heurístico do Visual Basic .NET. Assim que for aberto um dump de tela azul e carregados os símbolos e o caminho dos fontes, a nova versão do !analyze irá verificar os valores do BugCheck gerado e, caso seja detectado que o problema está em seu driver, irá sugerir uma correção na sua função que estiver na pilha.&lt;/p&gt;
&lt;p&gt;Existem um pouco de polêmica em torno dessa funcionalidade. Alguns dizem que ela vai mais atrapalhar do que ajudar os programadores de kernel com a vinda de analistas de sistemas Júnior programando filtros de file system sem a menor discrepância entre o que é um IRP assíncrono e uma ISR. Outros dizem que existirá uma versão paga do WinDbg com essa funcionalidade, nos mesmos moldes do Visual Studio 2010, que virá com a depuração reversa no Enterprise. Essas especulações só o tempo dirá se são verdade ou não. Se eu tiver que pagar mais caro por essas features, o lobby na empresa onde eu trabalho está garantido.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Convivendo entre TodoList e Microsoft Project</title>
  <link>http://www.caloni.com.br/convivendo-entre-todolist-e-microsoft-project/</link>
  <pubDate>2010-03-15</pubDate>
  
  <guid>http://www.caloni.com.br/convivendo-entre-todolist-e-microsoft-project/</guid>
  <description>&lt;p&gt;O próximo artigo sobre escovação de bits ainda está no forno. Tirar férias (de 40 dias) é uma escassez de ideias! No momento, posso explicar a facilidade que tive para continuar usando o TodoList para gerenciar minha equipe e ainda assim sincronizar nossas tarefas em um cronograma do Microsoft Project.&lt;/p&gt;
&lt;p&gt;As razões de eu usar o TodoList são meio óbvias: ele faz tudo que eu preciso para organizar minhas tarefas do dia-a-dia e é portátil. Enquanto isso, o Project, além de não ser portátil (eu preciso levar comigo o instalador de 200 MB? E Instalar?) possui um formato difícil de mudar, já que foi feito para projetar o mundo e não para ser compartilhado facilmente.&lt;/p&gt;
&lt;p&gt;Mas vamos lá. Tudo que precisamos é de uma edição atual do TodoList e do Microsoft Project. A primeira coisa que devemos fazer é exportar as tarefas que queremos do TodoList para um CSV padrão, usando as colunas que gostaríamos de importar para o Project:&lt;/p&gt;
&lt;p&gt;Depois vem a parte complicada, mas nem tanto. Abrimos o projeto para onde queremos importar essas tarefas e escolhemos a opção Abrir novamente, só que dessa vez selecionando o nosso amigo tarefas-exportadas.CSV.&lt;/p&gt;
&lt;p&gt;Só que antes de importarmos, calma lá. Temos que criar uma nova coluna que irá guardar os IDs das tarefas do TodoList, para que nas próximas importações consigamos mesclar os dados já existentes. Portanto, crie uma nova coluna (pode ser qualquer NúmeroX não-alocado ainda) com um nome significativo.&lt;/p&gt;
&lt;p&gt;Agora podemos partir para a importação. Imaginando que seja a primeira, vamos criar um mapeamento inicial para essa primeira migração:&lt;/p&gt;
&lt;p&gt;Na hora de escolher quem é que, só precisamos definir quais colunas no Project correspondem a quais colunas do TodoList, e lembrar de alocar o ID na nossa coluna especial.&lt;/p&gt;
&lt;p&gt;Mais alguns Next da vida e pronto! Temos nossas tarefas devidamente importadas.&lt;/p&gt;
&lt;p&gt;Mas é claro que todo esse trabalho não valeria a pena se tivéssemos que (arght) mexer no Project. Para evitar esse trabalho impuro, continuamos atualizando o andamento dos projetos no nosso pequeno, leve e sagaz TodoList e, quando precisarmos, é só importarmos novamente os dados, só que dessa vez usando um mapa já salvo (siga os screenshots acima) e marcando nosso ID do TodoList como chave. Dessa forma as tarefas já importadas são apenas atualizadas, e não criadas novamente. Esse é o famoso &amp;quot;pulo do gato&amp;quot; (que eu ouvia matinalmente na minha época de office-boy).&lt;/p&gt;
&lt;p&gt;Depois de eu pesquisar toda essa trama, descobri que o uso do Project não será necessário. Sorte minha. Agora, se você não tiver sorte...&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Bazaar gráfico</title>
  <link>http://www.caloni.com.br/bazaar-grafico/</link>
  <pubDate>2010-02-25</pubDate>
  
  <guid>http://www.caloni.com.br/bazaar-grafico/</guid>
  <description>&lt;p&gt;Bom, já que por enquanto os assuntos de macho estão em falta (acabei de voltar de férias), apresento-lhes o maravilhoso mundo do Bazaar para boiolas user-friendly!&lt;/p&gt;
&lt;p&gt;Ele é leve, vem enrustido embutido na última versão e pode economizar alguns page ups/downs no prompt do DOS. Ah, sim, antes que comentem, eu não uso o Tortoise for Bazaar porque instalar shell extensions, só os muito bem feitos. (Do contrário, bem-feito para quem instalou.)&lt;/p&gt;
&lt;p&gt;Para exibir a lista de comandos &amp;quot;amigáveis&amp;quot;, digite no prompt os comandos do Bazaar filtrando-os para os que começam com &amp;quot;q&amp;quot;:&lt;/p&gt;
&lt;p&gt;Os que eu mais uso no dia-a-dia são:&lt;/p&gt;
&lt;p&gt;Diversão garantida. Por meio destes simples comandos podemos ver o histórico de commits e navegar pela árvore de pastas e arquivos com a anotação do último commit para cada elemento. Só para ter uma ideia de quanto uso isso, transformei-os em opções do Explorer.&lt;/p&gt;
&lt;p&gt;Além da utilidade básica, de quebra, o qbrowse pode te levar para um qlog filtrado, e o qlog pode te levar a um diff gráfico, que é o próximo comando que eu iria mostrar.&lt;/p&gt;
&lt;p&gt;Coisa linda de Deus. Existem dois modos de exibição, mas o padrão já é show de bola, mostrando as mudanças em todos os arquivos de um commit de uma só vez ou do arquivo/pasta especificado pelo comando. É lógico que é possível especificar qualquer faixa de commits que você quiser ver.&lt;/p&gt;
&lt;p&gt;Uma desvantagem desse comando é que ele oculta o resto das linhas do fonte e não mostra de jeito nenhum (pelo menos não descobri ainda como fazer isso). Sendo assim, para uma análise mais detalhada das diferenças no código-fonte sempre use um editor externo que consiga comparar arquivos inteiros (eu uso o WinMerge). Você pode colocar esse comando na forma de um diff personalizado, com o uso do qconfig.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Restaurando o registro</title>
  <link>http://www.caloni.com.br/restauranto-o-registro/</link>
  <pubDate>2010-02-08</pubDate>
  
  <guid>http://www.caloni.com.br/restauranto-o-registro/</guid>
  <description>&lt;p&gt;Algumas ferramentas viram essenciais quando o importante é tempo. As minhas favoritas são: Visual Studio e batch. Com esses dois eu faço virtualmente qualquer coisa que preciso em pouquíssimo tempo. É lógico que, na ausência dessas, alternativas são bem-vindas, como Notepad++, viM, grep, cygwin.&lt;/p&gt;
&lt;p&gt;Ontem tive que resolver uma &amp;quot;situação&amp;quot; no cliente, e graças ao bom Deus (ele também é programador) existia um Notepad++ na bagagem que levávamos. Além, é claro, do Excel e do sistema batch do Windows.&lt;/p&gt;
&lt;p&gt;O problema consistia basicamente em usar a saída do RegMon para identificar e restaurar algumas modificações que danificavam a instalação do Internet Explorer. O sistema de reparo do IE não existia no cliente, pois ele estava sem Service Pack (bem-vindo ao mundo real), mas podíamos nos guiar através dele na nossa máquina virtual para saber o que faríamos. O estrago era feito durante o registro e/ou desregistro de um componente COM.&lt;/p&gt;
&lt;p&gt;Aliás, não, eu não preciso usar o onipresente e onipotente Process Monitor para resolver um detalhezinho no registro. Você talvez precise, já que a Microsoft já tirou o Reg e o File de circulação.&lt;/p&gt;
&lt;p&gt;Para iniciar, filtramos os resultados do RegMon para apenas capturar escritas no registro, não importando se falharam ou deram resultado.&lt;/p&gt;
&lt;p&gt;A partir disso executamos o registro e desregistro do componente, além da restauração do IE6, responsável por limpar a bagunça. O processo responsável por registrar componentes é o regsvr32 e o responsável por limpar a bagunça, rundll32.&lt;/p&gt;
&lt;p&gt;Tendo a saída do RegMon exportada para formato texto, abrimos no Excel e filtramos o conteúdo pelo nome do processo. Note que existem duas instâncias de regsvr32 para usar, pois não sabemos em qual delas é danificado o registro.&lt;/p&gt;
&lt;p&gt;Para cada um dos filtros copiamos apenas o endereço da chave alterada para dois arquivos texto: regsvr32.txt e ierestore.txt. Usaremos esse primeiro para encontrar ocorrências no segundo, provando que um modifica o que o outro consertou.&lt;/p&gt;
&lt;p&gt;Existe um comando muito simplório em batch Windows que é o aplicativo find. Através dele podemos encontrar a ocorrência de uma string em um arquivo. Para transformar todas aquelas linhas do registro do arquivo regsvr32 em comandos find poderíamos elaborar algumas colunas no Excel ou usar o Notepad++ e suas macros, mais rápidas.&lt;/p&gt;
&lt;p&gt;Para quem não conhece macros, saiba que elas são muito úteis. Às vezes até mais úteis que &amp;quot;regexes&amp;quot;, pois não é necessário pensar muito na expressão a ser usada. Macros apenas repetem os movimentos do teclado que fazemos enquanto as estamos gravando. Por exemplo, eu tenho o meu monte de linhas de registro assim:&lt;/p&gt;
&lt;p&gt;Quero transformar cada linha em um comando find. Iniciou a gravação da macro no início da primeira linha e digito o seguinte (em pseudo-alguma-coisa):&lt;/p&gt;
&lt;p&gt;find, espaço, abre aspas, end, fecha aspas, espaço, ierestore.txt, linha abaixo, home&lt;/p&gt;
&lt;p&gt;Pronto. Parar macro. Terei que repetir isso dois milhões de vezes até o final do arquivo. Ora, então mando o Notepad++ repetir a minha macro até o final do arquivo e adio minha tendinite para os próximos anos.&lt;/p&gt;
&lt;p&gt;Só preciso agora renomear meu arquivo para .bat e executar. Posso redirecionar a saída da tela para um terceiro arquivo, de onde irei formatar minha lista de entradas no registro que foram adulteradas por ambos os programas (o registro do componente COM e a restauração do Internet Explorer).&lt;/p&gt;
&lt;p&gt;Nesse momento podemos ir tomar café. Bem melhor do que ficar horas e horas dando localizar, copiar, colar em todas as entradas do regsvr.&lt;/p&gt;
&lt;p&gt;Terminada a operação, abrimos o terceiro arquivo, retiramos as entradas insignificantes (por exemplo, o gerador de sementes de números randômicos) e os cabeçalhos do comando, algo bem fácil já que se trata do mesmo arquivo.&lt;/p&gt;
&lt;p&gt;A próxima tarefa seria analisar cada entrada e ver se ela é relevante. Essa parte foi manual, mas, encontrado um padrão, listamos rapidamente o que poderia estar dando errado e criamos uma lista de entradas para exportar do registro &amp;quot;sadio&amp;quot; a fim de gerar um .REG que corrigiria sistemas danificados.&lt;/p&gt;
&lt;p&gt;Algumas passadas no Notepad++ para eliminar linhas duplicadas e algumas passadas pelo cérebro para eliminar chaves redundantes (chave dentro de chave) e tcharam!&lt;/p&gt;
&lt;p&gt;O próximo passo para nossa obra-prima é outra macro que irá reproduzir o comando reg, que pode realizar operações no registro do Windows.&lt;/p&gt;
&lt;p&gt;E o último passo é juntar toda essa galera em um arquivo só.&lt;/p&gt;
&lt;p&gt;Claro, não se esqueça de retirar os cabeçalhos duplicados (Windows Registry Editor Version X.XX). E Voilà! Fácil, não? Não?! Bom, então é por isso que eu sou bem pago =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Correção de bugs instantânea</title>
  <link>http://www.caloni.com.br/correcao-de-bugs-instantanea/</link>
  <pubDate>2010-02-01</pubDate>
  
  <guid>http://www.caloni.com.br/correcao-de-bugs-instantanea/</guid>
  <description>&lt;p&gt;Um programador tarimbado sabe que a melhor situação da vida dele para corrigir um bug é quando esse bug acontece em sua máquina de desenvolvimento, na versão Debug e ainda passo-a-passo. Como nessa situação a correção é um verdadeiro &amp;quot;passeio no parque&amp;quot; (ou na mesa do café) ela tende a quase nunca acontecer. Isso é Murphy Aplicado.&lt;/p&gt;
&lt;p&gt;Para quem programa para sistemas, então, só o fato de acontecer no mesmo processo toda vez que ele for executado já é o máximo (quem já programou serviços, plugins, GINAs e afins sabe do que eu estou falando).&lt;/p&gt;
&lt;p&gt;Porém, saber que uma determinada situação é mel na chupeta (by Thiago) por si só não adianta de muita coisa. É preciso conhecer as verdadeiras técnicas ninjas que conseguem resolver um bug escabroso num instante, coisa de deixar seu gerente de projetos tão feliz ao ponto dele não botar nenhum defeito na solução.&lt;/p&gt;
&lt;p&gt;Dentre as mais conhecidas entre os malloqueiros, temos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Comenta-descomenta-comenta&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Faz do zero&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Essas duas técnicas são tão úteis e tão fáceis de usar que merecem um artigo a respeito.&lt;/p&gt;
&lt;p&gt;Essa técnica milenar corresponde em tirar pedaços do código-fonte que poderiam estar causando o problema até que seja possível criar uma versão em que o problema não ocorra mais. Quando chega-se nesse nível, então volta-se a descomentar o código retirado até que o problema ocorra novamente. O processo é um fluxo de tira-código com volta-código, sendo que é necessário o bom conhecimento do projeto para não gerar outros problemas com a mutilação temporária do projeto.&lt;/p&gt;
&lt;p&gt;Se o código começa a ser tão mutilado que chegamos quase em uma versão vazia (sem código), então talvez a melhor forma de atacar o problema seja criar um esqueleto que contenha apenas o código necessário para que ele não faça nada. Isso mesmo. Não fazendo nada, mas instalado. Com isso prova-se que é possível estar lá sem fazer cagadas. A partir daí vai colocando-se o código do projeto real aos poucos no projeto-esqueleto, até que ele apresente o problema. Ou não. Já vi casos em que todo o código foi migrado e o problema sumiu. Ce la vie.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Passagem por valor e emails com anexo</title>
  <link>http://www.caloni.com.br/passagem-por-valor-e-emails-com-anexo/</link>
  <pubDate>2010-01-18</pubDate>
  
  <guid>http://www.caloni.com.br/passagem-por-valor-e-emails-com-anexo/</guid>
  <description>&lt;p&gt;Mais uma analogia vencedora para ponteiros, chamadas por valor e chamadas por referência: e-mails.&lt;/p&gt;
&lt;p&gt;Quando passamos um parâmetro por valor, estamos enviando um e-mail com um arquivo em anexo. Não importa o que o destinatário faça com o arquivo: nós não vamos saber o que foi mudado se ele não enviar uma outra cópia.&lt;/p&gt;
&lt;p&gt;Por outro lado, ao passar um parâmetro por referência, estamos enviando um e-mail com um endereço de onde está o arquivo. Se o usuário alterar o arquivo diretamente do endereço que enviamos será possível ver essa alteração imediatamente, pois ambos estão olhando para o mesmo valor na memória.&lt;/p&gt;
&lt;p&gt;A analogia pode ser levada mais longe, com ponteiros de ponteiros: enviamos um e-mail com o endereço de um arquivo; dentro desse arquivo existe um endereço para outro arquivo. Dessa forma é possível tanto alterar o arquivo final quanto o endereço de onde ele está; ou ainda &amp;quot;apontar&amp;quot; para outro arquivo, trocando o endereço de dentro do primeiro arquivo.&lt;/p&gt;
&lt;p&gt;Assim é fácil de visualizar que os dados estão sempre em um arquivo que ocupa espaço na memória (do disco ou da RAM), mas endereços também podem ocupar espaço, se estiverem salvos em um arquivo.&lt;/p&gt;
&lt;p&gt;Dessa forma, um e-mail que contenha um arquivo em anexo vai ser muito maior que um e-mail apenas com o endereço do arquivo, mas é porque todo o conteúdo do arquivo está dentro do e-mail no primeiro caso. No segundo caso, o endereço ocupa apenas alguns caracteres que identificam a localização do arquivo.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Importando tipos de outros projetos</title>
  <link>http://www.caloni.com.br/importando-tipos-de-outros-projetos/</link>
  <pubDate>2010-01-11</pubDate>
  
  <guid>http://www.caloni.com.br/importando-tipos-de-outros-projetos/</guid>
  <description>&lt;p&gt;A engenharia reversa das entranhas do kernel não tem limites se você sabe o que está fazendo. No entanto, algumas facilidades do depurador podem ajudar a minimizar o tempo que gastamos para analisar uma simples estrutura. Por exemplo, o Process Environment Block de um processo específico.&lt;/p&gt;
&lt;p&gt;O comando !peb traz inúmeras informações sobre essa estrutura. Mas talvez estivéssemos interessados em coisas não mostradas por esse comando, mas que existem na estrutura.&lt;/p&gt;
&lt;p&gt;Nesse caso, podemos criar um projeto vazio que contenha a definição da estrutura como acreditamos que esteja na versão do kernel que estamos depurando.&lt;/p&gt;
&lt;p&gt;Compilamos e geramos um PDB (arquivo de símbolos) que contém a definição desse tipo. Tudo que precisamos fazer agora é carregar esse símbolo na sessão que estivermos depurando.&lt;/p&gt;
&lt;p&gt;É claro que nosso executável não vai existir na sessão de kernel local, mas isso não importa. Podemos usar qualquer módulo carregado e usá-lo como host de nosso conjunto de símbolos:&lt;/p&gt;
&lt;p&gt;Depois que o símbolo foi carregado em nosso módulo de mentirinha, tudo que temos a fazer é alterar o contexto do processo atual (para que os endereços de user mode façam sentido) e moldar nossa memória com o comando dt, usando o tipo importado do símbolo carregado.&lt;/p&gt;
&lt;p&gt;Para que isso funcione, a estrutura definida tem que bater offset por offset com os dados na memória, o que envolve alinhamento (se lembre do pragma pack) e versionamento corretos. Se isso não ocorrer, logo aparecerá algum lixo nos membros da estrutura que não fará sentido. Se isso ocorrer, detecte onde o lixo começa e verifique se o membro existe nessa versão do sistema operacional, ou se o alinhamento está de acordo com o módulo analisado.&lt;/p&gt;
&lt;p&gt;Acho que não é preciso dizer que isso não serve apenas para kernel mode =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Devaneio nerd rápido sobre profecias</title>
  <link>http://www.caloni.com.br/devaneio-nerd-rapido-sobre-profecias/</link>
  <pubDate>2009-12-30</pubDate>
  
  <guid>http://www.caloni.com.br/devaneio-nerd-rapido-sobre-profecias/</guid>
  <description>&lt;p&gt;Para quem já analisou os dados de uma tela azul sabe que, quando o Windows acha um culpado (vulgo driver) a data de sua compilação é exibida em um formato conhecido como DateStamp ou TimeStamp. Nesse formato o que temos é um número hexadecimal que segue o formato de tempo do Unix, que no caso é o número de segundos desde o dia primeiro de Janeiro de 1970. Isso, por curiosidade, nos dá uma margem de 140 anos antes dos número se repetirem se usarmos 32 bits nessa contagem.&lt;/p&gt;
&lt;p&gt;O comando .formats do WinDbg nos consegue trazer desse número a hora exata em que determinado componente foi compilado. Se, por exemplo, um driver faltoso apresentou um DateStamp igual a 49EE9758, podemos concluir que ele foi compilado no dia 22 de abril de 2009, uma linda quarta-feira.&lt;/p&gt;
&lt;p&gt;Quando fazemos algo muitas vezes seguidas temos o hábito inconsciente de observar certas idiossincrasias dos dados que sempre vem e vão. No caso dos Date Stamps, sempre me veio o fato deles iniciarem com 4 e estarem prestes a &amp;quot;virar o contador&amp;quot; para 5.&lt;/p&gt;
&lt;p&gt;Isso aos poucos - entre uma tela azul e outra - me deixou curioso a respeito de quando seria o dia fatídico em que teríamos o DateStamp 50000000, um número cabalístico em nosso sistema decimal. E, imaginem só:&lt;/p&gt;
&lt;p&gt;Pois é, meus amigos. O DateStamp para a virada do contador Unix se fará numa manhã de sexta. Para ser preciso, uma sexta-feira 13.&lt;/p&gt;
&lt;p&gt;Curioso, não? Mais curioso que isso, só sabendo que o ano que isso vai ocorrer é o igualmente fatídico 2012. Felizmente antes de dezembro.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O boot no Windows: Kernel</title>
  <link>http://www.caloni.com.br/o-boot-no-windows-kernel/</link>
  <pubDate>2009-12-04</pubDate>
  
  <guid>http://www.caloni.com.br/o-boot-no-windows-kernel/</guid>
  <description>&lt;p&gt;Finalmente chegamos em um pouco onde podemos usar o WinDbg.&lt;/p&gt;
&lt;p&gt;Podemos espetar o depurador e fazê-lo parar assim que conectado. Se estiver rodando antes do próprio sistema operacional, teremos um sistema sem processos e sem threads, pois ele irá parar assim que o executivo puder enviar o sinal de início pela porta serial, após carregar na memória os módulos básicos.&lt;/p&gt;
&lt;p&gt;Todos os módulos carregados antes dessa fase são os drivers que tiveram seu Start definido em zero no registro. Todos os programadores que desenvolvem esses drivers gostariam de um dia poder usar o WinDbg. Mas não podem. Quem inicia a comunicação serial com o depurador é o kernel, que só recebe o controle do ntldr depois que os drivers básicos foram carregados.&lt;/p&gt;
&lt;p&gt;Brincadeira. É claro que esses programadores usam o WinDbg, usam até demais. Mas só a partir desse ponto. Se algum problema evitar que o sistema chegue nessa fase, o desenvolvedor terá que usar métodos alternativos de depuração, como teste de mesa (risos incontroláveis).&lt;/p&gt;
&lt;p&gt;De qualquer forma, estamos aí. Agora podemos depurar a criação de qualquer thread, qualquer processo, o carregamento de qualquer módulo, e a chamada a qualquer função do kernel.&lt;/p&gt;
&lt;p&gt;Para depurar a criação de qualquer thread: coloque um breakpoint na função PsCreateSystemThread.&lt;/p&gt;
&lt;p&gt;Para depurar a criação de qualquer processo: coloque um breakpoint na função PspCreateProcess, logo no começo. Será possível capturar a criação do processo System, o processo onde roda a primeira thread do kernel, que inicializa o resto dos componentes.&lt;/p&gt;
&lt;p&gt;E não é lindo ver que, após a chamada ao Process Manager o processo REALMENTE foi criado e está na lista de processos?&lt;/p&gt;
&lt;p&gt;É nesse momento que percebemos que um processo, uma thread, um qualquer-coisa dentro do kernel não é nada mais nada menos que um item em uma lista. Quase tudo no kernel será um item numa lista com um monte de ponteiros referenciando outras estruturas. É isso que mantém a lógica e a coerência no sistema inteiro. Tudo isso é basicamente software, construído como castelos no ar.&lt;/p&gt;
&lt;p&gt;O próximo processo a ser criado, logo após carregar todos os drivers, é o nosso amigo SMSS, o Gerenciador de Sessão, o primeiro pedacinho do iceberg que desponta no oceano. É ele que irá iniciar toda a &amp;quot;parte user-mode do kernel&amp;quot;.&lt;/p&gt;
&lt;p&gt;Nota: Apesar de parecer contraditório, algumas partes do kernel são de fato implementadas em user mode. Os motivos podem variar, mas geralmente são maior segurança (código que não precisa rodar em um ring privilegiado) e desempenho (código que não precisa de muita prioridade).&lt;/p&gt;
&lt;p&gt;Como podemos ver, isso é muito divertido e muito extenso. Poderíamos ir para qualquer lado da evolução do boot. Talvez em artigos futuros daremos uma olhada no processo de logon de um usuário, o que nos obrigaria a ter uma leve noção de como o Windows autentica e autoriza as pessoas. ou talvez daremos uma passadinha no sistema de escalonamento de threads do kernel, um assunto pra lá de complicado e esotérico.&lt;/p&gt;
&lt;p&gt;Nota: Eu pessoalmente recomendo acompanhar o processo de boot descrito por Russinovich e depurar passo-a-passo um boot de verdade. Serão horas e mais horas de puro conhecimento empírico catalogado em seu cérebro-depurador.&lt;/p&gt;
&lt;p&gt;Então até lá. Com licença que eu preciso ver a criação do System mais uma vez.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O boot no Windows: NTLDR</title>
  <link>http://www.caloni.com.br/o-boot-no-windows-ntldr/</link>
  <pubDate>2009-11-26</pubDate>
  
  <guid>http://www.caloni.com.br/o-boot-no-windows-ntldr/</guid>
  <description>&lt;p&gt;Minhas análises estão demorando muito para ser feitas. Talvez seja a hora de revelar o pouco que sei (e pesquisei) sobre o próximo processo de boot do Windows: o NTLDR.&lt;/p&gt;
&lt;p&gt;O nosso amigo NT Loader pode ser entendido através da leitura do já citado Windows Internals ou através de uma outra leitura que estou fazendo atualmente e que pouquíssimos amigos blogueiros irão se lembrar: o livro da galinha preta; formalmente conhecido como Windows Nt File System Internals.&lt;/p&gt;
&lt;p&gt;Para os sabichões de plantão, inclusive os que me criticaram (?) no meu último texto humorístico sobre como Java é podre, eu sei que o bicho da capa não é uma galinha, mas um urubu. A troca de urubu por galinha vem do requisito básico para você fazer trabalhos esotéricos, como macumba e desenvolvimento de drivers: uma galinha preta na encruzilhada. Alguns usam um papel dentro da boca de um sapo, mas vai do gosto de cada um. =)&lt;/p&gt;
&lt;p&gt;E, para os que leram o livro, devem entender que para explicar sobre o funcionamento do sistema de arquivos do Windows, parte intrínseca do funcionamento do próprio kernel, foi necessário ao autor explicar várias partes do kernel, inclusive sua inicialização; e é nessa parte que podemos aprender algo mais sobre o NT Loader.&lt;/p&gt;
&lt;p&gt;Podemos aprender, por exemplo, que ele é carregado logo depois do NT Detect, que é o executável que dá uma olhada no hardware e ajusta a configuração do boot de acordo com o ambiente encontrado. Após esse ajuste, o nosso amigo NT Loader faz algumas coisas pra lá de interessantes.&lt;/p&gt;
&lt;p&gt;O NTLDR é um executável &amp;quot;híbrido&amp;quot; que possui tanto código em modo real quanto código em modo protegido. Com isso podemos supor que é ele o responsável por entrar em modo protegido, uma tarefa que exige alguns conhecimentos da arquitetura.&lt;/p&gt;
&lt;p&gt;Além disso, como o próprio nome diz, ele tecnicamente &amp;quot;sobe&amp;quot; o sistema operacional, pois provê a comunicação entre o hardware (processador e periféricos da máquina) e o software (kernel e drivers de boot). O hardware é o que está espetado na máquina e o kernel é o arquivo ntoskrnl.exe; para a comunicação entre eles existe uma camada de abstração, o hal.dll.&lt;/p&gt;
&lt;p&gt;Esses dois arquivos, juntos dos drivers de boot, são carregados pelo NTLDR.&lt;/p&gt;
&lt;p&gt;Depois de todo aquele trabalhão do setor de boot para analisar o sistema de arquivos, achar o NTLDR, carregá-lo na memória e executá-lo, o controle passa para o nosso amigo híbrido, ainda em modo real. Ele então abre a partição de boot e procura pelo arquivo boot.ini (estamos falando de um boot antes de bcdedit, mas o funcionamento seria aproximado). Como o driver do sistema de arquivos ainda não subiu, isso quer dizer que o NTLDR usa o próprio código embutido para interpretar uma FAT, NTFS ou outros sistemas suportados (um dos motivos por que não é possível instalar o Windows em um ReiserFS).&lt;/p&gt;
&lt;p&gt;Nesse ponto o nosso amigo loader faz o que todo mundo já fez na infância (não fez?): trocar o modo de tela fazendo uma chamada para a BIOS para modo texto 80x50 em 16 cores. Ah, ele também faz algo que eu adorava fazer (você não?): encher a memória de vídeo de pixels pretos para limpar a tela!&lt;/p&gt;
&lt;p&gt;Como ele leu a lista de kernels bootáveis, é isso que ele exibe naquela famosa tela que qualquer um que depura o kernel vê:&lt;/p&gt;
&lt;p&gt;Escolheu seu boot, é a partir daí que ele acha o executável do kernel: ntoskrnl.exe. Ele deve estar na pasta system32 (em ambientes 32 bits). Também é nesse momento que é carregada a HAL (hal.dll) e isola-se o hardware do software a partir daí. As DLLs que esses dois componentes dependem são identificadas e carregadas na memória.&lt;/p&gt;
&lt;p&gt;Agora é hora de abrir o registro. Quer dizer, parte dele. Dentro da pasta system32/config deve estar a hive SYSTEM, que é onde ficam os drivers que devem ser carregados a partir daí em vários níveis. Inicialmente são carregados os que possuem o valor Start igual a zero, como o driver Atapi (controlador de disco):&lt;/p&gt;
&lt;p&gt;A partir daí vários componentes do kernel serão carregados progressivamente. Só que a partir do momento que é chamada a rotina interna KiInitializeKernel o NTLDR não tem mais nada pra fazer: o kernel, em sua forma básica e primitiva, está carregado.&lt;/p&gt;
&lt;p&gt;Veremos nos próximos capítulos como podemos nos aproveitar do ntoskrnl.exe para poder depurar o código a partir daí. Até lá.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O boot no Windows: pré-NTLDR</title>
  <link>http://www.caloni.com.br/o-boot-no-windows-pre-ntldr/</link>
  <pubDate>2009-09-09</pubDate>
  
  <guid>http://www.caloni.com.br/o-boot-no-windows-pre-ntldr/</guid>
  <description>&lt;p&gt;Conforme fui estudando para recordar os momentos sublimes do boot do Windows me deparei com o artigo mais &amp;quot;espetaculoso&amp;quot; de todos os tempos sobre esse assunto, parte integrante do livro Windows Internals e escrito pelo nada mais nada menos Mark Russinovich: Boot Process, no capítulo 5, &amp;quot;Startup and Shutdown&amp;quot;.&lt;/p&gt;
&lt;p&gt;O meu primeiro artigo sobre o boot sem Windows foi 80% escrito com o que eu já sabia de cabeça de tanto mexer na MBR  e de tanto depurar o processo de boot em 16 bits. Os artigos posteriores seriam escritos com uma pitada do que sei mais a &amp;quot;inspiração&amp;quot; da minha pesquisa. Apesar de não parecer pouco para os que não sabem inglês, deixa a desejar para os que sabem (boa parte dos meus leitores, imagino).&lt;/p&gt;
&lt;p&gt;Nesse caso decidi salpicar a explicação com uma boa dose de reversing para aproveitarmos a caminhada e fuçarmos um pouco no funcionamento interno dos componentes de boot e ver no que dá. Antes de começar, porém, aviso que este não é um tratado sobre o sistema de boot. Eu diria que é apenas o resultado de algumas mexidas inconsequentes pelo disassembly do código de boot. Espero encontrar alguém tão curioso (ou mais) do que eu que compartilhe o que achou de todo esse processo. Antes de mais nada um mapinha para vermos até onde chegamos:&lt;/p&gt;
&lt;p&gt;Pelo visto esse foi só o começo. O próximo passo é saber como do setor de boot chegamos ao NTLDR. O que não é nenhum segredo, uma vez que o NTLDR é um arquivo que fica na pasta raiz do sistema de arquivos. Como todos sabemos, qualquer assembly 16 bits de 400 bytes de tamanho consegue ler um arquivo de 250 KB na memória e executá-lo.&lt;/p&gt;
&lt;p&gt;Se o NTLDR não conseguir ser encontrado, o seguinte erro será exibido:&lt;/p&gt;
&lt;p&gt;Que usuário merece ver isso?&lt;/p&gt;
&lt;p&gt;Bom, se ele soubesse analisar o assembly do setor de boot, seria fácil entender essa mensagem. E analisar o assembly é simples demais, quase tão simples quanto entender a mensagem acima. Tudo que precisamos é do programa Debug 16 bits, como o que já vem com o Windows ou aquele mais turbinado do FreeDOS.&lt;/p&gt;
&lt;p&gt;Podemos usar o Debug 16 bits para abrir o setor de boot salvo em algum arquivo e analisá-lo. Esse &amp;quot;salvo em algum arquivo&amp;quot; nós podemos obter usando o HxD, um sofware bom demais que eu uso quase todos os dias da minha vida, ou para analisar os primeiros setores do disco ou ler arquivos binários que caem na minha caixa de e-mails.&lt;/p&gt;
&lt;p&gt;Eu não vou explicar como salvar um setor do disco em um arquivo. Pelamordedeus, isso é fácil demais. É só fuçar que se acha um jeito.&lt;/p&gt;
&lt;p&gt;Se bem que, como esse é um quase-tutorial, vão abaixo apenas algumas dicas:&lt;/p&gt;
&lt;p&gt;(1) no primeiro setor do disco de boot, podemos encontrar a tabela de partições;&lt;/p&gt;
&lt;p&gt;(2) nessa tabela, a partição ativa é a que começa com 0x80;&lt;/p&gt;
&lt;p&gt;(3) existe um campo onde é possível obter o offset de onde está o primeiro setor dessa partição (em setores);&lt;/p&gt;
&lt;p&gt;(4) uma simples conversão de Little Endian e de hexadecimal para decimal nos retorna o número do setor que precisamos;&lt;/p&gt;
&lt;p&gt;(5) o próprio HxD nos consegue levar para esse setor, de onde podemos selecioná-lo e salvá-lo em um arquivo!&lt;/p&gt;
&lt;p&gt;Isso é tudo o que você precisa para fazer engenharia reversa do setor de boot. Bom divertimento!&lt;/p&gt;
&lt;p&gt;Existem duas formas que conheço para analisar o disassembly de um setor de boot pelo Debug. Para os que gostam de aventuras radicais (RPG em modo texto?) existe a análise dinâmica, que consiste em digitar no prompt do DOS o comando Debug e o nome do arquivo salvo com o setor de boot. O primeiro comando u irá desmontar os primeiros bytes do setor (e, portanto, as primeiras instruções). Eu costumo fazer isso para uma visão geral de cinco minutos.&lt;/p&gt;
&lt;p&gt;A segunda forma de análise que exixte é para os preguiçosos que não conseguem fazer tudo no mesmo dia e optam por salvar o dump do disasssembly em um segundo arquivo. Para realizar essa proeza usando o Debug não é preciso mais que três neurônios:&lt;/p&gt;
&lt;p&gt;(1) digite em um arquivo chamado u.bat o seguinte conteúdo:&lt;/p&gt;
&lt;p&gt;(2) rode o debug como a linha abaixo:&lt;/p&gt;
&lt;p&gt;(3) Pronto! Temos um a.asm com toda a saída do setor de boot. Agora podemos analisá-la e editá-la:&lt;/p&gt;
&lt;p&gt;Se fuçarmos por um tempo esse código podemos encontrar várias coisas interessantes, como por exemplo a mensagem que é exibida quando o setor de boot não contém a assinatura padrão 0x55 0xAA em seu final:&lt;/p&gt;
&lt;p&gt;Outra coisa interessante é encontrar a sub-rotina que carrega blocos e blocos de conteúdo do disco na memória, utilizando-se para isso da interrupção 0x13 função 0x42: a leitura estendida!&lt;/p&gt;
&lt;p&gt;Enfim, todo esse assembly para fazer apenas uma coisa: achar o NTLDR na diretório-raiz da partição onde estamos, carregá-lo na memória e executá-lo. O que se passa a partir daí é o que iremos abordar na futura continuação. Não perca!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O boot no Windows: sem Windows</title>
  <link>http://www.caloni.com.br/o-boot-no-windows-sem-windows/</link>
  <pubDate>2009-08-18</pubDate>
  
  <guid>http://www.caloni.com.br/o-boot-no-windows-sem-windows/</guid>
  <description>&lt;p&gt;Desde quando o usuário liga o computador até o momento em que ele vê a barra de tarefas e aqueles fundos lindos de papel de parede existem diversas coisas sendo feitas por debaixo do pano. Essa série de artigos irá explicar essas diversas coisas, ou seja, como funciona e quais as fases do boot de uma máquina que possui Windows instalado (plataforma NT).&lt;/p&gt;
&lt;p&gt;O que esses artigos não vão fazer muito bem é explicar o lado do kernel mode funcionando, até porque temos artigos melhores explicando esse ponto de vista. Essa é uma abordagem mais &amp;quot;high level&amp;quot;, apesar de &amp;quot;low enough&amp;quot;. No entanto, espero que seja divertido. É esse o mais importante requisito em qualquer aprendizado, certo? Let&#39;s go!&lt;/p&gt;
&lt;p&gt;Tudo começa no hardware, que recebe um lampejo de energia que o põe em funcionamento (&amp;quot;levanta-te e anda!&amp;quot;). Isso faz com que um pequeno pedaço de software comece a rodar. Esse pedaço inicial de código é chamado de firmware, que é um meio termo entre hardware e software.&lt;/p&gt;
&lt;p&gt;O firmware fica gravado na placa-mãe e normalmente nós ouvimos falar dele pelo nome de BIOS, Basic Input Output System (Sistema Básico de Entrada e Saída). É nele que estão gravadas as rotinas mais básicas para fazer o hardware mais básico funcionar: CPU, memória, vídeo e teclado.&lt;/p&gt;
&lt;p&gt;Quando o computador é ligado, o código da BIOS realiza duas operações vitais antes de continuar:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ver se todos os componentes de hardware estão bem;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ver quem é o dispositivo que inicia o sistema operacional.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Esse segundo item é o que veremos agora.&lt;/p&gt;
&lt;p&gt;Dependendo do computador, podemos iniciá-lo por um disco rígido (HD), por um CD-ROM, por um PenDrive USB e até pela rede. Isso está subordinado ao firmware da máquina, pois é ele que comanda, até segunda ordem, todo o hardware acoplado ao sistema.&lt;/p&gt;
&lt;p&gt;Vamos supor que um HD foi configurado para ser o inicializador do sistema operacional. Então será lido um pequeno espaço de 512 bytes, mais conhecido como setor, bem no início desse HD. Esse setor inicial possui código de inicialização (chamado de bootstrapping). Por isso, ele é colocado na memória inicial da máquina e executado. O lugar onde ele fica é fixo e conhecido por todos (lembre-se que estamos rodando em modo real!): 0x7C00.&lt;/p&gt;
&lt;p&gt;Agora o próximo passo é com esse setor inicial do disco, que chamamos de MBR: Master Boot Record (ou Registro de Boot Mestre, em tradução livre).  Ele contém código 16 bits que não pode depender de runtime nenhuma e faz o que quiser com a memória. Também possui no seu final uma tabela de quatro entradas de partições; é nessa tabela que deve estar a partição ativa, onde está o sistema operacional.&lt;/p&gt;
&lt;p&gt;Uma MBR padrão procura por essa partição e lê seu primeiro setor, fazendo um processo bem parecido com o que a BIOS faz inicialmente: carrega na memória o primeiro setor da partição e executa.&lt;/p&gt;
&lt;p&gt;Vamos supor que você tenha algum Windows moderno na partição ativa. A MBR irá carregar o primeiro pedaço de código desse sistema operacional moderno, que, até então, estará rodando em modo real desprotegido como o bom e velho MS-DOS.&lt;/p&gt;
&lt;p&gt;(Note que, mesmo que se trate de uma MBR escrita por terceiros, se ela se comportar como manda o figurino, irá carregar o primeiro setor da partição ativa descrita na tabela de partições. Isso é o que faz com que MBRs escritas pelo pessoal do Linux (e.g. Lilo) consiga fazer o boot de uma partição Microsoft.)&lt;/p&gt;
&lt;p&gt;Agora chegamos em todos os passos iniciais realizados antes de entrar em cena o S.O.:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;O firmware da placa-mãe, conhecida como BIOS, verifica se o hardware básico está funcionando;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Em seguida, o mesmo código procura pelo dispositivo iniciável que irá dar início ao processo de boot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Se for um HD, então o primeiro setor físico desse HD será carregado em memória e executado;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Esse primeiro setor se chama MBR e contém uma tabela com até quatro entradas de partições no disco;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O código da MBR procura pela partição ativa onde deve estar o sistema operacional;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Assim como a BIOS, a MBR carrega na memória o primeiro setor da partição ativa e executa;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A partir daí temos o código de um possível sistema operacional rodando.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Todos os componentes principais desse boot podem ser visualizados de uma forma bem macro na figura abaixo.&lt;/p&gt;
&lt;p&gt;Alguns detalhes sórdidos que podem fazer alguma diferença para você, desenvolvedor de sistemas operacionais, um dia desses:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Os setores de que estamos falando (MBR, partição ativa) normalmente devem terminar com uma assinatura de dois bytes (0x55 0xAA), o que &amp;quot;garante&amp;quot; que o código contido nesse setor é válido e pode ser executado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No caso do loader do Windows (pré-Vista), existia um arquivo no diretório-raiz da partição ativa chamado boot.ini que continha uma lista de possíveis modos de inicializar o sistema operacional, inclusive com múltiplas versões do Windows, cada um localizado em uma partição/pasta distinta (e.g., multiboot com Windows 98 e XP).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O limite de quatro partições da MBR pode ser aumentado com o uso de partições estendidas; as partições estendidas apontam para um bloco de setores no HD que inicia com um setor que contém outra tabela de partições exatamente onde fica a tabela da MBR, também com quatro entradas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O endereçamento da localização das partições na MBR pode ser feito de duas maneiras distintas: por CHS ou por LBA. A versão CHS é bem antiga, mas ainda usada, e especifica uma localização no HD através de um posicionamento físico de três dimensões, com cilindro/trilha (C - Cylinder), cabeça (H - Head) e setor (S - Sector). Sim, isso é bem &lt;em&gt;old-fashionable&lt;/em&gt;. Também existe o LBA (Logical Block Addressing), que é uma forma lógica de endereçar setores no disco, através de deslocamentos (&lt;em&gt;offsets&lt;/em&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para detectar problemas de hardware, a BIOS pode ajudar com seus beeps significativos. Isso aparentemente parece ser o fim da picada, mas não é. O DQ sabe muito bem que podemos ter problemas no hardware que exigem análises mais sofisticadas (como comprimento de onda dos sinais).&lt;/p&gt;
&lt;p&gt;Se for detectar algum problema no sistema de boot baseado em MBR, então você tem dois caminhos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Usar o SoftICE 16 bits e depurar o carregamento da MBR pela BIOS&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Usar o Debug 16 bits do MS-DOS (ou similar) e depurar diretamente o código de boot da MBR, reproduzindo os passos anteriores da BIOS.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Se o problema for durante o carregamento do próprio sistema operacional, as mensagens de erro do loader são significativas. No entanto, pode-se usar o Debug mais uma vez e depurar essa parte, logo antes, é claro, do sistema entrar em modo protegido de 32 bits, o que daí já é outra história (que pretendo contar em breve).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Artigo sobre o boot no Linux&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>What I&#39;ve been doing in the last 10 years</title>
  <link>http://www.caloni.com.br/what-ive-been-doing-in-the-last-10-years/</link>
  <pubDate>2009-08-17</pubDate>
  
  <guid>http://www.caloni.com.br/what-ive-been-doing-in-the-last-10-years/</guid>
  <description>&lt;p&gt;This week I dedicate myself to update my resumè and I have the brilliant idea of put into it my technical historical, what resuming is a list of things I did or was involved with during my brief ten years stay in the programming world.&lt;/p&gt;
&lt;p&gt;So I thought: &amp;quot;this could be useful to the people read me&amp;quot;. Why not? Perhaps you got some doubt waiting to be solved and is unable to find a guy who knows something about this. Perhaps this fork guy even exists and has a blog where he could share some knowledge that is stuck in that empty programmer head.&lt;/p&gt;
&lt;p&gt;In this case, it follows bellow a brief description of my professional life, with the things I could remember I did since December 2000. What I haven&#39;t remember probably is not worth of.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Software and hardware inventory&lt;/li&gt;
&lt;li&gt;Clipboard and PrintScreen protection using windows hooks and global messages manipulation&lt;/li&gt;
&lt;li&gt;Driver writing system event log&lt;/li&gt;
&lt;li&gt;DeviceIoControl user/kernel communication&lt;/li&gt;
&lt;li&gt;Desktop remote control using VNC technique&lt;/li&gt;
&lt;li&gt;Remote execution tool PsExec (SysInternals) like&lt;/li&gt;
&lt;li&gt;Print control using regex (Boost) and shell hook&lt;/li&gt;
&lt;li&gt;Access policies management during user logon/logoff (register and hooks)&lt;/li&gt;
&lt;li&gt;Database migration CTree -&amp;gt; SQL (OLE classes)&lt;/li&gt;
&lt;li&gt;Windows authentication using custom GINA and DCOM; Credential Provider (Vista)&lt;/li&gt;
&lt;li&gt;CTree database synchronism using custom DCOM service&lt;/li&gt;
&lt;li&gt;Bootable Linux CD with bash scripts and disk cryptography tools using C language&lt;/li&gt;
&lt;li&gt;Hard disk encryption and PenDrive (USB) storage control&lt;/li&gt;
&lt;li&gt;Blue Screen analysis using memory dumps and WinDbg live (Gflags)&lt;/li&gt;
&lt;li&gt;System account execution using custom COM service&lt;/li&gt;
&lt;li&gt;MBR (Master Boot Record) customization library&lt;/li&gt;
&lt;li&gt;Blowfish/SHA-1 encryption library using C++ and 16 bits Assembly&lt;/li&gt;
&lt;li&gt;Log access driver using shared memory between user and kernel mode&lt;/li&gt;
&lt;li&gt;Kernel mode API hook for 9X and NT platforms&lt;/li&gt;
&lt;li&gt;16 bits Assembly loader; debugging using debug.com tool&lt;/li&gt;
&lt;li&gt;Executable protection using embedded domain authentication recorded inside files resources&lt;/li&gt;
&lt;li&gt;Internet Explorer 6/7 and Firefox 1/2 browsing protection using Assembly 32 bits code injection&lt;/li&gt;
&lt;li&gt;Code, strings and execution protection library (using Win32 interruptions)&lt;/li&gt;
&lt;li&gt;Centralized log generation library using shared memory and global events&lt;/li&gt;
&lt;li&gt;Internet Explorer 6/7 BHO (Broser Helper Object) and ActiveX; Mozilla/Firefox XPI plugin&lt;/li&gt;
&lt;li&gt;Projects management using Source Safe, Bazaar and Batch (Win) scripts&lt;/li&gt;
&lt;li&gt;Kernel mode debugging using SoftIce and WinDbg for NT platform, SoftIce and WDeb98 for 9X platform&lt;/li&gt;
&lt;li&gt;Trojans reverse engineering (C++, Visual Basic, Delphi) using WinDbg and IDA&lt;/li&gt;
&lt;li&gt;Diagnostic tool listing files, services, drivers, register, disk partitions, processes, etc&lt;/li&gt;
&lt;li&gt;Jobs monitoring in Win2000+ to installation and update control&lt;/li&gt;
&lt;li&gt;Application use monitoring using noninvasive and invasive windows hooks&lt;/li&gt;
&lt;li&gt;Houaiss reverse engineering and Babylon importation (dictionaries)&lt;/li&gt;
&lt;li&gt;Build control with Cruise Control .NET, symbol server with Debugging Tools&lt;/li&gt;
&lt;li&gt;Projects documentation using Doxygen and Wiki (Trac)&lt;/li&gt;
&lt;li&gt;Management interfaces using C++ Builder 5/6 and Visual C++ custom libraries&lt;/li&gt;
&lt;li&gt;E-mails analyzer using regular expressions (ATL classes)&lt;/li&gt;
&lt;li&gt;Configuration interfaces using Visual C++ (MFC /ATL/WTL)&lt;/li&gt;
&lt;li&gt;Project and tracing analysis using regular expressions (Vim and Grep)&lt;/li&gt;
&lt;li&gt;Articles development using technical blog and Code Project community.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Perhaps I update this list frequently. Although I guess the rightest choice would be to update the list with articles about my every day &amp;quot;brushing bits&amp;quot; life . After all, I got a technical blog already!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>AdPlus no cliente, não você!</title>
  <link>http://www.caloni.com.br/adplus-no-cliente-nao-voce/</link>
  <pubDate>2009-08-10</pubDate>
  
  <guid>http://www.caloni.com.br/adplus-no-cliente-nao-voce/</guid>
  <description>&lt;p&gt;O AdPlus é uma das poderosas ferramentas do pacote Debugging Tools for Windows. Se trata basicamente de um script que serve para realizar múltiplas fotografias no estado de um programa em execução usando para isso os depuradores do próprio pacote. Quando alguma coisa estiver errada, principalmente um crash ou travamento, ele paralisa a execução e gera um dump final com toda a história contada desde o começo.&lt;/p&gt;
&lt;p&gt;Ele pode ser usado na situação mais comum: o programa trava/quebra em um cliente específico e/ou em um momento específico que pode acontecer em cinco segundos ou daqui a quinze horas. Como você não pode ficar monitorando o tempo todo a execução do programa (haja indexadores no PerfMon!) então você precisa de alguém que monitore por você. Como seres humanos costumam ter deficit de atenção muito facilmente você vai lá no cliente (ou pede para alguém ir) e executa o AdPlus, que dá conta do recado:&lt;/p&gt;
&lt;p&gt;Esse notepad, viu! Sempre ele!&lt;/p&gt;
&lt;p&gt;Bom, vamos fazer alguma brincadeira de desmontar para ver seu funcionamento. Com o notepad recém-aberto por esse comando, vamos abrir outro depurador em modo de visualização e alterar alguma chamada-chave para quebrar propositadamente:&lt;/p&gt;
&lt;p&gt;Após isso só precisamos abrir um arquivo qualquer que não existe:&lt;/p&gt;
&lt;p&gt;Depois desse lapso de memória o AdPlus irá gerar dois &amp;quot;dumpões&amp;quot; e um &amp;quot;dumpinho&amp;quot; para você:&lt;/p&gt;
&lt;p&gt;O dumpinho é a exceção de first chance, que ele iria gerar de qualquer forma se houvesse uma exceção capturada pelo programa. É apenas um minidump.&lt;/p&gt;
&lt;p&gt;Os outros dois dumpões são o momento da exceção second chance, o que quer dizer que é antes da casa cair, e o segundo é quando a casa já caiu e o processo pegou suas coisas e já tá indo embora.&lt;/p&gt;
&lt;p&gt;A partir do second chance podemos visualizar a cagada feita pelo nosso WinDbg de passagem.&lt;/p&gt;
&lt;p&gt;Se você não é desenvolvedor apenas empacote essa pasta com os dumps e envie para o culpado (ou quem você gostar menos).&lt;/p&gt;
&lt;p&gt;Existem alguns outros parâmetros bem comuns e que podem ser muito úteis para outras situações:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Quando o programa já está rodando e não pode ser parado senão tudo está perdido (adplus -crash -pn processo.exe).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Quando o programa não vai capotar, mas vai travar/parar de responder (adplus -hang -sc processo.exe).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Quando existem muitos outros processos com o mesmo nome (adplus -crash -p [PID]).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Existem outros mais, mas apenas decorando esses e guardando a pasta do Debugging Tools no PenDrive já garante sucesso em 90% dos casos em que o cliente xingar o suporte.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Cuidado com a cópia de arquivos na VMWare</title>
  <link>http://www.caloni.com.br/cuidado-com-a-copia-de-arquivos-na-vmware/</link>
  <pubDate>2009-07-27</pubDate>
  
  <guid>http://www.caloni.com.br/cuidado-com-a-copia-de-arquivos-na-vmware/</guid>
  <description>&lt;p&gt;Quebrei a cabeça com uma DLL de hook que não estava funcionando para usuários comuns. No entanto, para qualquer administrador funcionava.&lt;/p&gt;
&lt;p&gt;Isso acontece porque quando se arrasta uma DLL recém-compilada para a VMWare ela possui um mecanismo que primeiro cria esse arquivo no temporário do usuário atual e depois move esse arquivo para o lugar onde você de fato arrastou.&lt;/p&gt;
&lt;p&gt;Como sabemos, a pasta temporária de um usuário fica em seu perfil, que possui direitos de uso apenas do usuário e dos administradores do sistema. Se eu copio um arquivo de uma pasta restrita para outra pasta os direitos do arquivo permanecem. Isso quer dizer que apenas o usuário atual e os administradores terão acesso ao arquivo, mesmo que se trate de um arquivo para uso de todos.&lt;/p&gt;
&lt;p&gt;Resultado: arrastava a nova DLL de hook compilada da pasta de saída direto para a pasta de sistema da máquina virtual e esse caminho através do temporário era seguido, tornando a DLL inacessível para os usuários que eu estava testando.&lt;/p&gt;
&lt;p&gt;Solução: após arrastar o arquivo, mude suas permissões. Ou copie-o através do bom e velho copiar/colar. Diferente do arrastar, o Ctrl+C Ctrl+V não gera arquivos temporários.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Name mangling</title>
  <link>http://www.caloni.com.br/name-mangling/</link>
  <pubDate>2009-07-13</pubDate>
  
  <guid>http://www.caloni.com.br/name-mangling/</guid>
  <description>&lt;p&gt;A sobrecarga estática possui algumas desvantagens em relação ao sistema de nomes da boa e velha linguagem C: ela não foi padronizada entre compiladores. O que isso quer dizer na prática é que funções exportadas de bibliotecas dinâmicas (DLLs) vão possuir nomes diferentes dependendo do compilador utilizado (e sua versão). Isso é o que chamamos name mangling.&lt;/p&gt;
&lt;p&gt;Em dois projetos usando Visual C++ 2008 e Borland C++ Builder 5 (última versão que funciona direito) eu fiz uma exportação da função soma em linguagem C (o fonte é um .c). Veja o resultado:&lt;/p&gt;
&lt;p&gt;Já usando a linguagem C++ (o fonte é um .cpp) temos outro resultado totalmente diferente para nossas duas funções soma descritas no artigo anterior:&lt;/p&gt;
&lt;p&gt;Se quiser tentar entender essas letrinhas bizarras, recomendo baixar projetos de exemplo. Se apenas entender que você não conseguirá juntar classes VC++ e Builder usando dllexport.aspx) para tudo quanto é lado, então terminamos por aqui.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Polimorfismo estático</title>
  <link>http://www.caloni.com.br/polimorfismo-estatico/</link>
  <pubDate>2009-07-10</pubDate>
  
  <guid>http://www.caloni.com.br/polimorfismo-estatico/</guid>
  <description>&lt;p&gt;Para explicar polimorfismo, nada como ver as coisas como elas eram. Se você fosse um programador C de vinte anos atrás e criasse as seguintes funções:&lt;/p&gt;
&lt;p&gt;Imediatamente o compilador iria acusar os seguintes erros:&lt;/p&gt;
&lt;p&gt;Isso acontece porque em C os identificadores são únicos por escopo. Esse é o motivo por que o seguinte código também está errado:&lt;/p&gt;
&lt;p&gt;De volta aos anos 90, isso também está errado em C++. Até por uma questão de lógica: como o compilador pode saber a qual variável estamos nos referindo se usarmos o mesmo nome para duas delas?&lt;/p&gt;
&lt;p&gt;Só que existe um truquezinho para impedir essa ambiguidade quando falamos de funções: os parâmetros que ela recebe.&lt;/p&gt;
&lt;p&gt;Isso permitiu que em C++ fosse criada a sobrecarga estática, que é exatamente isso: chamar a função não apenas de acordo com seu nome, mas também de acordo com sua assinatura, ou seja, o número e o tipo dos parâmetros recebidos. Chamamos de sobrecarga estática porque isso é feito apenas pelo compilador, não pesando em nada durante a execução do programa.&lt;/p&gt;
&lt;p&gt;Entre seus usos mais comuns estão os seguintes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ter funções com o mesmo nome mas que tratam de diferentes parâmetros;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Versões novas da mesma função que recebem parâmetros adicionais;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mesmo nome de método para setar e obter o valor de uma propriedade;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bom, o que mais sua imaginação mandar =)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Static Polymorphism</title>
  <link>http://www.caloni.com.br/static-polymorphism/</link>
  <pubDate>2009-07-10</pubDate>
  
  <guid>http://www.caloni.com.br/static-polymorphism/</guid>
  <description>&lt;p&gt;To explain the polymorphism nothing is better than see how stuff used to be. If you were a twenty old C programmer in the past and created the following functions:&lt;/p&gt;
&lt;p&gt;Immediately the compiler would blame you about the following errors:&lt;/p&gt;
&lt;p&gt;This happens because in C the identifiers are unique into the scope. This is the reason why the following code is wrong also:&lt;/p&gt;
&lt;p&gt;Back to the 90&#39;s, this is also wrong in C++. Even for a logic issue: how the compiler can pick a variable if we&#39;re using the same name for both of them?&lt;/p&gt;
&lt;p&gt;Even though, there&#39;s a little trick to stop the ambiguity when we talk about functions: the parameters that they receives.&lt;/p&gt;
&lt;p&gt;This allowed in C++ the creation of static overload, that is exactly this: to call a function not just by its name, but also to match its signature, the number and the type of the received parameters. We call static because this is done just by the compiler, not creating any overhead during the execution.&lt;/p&gt;
&lt;p&gt;Among the most common uses some are as it follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Functions with the same name treating different parameters;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;New version of the same fuction with addictional parameters;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Same method name to set and get the value of a class property;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Well, whatever your imagination and needs demand =)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Strings</title>
  <link>http://www.caloni.com.br/strings/</link>
  <pubDate>2009-07-07</pubDate>
  
  <guid>http://www.caloni.com.br/strings/</guid>
  <description>&lt;p&gt;Como já vimos centenas e centenas de vezes, memória é apenas memória até que alguém diga que isso vale alguma coisa. Em seu estado latente é o que chamamos formalmente de dados. E dados são bytes armazenados na memória.&lt;/p&gt;
&lt;p&gt;No entanto, quando esses dados viram algo de útil em um determinado contexto, não necessariamente alterando-se seu conteúdo na memória, passamos a lidar com informação. Ou seja, é um dado com significado. E informação é a interpretação desses mesmos dados.&lt;/p&gt;
&lt;p&gt;A conclusão óbvia para isso, falando de strings, é: uma série de bytes enfileirados na memória pode ser uma string.&lt;/p&gt;
&lt;p&gt;Para tanto precisamos apenas de dados (os bytes enfileirados) e significado (uma tabela de símbolos que traduza esses bytes para caracteres e a definição de como a string se organiza).&lt;/p&gt;
&lt;p&gt;Por exemplo, uma série de bytes diferentes de zero com valores que representam índices de uma tabela de tradução de caracteres e que termina sua sequência em um byte com o valor zero nele é considerada uma string C, ou string terminada em nulo.&lt;/p&gt;
&lt;p&gt;Já uma mesma sequência de bytes no mesmo molde só que sem o byte final com o valor zero, mas com um byte inicial que tem como valor não um índice de caractere, mas o número de bytes subsequentes, isso é uma string Pascal, ou uma string com contador de tamanho.&lt;/p&gt;
&lt;p&gt;Agora note por que tanto uma string vazia em Pascal e em C possuem os mesmos dados, mas informação diferente.&lt;/p&gt;
&lt;p&gt;Outras strings que não necessariamente possuem terminador nulo: std::string, UNICODESTRING.aspx), strings no kernel.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Bugs Difíceis de Achar</title>
  <link>http://www.caloni.com.br/bugs-dificeis-de-achar/</link>
  <pubDate>2009-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/bugs-dificeis-de-achar/</guid>
  <description>&lt;p&gt;Saiu um artigo na Wired News sobre os piores bugs da história. Entre eles estão a explosão de um oleoduto soviético em plena guerra-fria (como se não bastasse chernobyl), o primeiro worm da Internet (que se aproveita de um buffer overflow da função gets) e o famoso erro de divisão em ponto flutuante do Pentium; um erro de cálculo de cerca de 0,006% que causou um prejuízo de 457 milhões de dólares para a Intel.&lt;/p&gt;
&lt;p&gt;Mas o que achei mais legal, apesar de não estar na lista, estava relacionado com o Mariner 1, primeira espaçonave de um programa da NASA para pesquisar Marte, Vênus e Mercúrio em voos automatizados. Mariner 1 não chegou a sair de órbita, pois houve uma falha na antena de comunicação entre módulos e um bug no programa do computador de bordo.&lt;/p&gt;
&lt;p&gt;Falava-se que o bug havia sido gerado ao trocar uma vírgula por um ponto em um loop escrito em FORTRAN. Apesar de não ter sido esse o causador da falha do computador da nave do projeto Mariner, ele existiu de fato em outro projeto da NASA, o Mercury. A linha fatal no caso era essa:&lt;/p&gt;
&lt;p&gt;É óbvio que a intenção do programador foi fazer um loop até o label 17 dez vezes, pois a instrução para isso é:&lt;/p&gt;
&lt;p&gt;Mas pela troca da vírgula pelo ponto, e como em FORTRAN os caracteres de espaço não são significativos, a linha com o bug não representa mais um loop, mas uma atribuição à uma variável chamada &amp;quot;DO17I&amp;quot;:&lt;/p&gt;
&lt;p&gt;Esse detalhe esdrúxulo de uma das linguagens mais famosas da época nos leva a crer que antigamente os programadores deveriam estar muito mais atentos durante a digitação de código do que os programadores de hoje em dia, com seus ambientes com verificação sintática embutida. Existe inclusive um texto humorístico de longa data comparando programadores de verdade e programadores de linguagens estruturadas como PASCAL recém-saídos da faculdade, carinhosamente citados no texto como &amp;quot;Quiche Eaters&amp;quot; (comedores de pastelão).&lt;/p&gt;
&lt;p&gt;O tipo de erro de falta de atenção do programa da NASA lembra uma das mais duras críticas às linguagem C e C++: é fácil escrever um código errado do ponto de vista lógico mas sintaticamente correto (compilável). Alguns exemplos famosos:&lt;/p&gt;
&lt;p&gt;Dessa coleção de problemas, o compilador nos brinda com dois warnings:&lt;/p&gt;
&lt;p&gt;Agora imagine o número de horas noturnas em frente ao micro que você não poderia ter economizado em sua vida se aumentasse o nível de warning e lêsse-os de vez em quando? =)&lt;/p&gt;
&lt;p&gt;Colaborando com a lista de bugs difíceis de achar do artigo ai vai código/piadinha:&lt;/p&gt;
&lt;p&gt;Esse não é pego pelos alertas dos compiladores (pelo menos não pelos que eu uso)... É um bom motivo para usar const no lugar de define em alguns casos, ou no mínimo cercar o define por parênteses &amp;quot;(&amp;quot; e &amp;quot;)&amp;quot;&lt;/p&gt;
&lt;p&gt;Outro bug muito comum entre iniciantes é o de templates aninhados, apesar de que compiladores mais novos lidam melhor com o bug e trazem mensagens de erro mais claras:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Programadores de verdade não usam Java</title>
  <link>http://www.caloni.com.br/programadores-de-verdade-nao-usam-java/</link>
  <pubDate>2009-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/programadores-de-verdade-nao-usam-java/</guid>
  <description>&lt;p&gt;Quando era um newbie (e um wanna-be) gostava de ler o &amp;quot;Real Programmers Don&#39;t Use Pascal&amp;quot;, um texto humorístico que mais me influenciou e encorajou a caminho da iluminação C/C++ do que o livro de K&amp;amp;R. A partir dele, supunha eu, ser um &amp;quot;programador de verdade&amp;quot; era ser tudo. Ser um Quiche Eater (Comedor de Torta) não era nada. Programadores de verdade é que resolvem os problemas de verdade! Quiche Eaters são os losers que estudam os conceitos acadêmicos da ciência da computação e nunca fazem um maldito programa que preste (conhece alguém assim?).&lt;/p&gt;
&lt;p&gt;Piadas à parte, para mim o humor do texto ainda pode ser aproveitado por aqueles que já se acham muito bons e acreditam não terem mais como crescer profissionalmente. Quando meu ego infla demais, ainda me lembro que enquanto programo com APIs de brincadeirinha e um sistema operacional que é uma piada tem gente projetando uma nave que vai sair da órbita do Sistema Solar!&lt;/p&gt;
&lt;p&gt;Por outro lado, muitas pessoas recém-saídas da faculdade de computação ainda acham programação uma matéria difícil. Esse texto nos lembra que difícil era a vida 20, 40, 70 anos atrás, quando engenheiros e programadores eram a mesma pessoa, e quando se você não soubesse o que estava fazendo colocaria projetos de milhões em risco.&lt;/p&gt;
&lt;p&gt;Por consequência, o programador de verdade vive no passado. E ele sempre se valoriza frente ao povão jovem, porque ele sabe resolver aquele problema de tela azul que mais ninguém sabe. E como eu costumo dizer, parafraseando uma figura ilustre da televisão brasileira, quem tem medo de abrir o Visual Studio e em vez disso fica projetando eternamente o software não vai muito longe: &amp;quot;quem sabe faz na hora!&amp;quot;.&lt;/p&gt;
&lt;p&gt;Aqui segue um breve resumo do texto original adaptado para os tempos atuais e com a minha visão preconceituosa de pensar sobre o assunto. Se quiser, use sua parte politicamente correta da mente e critique à vontade!&lt;/p&gt;
&lt;p&gt;Linguagens. Lembre-se: inventar que você precisa de mais linguagens/recursos para fazer seu trabalho é lembrar que você é incompetente o suficiente para inventar esse tipo de desculpinha. Você é daqueles que diz &amp;quot;cada problema tem sua ferramenta específica&amp;quot; ou algo do tipo. Ou seja, um programador politicamente correto e ineficiente. Não vê que tudo o que você precisa está na linguagem C. Se não estiver, então está no assembly. Se não estiver nem no C nem no assembly não vale a pena ser pensado a respeito.&lt;/p&gt;
&lt;p&gt;Programação Estruturada. É o primeiro e último paradigma a ser aplicado. Afinal de contas, Orientação a Objetos é mais uma desculpinha para não programar. São abstrações e mais abstrações para inventar que, uma vez que você é um peso morto que não consegue resolver um problema com funções e variáveis, precisa de classes, herança, templates e outras tranqueiras que vão transformar seu código simples e reto em uma cornucópia mágica que só vai impressionar os outros pela inutilidade e complexidade da solução!&lt;/p&gt;
&lt;p&gt;Estrutura de dados. Outro ótimo conceito para enganar a si mesmo. Hoje são muitos os que se escravizam nos leiautes SQL e classes estranhas de frameworks estranhos que fazem todo o trabalho. Todos sabemos que a única estrutura realmente útil de saber é o array. O resto são variantes do mesmo tema: filas e pilhas.&lt;/p&gt;
&lt;p&gt;Sistema operacional. Mac e Windows são brinquedinhos e Linux é um vídeo-game que dá mais trabalho de configurar do que de jogar. O programador de verdade usa algo como mainframes ou qualquer outro sistema operacional beta, que são bem esquisitos de mexer e que podem fazer um verdadeiro estrago nas mãos de quem não tiver lido TODO o manual. E saber todos os bugs conhecidos e importantes do kernel e sua localização de cor na hora de bootar é vital.&lt;/p&gt;
&lt;p&gt;Ferramentas. Se você depende de uma IDE que tem Code Completion e outros penduricalhos do tipo, ou depende de algum outro editor seu favorito com seus 17459 plugins instalados, então você não é um programador de verdade. um programador de verdade usa o que tiver à mão na hora que precisar, seja um notepad, um hexdump ou até mesmo alguns beeps. A ferramenta não é limite para quem sabe programar de verdade.&lt;/p&gt;
&lt;p&gt;Depuração. Vai dizer que precisa do código-fonte para depurar? Então você não faz a mínima ideia do que o programa faz. Apenas algumas olhadas na call stack e nos registradores podem fazer um programador de verdade solucionar um bug que os comedores de torta não conseguiriam depois de analisar aqueles gráficos UML com caixinhas dentro e casos de uso por meses a fio.&lt;/p&gt;
&lt;p&gt;O Trabalho de programadores de verdade com certeza não é fazer programinhas que acessam basezinhas de SQL com opção de consulta e cadastro. Nem são aqueles saitezinhos com PHP/Apache, scripts e mais scripts. Não, senhor. São programas que lidam com o Sistema Operacional de uma forma mais íntima (criptografia de HD, drivers de File System, serviços de comunicação crítica, etc), ou são programas que fazem algo de verdadeiramente útil (compiladores, o próprio sistema operacional). Ou tavez que mexam diretamente com hardware (microcontroladores complexos, robôs, naves, aparelhagem médica, etc).&lt;/p&gt;
&lt;p&gt;A Diversão de todo programador de verdade é conversar com os amigos (sobre programação), ler alguma coisa (sobre programação) e assistir filmes inteligentes (sobre programação ou pessoas que fizeram algum tipo de desafio intelectual &amp;quot;na marra&amp;quot;). Existe algo mais divertido que isso?&lt;/p&gt;
&lt;p&gt;E, por fim, em seu Habitat Natural, poderemos encontrar páginas de código assembly espalhadas em volta da mesa, um computador travado por uma depuração remota de kernel por cabo serial, algumas anotações em hexa em um pedaço de papel, algumas dezenas de páginas abertas no navegador sobre comportamento das funções BIOS em HDs SATA com mais de 500 GB trabalhando em RAID4, café, salgadinhos, manchas no carpete. Quando não há nada para fazer, o ambiente está arrumadíssimo e não se nota a presença de programadores de verdade à vista.&lt;/p&gt;
&lt;p&gt;E o Futuro do programador de verdade? Bom, a linguagem C pode até estar morrendo. Mas, e daí? Essa tal de C++ ainda suporta ponteiros. O resto das abstrações afeminadas como classes e herança podem ser totalmente ignoradas. O básico sempre existirá. Esqueça as versões com herança múltipla e o enigmático concepts. Seja homem!&lt;/p&gt;
&lt;p&gt;O fato é que, independente de quanto mais o mundo se tornar &amp;quot;gerenciado&amp;quot; por trás de frameworks e programadores que preferem &amp;quot;fazer projetos&amp;quot; atrás de seus pacotes de escritório e casos de uso, quando algum problema pipocar, algum bug tenebroso ameaçar a vida útil de um projeto, um programador de verdade estará lá para salvar o dia, pois só um programador de verdade sabe fazer o seu trabalho. E bem feito.&lt;/p&gt;
&lt;p&gt;PS: Na verdade, me lembrei. Eu peguei esse cacoete de falar &amp;quot;quem sabe faz na hora&amp;quot; do meu amigo Thiago. Ele também dizia &amp;quot;se vira nos 30!&amp;quot;. Bom, se eu citar todas as frases brilhantes que ele usava quando trabalhávamos juntos o texto vai ficar bem longo =)&lt;/p&gt;
&lt;p&gt;Se você gostou desse texto, talvez goste de eXtreme Go Horse!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como compilar em somente um passo</title>
  <link>http://www.caloni.com.br/como-compilar-em-somente-um-passo/</link>
  <pubDate>2009-05-25</pubDate>
  
  <guid>http://www.caloni.com.br/como-compilar-em-somente-um-passo/</guid>
  <description>&lt;p&gt;Uma das primeiras perguntas do teste do Joel é saber se você pode compilar todo o projeto em apenas um passo. Essa é uma questão essencial e um desafio para muitas equipes. Perdem-se horas sagradas para gerar um novo Release.&lt;/p&gt;
&lt;p&gt;Compilação automática geralmente está disponível nas ferramentas de desenvolvimento. Se você estiver usando o Visual Studio, por exemplo, é possível fazer isso com uma linha:&lt;/p&gt;
&lt;p&gt;Se não for exatamente o que você precisa, basta fazer uma pesquisa de quinze minutos e encontrar os parâmetros corretos. O objetivo é: eu rodo esse comando em cima do projeto inteiro em uma máquina zerada e ele simplesmente compila.&lt;/p&gt;
&lt;p&gt;É lógico que ter apenas um solution/workspace para guardar projetos médios e grandes é inviável. Demora para carregar no ambiente e possuem dezenas de dependências. Isso já foi tentado duas vezes nas duas empresas em que trabalhei e não funcionou. Talvez por isso seja necessário criar um script que rode o comando acima para todas as soluções do projeto, o que não muda muito o modus operandi da coisa:&lt;/p&gt;
&lt;p&gt;Note que meu script usa a estrutura padronizada dos diretórios de um projeto, onde cada tipo de componente tem sua pasta e solução.&lt;/p&gt;
&lt;p&gt;Aos poucos você pode ir colocando &amp;quot;frescurinhas&amp;quot; em seu build (executa Debug e Release, roda automatizado no servidor, faz testes unitários, incrementa o número da versão, ...), mas algumas premissas sempre se mantêm:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Deve ser possível compilar o projeto inteiro em um passo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Deve ser possível usar qualquer máquina de desenvolvimento para isso&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Regras simples de ser seguidas se você usar sempre a máxima do KISS.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Meu roteiro C&#43;&#43;</title>
  <link>http://www.caloni.com.br/meu-roteiro-c/</link>
  <pubDate>2009-05-20</pubDate>
  
  <guid>http://www.caloni.com.br/meu-roteiro-c/</guid>
  <description>&lt;p&gt;Como não consigo mais ter ideias para artigos, resolvi catalogar todas as coisas que já falei nesse blogue e, o mais importante, todas as coisas que ainda não falei nesse blogue (e espero um dia falar ou talvez nunca fale), começando por C++, que era o intuito original (só que não é mais, porque eu uso mais a Win32 API que a STL):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;História&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Conceitos&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linguagem&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Biblioteca&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dicas&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Espero que isso me ajude a continuar completando as lacunas do saite. Se não der certo, pelo menos já sei o que fiz.&lt;/p&gt;
&lt;p&gt;Sugestões?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>A sala da fila das threads</title>
  <link>http://www.caloni.com.br/a-sala-da-fila-das-threads/</link>
  <pubDate>2009-04-17</pubDate>
  
  <guid>http://www.caloni.com.br/a-sala-da-fila-das-threads/</guid>
  <description>&lt;p&gt;Quando falei sobre a fila das threads, e como cada thread espera pacientemente em uma fila até chegar sua vez de ser atendida no guichê das CPUs, também vimos como é fácil fazer caquinhas em um programa que roda paralelamente duas threads ou mais.&lt;/p&gt;
&lt;p&gt;Também falei que iríamos resolver esse problema, afinal de contas, temos que salvar todos aqueles programas que usam dezenas de threads trabalhando ao mesmo tempo para contar números de um até dez.&lt;/p&gt;
&lt;p&gt;A boa notícia é que o salvamento é mais simples do que parece: coloque todas as suas threads em uma sala trancada e deixe apenas uma chave. As threads terão que brigar para sair da sala e, depois que a vencedora sair, as outras terão que ficar esperando ela voltar.&lt;/p&gt;
&lt;p&gt;Confuso? Se estiver, ainda bem. Isso quer dizer que estamos novamente em um daqueles artigos com &amp;quot;pseudo-parábolas&amp;quot;, a maneira mais ilustrada de explicar as coisas.&lt;/p&gt;
&lt;p&gt;Os SOs modernos possuem inúmeras maneiras de controlar e monitorar o acesso a recursos do sistema. Neste breve artigo irei falar apenas de um: o critical section, ou, em tradução livre, &amp;quot;seção crítica&amp;quot;. O &amp;quot;seção&amp;quot; desse nome diz respeito a uma seção do programa, ou seja, um pedaço de código mesmo. Um pedaço de código crítico.&lt;/p&gt;
&lt;p&gt;Resumidamente, um critical section é um recurso que apenas uma thread por vez pode obter. Para que outra thread tenha acesso ao mesmo critical section, a primeira thread que o obteve deve soltá-lo. Enquanto ela não solta, as outras threads ficam paradas, esperando pela chave, na sala trancada.&lt;/p&gt;
&lt;p&gt;Do ponto de vista do programador, o critical secton é apenas uma estrutura que é usada na chamada de quatro funções básicas: para inicializar o recurso, para entrar na seção crítica.aspx), para sair da seção crítica.aspx) e para liberar o recurso.aspx) (quando aquele critical section não mais será usado).&lt;/p&gt;
&lt;p&gt;Falando assim, parece simples. Bom, na verdade é simples, mesmo. Tudo que você precisa para corrigir o programa do artigo anterior é criar um critical section e fazer com que as threads obtenham-no antes de mexer com o contador compartilhado.&lt;/p&gt;
&lt;p&gt;Para finalizar, algo para pensar: se uma thread só consegue um critical section depois que outra thread soltá-lo, o que acontece se essa outra thread estiver esperando por outro critical section que uma thread que aguarda estiver segurando?&lt;/p&gt;
&lt;p&gt;Acabamos de ilustrar um procedimento muito simples para cagar completamente no código e gerar um travamento que pode demorar de horas a semanas para ser detectado e resolvido. É o conhecido deadlock. Se você não entendeu ainda, imagine que, para voltar à sala das threads, a primeira thread que saiu precisa de duas chaves; só que ela só pegou a primeira, e a segunda está dentro da sala. Para pegar a segunda chave, ela precisa entrar na sala, só que a sala está trancada pelas duas chaves!&lt;/p&gt;
&lt;p&gt;Deadlocks são sempre indesejáveis, e é por isso que existem diversas técnicas para tentar evitá-los. A mais conhecida é sempre obter os critical sections na mesma ordem. Dessa forma a obtenção de recursos é hierarquizada, o que impede que dois CSs estejam no mesmo nível de obtenção, evitando que duas threads distintas os obtenham.&lt;/p&gt;
&lt;p&gt;Espero que tenha ficado claro nossa breve explanação de como podemos controlar programas multithreading. Espero, pois a próxima tarefa é entender outros conceitos mais abstratos e virtuais, como funções virtuais e classes abstratas.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>A fila das threads</title>
  <link>http://www.caloni.com.br/a-fila-das-threads/</link>
  <pubDate>2009-04-07</pubDate>
  
  <guid>http://www.caloni.com.br/a-fila-das-threads/</guid>
  <description>&lt;p&gt;Em um ambiente multithreading diversas threads disputam &amp;quot;a tapas&amp;quot; a atenção do processador (CPU). Certo? Podemos dizer que, em um ambiente com muito processamento a realizar, de certa forma é isso que acontece. São threads e mais threads rodando um pedacinho de código cada vez que passam pelo processador.&lt;/p&gt;
&lt;p&gt;Um ambiente complexo como um sistema operacional executando dezenas (às vezes centenas) de programas é repleto de pequenos detalhes que podem fazer o iniciante logo desanimar quando tentar depurar um programa com mais de uma thread. De fato, eu já percebi que muitos não vão saber nem como começar a pensar sobre o problema.&lt;/p&gt;
&lt;p&gt;Uma forma de visualizar o cenário multithread começa na fila das threads. Elas estão indo em direção ao guichê das CPUs onde vão conseguir tempo de processamento para rodar seu código. Depois que elas esgotam seu tempo elas se dirigem para o final da fila esperando por mais tempo para executar mais código.&lt;/p&gt;
&lt;p&gt;Para simplificar este cenário vamos imaginar duas threads iniciando com o mesmo código. Esse código incrementa um contador global até ele chegar a dez, quando a função retorna e as threads terminam.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int count = 0;

increment() {
  while( count &amp;lt; 10 ) {
    count++;
    print(tid, count);
  }
}

main() {
  thread t1(increment);
  thread t2(increment);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O tid no pseudo-código acima é sinônimo para Thread ID, o identificador único de uma thread, que costuma ser um número. Para simplificar vamos dar ao id os apelidos de t1 e t2. Esta é uma possível saída do código acima, dependendo de quantos processadores e cores possui a máquina:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t1 1
t1 2
t1 3
t1 4
t1 5
t1 6
t1 7
t1 8
t1 9
t1 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pelo jeito a primeira thread não deu chance para a outra executar. Isso acontece por causa do pequeno espaço de tempo que é necessário para realizar a tarefa de incrementar uma variável. É tão pequena a tarefa que nem foi suficiente para a primeira thread ficar sem tempo e a CPU mandar ela para o fim da fila. Por isso a segunda thread nunca chegou a incrementar o contador.&lt;/p&gt;
&lt;p&gt;Quando uma thread quer realizar algum processamento, ela precisa entrar na fila das threads ativas, que aguardam pela CPU que irá atendê-las. Nessa fila ela pega uma senha e aguarda a sua vez. Só que cada vez que uma thread é atendida ela ganha um tempo limitado de atendimento, que na arquitetura do sistema operacional é chamado de quantum ou time slice. Se o quantum de uma thread estoura, ou a thread não tem mais nada pra fazer, ela sai do guichê de atendimento e volta a ficar inativa, ou volta para o final da fila, aguardando por mais processamento.&lt;/p&gt;
&lt;p&gt;Uma thread pode opcionalmente ir para o final da fila por conta própria. Para isso, basta que ela chame uma função do sistema operacional pedindo para dormir. Por isso geralmente essa função é chamada de sleep na API do sistema operacional. Nessa função costuma haver um parâmetro de quanto tempo a thread deseja dormir. Se for maior que zero ela vai para a fila de threads dormindo até passar esse tempo, para depois se dirigir à fila de threads ativas, aguardar para ser processada. Se o tempo passado for exatamente zero ela vai direto para essa última fila, mas ficará sem executar do mesmo jeito, pois esta é a fila de quem está aguardando pela sua próxima fatia de tempo de processamento.&lt;/p&gt;
&lt;p&gt;Se chamarmos a função para dormir no código da thread antes de voltar a incrementar o contador é possível que a segunda thread tenha chance de executar.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;increment() {
  while( count &amp;lt; 10 ) {
    count++;
    print(tid, count);
    sleep();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora cada thread, depois de incrementar uma vez o contador, volta para o final da fila. Dessa forma vemos uma thread de cada vez incrementando o mesmo contador.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t1 1
t2 2
t1 2
t2 3
t1 4
t2 4
t2 6
t2 7
t1 5
t1 8
t2 8
t2 9
t2 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Peraí, o mesmo contador? Isso pode gerar problemas. Se duas threads tentarem incrementar o mesmo contador ao mesmo tempo, quem garante que elas não irão incrementar o mesmo valor? Bom, se você é bom observador já deve ter reparado que na execução acima ocorreu exatamente isso, com mais de uma thread incrementando o contador com o mesmo valor.&lt;/p&gt;
&lt;p&gt;Para forçar isso acontecer mais rápido e de maneira mais gritante podemos fazer a thread ir para o final da fila antes de incrementarmos e após pegarmos o valor atual do contador. Note que nesses testes a saída muda completamente dependendo de quantos processadores sua máquina tem. O resultado às vezes pode ser bem bizarro do que o visto nesse artigo. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;increment() {
  while( count &amp;lt; 10 ) {
    int c = count;
    sleep();
    c++;
    print(tid, c);
    count = c;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O código acima pode gerar a seguinte saída:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t1 1
t2 1
t1 2
t2 2
t1 3
t2 3
t1 4
t2 4
t1 5
t2 5
t2 6
t1 6
t2 7
t1 7
t1 8
t2 8
t2 9
t1 9
t2 10
t1 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Explicando mais uma vez com mais detalhes: quando uma thread guarda o valor do contador na variável local e volta para o final da fila, ela deixa de armazenar o contador atualizado para apenas &lt;strong&gt;depois&lt;/strong&gt; que todas as outras threads passarem na sua frente. Só que as outras threads também pegam o mesmo valor do contador, pois ele ainda não foi alterado. Quando chega a hora da segunda passada no guichê das CPUs, todas as threads incrementaram o mesmo valor do contador. Se houvesse apenas um processador em uma máquina o fluxo de execução do ponto de vista do processamento único para duas threads ficaria mais ou menos o seguinte (zzz é quando uma thread dorme):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t1 c = count (0)
t1 zzz
t2 c = count (0)
t2 zzz
t1 c++ (1)
t2 c++ (1)
t1 print c (1)
t2 print c (1)
t1 count = c (1)
t2 count = c (1)
t1 c = count (1)
t1 zzz
t2 c = count (1)
t2 zzz
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O exemplo acima forçou essa situação, mas é preciso lembrar que isso pode acontecer mesmo sem a thread dormir. É possível que o tempo da thread se esgote e ela pare de ser atendida justo na hora que iria salvar a variável c no contador global. Dessa forma, ela vai para o final da fila à força e, quando voltar a ser atendida, uma outra thread já terá lido o valor anterior para ela própria incrementar.&lt;/p&gt;
&lt;p&gt;O que gostaríamos que acontecesse para corrigir o problema é forçar a segunda thread a esperar antes que a primeira termine todo o processo de incrementar e salvar no contador global, o que resolveria o nosso problema (o wait no exemplo abaixo é uma thread aguardando e não fazendo nada):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t1 c = count (0)
t1 zzz
t2 wait
t1 c++ (1)
t2 wait
t1 print c (1)
t2 wait
t1 count = c (1)
t2 wait
t1 ready
t2 c = count (1)
t1 wait
t2 c++ (2)
t1 wait
t2 print c (2)
t1 wait
t2 count = c (2)
t2 ready
t1 c = count (2)
t2 wait
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esse wait do fluxo, ou seja, deixar a próxima thread aguardando a que chegou primeiro incrementar, pode ser obtido se utilizarmos um mecanismo de acesso exclusivo fornecido pelo sistema operacional. Uma outra história para contar, que chamarei de &amp;quot;A sala da fila das threads&amp;quot;.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Eu mesmo em meus testes não pude usar sleep passando zero como o tempo para dormir porque meu número de processadores não permite que eu faça esse experimento, já que sempre vão existir processadores dispostos a reprocessar a thread que acabou de ir para o final de sua fila. &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
</item>

     
        <item>
  <title>Depurando até o último segundo</title>
  <link>http://www.caloni.com.br/depurando-ate-o-ultimo-segundo/</link>
  <pubDate>2009-03-31</pubDate>
  
  <guid>http://www.caloni.com.br/depurando-ate-o-ultimo-segundo/</guid>
  <description>&lt;p&gt;Como depurar um programa que dá pau logo no final do desligamento de uma máquina?&lt;/p&gt;
&lt;p&gt;No cenário em que isso se passa não existem usuários logados no momento, o que significa a impossibilidade de rodar qualquer programa em uma sessão prévia e mantê-lo no ar após o logoff. A não ser que se trate de um serviço.&lt;/p&gt;
&lt;p&gt;O nosso programa é justamente um serviço, e por isso ele continua rodando até o final, ou bem perto dele. A primeira ideia que vem à mente é instalar o Msvcmon - depurador remoto do Visual Studio - como um serviço, como aliás já foi demonstrado neste blogue.&lt;/p&gt;
&lt;p&gt;Essa é uma boa ideia, de fato. Contudo, não podemos esquecer que a ordem de descarregamento dos serviços pode não favorecer o nosso depurador remoto e ele ir embora antes que consigamos &amp;quot;atachar&amp;quot; nosso VC no programa faltoso. Além do mais, a própria rede, que é disponibilizada com a ajuda de serviços, pode não estar no ar, mesmo que o Msvcmon esteja.&lt;/p&gt;
&lt;p&gt;Tudo bem, vamos dizer que você é um expert em configuração de dependências de serviços e conseguiu fazer com que a rede, o Msvcmon e o programa faltoso sejam os últimos serviços - com exceção dos drivers - a serem descarregados. Bravo!&lt;/p&gt;
&lt;p&gt;Contudo, isso não vai adiantar de muita coisa se for necessário parar a execução por um breve momento e analisar a pilha por, digamos,  cinco segundos. Esse é o tempo que o sistema - que continua rodando - precisa para desligar a máquina.&lt;/p&gt;
&lt;p&gt;Agora o problema é outro: não há tempo para análise durante a depuração, pois o sistema continua rodando. Nesse caso, teremos que ser mais radicais e parar o próprio sistema para que possamos depurar calmamente o problema. Isso implica em termos que utilizar um depurador de kernel (WinDbg), pois só ele tem poderes de congelar o sistema inteiro.&lt;/p&gt;
&lt;p&gt;Mas, ainda assim, precisamos de um depurador de user para fazer análises mais profundas ou, pelo menos, mais simples, com a ajuda de símbolos e tudo mais. Nesse caso é necessário usar um depurador de user que redireciona o controle para o depurador de kernel. A transição user mode &amp;gt;&amp;gt; kernel mode pode ser feita com apenas algumas configurações antes do reboot.&lt;/p&gt;
&lt;p&gt;E, após toda essa bagunça, podemos depurar, no conforto de uma VM, o bendito programa matador.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Os problemas mais cabeludos</title>
  <link>http://www.caloni.com.br/os-problemas-mais-cabeludos/</link>
  <pubDate>2009-03-05</pubDate>
  
  <guid>http://www.caloni.com.br/os-problemas-mais-cabeludos/</guid>
  <description>&lt;p&gt;Quase todos os problemas do Universo são resolvidos depois de um belo dia de depuração, código comentado, descomentado, recomentado e umas muitas e boas doses de café. Alguns outros problemas mais cabeludos precisam de uma boa noitada na frente do computador, e mais café. E, finalmente, existem aqueles que nem tomando o estoque inteiro de café a coisa anda.&lt;/p&gt;
&lt;p&gt;Um exemplo: um hook global do Windows que quando ativado em determinados eventos envia mensagens para uma única janela que cataloga informações sobre diversas janelas e processos no sistema. Esse procedimento é uma subfunção do programa principal, que já possui seus próprios problemas e idiossincrasias. Em momentos aparentemente aleatórios algumas funcionalidades não parecem estar de acordo com o que se espera.&lt;/p&gt;
&lt;p&gt;Para esse tipo de situação que envolve 1. o sistema como um todo, 2. processos de terceiros e 3. comportamento obscuro por parte do resto do código, vale a pena seguir um checklist mais rigoroso, colocar seu bonezinho de CSI e partir para desmembrar o funcionamento do código problemático:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Como o programa deveria funcionar?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O que exatamente não funciona?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O que pode ser? O que NÃO pode ser?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Existe uma maneira de provar?&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Cada uma dessas perguntas deve ser respondida com a maior sinceridade e disciplina, custe o que custar.&lt;/p&gt;
&lt;p&gt;Esse deve ser o primeiro e mais importante indício do que pode estar acontecendo. Sem entender o funcionamento do programa, dificilmente conseguiremos passar para os passos seguintes. Na maioria das vezes, sem saber onde a coisa começa e termina, o problema vai ficar rindo da nossa cara até entendermos de fato que aquele if não merece estar naquela linha.&lt;/p&gt;
&lt;p&gt;Para facilitar esse entendimento, nada como elaborar uma pequena explicação para si mesmo no estilo How Stuff Works. Não precisa exagerar e fazer uma tese a respeito e criar vídeos explicativos. Só precisa descrever o fluxo com os detalhes aparentemente importantes para a resolução do problema.&lt;/p&gt;
&lt;p&gt;Continuando nosso exemplo:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;O programa inicia e cria uma _thread _específica.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Essa _thread _específica cria uma janela que monitora e carrega uma DLL.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Essa DLL é chamada pela _thread _e instala um _hook _global no sistema.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O _hook _recebe eventos de todos os processos que possuem janelas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Quando eventos específicos são disparados, o processo atual envia uma mensagem para a janela que monitora.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A janela que monitora monta uma tabela estatística dos eventos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;De tempos em tempos, essa tabela é escrita em disco em um arquivo encriptado.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A lista acima é longa o suficiente para podermos elaborar perguntas interessantes e pequena o suficiente para podermos ter em mente o seu funcionamento como um todo, o que é vital para o sucesso das observações durante a depuração.&lt;/p&gt;
&lt;p&gt;Note que a pergunta nos direciona para o sintoma do problema, não o problema em si, que provavelmente ainda não é conhecido. E nunca é demais lembrar que podemos estar lidando com uma série de problemas trabalhando em conjunto para nos deixar acordados por dias a fio.&lt;/p&gt;
&lt;p&gt;Exemplos de respostas possíveis: a tabela estatística perde a lógica em determinado momento, o hook algumas vezes não funciona, aleatoriamente um dos processos &amp;quot;hookados&amp;quot; capota.&lt;/p&gt;
&lt;p&gt;Essa pergunta deve ser respondida com uma análise das respostas das duas primeiras perguntas. Batendo os sintomas do problema com o seu funcionamento macro, uma ou mais cabeças aos poucos irão elaborando teorias a respeito de onde pode estar falhando.&lt;/p&gt;
&lt;p&gt;Ex: talvez por algum motivo a DLL esteja sendo descarregada (que lugares podem ser estes?), alguém está desinstalando o hook (quais as partes do código que fazem isso?), alguma ferramenta de análise está atrapalhando nossos resultados (o que acontece se rodarmos sem o DebugView?).&lt;/p&gt;
&lt;p&gt;Ao mesmo tempo que os sintomas do problema acusam que algo está errado, existem os sintomas de que alguma coisa, afinal de contas, está funcionando nessa porcaria de código. Através dos sintomas positivos é possível chegar a algumas conclusões sobre o que está funcionando bem.&lt;/p&gt;
&lt;p&gt;Ex: o arquivo de log está sendo atualizado, a thread da janela que monitora recebe mensagens continuamente, algumas informações da tabela não estão corrompidas.&lt;/p&gt;
&lt;p&gt;Esse é o pulo do gato, a parte que diferencia meninos e meninas de homens e mulheres. Se conseguirmos, através de código de teste e/ou observação, aos poucos provar nossas conclusões a respeito do problema e conseguir elaborar, passo a passo, uma &amp;quot;maquete mental&amp;quot; de todo o código funcional, será possível aos poucos ir descartando teorias e reforçando nossa confiança sobre o caminho que estamos trilhando.&lt;/p&gt;
&lt;p&gt;Às vezes uma pequena mudança no código pode provar inúmeras coisas, como inocentar algumas partes e proteger-se de acusações infundadas feitas anteriormente. É uma briga contra o próprio ego, especialmente se o código foi feito por você mesmo.&lt;/p&gt;
&lt;p&gt;Ex: Desabilitei o tratamento dos eventos e o hook continua funcionando.&lt;/p&gt;
&lt;p&gt;O importante é nunca parar de pensar sobre o problema, evitando ao máximo agir mecanicamente e por impulso, a não ser que exista um bom motivo para isso. Às vezes apenas pensando de novo sobre o mesmo assunto comprova-se algo. É uma fase muito rica e próspera na resolução de problemas e deve ser aproveitada.&lt;/p&gt;
&lt;p&gt;Ex: Quando estava habilitado o tratamento de eventos, o hook parava de funcionar em menos de cinco minutos. Agora, rodando os testes por três horas, o hook continua ativo.&lt;/p&gt;
&lt;p&gt;Ex: Desabilitei um dos eventos que possui comunicação remota com o servidor. O hook continuou funcionando, apesar do resto dos eventos.&lt;/p&gt;
&lt;p&gt;Por fim, com uma pequena dose de sorte e muitas doses de força de vontade (e café), o problema cansa de se esconder e mostra a cara.&lt;/p&gt;
&lt;p&gt;Ex: Quando há falha na comunicação com o servidor com o erro 666 uma exceção é lançada, e quando capturada tenta gerar um logue, só que esse logue está mal formatado e causa com que a thread inteira vá para o espaço.&lt;/p&gt;
&lt;p&gt;Essa é a hora em que todos se esquecem do esforço que custou chegar até ali e não documentam nada do que foi feito. Desse jeito perde-se todo esse tempo não apenas uma vez, mas todas as vezes que alguém diferente do time mexer com a mesma situação. Por isso deve-se, com a cuca fresca, escrever algumas dicas de como reproduzir o problema e elaborar um pequeno relatório ou algo que o valha do que foi feito, como foi feito e por que funcionou. Mais uma vez, não exagere. Deixe as apresentações sofisticadas de PowerPoint para os outros departamentos da empresa.&lt;/p&gt;
&lt;p&gt;Como deve ter parecido, esse tipo de abordagem leva tempo e não é fácil de ser levado adiante sem disciplina e muita persistência. Por esse motivo é que só deve ser usado naqueles problemas em que já se perdeu uma imensidade de tempo e esperança, uma situação irremediável e que ainda não conseguiu vislumbrar o dia em que finalmente poderemos dedicar nossas vidas profissionais para uma outra tarefa mais interessante.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>WinDbg.info</title>
  <link>http://www.caloni.com.br/windbginfo/</link>
  <pubDate>2009-02-10</pubDate>
  
  <guid>http://www.caloni.com.br/windbginfo/</guid>
  <description>&lt;p&gt;Para os perdidos e desatualizados como eu, notei hoje que Robert Kuster possui um saite onde mantém diversas informações sobre o WinDbg; uma espécie de continuação de sua famosa transparência &amp;quot;WinDbg. From A to Z&amp;quot;.&lt;/p&gt;
&lt;p&gt;Como eu descobri? Bom, ele me mandou um e-mail perguntando se poderia deixar sua tradução para inglês do meu artigo como Foreword para os slides =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>As funções-polegar</title>
  <link>http://www.caloni.com.br/as-funcoes-polegar/</link>
  <pubDate>2009-01-30</pubDate>
  
  <guid>http://www.caloni.com.br/as-funcoes-polegar/</guid>
  <description>&lt;p&gt;Como já havia dito, não há nada mais prazeroso do que ensinar a alguém os velhos truques da profissão e relembrar o porquê de tantas coisas que guardamos na cabeça sobre programação. Hoje tive a oportunidade de explicar como funcionam as funções-polegar.&lt;/p&gt;
&lt;p&gt;A função-polegar, uma categoria de função muito peculiar em várias APIs, possui um comportamento padrão de retorno de erros. Entre as diversas funções-polegar que conheço e uso, eis algumas que lembro de cor:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;read, write (C)&lt;/li&gt;
&lt;li&gt;connect.aspx), send.aspx) (Sockets)&lt;/li&gt;
&lt;li&gt;ReadFile.aspx), WriteFile.aspx), CreateProcess (Win32)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;O que todas essas funções têm em comum? Bom, ignorando seu funcionamento interno ou seu objetivo, todas elas possuem um valor de retorno no estilo sim ou não, ou seja, deu certo ou não deu. Nessas funções o código de erro, o motivo da função não ter dado certo, não é retornado diretamente. É o que chamo de esquema do polegar pra cima ou polegar pra baixo. O retorno da função especifica o ângulo giratório do dedão:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ssize_t pread, ssize_t write. Retorno de -1 significa que deu algo errado.&lt;/li&gt;
&lt;li&gt;int connect, int send. Se retornar SOCKET_ERROR&lt;/li&gt;
&lt;li&gt;BOOL ReadFile, BOOL WriteFile, BOOL CreateProcess. TRUE sucesso, FALSE erro.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Por exemplo, chamamos a função ReadFile para ler um arquivo. Ela retorna FALSE. Isso significa que não deu certo nossa leitura. Por quê? Ora, não sabemos ainda. Apenas sabemos que o polegar está virado para baixo!&lt;/p&gt;
&lt;p&gt;Em funções nessas condições, geralmente existe uma segunda função (ou variável) que retorna o último erro que ocorreu na API, ou seja, o erro que fez com que última função chamada retornasse que algo não deu certo. Nas funções de exemplo, são usados três métodos distintos, pois estamos falando de três APIs distintas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Variável errno&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Função WSAGetLastError.aspx)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Função GetLastError.aspx)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;São esses métodos que realmente retornam o porquê da função ter dado errado. E é elas que devemos chamar, eu disse devemos chamar, sempre que a função der errado. Até porque, já que o polegar está virado para baixo, temos que fazer alguma coisa para que nosso programa não morra.&lt;/p&gt;
&lt;p&gt;Como bem observado pelo Fernando no comentário abaixo, nem todas as funções-polegar possuem uma função para obter a causa do erro. Vide SysAllocString, ou mesmo malloc. Nesse caso, não há muito o que determinar a não ser que não foi possível alocar o recurso pedido pelo sistema. Paciência.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Básico do básico: assembly</title>
  <link>http://www.caloni.com.br/basico-do-basico-assembly/</link>
  <pubDate>2009-01-26</pubDate>
  
  <guid>http://www.caloni.com.br/basico-do-basico-assembly/</guid>
  <description>&lt;p&gt;É lógico que não poderia faltar no cinto de utilidades de todo bom programador C conhecimentos básicos da linguagem assembly, sua mãe espiritual. São tantos conceitos em comum que, uma vez aprendido seu funcionamento, fica difícil não pensar no código-assembly gerado pelo compilador C. E é nesse ponto que as coisas começam a ficar mais claras.&lt;/p&gt;
&lt;p&gt;Antes de tudo, é importantíssimo lembrar que o foco aqui é apenas a arquitetura 8086, um dos marcos na invenção de computadores de massa, mas que existem trocentros outros modelos de processadores e computadores funcionando mundo afora. Não deixe sua mente fechar para os outros tipos de modelos.&lt;/p&gt;
&lt;p&gt;A CPU trabalha em conjunto com a memória RAM. Só que o acesso à essa memória, apesar de rápida, não é comparável à velocidade em que as coisas ocorrem dentro da própria CPU. Esse é apenas um dos motivos para a existência de um conjunto bem menor de memória que vive nas entranhas do processador, bem ao lado dele. São os chamados registradores.&lt;/p&gt;
&lt;p&gt;Os registradores são memória do tipo ultra-rápida que funciona no mesmo ritmo do processador. A maioria das instruções executadas pela CPU faz referência a pelo menos um registrador. E por um motivo muito simples: é o modelo de entrada-e-saída funcionando!&lt;/p&gt;
&lt;p&gt;No modelo de entrada-e-saída, ultrassimplificado por mim nesse artigo, o processador executa microinstruções muito básicas, que juntas fazem alguma coisa de útil, por exemplo, somar dois números:&lt;/p&gt;
&lt;p&gt;x = y + z;&lt;/p&gt;
&lt;p&gt;A operação acima é realizada através de microinstruções bem sucintas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leia memória y para registrador 1&lt;/li&gt;
&lt;li&gt;Leia memória z para registrador 2&lt;/li&gt;
&lt;li&gt;Some valor de registrador 1 e 2 e coloque resultado no registrador 1&lt;/li&gt;
&lt;li&gt;Carregue memória x com valor do registrador 1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;É lógico que o sistema não se baseia apenas em movimentações simples de memória. Existem algumas abstrações que estão incrustadas no funcionamento da arquitetura. Uma das mais importantes é o conceito de pilha, vital tanto em arquitetura, quanto assembly, quanto linguagem C e muitas outras linguagens, também.&lt;/p&gt;
&lt;p&gt;Pilha é uma forma de armazenar memória em blocos empilhados um-a-um. Esses blocos são empilhados na ordem a, b, c e desempilhados na ordem c, b, a. Ou seja, quem foi empilhado por último será o primeiro a ser desempilhado. A analogia com uma pilha de pratos é óbvia e simples de imaginar.&lt;/p&gt;
&lt;p&gt;Para isso funcionar em termos de memória computacional, o programa reserva um espaço de memória com começo e fim que irá guardar os blocos empilhados. Além de ter começo e fim é necessário ter um marcador de onde estamos para empilhar o próximo item ou desempilhar o último.&lt;/p&gt;
&lt;p&gt;Se você pensou rápido, a resposta é sim, existem registradores para guardar a posição na pilha em que estamos. Aliás, quando mudamos de função, o valor desses registradores é salvo na própria pilha, já que voltaremos à mesma posição após a chamada.&lt;/p&gt;
&lt;p&gt;Antigamente eram muito usados os chamados registradores de segmento. Eles representavam o endereçamento da arquitetura de 16 bits do 8086. Cada endereço de memória estava localizado em um segmento, que era uma abstração para multiplicar a memória e assim alcançar a quantidade de RAM que estava disponível no sistema. Com a chegada do 32 bits, isso não é mais usado diretamente pelos programadores, que não têm que se preocupar mais tanto com esses detalhes internos da memória.&lt;/p&gt;
&lt;p&gt;Resumidamente, temos no PC os seguintes tipos de registradores e seu uso geral na programação C:&lt;/p&gt;
&lt;p&gt;Registradores de uso geral. EAX, EBX, ECX, EDX.
Registradores de código e dados. ESP, EBP, EIP.&lt;/p&gt;
&lt;p&gt;Você os verá em 90% das ocasiões em que desassemblar seu código C, pois a rotina do código não muda muito: soma, divide, multiplica, muda endereço do código (saltos), compara valores (flags).&lt;/p&gt;
&lt;p&gt;Ah, sim, as flags! Elas são importantíssimas para o funcionamento sadio de nossos programas. Sem as flags, não teríamos coisas maravilhosas e fundamentais na programação moderna, tais como o salto condicional.&lt;/p&gt;
&lt;p&gt;As flags são bits que mudam de acordo com algumas instruções, principalmente as de comparação (vide cmp). Após a execução de comparação, o estado de determinadas flags junto da próxima instrução (que deverá ser um salto condicional) irá dizer para onde o programa irá pular sua execução. É assim que temos o if:&lt;/p&gt;
&lt;p&gt;O código acima seria representado em assembly mais ou menos como abaixo:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;carrega valor de x no registrador 1 2. compara registrador 1 com 10 3. pula para 6 se for diferente 4. chama XEhIgualA105. pula para 76. chama XEhDiferenteDe107. próxima instrução&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Uma curiosidade interessante é a flag de comparação. Se o resultado da comparação disser que os dois elementos são iguais, a flag fica igual a zero, o que significa que os comparandos são idênticos. Se você reparar, a mesma semântica é utilizada na conhecida função strcmp, que retorna zero caso duas strings sejam idênticas. Isso faz sentido em ambos os lados, já que o resultado computacional geralmente deixa um rastro de diferença que é usado como retorno. Se esse rastro não existir, quer dizer que o que foi comparado é idêntico.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mov&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cmp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jmp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;jne, jle, jnz, etc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push e pop&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;call e ret&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push ebp mov epb, esp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;push eax mov ecx, dword ptr[variavel] push 10 call funcao&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cmp something jne | jne | jae | ...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Desmonte programas, chamadas API. Veja que funções internas elas chamam para realizar determinada tarefa. Tente mudar o comportamento do programa para provar que suas observações sobre o funcionamento estavam corretas.&lt;/p&gt;
&lt;p&gt;PS.: Ia me esquecendo. Enquanto estava escrevendo este artigo, um conjunto bem mais detalhado de artigos estava sendo publicado pelo DQ. Recomendo veementemente sua leitura.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>HouaissParaBabylon versão 1.1</title>
  <link>http://www.caloni.com.br/houaissparababylon-versao-11/</link>
  <pubDate>2008-12-30</pubDate>
  
  <guid>http://www.caloni.com.br/houaissparababylon-versao-11/</guid>
  <description>&lt;p&gt;Saindo mais um do forno.&lt;/p&gt;
&lt;p&gt;Essa nova versão do conversor do dicionário Houaiss para Babylon corrige o problema de não encontrar o Houaiss 1.0. O problema ocorria porque o conversor se baseava na localização do desinstalador para encontrar o dicionário. Na primeira versão do dicionário o desinstalador fica na pasta c:\Windows, onde obviamente não estava o dicionário.&lt;/p&gt;
&lt;p&gt;Nessa nova versão, além de procurar o caminho do dicionário no registro (desinstalador) e antes de pedir para o usuário o caminho correto é tentado o caminho padrão de instalação, %programfiles%\Houaiss. Se mesmo assim o dicionário não existir continuamos perguntando para o usuário, que tem a opção de dizer onde está instalado o dicionário no disco rígido ou apontar diretamente para o CD de instalação.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Básico do básico: binário</title>
  <link>http://www.caloni.com.br/basico-do-basico-binario/</link>
  <pubDate>2008-12-18</pubDate>
  
  <guid>http://www.caloni.com.br/basico-do-basico-binario/</guid>
  <description>&lt;p&gt;Apesar do tema binário, o assunto de hoje no fundo remete-nos a todo e qualquer tipo de representação. É o faz-de-conta um pouco mais intenso, vindo das profundezas da matemática e dominado com maestria pela nossa mente e sua capacidade lógica de abstrair.&lt;/p&gt;
&lt;p&gt;Como todos sabemos, nós, seres humanos, somos dotados de dez dedos: cinco em cada mão. Isso influenciou fortemente nosso sistema de contagem de coisas, e, como consequência, nossa forma de representar números.&lt;/p&gt;
&lt;p&gt;No entanto, números serão sempre números, independente de seres humanos e de dedos. Outros seres inteligentes de outras galáxias poderiam representar os mesmo números, sendo um conceito lógico independente de raça, usando qualquer outra forma e quantidade de símbolos. Por falar em símbolos, nós temos dez, a saber:&lt;/p&gt;
&lt;p&gt;Outros seres poderiam usar, sei lá, dois:&lt;/p&gt;
&lt;p&gt;É lógico que esse &#39;0&#39; e esse &#39;1&#39; podem ser representados por outros sinais, como pedra e pau, cara e coroa, tico e teco, e por aí vai a valsa.&lt;/p&gt;
&lt;p&gt;O importante é que seriam na quantidade de dois.&lt;/p&gt;
&lt;p&gt;O nosso sistema de representação ainda possui algumas características singulares, como o valor posicional. Os mesmos dez símbolos, quando colocados em posições diversas, assumem valores diversos.&lt;/p&gt;
&lt;p&gt;Dessa forma, quando esgotamos todos os símbolos e chegamos a nove, para irmos ao dez começamos a repetir os símbolos, mas em outra posição:&lt;/p&gt;
&lt;p&gt;A nova posição do símbolo &#39;1&#39; possui o próximo valor após o nove. O zero, como sabemos, apenas marca posições e não possui valor algum. Se valesse algo, seria somado, como no número 111, que é uma soma de três valores distintos posicionados de acordo:&lt;/p&gt;
&lt;p&gt;Pronto! Eis toda a base de nosso sistema numérico. O resto é historinha pra boi dormir. Com isso é possível até mudarmos de base, ou seja, o número de símbolos usados, conforme nos convier.&lt;/p&gt;
&lt;p&gt;Para nos comunicarmos com a raça alienígena que usa dois símbolos poderíamos contar seguindo o mesmo princípio:&lt;/p&gt;
&lt;p&gt;O valor do número, como sabemos, depende de sua posição. Mas, calma lá! O 111 logo acima não é idêntico ao 111 que vimos anteriormente, pois mudamos a base! Agora só temos dois símbolos para representar números, quando antes tínhamos dez.&lt;/p&gt;
&lt;p&gt;O &amp;quot;segredo&amp;quot; do valor posicional também está na base, pois o zero, apesar de não possuir valor, marca a quantidade de símbolos que foram utilizados para se esgotar uma posição qualquer. Dessa forma, enquanto o nosso conhecido 10 (dez) vale todos os símbolos não-nulos (nove) mais um (nove + um = dez), o outro 10 (um-zero) da raça alienígena de dois dedos também vale todos os símbolos deles nã-nulos (um) mais um (um + um = dois).&lt;/p&gt;
&lt;p&gt;Como não faz parte do tema, não vou explicar como o sistema binário foi importante para a definição de uma arquitetura simples o suficiente para ser expandida a níveis nunca antes imaginados de processamento e comprimida em espaços que muitos diriam não caber qualquer coisa de útil que fosse. No entanto, apesar de brilhante, o binário no dia-a-dia do programador gera alguns problemas. Principalmente se o programador escreve seus cálculos de ponteiros em binário.&lt;/p&gt;
&lt;p&gt;Para entender isso, basta lembrar que, atualmente, a quantidade de memória RAM que é contada e, portanto, valor dos ponteiros que apontam para ela, é muito grande até para nosso sistema decimal, que possui, relembrando, dez símbolos. O que dirá, então, um sistema que possui meros dois símbolos para representar, digamos, três gigabytes:&lt;/p&gt;
&lt;p&gt;São tantos zeros que aqueles bugs de leak de memória, famosos por levar tempo para ser corrigidos, seriam mais famosos ainda, pois o tempo gasto para se entender alguma coisa no meio de ponteiros dessa magnitude seria astronômico!&lt;/p&gt;
&lt;p&gt;E, claro, ainda poderia ficar pior, se fosse depurado um desses novíssimos sistemas de 64 bits:&lt;/p&gt;
&lt;p&gt;Eu sei que não vou conseguir explicar tudo sobre bases numéricas em apenas um miniartigo. Porém, vamos dar uma rápida olhada no famoso hexadecimal, que foi o que nos salvou de lidar com os numerozinhos acima.&lt;/p&gt;
&lt;p&gt;Nesse sistema, a representação dos número ocupa menos espaço ainda que o sistema decimal, pois usa dezesseis símbolos distintos, usando as letras de A a F após os já conhecidos símbolos decimais:&lt;/p&gt;
&lt;p&gt;A grande vantagem de contar as coisas em dezesseis é que sua representação será sempre um múltiplo de dois, o que facilita a conversão para o sistema binário: em um único número hexadecimal cabem quatro números binários, ou quatro bits.&lt;/p&gt;
&lt;p&gt;Tabelinha básica, fácil de achar em qualquer lugar da internet, mas colocada aqui apenas para relembrar a relação entre as três bases.&lt;/p&gt;
&lt;p&gt;Bom, acho que é isso. Já ultrapassei o limite do teórico, porque na verdade o que importa aqui, para captar de fato o binário dos fatos, é praticar:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Conte em binário quando não estiver fazendo nada. É simples e ajuda a fixar. Dessa forma: um, um-zero, um-um, um-zero-zero, um-um-zero, um-um-um, ...&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Decore a relação entre os números hexadecimal e binário. Você pode até esquecer isso depois, mas o esforço para decorar será útil para fixar. E nunca se sabe quando você terá que reaver a MBR de um cliente seu.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Estude a lógica por trás da tabela ASCII e seus valores binários. Irá descobrir que existem relações muito óbvias entre letras, números (maíusculos e minúsculos) e sinais. Tente decorar.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Básico do básico: tipos</title>
  <link>http://www.caloni.com.br/basico-do-basico-tipos/</link>
  <pubDate>2008-12-12</pubDate>
  
  <guid>http://www.caloni.com.br/basico-do-basico-tipos/</guid>
  <description>&lt;p&gt;Um tipo nada mais é que do que uma forma (ô) de bolo, que molda a memória como acharmos melhor moldá-la. Bom, para isso fazer sentido é necessário explicar memória, que é um conceito mais básico ainda.&lt;/p&gt;
&lt;p&gt;A memória é qualquer lugar onde eu possa guardar alguma coisa. No artigo anterior era um punhado de gavetas. Mas poderiam muito bem ser caixas de presente. Ou um caderno. Ou até uma placa de memória RAM. O que sua criatividade quiser.&lt;/p&gt;
&lt;p&gt;O importante no conceito de memória, computacionalmente falando, é saber que ela pode guardar qualquer tipo de informação, mas ela não sabe o que você está guardando. E eis que surge o segredo do tipo: ele conta para você, e seu programa, o que de fato está guardado na memória.&lt;/p&gt;
&lt;p&gt;Vamos exemplificar.&lt;/p&gt;
&lt;p&gt;Computadores trabalham muito bem com números. A própria memória só guarda valores numéricos. Porém, se é dessa forma, como conseguimos abrir o Bloco de Notas e digitar algum texto?&lt;/p&gt;
&lt;p&gt;Para entender essa &amp;quot;mágica&amp;quot; é necessário vir à tona o conceito de representação, um tema que ainda pode dar muito pano pra manga quando estudarmos base numérica. Por enquanto, basta saber que uma representação é um faz-de-conta em que todos concordam com o que for dito. Por exemplo: Faz de conta que a letra &#39;A&#39; é o número 65. Dessa forma, sempre que for visto o número 65, de agora em diante, será vista a letra &#39;A&#39; no lugar.&lt;/p&gt;
&lt;p&gt;Existem alguns faz-de-conta que são muito difundidos entre e humanidade informática. Um deles é chamado tabela ASCII (se pronuncia &amp;quot;ásqui&amp;quot;). É uma forma de todos conseguirem entender os textos de todo mundo. Abaixo podemos ver a representação de todas as letras maiúsculas na codificação ASCII:&lt;/p&gt;
&lt;p&gt;Agora, imagine que você digitou o seguinte texto no bloco de notas:&lt;/p&gt;
&lt;p&gt;Como esse texto é guardado na memória de um computador, se ele só entende números?&lt;/p&gt;
&lt;p&gt;Através da nossa já conhecida tabela ASCII! Na verdade, números são armazenados na memória, mas por representarem as letras &#39;C&#39;, &#39;A&#39;, &#39;S&#39; e &#39;A&#39;, são traduzidos de volta para o formato texto pelo Bloco de Notas, que conhece o que guardou na memória.&lt;/p&gt;
&lt;p&gt;A técnica de representação pode guardar qualquer coisa na memória como números que serão traduzidos por algum programa que consiga abrir aqueles dados. Dessa forma podemos não só armazenar texto, como imagens, vídeos, páginas web e até mesmo os próprios programas que os abrem!&lt;/p&gt;
&lt;p&gt;Na programação do dia-a-dia, as coisas funcionam da mesma forma. As tão faladas variáveis reservam um espaço de memória para guardar alguma coisa, mas só sabemos o que essa alguma coisa é através do tipo da variável:&lt;/p&gt;
&lt;p&gt;Esses elementos, na memória, são um bando de número que, sem os tipos, não possuem significado algum, como podemos ver na depuração do programa abaixo:&lt;/p&gt;
&lt;p&gt;Note que os números não estão aqui representados em decimal, onde se esperaria 35 e 42, pois a representação formal da memória geralmente está no formato hexadecimal, transformando esses números em 0x23 e 0x2a, respectivamente. Para entender essa diferença cabe estudar um pouco sobre base numérica, outro tema básico do programador sólido.&lt;/p&gt;
&lt;p&gt;Nada é bem aprendido se não for apreendido. Algumas tarefas programáticas que podem fixar o conceito de tipo estão listadas abaixo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Usar printf especificando tipos diversos (%d, %s, %f, %p, ...) para a mesma variável, inclusive correndo o risco de gerar algumas exceções.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Usar scanf especificando diversas variáveis para o mesmo tipo (%d, %s, %f, %p, ...), vendo o resultado da leitura da entrada do usuário na memória.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tentar copiar o conteúdo de uma variável para outra variável de tipo diferente. Sempre analise a memória para ver o resultado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ordenação de extremidades): O problema Little Endian e Big Endian.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UNICODE: Por um conjunto de letras universal.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Base numérica: O que são binário e hexadecimal e como eles afetam nossa vida.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Básico do básico: ponteiros</title>
  <link>http://www.caloni.com.br/basico-do-basico-ponteiros/</link>
  <pubDate>2008-12-06</pubDate>
  
  <guid>http://www.caloni.com.br/basico-do-basico-ponteiros/</guid>
  <description>&lt;p&gt;Nessas últimas semanas tenho gastado meu tempo junto da mais nova pupila da SCUA, aspirante a programadora em C e Install Shield Script. Minha tarefa? Explicar tudo, desde o mais simples, como variáveis, até as coisas não tão triviais, como símbolos de depuração.&lt;/p&gt;
&lt;p&gt;Posso afirmar que tem sido muito compensador ativar algumas partes do meu cérebro que acreditava nem mais existirem. Rever velhos conceitos, apesar de manjados, nos dá a oportunidade de lembrar que as coisas mais complexas que construímos no dia-a-dia se baseiam em um punhado de preceitos básicos que é essencial ter na cabeça. E nunca esquecê-los.&lt;/p&gt;
&lt;p&gt;Meu amigo costuma chamar esses preceitos básicos de fundamentais. Isso por um bom motivo lógico e semântico: tudo que aprendemos de básico sobre qualquer área de conhecimento serve-nos de base para suportar as outras coisas que virão a ser entendidas na mesma área de conhecimento. Ou seja: é a parte mais importante a ser aprendida. Sem ela, a base, não nos é possível construir nada sólido e duradouro. Sem ela, toda a estrutura construída a posteriori se rompe e vai abaixo.&lt;/p&gt;
&lt;p&gt;Foi partindo desse princípio que me preocupei com esmero para explicar as peças mais fundamentais do conhecimento em jogo, formadoras da cabeça de um programador para sempre, seja em C como em qualquer outra linguagem. E como nada é bem explicado sem formar imagens na cabeça, aproveitei para desenhar alguns esboços no papel. O resultado desses esboços é esse artigo.&lt;/p&gt;
&lt;p&gt;Não tenho a presunção de conseguir explicar 100% para alguém iniciante o que são ponteiros em C, como usá-los e como se proteger deles. Definitivamente ponteiro não é um conceito simples, apesar de básico, e posso dizer sem vergonha que demorei cerca de seis meses no meu aprendizado em C pra entender completamente tudo relacionado com ponteiros. Demorou, quebrei a cabeça, mas depois nunca mais esqueci.&lt;/p&gt;
&lt;p&gt;De acordo com o meu amigo Rafael, a melhor definição que usei até hoje para explicar esse conceito envolvia um armário repleto de gavetas, todas numeradas em ordem de posição (1, 2, 3...). Cada gaveta podia guardar qualquer coisa, inclusive o número de outra gaveta em um pedaço de papel. Com isso, eu poderia guardar em uma gaveta aleatória o que eu precisava guardar e escrever o &amp;quot;endereço&amp;quot; dessa gaveta em um pedaço de papel e guardá-lo na gaveta número 1, por exemplo. Com isso poderia até esquecer a posição onde está o que eu guardei, pois bastava abrir a gaveta número 1 e ler a posição em que estava essa gaveta.&lt;/p&gt;
&lt;p&gt;Deve ter ficado óbvio, mas se não ficou: o armário é a memória RAM, as gavetas são váriáveis e as gavetas onde guardamos pedaços de papel são ponteiros, que não deixam de ser variáveis, e apontam para outras gavetas que são... adivinha? Outras variáveis!&lt;/p&gt;
&lt;p&gt;Outros conceitos que costumo utilizar é relacionar a memória RAM com a memória do programa e contar a memória como se contam carneirinhos. Dessa forma fica fácil pelo menos entender dois conceitos fundamentais na arte dos ponteiros: memória e endereço.&lt;/p&gt;
&lt;p&gt;O segundo passo, acredito eu, é entender como a memória é dimensionada através do programa, e como o tipo molda a representação dos bits e bytes através das ligações de silício, mas isso fica pra mais tarde. Temos que programar, e é isso que vai de fato fazer a diferença no aprendizado de uma linguagem como C. Nada como uma boa mistura de teoria e prática para gerar um concreto armado que irá suportar um Empire State de conhecimento.&lt;/p&gt;
&lt;p&gt;Por isso, segue uma lista de tarefas interessantes para exercitar o conceito de ponteiros:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Criar funções que modificam números passados como parâmetro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Criar funções que modificam texto passado como parâmetro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Alocar e desalocar memória dinamicamente.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tarefas mais específicas da minha área e que uso o tempo todo:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Escrever e ler texto em arquivos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Escrever e ler no registro do Windows.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Obter o endereço de uma função do Windows dinamicamente. E chamá-la.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Este vídeo é o mais didático do universo sobre como funcionam ponteiros em C. Veja e mostre pros seus filhos:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/embed/mnXkiAKbUPg&#34;&gt;https://www.youtube.com/embed/mnXkiAKbUPg&lt;/a&gt;&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>HouaissParaBabylon versão beta</title>
  <link>http://www.caloni.com.br/houaissparababylon-versao-beta/</link>
  <pubDate>2008-11-15</pubDate>
  
  <guid>http://www.caloni.com.br/houaissparababylon-versao-beta/</guid>
  <description>&lt;p&gt;Depois de muitos fins-de-semana divididos em horas picadinhas de programação de lazer, está disponível em vosso saite a primeira versão para usuários do conversor do dicionário Houaiss para o aplicativo Babylon.&lt;/p&gt;
&lt;p&gt;Foi uma longa jornada, sim, mas espero que valha a pena para quem esperou. Também espero poder receber inúmeras respostas com dúvidas, sugestões e até mesmo mais problemas que vierem a acontecer.&lt;/p&gt;
&lt;p&gt;Segue um pequeno roteiro do funcionamento do programa, que é bem simples, aliás. Para que tudo dê certo, no entanto, é necessário que o computador onde será feita a conversão possua os três programas abaixo instalados e funcionamento corretamente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dicionário Houaiss. Testado na versão 2, deve ser instalado com opção de cópia dos arquivos no disco rígido.&lt;/li&gt;
&lt;li&gt;Babylon. Testado nas versões 6 e 7. Pode ser registrado ou não.&lt;/li&gt;
&lt;li&gt;Babylon Builder. O construtor dos dicionários Babylon. Apesar de ser possível construir dicionários personalizados para o Babylon, é necessário que se use esse aplicativo conversor. O HouaissParaBabylon o usa, e por isso precisa que ele esteja instalado corretamente.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tudo isso verificado, basta então clicar no botão de Iniciar Conversão, sentar e esperar. A primeira fase envolve três passos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Desencriptação do dicionário original. Isso é feito baseando-se em nossa análise de engenharia reversa.&lt;/li&gt;
&lt;li&gt;Montagem do projeto de dicionário Babylon. Para isso existe um processo de interpretação do formato Houaiss, agora desencriptado, e sucessivas traduções para um projeto que o Babylon Builder irá entender.&lt;/li&gt;
&lt;li&gt;Construção do dicionário Babylon. Essa parte é feita pelo Babylon Builder. Por ser o maior dicionário de português da atualidade, esse processo pode demorar bastante, e com certeza irá se tornar o maior dicionário já instalado na sua lista de dicionários do Babylon.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Na segunda fase, após toda essa movimentação de HD, existe apenas uma coisa a fazer: instalar o dicionário no Babylon.&lt;/p&gt;
&lt;p&gt;Quem faz isso é o próprio Babylon, se devidamente instalado. Se tudo deu certo, o HouaissParaBabylon sai de fininho e deixa o usuário com o progresso da instalação do dicionário Houaiss-Babylon.&lt;/p&gt;
&lt;p&gt;Se não for encontrado o dicionário Houaiss devidamente instalado no disco rígido, será exibida uma mensagem de erro pedindo que a instalação seja feita dessa maneira. Se, contudo, não for possível localizar a instalação do dicionário, será pedido ao usuário que diga onde ela se encontra, ou aponte para a pasta &amp;quot;Houaiss&amp;quot; em seu CD de instalação, uma dica suficiente para que a operação seja bem-sucedida.&lt;/p&gt;
&lt;p&gt;Outros erros comuns, como o Babylon Builder não instalado, serão obviamente avisados ao usuário. Erros mais raros terão um tratamento mais genérico. No entanto, nem por isso ele está livre de solução. Ao sair de uma conversão mal-sucedida, o usuário tem a opção de exportar o log de operações que foram realizadas durante a malfadada operação. Dessa forma, ele próprio conseguirá diagnosticar o problema ou, em casos mais sérios, me enviar o resultado de suas tentativas.&lt;/p&gt;
&lt;p&gt;E é isso. Para uma versão inicial, talvez esteja razoável. Quem confirmará serão os ansiosos usuário que, espero sinceramente, consigam seus objetivos há tempos aguardados.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como funciona o PsExec</title>
  <link>http://www.caloni.com.br/como-funciona-o-psexec/</link>
  <pubDate>2008-10-29</pubDate>
  
  <guid>http://www.caloni.com.br/como-funciona-o-psexec/</guid>
  <description>&lt;p&gt;Semana passada precisei reproduzir o comportamento da ferramenta PsExec em um projeto, o que me fez sentir alguma nostalgia dos tempos em que eu fazia engenharia reversa todo dia. Este breve relato (espero) reproduz os passos que segui para descobrir o que esse programa tão útil quanto perigoso faz.&lt;/p&gt;
&lt;p&gt;Sabe-se que o PsExec consegue executar um programa remotamente, ou seja, de uma máquina para outra, outra essa que chamaremos de máquina-alvo. O programa a ser executado geralmente deve estar disponível na própria máquina-alvo (condição ideal). Além da simples execução, para aplicativos console ele permite ainda a interação como se estivéssemos executando o programa remoto em nossa própria máquina local. Ele consegue isso redirecionando sua entrada e saída, o que o torna, como nos descreve o próprio autor, um &amp;quot;telnet light&amp;quot;:&lt;/p&gt;
&lt;p&gt;Além desse comportamento já muito útil ainda existe um bônus que se trata de especificar um executável local que será copiado remotamente para a máquina-alvo e executado. Esse é o comportamento que espero imitar:&lt;/p&gt;
&lt;p&gt;No teste acima o myprogram.exe é somente o cmd.exe renomeado. Um teste básico =)&lt;/p&gt;
&lt;p&gt;Já fizemos isso logo acima. Se trata apenas de observar o programa funcionando. Ao mesmo tempo em que entendemos seu modus operandi coletamos pistas sobre suas entranhas. No caso do PsExec, que faz coisas além-mar, como redirecionar os pipes de entrada/saída de um programa console, iremos checar a existência de algum serviço novo na máquina-alvo e arquivos novos que foram copiados, além de opcionalmente dar uma olhada no registro. Ferramentas da própria SysInternals como Process Explorer e Process Monitor também são úteis nessa análise inicial.&lt;/p&gt;
&lt;p&gt;Como podemos ver, um serviço com o nome de PsExec foi criado na máquina-alvo. Se procurarmos saber o caminho do arquivo que corresponde a esse serviço, tanto pelo Process Explorer ou o Service Manager, descobriremos que se trata de um arquivo no diretório do windows chamado psexecsvc.exe.&lt;/p&gt;
&lt;p&gt;Se o arquivo existe nessa pasta, então é óbvio que alguém o copiou. Resta saber como.&lt;/p&gt;
&lt;p&gt;Nessa segunda fase, podemos refazer o comportamento esperado inúmeras vezes, coletando dados e pensando a partir dos dados obtidos. Para esse caso,  como quase todos que analiso, vou usar o nosso amigo WinDbg. Para isso, como tenho sempre minhas ferramentas disponíveis no ambiente onde trabalho, basta digitar &amp;quot;windbg&amp;quot; antes do comando anterior e dar uma olhada em algumas APIs-chave, como a criação/abertura de arquivos e a criação de serviços. Note que é importante fazer isso em um escopo limitado para não perdermos horas de análise. Descobrir coisas como, por exemplo, que as ações do PsExec só começam a ser executadas após a digitação da senha do usuário, pode ajudar, pois daí só começo minha análise a partir desse ponto.&lt;/p&gt;
&lt;p&gt;Uma rápida busca no Google nos informa que o pipe querendo ser aberto pertence à lista de pipes que estão sempre disponíveis nas máquinas para responder às requisições do sistema. São importantes para a comunicação entre processos (IRP, Inter Process Communication). No entanto, quem usa esse pipe é o sistema, e ele foi chamado, como pudemos ver, pela função WNetAddConnection2W.aspx).&lt;/p&gt;
&lt;p&gt;Se analisarmos mais a fundo a pilha de chamadas conseguiremos dar um olhada nos parâmetros passados. Para isso existe a opção de mostrar os argumentos passados para as funções ao exibir a pilha:&lt;/p&gt;
&lt;p&gt;Ele tenta abrir uma conexão com a máquina-alvo em seu compartilhamento de IPC, que como já vimos serve para comunicação entre processos, até entre máquinas distintas. Dessa forma, descobrimos um dos pontos importantes no funcionamento do PsExec: ele usa o nome e senha fornecidos para abrir uma comunicação remota no compartilhamento IPC$.&lt;/p&gt;
&lt;p&gt;Depois sugem várias paradas ao CreateFile, de maneira que a melhor forma de acompanhar isso é colocando um &amp;quot;dumpezinho&amp;quot; de memória na sua parada:&lt;/p&gt;
&lt;p&gt;Muito bem! Chegamos a mais um ponto importante de nossa análise: o psexecsvc.exe é copiado através do compartilhamento ADMIN$ remotamente (diretório c:\windows). Esse compartilhamento se torna acessível, uma vez que uma conexão autenticada já foi aberta. Se listarmos as conexões existentes, veremos o compartilhamento IPC$ aberto:&lt;/p&gt;
&lt;p&gt;Também podemos notar que, enquanto estamos parados depurando o processo psexec.exe, temos acesso ao compartilhamento admin$:&lt;/p&gt;
&lt;p&gt;A análise desses fatos demonstra como é importante fazer as coisas, pelo menos na fase &amp;quot;iniciante&amp;quot;,  bem lentamente, e entender a mudança de estado durante o processo. Nem sempre isso é possível, é verdade, ainda mais quando estamos falando de análise de kernel. Mas, quando as condições permitem, vale a pena pensar antes de fazer.&lt;/p&gt;
&lt;p&gt;Voltando à analise: temos direitos remotos nessa máquina. Dessa forma, fica fácil criar um serviço.aspx) remotamente, que é o que faz o nosso amigo PsExec:&lt;/p&gt;
&lt;p&gt;Pronto. Isso era tudo que precisava para conseguir reproduzir seu comportamento. Agora posso fazer isso programando ou até manualmente:&lt;/p&gt;
&lt;p&gt;O resto do comportamento, como o redirecionamento de entrada e saída e execução do processo na conta especificada, embora muito interessante, não me interessa de imediato. Quem sabe interesse a você, e não tenhamos uma continuação dessa análise em um outro blogue de &amp;quot;desmontagem&amp;quot; por aí =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>A alça dentro do fio gerou um bloqueio da morte</title>
  <link>http://www.caloni.com.br/a-alca-dentro-do-fio-gerou-um-bloqueio-da-morte/</link>
  <pubDate>2008-10-21</pubDate>
  
  <guid>http://www.caloni.com.br/a-alca-dentro-do-fio-gerou-um-bloqueio-da-morte/</guid>
  <description>&lt;p&gt;Estava folheando um livro fenomenal que meu amigo havia pedido emprestado para ler quando me deparei com algumas traduções (o livro estava em português) no mínimo curiosas.&lt;/p&gt;
&lt;p&gt;Se trata do primeiro Windows Internals publicado após o lançamento da primeira versão do Windows NT, uma plataforma escrita (quase) inteiramente do zero para suplantar as versões 9x, que herdaram do DOS algumas partes indesejáveis em sistemas operacionais modernos.&lt;/p&gt;
&lt;p&gt;Sabe-se lá por que, essa edição foi traduzida. É interessante notar que naquela época foi dado um tratamento especial a alguns termos e conceitos já comuns no dia-a-dia do programador americano, apesar de quase nenhum desses termos ter se mantido em sua versão original. Os exemplos mais gritantes são as threads (fios ou linhas), os dead locks (bloqueios da morte) e handles (alças).&lt;/p&gt;
&lt;p&gt;Apesar de não ter nada contra traduzir termos do inglês para português (e vice-versa), algumas coisas incomodam em tradução de livros técnicos.&lt;/p&gt;
&lt;p&gt;Com essa informação, que pode ser usada apenas nos primeiros usos da palavra, agradaria gregos e troianos. Abaixo um exemplo.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;os ponteiros em C (pointers) são um recurso rico e necessário para a escrita de programas de baixo/médio nível&amp;quot;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Por exemplo, ler um dado capítulo:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;... é muito importante inicializar seus ponteiros antes de usá-los.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;E, depois de se acostumar com o termo, ler em outro capítulo:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;... sabe-se que a pior desgraça para um programador C são os famigerados apontadores selvagens.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Um exemplo notável é o famoso livro de algoritmos em C da O&#39;Reilly, que mesmo na nova edição com uma errata de 49 itens foi possível detectar mais erros. O exemplo abaixo consta no item 46 da edição de 2000 (Editora Ciência Moderna):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (opos &amp;gt; 0)
{
    if ( (temp = (unsigned char *)
        realloc(orig, opos + 1)) == NULL)
    {
        bitree_destroy(tree);
        free(tree);
        free(original); /* original??? */
        return -1;
    }

    orig = temp;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obs.: importante notar que no original não consta esse erro da variável original. Entendeu? Entendeu?&lt;/p&gt;
&lt;p&gt;Isso é pior do que não colocar a versão em inglês, pois dá a impressão que não existe significado a ser explicado. Por exemplo, ver antes do capítulo sobre threads:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;... quando um fio espera o outro e vice-versa, acontece o terrível bug da trava da morte.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Para quem não descobriu o que foi escrito no original, se trata de um deadlock, cujo termo inclusive é usado no seu original na Wikipédia em português.&lt;/p&gt;
&lt;p&gt;Esses exemplos, salvo o exemplo do livro de algoritmos, foram criados para ilustrar os tipos de erros mais comuns em traduções de livros técnicos, e não estão relacionados com qualquer livro em específico. Então o que era inicialmente para ajudar as pessoas que estão iniciando alguns conceitos acaba por prejudicar ainda mais o aprendizado, gerando aquele tipo de confusão que só com ajuda extra (internet, professor, colega) pode ser resolvida.&lt;/p&gt;
&lt;p&gt;Assim como no vocabulário comum corrente, em que existem palavras dificilmente adaptáveis ou traduzíveis em um termo comum, como shopping e show, no meio técnico desabrocham as mais variadas expressões estrangeirísticas. Algumas são muito difíceis de encontrar seu primo lusófono, como link e login. Outros, no entanto, exageram um pouco as coisas, a ponto de conjugarmos um verbo em inglês usando nosso sistema gramatical (se você &amp;quot;stopar&amp;quot; o &amp;quot;debugador&amp;quot; vai &amp;quot;crashear&amp;quot; todo o sistema, porque esse software tá &amp;quot;bugado&amp;quot;!).&lt;/p&gt;
&lt;p&gt;O fato é que não há escapatória para quem trabalha nessa área, e no fundo isso é uma coisa boa, pois é da leitura técnica em inglês que podemos estender o nosso conhecimento além das barreiras do ponto com ponto br e encontrar conteúdo extremamente interessante (e inédito em nossa língua) para aprender. Se não estivéssemos abarrotados de estrangeirismos talvez fosse um pouco mais difícil fazer o switch entre essas duas linguagens. Entendeu? Switch? Entendeu?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como usar WTL com o ATL do DDK</title>
  <link>http://www.caloni.com.br/como-usar-wtl-com-o-atl-do-ddk/</link>
  <pubDate>2008-10-15</pubDate>
  
  <guid>http://www.caloni.com.br/como-usar-wtl-com-o-atl-do-ddk/</guid>
  <description>&lt;p&gt;No entanto, num belo dia, qual não foi minha surpresa ao notar umas pastinhas chamadas atl21, atl30 e atl71 dentro da distribuição do WDK (o finado DDK, renomeado sabe-se-lá-por-quê)? Pelo visto, tem alguém arrastando coisa errada pra onde não devia nos instaladores de Seattle. Esses estagiários!&lt;/p&gt;
&lt;p&gt;O fato é que eles fizeram isso, e agora é possível ter o WTL mais novo compilado com o WDK. E nem é tão difícil assim.&lt;/p&gt;
&lt;p&gt;A primeira coisa a fazer é obter o tal doWDK. Para variar um pouco, agora existe um processo de registro antes de obter acesso ao download, mais ou menos nos termos da Borland para baixar o Builder / Turbo / Developer Studio.&lt;/p&gt;
&lt;p&gt;Aliás, para os que baixaram esses produtos gratuitos da Borland versão C++ e não funcionou em algumas máquinas, como foi o meu caso, está disponível para baixar uma versão mais nova; dessa vez não vi nenhum problema na compilação e depuração. Ainda.&lt;/p&gt;
&lt;p&gt;Após instalado, em qualquer lugar da sua escolha, configure no seu Visual Studio Express o caminho de onde se encontra a pasta atl71 (ou a 30, ou a 21). Aproveite também para colocar a pasta do WTL e o diretório de LIBs:&lt;/p&gt;
&lt;p&gt;Isso vai fazer com que pelo menos os exemplos que vêem com o WTL compilem.&lt;/p&gt;
&lt;p&gt;No entanto, você verá o seguinte erro durante a compilação dos recursos:&lt;/p&gt;
&lt;p&gt;Para resolver esse problema, remova a inclusão do arquivo de manifesto no arquivo RC:&lt;/p&gt;
&lt;p&gt;Depois dessa alteração, deve ainda existir o seguinte erro de linquedição:&lt;/p&gt;
&lt;p&gt;Esse problema ocorre porque as funções de alocação e desalocação de memória da ATL estão em outra LIB que os exemplos da WTL desconhecem. Para resolver, basta incluir essa nova dependência:&lt;/p&gt;
&lt;p&gt;E pronto! Agora temos todo o poder das 500 milhões de classes da ATL aliadas à ilimitada flexibilidade das classes de janelas da WTL.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Explicando a sopa de letrinhas da programação C/C++ para Windows: WTL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WTL for MFC Programmers&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Windows Jobs com Completion Port</title>
  <link>http://www.caloni.com.br/windows-jobs-com-completion-port/</link>
  <pubDate>2008-09-23</pubDate>
  
  <guid>http://www.caloni.com.br/windows-jobs-com-completion-port/</guid>
  <description>&lt;p&gt;Ou &amp;quot;Como esperar o término de todos os processos-filho criados a partir de um conjunto de processos&amp;quot;.&lt;/p&gt;
&lt;p&gt;Dessa vez confesso que esperava um pouco mais de documentação do MSDN, ou pelo menos um sistema de referências cruzadas eficiente. Outro dia demorei cerca de duas horas para conseguir criar um job.aspx), anexar o processo desejado e, a pior parte, esperar que todos os processos (o principal e seus filhos e netos) terminassem.&lt;/p&gt;
&lt;p&gt;Além da pouca documentação.aspx), parece que não são muitas as pessoas que fazem isso e publicam na web, ou eu não sei procurar direito.&lt;/p&gt;
&lt;p&gt;Mas, pra início de conversa, o que é um job mesmo?&lt;/p&gt;
&lt;p&gt;Um job é um objeto &amp;quot;novo&amp;quot; no kernel do Windows 2000 em diante, e se prontifica a suprir a carência que havia anteriormente de controle sobre o que os processos podem fazer e por quanto tempo.&lt;/p&gt;
&lt;p&gt;A abstração mais coerente que eu consigo tirar de um job é como um trabalho a ser executada por um ou mais processos. O objeto job controla a criação, o término e as exceções que ocorrem dentro dele mesmo.&lt;/p&gt;
&lt;p&gt;Entre as funções mais úteis de um job estão limitar o tempo de execução do conjunto de processos, o número de handles/arquivos/outros objetos abertos, limite de memória RAM ocupada e a possibilidade de terminar todos os processos de uma só vez.&lt;/p&gt;
&lt;p&gt;Para informações básicas de como criar um job e anexar processos recomendo o ótimo artigo de Jeffrey Richter.&lt;/p&gt;
&lt;p&gt;No final desse artigo ele chega a citar o controle mais refinado dos processos através de uma completion port.aspx), que permitirá receber eventos que ocorrem dentro de um job durante sua vida útil. Apesar de citar, não há código de exemplo que faça isso.&lt;/p&gt;
&lt;p&gt;Bom, agora há:&lt;/p&gt;
&lt;p&gt;O exemplo acima cria um processo baseado em uma linha de comando e espera pelo término do processo criado e de todos os subprocessos criados a partir do primeiro processo. Note que mesmo que o primeiro processo termine, a Completion Port só receberá o evento que todos os processos acabaram depois que o último subprocesso terminar.&lt;/p&gt;
&lt;p&gt;Dessa forma, ao compilarmos o código:&lt;/p&gt;
&lt;p&gt;E rodarmos mais um prompt de comando através de nosso programa (o texto em azul significa nossa nova janela de prompt):&lt;/p&gt;
&lt;p&gt;Microsoft Windows XP [versão 5.1.2600] (C) Copyright 1985-2001 Microsoft Corp. C:\Tests\CreateJob&amp;gt;notepad C:\Tests\CreateJob&amp;gt;exit&lt;/p&gt;
&lt;p&gt;Mesmo ao fecharmos o prompt criado, o programa só será finalizado ao fecharmos o Bloco de Notas iniciado pelo segundo prompt.&lt;/p&gt;
&lt;p&gt;Além desse evento, que era o que eu estava procurando, esse método permite obter outros eventos bem interessantes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JOB_OBJECT_MSG_NEW_PROCESS. Um novo processo foi criado dentro do job.&lt;/li&gt;
&lt;li&gt;JOB_OBJECT_MSG_EXIT_PROCESS. Um processo existente dentro do job foi terminado.&lt;/li&gt;
&lt;li&gt;JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT. O limite de memória de um processo já foi alcançado.&lt;/li&gt;
&lt;li&gt;JOB_OBJECT_MSG_END_OF_PROCESS_TIME. O limite de tempo de processamento de um processo já foi alcançado.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Enfim, jobs não terminam por aí. Dê mais uma olhada no MSDN e veja se encontra mais alguma utilidade interessante para o nosso amigo job. Eu encontrei e fiquei feliz.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Reúna seus comandos mais usados no WinDbg com .cmdtree</title>
  <link>http://www.caloni.com.br/reuna-seus-comandos-mais-usados-no-windbg-com-cmdtree/</link>
  <pubDate>2008-09-19</pubDate>
  
  <guid>http://www.caloni.com.br/reuna-seus-comandos-mais-usados-no-windbg-com-cmdtree/</guid>
  <description>&lt;p&gt;Tudo começou com o artigo de Roberto Farah sobre o comando &amp;quot;escondido&amp;quot; do WinDbg .cmdtree. Logo depois meus outros colegas do fã-clube do WinDbg Volker von Einem e Dmitry Vostokov comentaram sobre a imensa utilidade desse comando.&lt;/p&gt;
&lt;p&gt;E não é pra menos. É de longe o melhor comando não-documentado do ano. Tão bom que sou obrigado a comentar em português sobre ele, apesar dos três artigos já citados.&lt;/p&gt;
&lt;p&gt;E eu estava justamente falando sobre essa mania dos programadores sempre acharem soluções para tarefas repetitivas e monótonas que o computador possa fazer sozinho.O comando .cmdtree é uma dessas soluções, pois possibilita ao depurador profissional juntar em uma só guia o conjunto de comandos mais usados por ele no dia-a-dia, por mais bizarros e com mais parâmetros que eles sejam, já que é possível representá-los por um alias (apelido):&lt;/p&gt;
&lt;p&gt;O resultado:&lt;/p&gt;
&lt;p&gt;E podemos usar essa janela no nosso WinDbg, cada vez mais bonitinho e cada vez mais WYSIWYG:&lt;/p&gt;
&lt;p&gt;Realmente não há segredos em seu uso. Esse artigo foi apenas um patrocínio do clube do WinDbg.&lt;/p&gt;
&lt;p&gt;PS: Interessantemente o suficiente, durante minha navegação em busca das referências encontrei mais dois artigos de duas figurinhas carimbadas no mundo de debugging: John Robbins e a Tess. Pois é, se o mundo de informática já é pequeno, imagine o mundo de WinDbg =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Retorno do PathIsDirectory</title>
  <link>http://www.caloni.com.br/retorno-do-pathisdirectory/</link>
  <pubDate>2008-09-10</pubDate>
  
  <guid>http://www.caloni.com.br/retorno-do-pathisdirectory/</guid>
  <description>&lt;p&gt;Estava eu outro dia programando aquele código esperto &amp;quot;para ontem&amp;quot; quando me deparei com uma situação no mínimo inusitada. Ao testar se um caminho recebido era de fato um diretório.aspx) me foi retornado pela API um valor diferente de TRUE. E diferente de FALSE!&lt;/p&gt;
&lt;p&gt;De acordo com a documentação, o retorno deveria ser TRUE caso o caminho enviado à função fosse de fato um diretório. Caso contrário, o retorno deveria ser FALSE.&lt;/p&gt;
&lt;p&gt;Note que existem apenas dois valores possíveis para essa função. Porém, o valor retornado não é 1, o equivalente ao define TRUE, mas sim 0x10 (16 em hexadecimal). O simples exemplo abaixo deve conseguir reproduzir a situação (Windows XP Service Pack 3):&lt;/p&gt;
&lt;p&gt;Isso quer dizer apenas que o código abaixo vai funcionar,&lt;/p&gt;
&lt;p&gt;o código abaixo vai funcionar&lt;/p&gt;
&lt;p&gt;e o código abaixo não vai funcionar:&lt;/p&gt;
&lt;p&gt;E, pior, o código abaixo também não vai funcionar!&lt;/p&gt;
&lt;p&gt;Pesquisando um pouco descobri uma boa discussão sobre o tema, e inclusive que outras pessoas descobriram o interessante detalhe que para pastas normais o retorno é 0x10, mas para compartilhamentos o retorno é 0x1.&lt;/p&gt;
&lt;p&gt;O problema ocorre por causa da maneira que a função determina se o caminho é um diretório ou não. Uma simples vistoria sobre a função nos revela o detalhe crucial:&lt;/p&gt;
&lt;p&gt;Ou seja, para pastas locais a função simplesmente usa a conhecidíssima GetFileAttributes.aspx), que retorna o flag 0x10 setado caso se trate de uma pasta, de acordo com a documentação:&lt;/p&gt;
&lt;p&gt;&amp;quot;The attributes can be one or more of the following values.&lt;/p&gt;
&lt;p&gt;Aqui termina nossa dúvida sobre o pequenino bug na documentação. E isso nos lembra também que é sempre bom comparar as coisas da melhor maneira possível. E essa melhor maneira em se tratando de ifs é supor apenas dois valores binário: ou é zero ou é não-zero.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>ProcessLeaker</title>
  <link>http://www.caloni.com.br/processleaker/</link>
  <pubDate>2008-08-21</pubDate>
  
  <guid>http://www.caloni.com.br/processleaker/</guid>
  <description>&lt;p&gt;O artigo anterior mostrava como detectar o leak de um processo gerado pela retenção e não-liberação de handles para o Windows Explorer. O problema fora causado por um serviço malcriado. No entanto, a título de demonstração, criei um pequeno programinha sem-vergonha para fazer as coisas parecerem difíceis. No entanto o programa é bem fácil:&lt;/p&gt;
&lt;p&gt;Para usá-lo, basta abrir um Gerenciador de Tarefas com opção de exibir o PID dos processos.&lt;/p&gt;
&lt;p&gt;A partir daí, é só criar e matar várias instâncias do explorer.exe. Antes de matar um, digite o PID do novo processo no ProcessLeaker.&lt;/p&gt;
&lt;p&gt;Para listar os processos perdidos, basta usar o comando &amp;quot;!process 0 0&amp;quot; no WinDbg depurando em kernel. O resto você já sabe.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Os processos-fantasma</title>
  <link>http://www.caloni.com.br/os-processos-fantasma/</link>
  <pubDate>2008-08-20</pubDate>
  
  <guid>http://www.caloni.com.br/os-processos-fantasma/</guid>
  <description>&lt;p&gt;Estava eu outro belo dia tentando achar um problema em um driver que controla criação de processos quando, por acaso, listo os processos na máquina pelo depurador de kernel, após ter dado alguns logons e logoffs, quando me vem a seguinte lista de processos do Windows Explorer:&lt;/p&gt;
&lt;p&gt;Analisando pelo Gerenciador de Tarefas, podemos detectar que o único processo de pé possui o PID (Process ID) do último elemento de nossa lista, curiosamente o único com um contador de handles diferente de zero.&lt;/p&gt;
&lt;p&gt;Lembrando que 1940 em hexadecimal é 0x794, exatamente o valor deixado em destaque na lista acima, e reproduzido abaixo:&lt;/p&gt;
&lt;p&gt;Sendo ele o único processo a rodar, a única explicação válida para as outras instâncias do explorer.exe estarem de pé seria o fato de haver algum outro processo (inclusive o sistema operacional) com um handle aberto para ele. Felizmente isso pode ser facilmente verificado pelo uso do comando !object do WinDbg, no caso abaixo com o primeiro explorer.exe da lista, utilizando-se a sua estrutura EPROCESS (em vermelho na lista acima).&lt;/p&gt;
&lt;p&gt;Muito bem. Temos dois handles e dois ponteiros ainda abertos para o objeto processo-fantasma explorer.exe. O fato de haver um handle aberto indica que é muito provável que se trate de um outro processo rodando em user mode, já que normalmente as referências para objetos dentro do kernel são feitas com o uso de ponteiros.&lt;/p&gt;
&lt;p&gt;Para descobrirmos quem detém esse handle, existe o comando !handle, que pode exibir informações sobre todos os handles de um determinado tipo no processo atual. Como queremos procurar por todos os handles do tipo Process em todos os processos existentes, é necessário usá-lo em conjunto com o comando mais esperto !foreachprocess, que pode fazer coisas incríveis para o programador de user/kernel:&lt;/p&gt;
&lt;p&gt;Uma simples busca pelo EPROCESS do processo-fantasma nos retorna dois processos que o estão referenciando: um svchost.exe e um outro processo com um nome muito suspeito, provavelmente feito sob encomenda para a confecção desse artigo:&lt;/p&gt;
&lt;p&gt;Se lembrarmos o ponteiro dos outros processos, podemos notar que ele está bloqueando todas as outras instâncias dos antigos explorer.exe, executados em outras sessões do usuário:&lt;/p&gt;
&lt;p&gt;Esse ProcessLeaker se tratava de um serviço do mesmo produto que contém de fato um leak de recurso: em um dado momento ele abre um handle para o processo explorer.exe, só que por alguns motivos obscuros ele não é fechado nunca, gerando uma lista interminável de processos-fantasma. E é lógico que ele originalmente não chama ProcessLeaker.exe =)&lt;/p&gt;
&lt;p&gt;Essa análise mostra duas coisas: que com um pouco de conhecimento e atitude é possível encontrar bugs em outras partes do programa, mesmo quando resolvendo outros problemas e que, nem sempre o problema está onde parece estar, que seria no nosso querido driver de controle de processos do começo da história.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Quando o navegador não quer largar um arquivo</title>
  <link>http://www.caloni.com.br/quando-o-navegador-nao-quer-largar-um-arquivo/</link>
  <pubDate>2008-08-13</pubDate>
  
  <guid>http://www.caloni.com.br/quando-o-navegador-nao-quer-largar-um-arquivo/</guid>
  <description>&lt;p&gt;De vez em quando gosto muito de um vídeo que estou assistindo. Gosto tanto que faço questão de guardar para assistir mais vezes depois. O problema é que o meu Firefox ou, para ser mais técnico, o plugin de vídeo que roda em cima do meu navegador, não permite isso. Ele simplesmente cria um arquivo temporário para exibir o vídeo e logo depois o apaga, utilizando uma técnica muito útil da função CreateFile, que bloqueia o acesso do arquivo temporário e apaga-o logo após o uso:&lt;/p&gt;
&lt;p&gt;Muito bem. Isso quer dizer que é possível abrir um arquivo que mais ninguém pode abrir (nem para copiar para outro arquivo), e ao mesmo tempo garante que quando ele for fechado será apagado. Isso parece uma ótima proteção de cópia não-autorizada para a maioria das pessoas.&lt;/p&gt;
&lt;p&gt;Infelizmente, tudo isso roda sob limites muito restritos: um navegador, rodando em user mode, usando APIs bem definidas e facilmente depuráveis.&lt;/p&gt;
&lt;p&gt;Antes de iniciar a reprodução do vídeo, e conseqüentemente a criação do arquivo temporário, podemos atachar uma instância do nosso depurador do coração e colocar um breakpoint onde interessa:&lt;/p&gt;
&lt;p&gt;Nesse momento podemos dar uma boa olhada nos parâmetros 4 e 6 da função para ver se trata-se realmente da proteção prevista (na verdade, prevista, nada; esse é um artigo baseado em uma experiência passada; vamos imaginar, contudo, que estamos descobrindo essas coisas como na primeira vez).&lt;/p&gt;
&lt;p&gt;Como podemos ver, o modo de compartilhamento do arquivo é nenhum. Entre os flags definidos no sexto parâmetro, está o de apagar o arquivo ao fechar o handle, como pude constatar no header do SDK:&lt;/p&gt;
&lt;p&gt;Nesse caso, a solução mais óbvia e simples foi deixar esse bit desabilitado, não importando se o modo de compartilhamento está desativado. Tudo que temos que fazer é assistir o vídeo mais uma vez e fechar a aba do navegador. O arquivo será fechado, o compartilhamento aberto, e o arquivo, não apagado.&lt;/p&gt;
&lt;p&gt;E agora posso voltar a armazenar meus vídeos favoritos.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Guia para iniciantes no DriverEntry</title>
  <link>http://www.caloni.com.br/guia-para-iniciantes-no-driverentry/</link>
  <pubDate>2008-08-11</pubDate>
  
  <guid>http://www.caloni.com.br/guia-para-iniciantes-no-driverentry/</guid>
  <description>&lt;p&gt;A mensagem anterior deixou bem claro que tenho um roteiro de leituras bem hardcore a fazer nos próximos 20 anos. Pretendo, enquanto isso, programar alguma coisinha rodando em ring0, porque nem só de teoria vive o programador-escovador-de-bits. Pensando nisso, esse fim-de-semana comecei a me aventurar nos ótimos exemplos e explicações do DriverEntry.com.br, nossa referência kernel mode tupiniquim.&lt;/p&gt;
&lt;p&gt;A exemplo do que Dmitry fez com os livros de drivers, acredito que a mesma coisa pode ser feita com os blogues. A maneira de esmiuçá-los vai depender, principalmente, da quantidade de material a ser estudado e das práticas necessárias para que o conhecimento entre na cabeça de uma vez por todas.&lt;/p&gt;
&lt;p&gt;No momento, minha prática se resume a isso:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Debug or not debug. Aqui resolvi dar uma olhada de perto nas macros e funções usadas para &lt;em&gt;tracing&lt;/em&gt; no DDK, e descobri que, assim como a runtime do C, podemos ter mensagens formatadas no estilo do printf e vprintf, o que economiza uma porção de código repetitivo. Dessa forma pude usar minha estratégia de ter a macro LOG usada para mandar linhas de depuração na saída padrão. Ainda tenho que estudar, contudo, o uso da variável va_list em kernel.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ExAllocatePool (WithoutTag). Precisei fazer alguns testes no Dependency Walker e anexar o fonte que faz a vez do GetProcAddress para drivers em meu miniprojeto do Bazaar para aprendizado de programação em &lt;em&gt;kernel&lt;/em&gt; (linque para &lt;em&gt;download&lt;/em&gt; no final do artigo).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Getting Started. Esse foi o artigo mais interessante de todos, pois foi a base de todo o código que ando repetindo em meus exercícios. Além desse, é vital o uso do Visual Studio no processo de desenvolvimento, pois muitas (quase todas) das funções do DDK são alienígenas para mim, assim como os seus 497 parâmetros cada.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Driver plus plus. Tive que perder algum tempo codificando uma segunda versão do Useless e baixando o framework da Hollis para testar as peculiaridades do C++ em kernel mode. Não que eu vá usar alguma coisa avançada nesse estágio, mas preciso conhecer algumas limitações e alguns macetes que farão uma grande diferença no futuro, quando as linhas de código ultrapassarem 10.000.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pulei alguns tópicos que pretendo explorar quando estiver mais à vontade com alguns conceitos básicos, como a explicação de como obter o processo dono de uma IRP, a explicação do que é uma IRP (apesar de eu ter baixado e brincado com o monitor da OSR) e a aparentemente simples explanação sobre como funcionam as listas ligadas do DDK. Tudo isso virá com o tempo, e algumas coisas estarão sempre martelando na cabeça. É só dar tempo ao tempo e codificar.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Nós queremos exemplos. Esse foi o artigo que mais me deu trabalho, mas que mais valeu a pena. Codifiquei tudo do zero, olhando aos poucos no código do Fernando para pegar o jeito de usar funções com nomes enormes e auto-explicativas e parâmetros com os nomes a, b, c. Também dediquei um tempinho considerável com a aplicação de user mode, para (re)aprender a depurar dos dois lados da moeda.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Próximos passos?&lt;/p&gt;
&lt;p&gt;Pelo que eu vi, no geral, acredito que aos poucos irei voltar para os tópicos que pulei, além de olhar em outros artigos que chamaram minha atenção:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Como criar um driver de boot&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Usando o DSF para interagir com dispositivos USB de mentirinha&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A continuação emocionante de nosso driver que recebe reads e writes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Usar o que existe de bom e melhor para garantir a qualidade de um driver&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mais alguns detalhes que começam a fazer sentido em nosso KernelEcho&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Criando e usando IOCTLs. Essa vai ser ótima!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A necessidade inevitável de mexer com o registro do sistema&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tudo isso aliado aos exemplos e à teoria latente do Windows 2000 Device Driver Book (minha primeira leitura) irá dar um upgrade forçado aos meus neurônios. Espero sobreviver para contar o final da história.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Aprendizado em kernel mode</title>
  <link>http://www.caloni.com.br/aprendizado-em-kernel-mode/</link>
  <pubDate>2008-08-07</pubDate>
  
  <guid>http://www.caloni.com.br/aprendizado-em-kernel-mode/</guid>
  <description>&lt;p&gt;Hoje terminei minha primeira leitura de Memory Dump Analysis Vol. 1, e qual não foi a minha surpresa ao encontrar entre os últimos posts justamente o que eu estava precisando: um guia de livros que se deve ler para começar a programar em kernel mode.&lt;/p&gt;
&lt;p&gt;O melhor de tudo nem é a lista de livros, cujos títulos já estão batidos na minha cabeça de tanto meu amigo Ferdinando comentar a respeito. A grande sacada foi ele ter feito um roteiro no estilo &amp;quot;leia esse livro primeiro, depois comece com esse e ao mesmo tempo acompanhe aquele, sempre atento ao Windows Internals&amp;quot;. As coisas não ficam mais fáceis (ler 8 livros, todos com média de 700 páginas), mas pelo menos ficam mais organizadas, tem começo, meio e fim (será?).&lt;/p&gt;
&lt;p&gt;Claro, esse é o método Dmitry Vostokov, o que não quer dizer que funciona com qualquer um. No entanto, gosto de suas buscas de padrão, analogias de dumps com o mundo real, abstrações filosóficas e, principalmente, as explicações das telas azuis em UML. Se entendo facilmente essa forma de explicar, é possível que esse método facilite um poucos as coisas não-tão-fáceis de fazer para mim.&lt;/p&gt;
&lt;p&gt;Agora só falta começar =).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Antidebugging during the process attach</title>
  <link>http://www.caloni.com.br/antidebugging-during-the-process-attach/</link>
  <pubDate>2008-08-05</pubDate>
  
  <guid>http://www.caloni.com.br/antidebugging-during-the-process-attach/</guid>
  <description>&lt;p&gt;Today was a great day for reverse engineering and protection analysis. I&#39;ve found two great programs to to these things: a API call monitor and a COM call monitor. Besides that, in the first program site - from a enthusiastic of the good for all Win32 Assembly - I&#39;ve found the source code for one more antidebugging technique, what bring us back to our series of antidebugging techniques.&lt;/p&gt;
&lt;p&gt;The purpose of this protection is to detect if some debugger tries to attach into our running process. The attach to process operation is pretty common in all known debugger, as WinDbg and Visual Studio. Different from the DebugPort protection, this solution avoids the attach action from the debuggee program. In this case the protection can make choices about what to do on the event of attach (terminate the process, send an e-mail, etc).&lt;/p&gt;
&lt;p&gt;The code I&#39;ve found does nothing more than to make use of the attach process function that&#39;s always called: the ntdll!DbgUiRemoteBreakin. Being always called, we can just to put our code there, what is relatively easy to do:&lt;/p&gt;
&lt;p&gt;To compile the code above, just call the compiler and linker normally. Obs.: We need the user32.lib in order to call MessageBox API:&lt;/p&gt;
&lt;p&gt;After the program has been running, every try to attach will show a detection message and program termination.&lt;/p&gt;
&lt;p&gt;Yes, I know. Sometimes we have to use &amp;quot;brute force codding&amp;quot; and make obscure codes, like this:&lt;/p&gt;
&lt;p&gt;There are a lot of ways to do the same thing. The example above is what is normally called in the crackers community as a shellcode, what is a pretty name for &amp;quot;byte array that is really the assembly code that does interesting things&amp;quot;. Shellcode for short =).&lt;/p&gt;
&lt;p&gt;Alternative ways to do this are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To declare a naked function in Visual Studio, to create an empty function just after, do some math to calculate the size of the function to be copied into another place (aware of Edit and Continue option).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To create a structure whose members are masked opcodes. This way, is possible in the constructor to receive the values and use it as a &amp;quot;mobile function&amp;quot;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both have pros and cons. The cons are related with the environment dependency. In the first alternative is necessary to configure the project to disable &amp;quot;Edit and Continue&amp;quot; option, whilst in the second one is necessary to align 1 byte the structure.&lt;/p&gt;
&lt;p&gt;Anyway, given the implementation, the main advantage is to isolate the code in only two functions - AntiAttachAbort and InstallAntiAttach - an API local hook (in the same process) that should never be called in production code. Besides, there are C++ ways to do such thing like &amp;quot;live assembly&amp;quot;. But this is matter for other future and exciting articles.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Antidebugging using the DebugPort</title>
  <link>http://www.caloni.com.br/antidebugging-using-the-debugport/</link>
  <pubDate>2008-08-01</pubDate>
  
  <guid>http://www.caloni.com.br/antidebugging-using-the-debugport/</guid>
  <description>&lt;p&gt;When a debugger starts a process to be debugged or, the article case, connects to a already created process, the communication between these processes is made through an internal resource inside Windows called LPC (Local Procedure Call). The system creates a &amp;quot;magic&amp;quot; communication port for debugging and the debugging events pass throw it.&lt;/p&gt;
&lt;p&gt;Among these events we can tell the most frequent:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Activated breakpoints&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Thrown exceptions&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Threads creation/termination&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DLLs load/unload&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Process exit&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the case of connecting into a existent process, the API DebugActiveProcess is called. Since this call, if successful, the caller program is free now to call the API DebugActiveProcess looking for debugging events. The main loop for a debugger is, so, pretty simple:&lt;/p&gt;
&lt;p&gt;The interesting detail about this communication process is that a program can be debugged actively only for ONE debugger. In other words, while there&#39;s a process A debugging process B, no one besides A can debug and break B.Using this principle, we can imagine a debugging protection based on this exclusivity, creating a protector process that connects to the protected process and &amp;quot;debugs&amp;quot; it:&lt;/p&gt;
&lt;p&gt;The needed steps to test the code above are:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the code&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run notepad (or another victim)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get its PID (Process ID)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the protector process passing the notepad PID as the argument&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Try to attach to the notepad using a debugger (e.g. Visual C++)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After the attach process, the debug port is occupied, and the communication between the debugger and debuggee is made throug LPC. Bellow we can see a little illustration of how things work:&lt;/p&gt;
&lt;p&gt;Basically the process stay receiving debugging events (through the LPC message queue) until the final event, the process exit. Notice that if someone try to terminate the protector process the debuggee process will be terminated, too.&lt;/p&gt;
&lt;p&gt;The strength in this protection is that it doesn&#39;t affect the code understanding and readability. In fact the code that protects is in another process. The weakness, I would say, it is your visibility. Everyone that will try to attack the solution will se two processes being created, what gives him/her something to think about...&lt;/p&gt;
&lt;p&gt;That&#39;s why thinking about the implementation is vital. Particularly the main point to be thought is the debugger/debuggee union. As much as better these two pieces were packed, harder to the attacker will be to separate them. An additional idea is to use the same technique in the opposite way, in other words, the debuggee process to attach into the debugger.&lt;/p&gt;
&lt;p&gt;This time I&#39;m not going to say that there&#39;s a easy solution. Maybe because I haven&#39;t though enough about the problem. Ideas?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Antidebugging using exceptions (part two)</title>
  <link>http://www.caloni.com.br/antidebugging-using-exceptions-part-two/</link>
  <pubDate>2008-07-30</pubDate>
  
  <guid>http://www.caloni.com.br/antidebugging-using-exceptions-part-two/</guid>
  <description>&lt;p&gt;In the first article we saw how it&#39;s possible to spoof the debugger through exceptions and let the attacker lose some considerable time trying to unbind the program from the fake breakpoints. However, we saw also that this is a difficult solution to keep in the source code, besides its main weakness to be easily bypassed if discovered. Now it&#39;s time to put things easier to support and at the same time to guarantee tough times even if the attacker discover what is going on.&lt;/p&gt;
&lt;p&gt;The upgrade showed here still uses the exception throwing intrinsically, but now it doesn&#39;t depends on the code division in minifunctions and minicalls. Instead, we just need to get code traces and put them inside a miraculous macro that will do everything we want. This, of course, after some &amp;quot;hammer work&amp;quot; that will be explained here.&lt;/p&gt;
&lt;p&gt;The solution above is explained in pseudocode to make things clearer. Notice that exist some kind of invisible return, not stack based. To handle it, however, we can use the good for all C ANSI standard, using the setjmp (step one) and longjmp (step 3). To understand the implementation for theses functions running on the 8086 platform we need to get the basic vision of the function calls in a stack based environment (the C and Pascal way).&lt;/p&gt;
&lt;p&gt;Registers are reserved variables in the processor that can be used by the assembly code. Stack frame is the function calling hierarchy, the &amp;quot;who called who&amp;quot; in a given execution state. Call and ret are assembly instructions to call and return from a function, respectively. Both change the stack frame.&lt;/p&gt;
&lt;p&gt;Imagine you have a function, CallFunc, and another function, Func, and one calls the other. In order to analyse just the function call, and just that, let&#39;s consider Func doesn&#39;t receive any argument and doesn&#39;t return any value. The C code, would be like bellow:&lt;/p&gt;
&lt;p&gt;Simple, huh? Being simple, the generated assembly will be simple as well. In CallFunc it should have the function call, and inside Func the return from the call. The rest of the code is related with Debug version stuff.&lt;/p&gt;
&lt;p&gt;From the assembly above we can conclude two things: 1. The stack grows down, since its value decremented four bytes (0012FD3C minus 0012FD38 equal four) and 2. The return value from the calling is the address of the very next instruction after the call instruction, in the case 00411FA3.&lt;/p&gt;
&lt;p&gt;Well, in the same way we can follow this simple execution, the attacker will do as well. That&#39;s why in the middle of this call we will throw an exception and, in the return, we will not do the return in the conventional way, but using another technique that, instead using the ret instruction, sets manually the esp value (stack state) and jumps to the next instruction in CallFunc.&lt;/p&gt;
&lt;p&gt;All this assembly stuff doesn&#39;t need to be written in assembly level. It was just a way I found to illustrate the differences between the stack return and the jump return. As it was said, to the luck and well being for all, this same technique can be implemented using ANSI C functions:&lt;/p&gt;
&lt;p&gt;That was the new trick for the trowing of exceptions. The final code is clearer, now:&lt;/p&gt;
&lt;p&gt;At first sight, it seems a waste the if being directly in the code (remember we gonna use the same conditional structure in several parts in the code). To turn things clearer, resume the protected call and allows the protection to be disabled in debug version code, let&#39;s create a macro:&lt;/p&gt;
&lt;p&gt;Now we allow the antidebugging selection by call, what turns things much easier than to choose the protected points inside the code.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Antidebugging using exceptions (part one)</title>
  <link>http://www.caloni.com.br/antidebugging-using-exceptions-part-one/</link>
  <pubDate>2008-07-28</pubDate>
  
  <guid>http://www.caloni.com.br/antidebugging-using-exceptions-part-one/</guid>
  <description>&lt;p&gt;A debugger puts breakpoints to stop for a moment the debuggee execution. In order to do this it makes use of a well known instruction: int 3. This instruction throws an exception - the breakpoint exception - that is caught by the operating system and bypassed to the handling code for this exception. For debuggee processes this code is inside the debugger. For free processes this code normally doesn&#39;t exist and the application simply crashs.&lt;/p&gt;
&lt;p&gt;The main idea in this protection is to take care these exceptions during the application execution. Doing this, we can make use of this fact and, in the handling code, run the protected code. The solution here looks like a script interpreter. It consists basically of two threads: The first one read an instructions sequence and tells the second thread to run it step to step. In order to do this the second thread uses a small functions set with well defined code blocks. Here&#39;s the example in pseudocode:&lt;/p&gt;
&lt;p&gt;The protection isn&#39;t there yet. But it will as intrinsic part of the execution thread. All we need to do is to add a exception handling and to throw lots of int 3. The thrown exceptions are caught by a second function that runs the instruction before to returning:&lt;/p&gt;
&lt;p&gt;The execution thread algorithm is the same. Just the point where each instruction is executed depends to the exception throw system. Note that this exception has to be thrown in order to the next instruction run. This is fundamental, since this way nobody can just rip of the int 3 code to avoid the exception. If one does that, so no instruction will be executed at all.&lt;/p&gt;
&lt;p&gt;In practice, if one tries to debug such a program one will have to deal with tons of exceptions until find out what&#39;s happening. Of course, as in every software protection, is&#39;s not definitive; it has as a purpose to make hard the reverse engineering understanding. That&#39;s not going to stop those who are really good doing that stuff.&lt;/p&gt;
&lt;p&gt;The price paid for this protection stays on the source code visibility and understanding, compromised by the use of this technique. The programming is state machine based, and the functions are limited to some kind of behavior standard. So much smaller the code blocks inside the minifunctions, so much hard the code understanding will be.&lt;/p&gt;
&lt;p&gt;The example bellow receives input through a command prompt and maps the first word typed to the function that must be called. The rest of the typed line is passed as arguments to the functions. The interpreter thread reads the user input and writes into a global string variable, at the same time the executor thread waits the string to be completed to starts the action. It was used the variable pool to let the code simpler, but the ideal would be some kind of synchronise, just like events, by example.&lt;/p&gt;
&lt;p&gt;The strength in this protection is to confound the attacker easily in the first steps (days, months...). Its weakness is the simplicity for the solution, since the attacker eventually realize what is going on. It is so easy that I will let it as an exercise for my readers.&lt;/p&gt;
&lt;p&gt;In the next part we will se an alternative to make the code clearer and easy to use in the every day by a security software developer.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Aprenda a usar sua API</title>
  <link>http://www.caloni.com.br/aprenda-a-usar-sua-api/</link>
  <pubDate>2008-07-22</pubDate>
  
  <guid>http://www.caloni.com.br/aprenda-a-usar-sua-api/</guid>
  <description>&lt;p&gt;É conhecido que uma das desvantagens de se programar diretamente em Win32 API é a dificuldade de se entender os parâmetros e o retorno das funções. Concordo em parte. Constituída de boa documentação, parte da culpa dos programas mal-feitos reside na preguiça do programador em olhar a documentação por completo.&lt;/p&gt;
&lt;p&gt;A Win32 API está longe de ser perfeita, mas pelo menos está razoavelmente documentada, e é na leitura atenta da documentação que iremos encontrar as respostas que precisamos para que o programa funcione.&lt;/p&gt;
&lt;p&gt;Vejamos alguns exemplos.&lt;/p&gt;
&lt;p&gt;O código abaixo parece bem razoável:&lt;/p&gt;
&lt;p&gt;No entanto, está errado.&lt;/p&gt;
&lt;p&gt;É fato que a maioria das funções que retornam handles retornam NULL para indicar o erro na tentativa de obter o recurso. Ao comparar o retorno com NULL, o programador geralmente faz uma chamada a GetLastError.aspx) para saber o que aconteceu. No entanto, uma das funções mais usadas, a CreateFile, não retorna NULL, mas INVALIDHANDLEVALUE.&lt;/p&gt;
&lt;p&gt;Sendo assim, o código acima deveria ser:&lt;/p&gt;
&lt;p&gt;Taí uma função que muitos erraram. Erraram tanto que eles fizeram uma nova versão menos complicada. Como está escrito no MSDN.aspx):&lt;/p&gt;
&lt;p&gt;&amp;quot;The GetVersionEx function was developed because many existing applications err when examining the packed DWORD value returned by GetVersion, transposing the major and minor version numbers.&amp;quot;&lt;/p&gt;
&lt;p&gt;O motivo de tantos erro pode ter sido o fato que o valor retornado é uma estrutura de bits dentro de um DWORD, coisa que nem todos programadores C sabem lidar muito bem, e o fato de ser uma função muito utilizada por todos (pegar a versão do sistema operacional).&lt;/p&gt;
&lt;p&gt;Eis a tabela de campos do retorno de GetVersion:&lt;/p&gt;
&lt;p&gt;Mesmo que não seja tão difícil, pode ser ambíguo. Por exemplo, como saber se o Windows é 95, 98 ou ME?&lt;/p&gt;
&lt;p&gt;O código abaixo, muito usado por todos que suportam ainda o Windows mais velhinhos, verifica se estamos rodando em plataforma NT ou 9x.&lt;/p&gt;
&lt;p&gt;Nem sempre o handle que obtemos é fechado com CloseHandle. As funções abaixo retornam handles que devem ser desalocados com as funções à direita:&lt;/p&gt;
&lt;p&gt;Sempre tem. Algumas dicas úteis para o dia-a-dia de um programador Win32 API são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leia a documentação&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Se atente aos valores de retorno em caso de sucesso e erro&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leia sempre a seção remarks pelo menos uma vez; ela explica como desalocar recursos&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Releia a documentação&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Às vezes uma singela chamada de uma função de autenticação pode nos fazer preencher uma estrutura de 20 membros, sendo que seis deles são obtidos com mais sete chamadas de funções, todas com direito a desalocar recursos no final. O importante é sempre manter a calma, o espírito de aprendizado e aventura. Afinal, quem mandou não fazer software de telinha?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O conhecido unresolved external</title>
  <link>http://www.caloni.com.br/o-conhecido-unresolved-external/</link>
  <pubDate>2008-07-18</pubDate>
  
  <guid>http://www.caloni.com.br/o-conhecido-unresolved-external/</guid>
  <description>&lt;p&gt;O artigo anterior mostrou que nem sempre as coisas são simples de resolver, mas que sempre existe um caminho a seguir e que, eventualmente, todos os problemas se solucionarão.&lt;/p&gt;
&lt;p&gt;Porém, resolver um problema por si só não basta: é preciso rapidez. E como conseguimos rapidez para resolver problemas? Um jeito que eu, meu cérebro e o Dmitry Vostokov conhecem é montando padrões.&lt;/p&gt;
&lt;p&gt;Um padrão nos ajuda a não pensar novamente em coisas que sabemos a resposta, de tantas vezes que já fizemos. Só precisamos saber o caminho para resolver determinado problema.&lt;/p&gt;
&lt;p&gt;Mesmo assim, existem diversos caminhos a percorrer. Até mesmo para um singelo e batidíssimo &amp;quot;unresolved external&amp;quot;.&lt;/p&gt;
&lt;p&gt;O erro mais comum é usar uma LIB onde não está a função que estamos usando, ou usar uma versão diferente da mesma LIB que não contém a função, ou contém, mas com assinatura (parâmetros da função) diferentes. Isso pode ser verificado no código-fonte da LIB, se disponível, ou então pelo uso do dumpbin, como já vimos anteriormente.&lt;/p&gt;
&lt;p&gt;Dica extra: às vezes você pensa que está usando uma LIB em um determinado caminho, mas o linker achou a LIB primeiro em outro lugar. Para se certificar que está verificando a mesma LIB que o linker achou, use o Process Monitor.&lt;/p&gt;
&lt;p&gt;Às vezes, porém, não estamos usando a função diretamente e não conhecemos quem a usaria. Para isso que hoje em dia os compiladores mais espertos nos dizem em que parte do código foi referenciado a tal função:&lt;/p&gt;
&lt;p&gt;É sábio primeiro inspecionar a função que referencia, para depois entender porque ela não foi encontrada. Mesmo parecendo diferente, essa operação faz parte do primeiro passo, que é identificar a origem.&lt;/p&gt;
&lt;p&gt;Parece estúpido, mas às vezes é esse o caso. Essa é a segunda coisa a fazer porque não é tão comum quanto a primeira, visto que hoje em dia é rotina colocarmos as funções em um header e incluirmos esse cabeçalho em nosso código-fonte (em C++, praticamente obrigatório). Se houvesse discrepância entre o nome da função chamada e o nome da função existente, provavelmente teríamos um erro de compilação (&amp;quot;função não encontrada&amp;quot;) antes do erro de linking.&lt;/p&gt;
&lt;p&gt;Se a LIB não está cooperando, e der pouco trabalho, experimente incluir a função inteira (ou o cpp) dentro do seu projeto, para linkar diretamente. Se funcionar, então existe alguma diferença de compilação entre os dois projetos (o seu e o da LIB) para que haja uma divergência no nome procurado. Procure nas opções de projeto.&lt;/p&gt;
&lt;p&gt;Sempre que nos deparamos com um problema que aos poucos vai consumindo o nosso tempo, tendemos a gastar mais tempo fazendo coisas inúteis que sabemos que não irá adiantar de nada. Às vezes fazer brute force pode dar certo. Outras vezes, seria melhor recomeçar a pesquisa e tentar entender de fato o que está acontecendo na compilação. Em outras palavras: gastar o seu tempo pensando pode ser mais produtivo do que agir instintivamente.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O caso da função de Delay Load desaparecida</title>
  <link>http://www.caloni.com.br/o-caso-da-funcao-de-delay-load-desaparecida/</link>
  <pubDate>2008-07-16</pubDate>
  
  <guid>http://www.caloni.com.br/o-caso-da-funcao-de-delay-load-desaparecida/</guid>
  <description>&lt;p&gt;Todos os projetos do Visual Studio 6 estavam compilando normalmente com a nova modificação do código-fonte, uma singela chamada a uma função.aspx) da DLL iphlpapi.dll. No entanto, ainda restava a compilação para Windows 95, um legado que não era permitido esquecer devido ao parque antigo de máquinas e sistemas operacionais de nossos clientes.&lt;/p&gt;
&lt;p&gt;Ora, acontece que a função em questão não existe em Windows 95! O que fazer?&lt;/p&gt;
&lt;p&gt;Essa é uma situação comum e controlada, que chega a ser quase um padrão de projeto: funções novas demais. A saída? Não chamar a função quando o sistema não for novo o suficiente. Isso pode ser resolvido facilmente com uma chamada a GetVersion.aspx).&lt;/p&gt;
&lt;p&gt;Porém, um outro problema decorrente dessa situação é que a função chamada estaticamente cria um link de importação da DLL para o executável. Ou seja, uma dependência estática. Dependências estáticas necessitam ser resolvidas antes que o programa execute, e o carregador (loader) de programas do sistema é responsável por essa verificação.&lt;/p&gt;
&lt;p&gt;Para verificar a existência de todas as DLLs e funções necessárias para nosso programa podemos utilizar o mundialmente conhecido Dependency Walker:&lt;/p&gt;
&lt;p&gt;Se a função ou DLL não existe no sistema, o seguinte erro costuma ocorrer (isso depende da versão do Sistema Operacional):&lt;/p&gt;
&lt;p&gt;Mas nem tudo está perdido!&lt;/p&gt;
&lt;p&gt;Existe uma LIB no Visual Studio que serve para substituir a dependência estática de uma DLL pela verificação dinâmica da existência de suas funções quando, e se, for executada a função no programa.&lt;/p&gt;
&lt;p&gt;Essa LIB contém algumas funções-chave que o Visual Studio utiliza ser for usado o seguinte parâmetro de compilação:&lt;/p&gt;
&lt;p&gt;A função principal se chama &amp;quot;delayLoadHelper@8&amp;quot;, ou seja, é uma função com convenção de chamada WINAPI (stdcall) que recebe dois parâmetros.&lt;/p&gt;
&lt;p&gt;Isso costuma sempre funcionar, sendo que tive uma grande surpresa com os seguintes erros de compilação na versão do programa que deve ser executada em Windows 95:&lt;/p&gt;
&lt;p&gt;Isso, é claro, depois de ter checado e rechecado a existência da LIB de Delay Load na lista de LIBs a serem lincadas:&lt;/p&gt;
&lt;p&gt;Acontece que eu conheço algumas ferramentas que podem sempre me ajudar em situações de compilação e linque: Process Monitor e dumpbin.&lt;/p&gt;
&lt;p&gt;O Process Monitor pode ser usado para obter exatamente a localização da LIB que estamos tentando verificar:&lt;/p&gt;
&lt;p&gt;Após localizar o local, podemos listar seus símbolos, mais precisamente a função &amp;quot;delayLoadHelper&amp;quot;:&lt;/p&gt;
&lt;p&gt;A análise mostra que a função possui um &amp;quot;2&amp;quot; no final de seu nome, causando o erro de linque.&lt;/p&gt;
&lt;p&gt;Essa função, pelo visto, tem mudado de nome desde o Visual C++ 6, o que fez com que LIBs mais novas não funcionassem com essa versão do Visual Studio.&lt;/p&gt;
&lt;p&gt;Para sanar o problema, existem duas coisas que podem ser feitas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Usar a delayimp.lib antiga. Isso não exige nenhuma mudança no código.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Criar uma função delayLoadHelper como wrapper. Isso exige a escrita de código. O código-fonte dessa função está disponível no diretório Include do Visual Studio, e pode ser adaptada para versões antigas.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Nessa sessão de depuração você aprendeu como usar o Process Monitor para rastrear arquivos usados na compilação e como listar símbolos de LIBs que são usadas para lincar o programa.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Segunda versão do Houaiss2Babylon</title>
  <link>http://www.caloni.com.br/segunda-versao-do-houaiss2babylon/</link>
  <pubDate>2008-07-14</pubDate>
  
  <guid>http://www.caloni.com.br/segunda-versao-do-houaiss2babylon/</guid>
  <description>&lt;p&gt;Depois de vários comentários (na época que o saite tinha comentários) de pessoas tendo problemas em converter seus dicionários Houaiss para o formato Babylon, resolvi criar vergonha na cara e dar uma pequena melhora na versão beta do conversor.&lt;/p&gt;
&lt;p&gt;Agora a maioria dos erros que houver será descrita por uma mensagem no seguinte formato:&lt;/p&gt;
&lt;p&gt;O primeiro erro acima ocorre principalmente se não houver algum Houaiss instalado que o programa possa detectar. Resolva este problema fazendo uma busca no Buscapé.&lt;/p&gt;
&lt;p&gt;Abaixo segue a função criada para exibir essas mensagens:&lt;/p&gt;
&lt;p&gt;Se você notou, a função acima pode receber um número de argumentos variáveis para formatar a string da mensagem principal do erro, além de exibir seu código. Essa mágica pode ser feita usando-se o cabeçalho padrão &amp;quot;stdarg.h&amp;quot;. Através dele temos acesso ao tipo valist, que representa uma lista de argumentos variáveis.&lt;/p&gt;
&lt;p&gt;Pela convenção de chamada da linguagem C (e C++), quem desmonta a pilha é o chamador. Sendo assim, a função chamada não precisa conhecer o número de argumentos com que foi chamado.&lt;/p&gt;
&lt;p&gt;A função de formatação de string é uma variante do conhecidíssimo printf, na versão que recebe um tipo valist. Muito útil para formatação de logs.&lt;/p&gt;
&lt;p&gt;A versão beta do Houaiss2Babylon está para sair. Não estarei mais atualizando o saite do projeto no LaunchPad. Aguardem por mais novidades no próprio blogue.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Primeiros passos no VMware Workstation</title>
  <link>http://www.caloni.com.br/primeiros-passos-no-vmware-workstation/</link>
  <pubDate>2008-07-10</pubDate>
  
  <guid>http://www.caloni.com.br/primeiros-passos-no-vmware-workstation/</guid>
  <description>&lt;p&gt;Como uma ferramenta essencial que uso todos os dias da minha vida de programador, sou obrigado a falar neste blogue sobre a VMware, ferramenta que tem me salvado algumas centenas de horas de depuração, testes e alguns cabelos brancos (a mais).&lt;/p&gt;
&lt;p&gt;Para os que não sabem, o VMware é um software de virtualização que permite rodar diversos sistemas operacionais secundários (chamados de convidados, ou guests) em cima do sistema operacional primário (chamado de hospedeiro, ou host). Para isso ele utiliza uma técnica muito interessante conhecida como virtualização, onde o desempenho da máquina virtual chega bem próximo da máquina nativa em que estamos rodando, ainda mais se instalados os apetrechos de otimização (vide VMware Tools) dentro dos sistemas operacionais convidados.&lt;/p&gt;
&lt;p&gt;O VMware, diferente de alguns outros programas de virtualização, não é gratuito. No entanto, o tempo despendido pela equipe da VMware em tornar esta a solução a de melhor qualidade (opinião pessoal de quem já mexeu com Virtual PC e pouco de VirtualBox) está bem cotado, sendo que seu preço é acessível pelo desenvolvedor médio. Pior que o preço da VMware com certeza será o dos sistemas operacionais convidados, se estes forem da Microsoft, que obriga cada instância do Windows, seja hospedeiro ou convidado, a possuir uma licença separada. Se rodar um Windows XP como hospedeiro e um Vista e 2000 como convidados vai desembolsar pelo menos o quíntuplo da licença da VMware.&lt;/p&gt;
&lt;p&gt;No entanto, não entremos em mais detalhes financeiros. Os detalhes técnicos são mais interessantes.&lt;/p&gt;
&lt;p&gt;A instalação é simples e indolor, sendo constituída de cinco ou seis botões de next. O resto, e mais importante, é a instalação de um sistema operacional dentro de sua primeira máquina virtual. Outro assistente existe nessa fase para guiá-lo através de suas escolhas que irão configurar sua futura máquina.&lt;/p&gt;
&lt;p&gt;Um pouco sobre redes&lt;/p&gt;
&lt;p&gt;Use bridged networking. É criada uma conexão real através de uma ponte feita em cima de uma placa de rede da máquina real. É usado um IP diferente da máquina real e se comporta como uma outra máquina qualquer na rede.&lt;/p&gt;
&lt;p&gt;Use NAT. As conexões são criadas usando o IP do sistema operacional hospedeiro. Para isto acontecer é usado o conhecido esquema de NAT, onde um único IP externo pode representar n IPs internos de uma rede (nesse caso, a rede virtual formada pelas máquinas virtuais de uma mesma máquina real).&lt;/p&gt;
&lt;p&gt;Use host-only networking. O IP usado nessa conexão é diferente da máquina real, mas só é enxergada por ela e por outras VMs localizadas na mesma máquina hospedeira. Muito útil para isolar um teste de vírus, quando se precisa de uma rede mas não podemos usar a rede da empresa inteira.&lt;/p&gt;
&lt;p&gt;Imagine uma VM (Virtual Machine) como uma máquina de verdade, onde podemos dar boot, formatar HDs (virtuais ou reais), colocar e remover dispositivos. Tendo isso em mente, fica simples entender o que funciona por dentro de sua console, ou seja, a tela onde vemos a saída da virtualização.&lt;/p&gt;
&lt;p&gt;Um pouco sobre discos virtuais&lt;/p&gt;
&lt;p&gt;Os HDs que criamos para nossas VMs são arquivos lógicos localizados em nosso HD real. A mágica em que o sistema operacional virtual acessa o disco virtual como se fosse de verdade é feita pela VMware, inclusive a doce ilusão que ele cotém 80 GB, enquanto seu arquivo-repositório ocupa meros 5 GB no disco. Nas edições novas do software, é possível mapear um HD virtual e exibi-lo na máquina real.&lt;/p&gt;
&lt;p&gt;Se você dispõe do CD de instalação de um sistema operacional, por exemplo, Windows XP, basta inseri-lo no CD virtual de sua VM. Ela aceita também imagens ISO, se for o caso. Lembre-se apenas que ele terá que ser &amp;quot;bootável&amp;quot;, do contrário é necessário um disquete de boot.&lt;/p&gt;
&lt;p&gt;Um pouco sobre BIOS&lt;/p&gt;
&lt;p&gt;A sua VM emula todo o comportamento de uma máquina real. Ela, portanto, contém uma BIOS, feita pela VMware. Essa BIOS possui as mesmas opções interessantes de ordem de boot (primeiro o disquete, depois o HD, etc) e escolha de dispositivo de boot (tecla ESC).&lt;/p&gt;
&lt;p&gt;A instalação do sistema operacional segue os mesmos passos que a instalação do sistema operacional de qualquer máquina de verdade.&lt;/p&gt;
&lt;p&gt;As teclas mágicas&lt;/p&gt;
&lt;p&gt;Entrar o foco na VM. Digite Ctrl + G. Todos seus movimentos de teclado e mouse só irão funcionar dentro da máquina virtual, exceto o Ctrl + Alt + Del, exclusividade do sistema de autenticação do Windows.&lt;/p&gt;
&lt;p&gt;Tirar o foco da VM. Digite Ctrl + Alt. Todos seus movimentos de teclado e mouse passam a ser do SO hospedeiro.&lt;/p&gt;
&lt;p&gt;Ctrl + Alt + Del dentro da VM. Use Ctrl + Alt + Insert. Ele terá o mesmo efeito que um CAD, independente em que tela estiver em sua VM.&lt;/p&gt;
&lt;p&gt;Após feita a instalação, você terá um sistema operacional rodando dentro de um sistema operacional. Isso não é legal?&lt;/p&gt;
&lt;p&gt;Snapshots&lt;/p&gt;
&lt;p&gt;A primeira coisa a fazer em sua VM com SO recém-instalado é criar um snapshot, ou seja, salvar o estado atual de sua máquina virtual. Ao fazer isso, se fizer alguma coisa dentro da VM que possa se arrepender depois, basta voltar para o estado que salvou anteriormente. A VMware permite criar quantos snapshots precisar (basta ter espaço em disco). Ela permite que você crie novas máquinas virtuais a partir de um estado de uma VM já criada, o que pode economizar todo o tempo de montar do zero outra VM ou copiar o disco virtual.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Abrir os seus e-mails suspeitos. Não tenha mais medo de sujar seu computador com e-mails de conteúdo duvidoso. Crie um estado seguro em sua VM através de um snapshot (fotografia de estado da máquina virtual) e execute os anexos mais absurdos. Depois basta voltar para o estado seguro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Testes que costumam alterar o estado da máquina. Driver, GINA ou serviço novo? Que tal usar uma VM para fazer os testes iniciais e parar de reformatar o Windows?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As VMs possibilitam um mundo de utilidades que o mundo ainda está descobrindo. Para nós, desenvolvedores, a maior vantagem de tudo isso é termos nossos ambientes de testes mais bizarros facilmente configurados no conforto de uma caixinha de areia.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Projeto-modelo</title>
  <link>http://www.caloni.com.br/projeto-modelo/</link>
  <pubDate>2008-07-08</pubDate>
  
  <guid>http://www.caloni.com.br/projeto-modelo/</guid>
  <description>&lt;p&gt;É muito difícil construir um modelo de pastas que sirva para a maioria dos projetos que tivermos que colocar na fôrma. Ainda mais se esses projetos tiverem que futuramente fazer parte da mesma ramificação. Foi pensando em várias coisas que chegamos a uma versão beta que pode ajudar aqueles que ficam pensando durantes dias antes mesmo de colocar as mãos no código.&lt;/p&gt;
&lt;p&gt;Antes de começar a pensar em como as pastas estarão alinhadas, é importante saber como funcionará o controle de código do seu projeto. Como eu disse sobre o Bazaar, a estrutura inicial permitirá a junção de dois projetos distintos se estes compartilharem do mesmo commit no começo de suas vidas.&lt;/p&gt;
&lt;p&gt;Portanto, trate de iniciar a estruturação em um projeto-modelo que já contenha pelo menos um commit: o das pastas vazias já estruturadas.&lt;/p&gt;
&lt;p&gt;Build. Essa pasta contém tudo que é necessário para compilar e testar o projeto como um todo. Idealmente a execução da batch build.bat deve executar todo o processo. Após a compilação, é de competência dos componentes na subpasta Tests fazer os testes básicos do projeto para se certificar de que tudo está funcionando como deveria.&lt;/p&gt;
&lt;p&gt;Common. Aqui devem ser colocados aqueles includes que servem para vários pontos do projeto. Está exemplificado pelo arquivo de versão (Version.h), pois todos os arquivos devem referenciar uma única versão do produto. Podem existir Outras definições básicas, como nome do produto, dos arquivos, etc. É aqui que são gravadas as interfaces que permitem dependência circular entre os componentes (e.g. Interface de componentes COM).&lt;/p&gt;
&lt;p&gt;Docs. Aqui deve ser colocada toda a documentação que diz respeito ao projeto. A organização interna ainda não foi definida, pois imagina-se ser possível usar diversas fontes, como doxygen, casos de uso, bugs, arquivos de projeto e UML. Foi exemplificado com o arquivo todo.txt e changes.txt, que deve ter sempre a lista de coisas a fazer e a lista de coisas já feitas, respectivamente, tendo, portanto, que ser sempre atualizados.&lt;/p&gt;
&lt;p&gt;Drivers. Essa é a parte onde ficam todos os componentes que rodam em kernel mode. Por se tratar de um domínio específico e muitas vezes compartilhar código-fonte de maneira não-heterodoxa (e.g. sem uso de LIBs), faz sentido existir uma pasta que agrupe esses elementos. Dentro da pasta existem subpastas para cada driver, exemplificados em Driver1 e Driver2.&lt;/p&gt;
&lt;p&gt;Install. Todas as coisas relacionadas com instalação, desinstalação e atualização do software deve vir nessa pasta. Foi reservada uma subpasta para cada item, não sendo obrigatória sua divisão. Também existe uma pasta de DLLs, onde possivelmente existam telas personalizadas e biblioteca de uso comum pelos instaladores (o desinstalador conversa com o instalador e assim por diante).&lt;/p&gt;
&lt;p&gt;Interface. Todas as telas de um programa devem ser colocadas nessa pasta. Essa é uma divisão que deve ser seguida conceitualmente. Por exemplo, se existir um gerenciador de alguma coisa no produto, as telas do gerenciador e o comportamento da interface ficam nessa pasta, mas o comportamento intrínseco do sistema (regras de negócio) devem ficar em Libraries. Para exemplificar o uso, foram criadas as Interface1 e Interface2.&lt;/p&gt;
&lt;p&gt;Libraries. O ponto central do projeto, deve conter o código mais importante. Imagine a pasta Libraries como a inteligência de um projeto, de onde todos os outros componentes se utilizam para que a lógica do software seja sempre a mesma. As outras partes do projeto lidam com aspectos técnicos, enquanto o Libraries contém as regras abstratas de funcionamento. Opcionalmente ela pode ser estática ou dinâmica, caso onde foi criada a subpasta DLLs. Porém, elas devem ser divididas por função em bibliotecas estáticas, como foi exemplificado em Library1 e Library2.&lt;/p&gt;
&lt;p&gt;Resources. A origem de todas as imagens, sons, cursores, etc de um projeto devem residir primeiramente na pasta Resources. A divisão interna desse item fica a critério do designer responsável, pois ele pode dividir tanto por função (Install, Interface) quanto por elementos (Images, Sounds).&lt;/p&gt;
&lt;p&gt;Services. Além dos drivers e das interfaces alguns projetos necessitam de processos &amp;quot;invisíveis&amp;quot; que devem fazer algo no sistema. Isso inclui serviços do Windows, GINAs, componentes COM e coisas do gênero. Devem ser colocados nessa pasta e distribuídos como no exemplo, em Service1 e Service2.&lt;/p&gt;
&lt;p&gt;Tools. Além dos componentes essenciais para o funcionamento do software também existem aqueles componentes que fornecem mais poder ao usuário, ao pessoal do suporte ou ao próprio time de desenvolvimento. Essas são as ferramentas de suporte que permitem a fácil identificação de erros no programa ou a configuração mais avançada de um item que a Interface não cobre. Adicionalmente foi colocada a subpasta Develop, que deve conter ferramentas usadas estritamente durante a fase de desenvolvimento.&lt;/p&gt;
&lt;p&gt;Todos os componentes que disponibilizarem unidades de testes devem conter uma pasta Tests dentro de si. Essa padronização permite facilmente a localização de testes internos aos componentes. Além disso, os arquivos executáveis de testes devem sempre terminar seu nome com Test, o que permite a automatização do processo de teste durante o build.&lt;/p&gt;
&lt;p&gt;Acredito que este esboço esteja muito bom. É o modelo inicial que estou utilizando nos projetos da empresa e de casa.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>VirtualBox</title>
  <link>http://www.caloni.com.br/virtualbox/</link>
  <pubDate>2008-07-04</pubDate>
  
  <guid>http://www.caloni.com.br/virtualbox/</guid>
  <description>&lt;p&gt;O VirtualBox parece ser o concorrente mais próximo atualmente da VMWare. Descobrimos ele essa semana e resolvemos fazer alguns testes. O resultado foi bem animador.&lt;/p&gt;
&lt;p&gt;Desenvolvido pela Sun Microsystems, as características do VirtualBox impressionam pelo cuidado que houve em torná-lo muito parecido com sua concorrente paga. Apenas para começar, ela suporta dispositivos USB, possui múltiplos snapshots e já suporta o modo do VMWare Fusion - chamado de &amp;quot;seamless mode&amp;quot; - , que estará integrado na versão 7 da VMWare.&lt;/p&gt;
&lt;p&gt;No entanto, entre as coisas que testamos (instalado em um Windows Vista SP1 como host), o que não funcionou já não agradou tanto. A lista de prós e contras ainda confirma a liderança da VMWare, pelo menos em qualidade:&lt;/p&gt;
&lt;p&gt;Além da tabela de testes acima, é necessário notar que por mas três vezes a VM simplesmente parou de responder, sendo necessário reiniciar o programa Host.&lt;/p&gt;
&lt;p&gt;Em suma, o VirtualBox tem tudo para arrasar em futuras versões. Se, é claro, conseguir competir em qualidade com a VMWare que, no momento, é a líder em soluções de virtualização. Talvez por isso sua solução não seja tão barata.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Pesquisas sobre a GINA</title>
  <link>http://www.caloni.com.br/pesquisas-sobre-a-gina/</link>
  <pubDate>2008-07-02</pubDate>
  
  <guid>http://www.caloni.com.br/pesquisas-sobre-a-gina/</guid>
  <description>&lt;p&gt;Já sabemos o que é uma GINA. Afinal, todo mundo já viu uma antes. E sabemos que hoje em dia ela está morta.&lt;/p&gt;
&lt;p&gt;No entanto, algumas pequenas mudanças foram feitas nela no Windows XP que ainda almaldiçoam o código de quem tenta reproduzir a famosa GINA da Microsoft. Nem todos chegam no final e morrem tentando.&lt;/p&gt;
&lt;p&gt;Eu sou um deles.&lt;/p&gt;
&lt;p&gt;Uma explicação sobre como funciona o processo de logon (local e remoto) e os componentes envolvidos está no artigo &amp;quot;How Interactive Logon Works&amp;quot; da Technet. Esse artigo irá abrir os olhos para mais detalhes que você gostaria de saber sobre nossa velha e querida amiga. Os desenhos explicativos estão ótimos!&lt;/p&gt;
&lt;p&gt;Após essa leitura picante, podemos voltar ao feijão com arroz e começar de novo lendo a descrição de como funciona a GINA na Wikipedia, que nos remete a vários linques interessantes, entre os quais:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A explicação documentada do MSDN de como funciona a interação entre Winlogon e GINA.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Um ótimo artigo dividido em duas partes que explica como fazer sua própria customização de GINA. Foi nele que encontrei o retorno que precisava para emular a execução do Gerenciador de Tarefas baseado na digitação do Ctrl + Alt + Del. De brinde ainda vem uma GINA de exemplo para &lt;em&gt;download&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A partir de mais algumas buscas e execuções do Process Monitor podemos encontrar os valores no registro que habilitam o Fast User Switching e a Tela de Boas Vindas do Windows XP. O valor da Tela de Boas Vindas é que habilita e desabilita a execução do Gerenciador de Tarefas baseado em Ctrl + Alt + Del. Esses itens são essenciais para os que quiserem criar uma réplica perfeita da GINA da Microsoft no Windows XP. Isso finaliza a minha busca.&lt;/p&gt;
&lt;p&gt;Sempre tem mais. Se a máquina estiver no domínio essa opção não funciona. Porém, o WinLogon verifica se existe um valor chamado ForceFriendlyUi, que descobri graças ao Process Monitor. Aliado ao LogonType, sendo igual a 1, a Tela de Boas-Vindas é habilitada, mesmo em um ambiente com servidor de domínio.&lt;/p&gt;
&lt;p&gt;Por último, claro, salvo se não existir o valor GinaDll dentro da chave do WinLogon. Se esse for o caso, o ForceFriendlyUi também não funciona. E é exatamente aí que uma GINA é instalada.&lt;/p&gt;
&lt;p&gt;E eis que surge uma nova GINA.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Reflexão em C&#43;&#43;</title>
  <link>http://www.caloni.com.br/reflexao-em-c/</link>
  <pubDate>2008-06-30</pubDate>
  
  <guid>http://www.caloni.com.br/reflexao-em-c/</guid>
  <description>&lt;p&gt;O termo e conceito de &amp;quot;reflection)&amp;quot; (reflexão), muito usado em linguagens modernas, é a capacidade de um programa de observar e até de alterar sua própria estrutura. Bom, isso você pode ler na Wikipédia. O interessante é o que podemos usar desse conceito na linguagem C++.&lt;/p&gt;
&lt;p&gt;Infelizmente não muito.&lt;/p&gt;
&lt;p&gt;O sistema de RTTI (Run Time Type Identification), a identificação de tipos em tempo de execução, seria o começo do reflection em C++. Foi um começo que não teve meio nem fim, mas existe na linguagem. Dessa forma podemos tirar algum proveito disso.&lt;/p&gt;
&lt;p&gt;Um leitor pediu para que eu falasse um pouco sobre essas coisas, especificamente como se faz para obter o nome da classe de onde estamos executando um determinado método. Para esse tipo de construção podemos usar o operado typeid, que retorna informações básicas sobre um tipo de acordo com um tipo, instância ou expressão:&lt;/p&gt;
&lt;p&gt;Dessa forma, podemos nos aproveitar do fato que todo método não-estático possui a variável implícita this, do tipo &amp;quot;ponteiro constante para T&amp;quot;, onde T é o tipo da classe que contém o método sendo chamado.&lt;/p&gt;
&lt;p&gt;class MyClass::MyMethod&lt;/p&gt;
&lt;p&gt;Com classes não-polimórficas a coisa parece não ter muita utilidade. No entanto, essa mesma técnica pode ser aplicada em classes derivadas, uma vez que o operador typeid pode trabalhar em tempo de execução:&lt;/p&gt;
&lt;p&gt;Apenas se lembre de ter de fato uma classe polimórfica (eu consegui isso tornando MyMethod uma função virtual). Do contrário você pode ter problemas.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Primeiros passos na documentação de código-fonte usando Doxygen</title>
  <link>http://www.caloni.com.br/primeiros-passos-na-documentacao-de-codigo-fonte-usando-doxygen/</link>
  <pubDate>2008-06-26</pubDate>
  
  <guid>http://www.caloni.com.br/primeiros-passos-na-documentacao-de-codigo-fonte-usando-doxygen/</guid>
  <description>&lt;p&gt;Comentários são essenciais em um código-fonte bem feito. O código pode até fazer milagres, salvar vidas e multiplicar pães, mas se não tiver um apóstolo eficiente que escreva um evangelho para ele, as pessoas não vão conseguir usar!&lt;/p&gt;
&lt;p&gt;OK, a analogia foi horrível.&lt;/p&gt;
&lt;p&gt;Bom, já que é pra fazer comentários, porque não fazê-los de uma forma que seja possível extrair todo esse texto diretamente do fonte e transformá-lo em documentação? Dessa forma você evita ter que abrir o Word (arght!) e evita que a documentação fique desatualizada quando o documentador do seu projeto for embora da empresa.&lt;/p&gt;
&lt;p&gt;Vocês não têm documentador no projeto? Ah, tá. Bem-vindo ao grupo.&lt;/p&gt;
&lt;p&gt;O Doxygen é uma ferramenta que consegue extrair comentários do seu código-fonte, formatados ou não, e transformar em arquivos html, doc, chm, etc. O resultado é muito impressionante, pois ele é capaz de interpretar algumas linguagens (como C++) e mostrar a hierarquia de classes e funções.&lt;/p&gt;
&lt;p&gt;Ele não obriga que o desenvolvedor formate corretamente os comentários, mas ao fazer isso podemos descrever o funcionamento exato de funções de interface, como o que cada parâmetro significa, o valor de retorno, algumas observações quanto ao uso, etc.&lt;/p&gt;
&lt;p&gt;Aprender a usar Doxygen é muito fácil. Ele possui uma ajuda com vários exemplos com os quais podemos começar a programar um código auto-documentado.&lt;/p&gt;
&lt;p&gt;Por ser uma ferramenta bem flexível, são permitidos inúmeros formatos para se auto-documentar o código. Vou descrever como eu faço, mas pode ser que outro formato lhe agrade mais. Para conhecê-los, dê uma olhada no manual.&lt;/p&gt;
&lt;p&gt;A primeira coisa a saber sobre comentários de documentação é que eles devem vir sempre ANTES do elemento que estamos comentando. Por exemplo, uma classe:&lt;/p&gt;
&lt;p&gt;Note que o comentário inicia com um duplo asterisco &amp;quot;/&amp;quot;. Isso indica ao Doxygen que vem documentação por aí.&lt;/p&gt;
&lt;p&gt;Observe que seria mais simples que o Doxygen pegasse todo e qualquer comentário e transformasse em documentação. No entanto, existem comentários que não devem ser publicados, pois são muito específicos do funcionamento interno da função. Dessa forma o programa-documentador lhe dá a liberdade de fazer comentários documentáveis e não-documentáveis.&lt;/p&gt;
&lt;p&gt;Também existe um outro formato bem popular, usado pelo pessoal do Java, que são os comentários que se iniciam com três barras:&lt;/p&gt;
&lt;p&gt;Além desse estilo de comentário, existem campos-chave que podemos colocar. Para definir um campo-chave, uma forma válida é usar o arroba seguido do seu nome, e a descrição. Eis um exemplo cheio deles:&lt;/p&gt;
&lt;p&gt;Vejamos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;brief. Serve como descrição inicial e sucinta do que a função faz. Mais explicações podem existir depois dessa primeira linha introdutória.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;param. Descreve o objetivo de um parâmetro, assim como se ele é de entrada ou saída.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;return. Explica os diversos retornos que a função pode ter.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;remark. Observações especiais que podem ajudar quem chama a função.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Existem diversos outros tipos de marcadores e com certeza você encontrará muita utilidade em outros. No entanto, esse é o basico que todo desenvolvedor do seu time deve saber para já começar a documentar suas funções.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Usando o Doxygen (Parte 1 e Parte 2) - Daniel Quadros&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Como estou trabalhando com o Bazaar</title>
  <link>http://www.caloni.com.br/como-estou-trabalhando-com-o-bazaar/</link>
  <pubDate>2008-06-24</pubDate>
  
  <guid>http://www.caloni.com.br/como-estou-trabalhando-com-o-bazaar/</guid>
  <description>&lt;p&gt;Depois de alguns ajustes e muitas perguntas do meu amigo-colega desenvolvedor Rafael, conseguimos definir alguns usos e costumes em nosso código controlado pelo Bazaar. Este é um guia para Dummies de como é possível organizar um ou mais projetos de forma a favorecer o refactoring e a liberdade de uso.&lt;/p&gt;
&lt;p&gt;Nosso padrão de diretórios utiliza um repositório compartilhado e dentro, na mesma ramificação, os branches. O branch principal tem o mesmo nome do projeto. Isso na máquina de um desenvolvedor ficaria:&lt;/p&gt;
&lt;p&gt;No servidor de fontes geralmente teremos apenas o branch principal, apesar de que o desenvolvimento em paralelo seja permitido:&lt;/p&gt;
&lt;p&gt;Foi criado um projeto modelo para que todos os projetos herdassem seu histórico. Para que isso? Bom, na eventualidade de partes de um projeto irem parar em outro (isso quase nunca acontece), isso pode ser feito sem perder todo o histórico do início do projeto.&lt;/p&gt;
&lt;p&gt;Resumindo: todos os projetos novos são branches do projeto-modelo.&lt;/p&gt;
&lt;p&gt;Como podemos ver acima, o projeto modelo segue o mesmo padrão de repositório compartilhado. Os projetos que criarmos serão baseados nesse projeto modelo, mas em outro repositório compartilhado.&lt;/p&gt;
&lt;p&gt;A ramificação dos projetos estará sempre no mesmo lugar, independente da pasta raiz.&lt;/p&gt;
&lt;p&gt;O controle distribuído de fontes não significa que não existe um servidor. Existe. O detalhe é que todos os desenvolvedores guardam todo o histórico do projeto com eles, igualzinho o servidor, que é apenas mais uma máquina com mais um branch.&lt;/p&gt;
&lt;p&gt;O repositório do servidor pode ser criado com a opção que não cria o diretório de trabalho, que é onde os programadores mexem no código-fonte. Sendo um servidor, o código-fonte não é necessário, só a base de dados:&lt;/p&gt;
&lt;p&gt;O Bazzar possui um esquema de servidor embutido nele, que fica escutando em uma porta e se comunica em um protocolo otimizado. Nós gostamos desse esquema, pois protege os projetos de acidentes de usuários que podem apagar uma pasta sem querer.&lt;/p&gt;
&lt;p&gt;Para manter o Bazaar eternamente rodando, usamos o programa do DriverEntry que transforma qualquer coisa no formato de um serviço de gelo.&lt;/p&gt;
&lt;p&gt;Ou não sei usar direito esse programa ou ele não permite uso de aspas no nome do aplicativo junto de argumentos. Por isso tive que editar o registro onde ele fica para colocar aspas duplas em torno do bzr.exe.&lt;/p&gt;
&lt;p&gt;Após isso, ainda temos que configurar o serviço para iniciar automaticamente e usar um usuário conhecido. Enquanto o computador estiver ligado, mesmo que sem sessões abertas, nenhuma tela irá aparecer, mas o Bazaar estará rodando e ativo, escutando em sua porta padrão:&lt;/p&gt;
&lt;p&gt;Se estiver tudo certo, ao iniciar o serviço o Bazaar passará a ficar escutando e pronto para fazer commits e branches.&lt;/p&gt;
&lt;p&gt;Agora qualquer usuário da rede consegue fazer updates e commits. Um desenvolvedor novo faria o seguinte comando:&lt;/p&gt;
&lt;p&gt;Note que o usuário do Bazaar não é obrigado a criar um repositório compartilhado. Esse foi um padrão definido aqui e não necessariamente é o melhor.&lt;/p&gt;
&lt;p&gt;O Bazaar por ser muito flexível entra naquela categoria de &amp;quot;Difícil de acertar a maneira certa de utilizar&amp;quot;. Bom, mais ou menos. Eu sinceramente não acho que exista uma maneira errada de usar o Bazaar, mas vamos ver as maneiras mais comuns, que não são exclusivas entre si.&lt;/p&gt;
&lt;p&gt;É aquele que prefere fazer tudo localmente e só depois, bem depois, mandar seus commits para o servidor. Nesse caso o comando para começar a programar é branch.&lt;/p&gt;
&lt;p&gt;Nesse esquema o servidor e a máquina do desenvolvedor não trocam idéia se ele não quiser. Quando quiser, pode usar os comandos push, pull e merge. O push coloca coisas novas no servidor; o pull puxa coisas novas do servidor, e o merge é necessário quando existem conflitos entre as mudanças no fonte. Mais sobre conflitos em um futuro artigo.&lt;/p&gt;
&lt;p&gt;É o cara que quer sempre atualizar todas as modificações que ele faz imediatamente colocadas no servidor. Tudo bem. É só trabalhar no modo Source Safe (ou Subversion) com o comando checkout:&lt;/p&gt;
&lt;p&gt;Um checkout funciona como o branch, só que faz um bind (ligação) com o servidor. O que quer dizer que qualquer commit feito localmente irá parar imediatamente também no servidor, a não ser que seja usado o parâmetro --local.&lt;/p&gt;
&lt;p&gt;O modo checkout permite usar o comando update para ver se existem mudanças entre a máquina local e o servidor, diferente do modo standalone, onde o update apenas compara com o branch local e o diretório de trabalho.&lt;/p&gt;
&lt;p&gt;Como eu havia dito, uma coisa não exclui outra. Se você está trabalhando em um branch e deseja se conectar ao servidor para atualizar mudanças, basta usar o comando bind.&lt;/p&gt;
&lt;p&gt;O branch começará a trabalhar como um checkout.&lt;/p&gt;
&lt;p&gt;O contrário, que é fazer um checkout ficar desconectado é conseguido pelo comando unbind.&lt;/p&gt;
&lt;p&gt;Todos os novos commits serão feitos apenas localmente.&lt;/p&gt;
&lt;p&gt;Esses esquemas de conectado e desconectado podem ser usados no modo cliente x servidor ou tudo em uma máquina só. Por exemplo, uma série de mudanças em um projeto pode ser feito em um outro branch desconectado:&lt;/p&gt;
&lt;p&gt;Os commits de &amp;quot;novo-branch&amp;quot; não serão replicados para o branch &amp;quot;projeto&amp;quot;.&lt;/p&gt;
&lt;p&gt;No entanto, se é uma série de mudanças que devem ser colocadas imediatamente no branch principal, pode-se usar checkout.&lt;/p&gt;
&lt;p&gt;Existem diversas outras formas de usar o Bazaar, e isso está sob o controle do desenvolvedor. O importante para quem está migrando é saber definir alguns padrões (onde é o servidor principal, ramificação dos projetos) e o resto é só programar, exatamente como antes.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
</description>
</item>

     
        <item>
  <title>É possível carregar duas DLLs gêmeas no mesmo processo?</title>
  <link>http://www.caloni.com.br/e-possivel-carregar-duas-dlls-gemeas-no-mesmo-processo/</link>
  <pubDate>2008-06-21</pubDate>
  
  <guid>http://www.caloni.com.br/e-possivel-carregar-duas-dlls-gemeas-no-mesmo-processo/</guid>
  <description>&lt;p&gt;Um dos últimos artigos de Dmitry Vostokov, e tenho que falar assim porque o cara escreve muito em pouco tempo, fala sobre os perigos de termos uma mesma DLL carregada duas vezes em um único processo, muitas vezes em versões diferentes. Para os observadores atentos como Dmitry esse é um perigo que muitas vezes temos que estar preparados. Para os espertinhos de plantão, a resposta padrão seria: &amp;quot;não vou me preocupar, porque o contador de instâncias cuida disso&amp;quot;.&lt;/p&gt;
&lt;p&gt;Será mesmo tão simples?&lt;/p&gt;
&lt;p&gt;Vamos supor um caso bem simples e plausível, que é exatamente o mesmo do artigo do Crash Dump Analysis: um produto qualquer possui dois pontos em que ele carrega a mesma DLL. Contudo, no primeiro ponto é usado um caminho relativo, dentro da pasta DLL; na segunda chamada é usado o caminho atual. Se existir de fato duas DLLs, mesmo que idênticas, nesses lugares, então teremos duas instâncias da &amp;quot;mesma DLL&amp;quot; carregadas no processo.&lt;/p&gt;
&lt;p&gt;O código do aplicativo apenas tenta carregar a DLL em dois lugares distintos e exibe o endereço para onde elas foram mapeadas em nosso processo de teste:&lt;/p&gt;
&lt;p&gt;A DLL é uma DLL trivial:&lt;/p&gt;
&lt;p&gt;Vamos aos testes.&lt;/p&gt;
&lt;p&gt;Nesse caso, ambos os retornos serão nulos, que é o natural e esperado quando a DLL não pode ser encontrada nos lugares especificados pelo sistema e pelo aplicativo.&lt;/p&gt;
&lt;p&gt;No segundo caso, a DLL é carregada com sucesso se usado o caminho relativo, pois o caminho atual faz parte da lista de caminhos que o sistema percorre para encontrá-la. A primeira chamada deve falhar.&lt;/p&gt;
&lt;p&gt;No caso problemático, a mesma DLL é carregada em dois endereços distintos da memória do mesmo processo, o que pode causar sérios problemas dependendo do código envolvido.&lt;/p&gt;
&lt;p&gt;Apesar do mundo parecer injusto, temos uma segunda regra que podemos usar para aqueles casos onde a idiotisse já foi feita:&lt;/p&gt;
&lt;p&gt;Vamos supor que estamos no meio de uma mudança bem radical no produto e queremos ter certeza que qualquer chamada à nossa DLL irá invocar unicamente a que estiver dentro do caminho do produto (caminho atual). Para esse caso o Windows permite uma saída muito interessante, que é o uso de um arquivo com o nome do aplicativo mais o sufixo &amp;quot;.local&amp;quot;. Se esse arquivo existir, de acordo com o MSDN.aspx), então qualquer chamada à DLL irá ter sempre a prioridade do caminho atual.&lt;/p&gt;
&lt;p&gt;Tente evitar a replicação do mesmo arquivo em diversos lugares. Quando eu digo &amp;quot;mesmo arquivo&amp;quot; me refiro ao mesmo nome de DLL, embora não necessariamente a mesma versão. Isso pode evitar algumas dores de cabeça futuras. E muitas, muitas horas de depuração.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Alinhamento de memória portável</title>
  <link>http://www.caloni.com.br/alinhamento-de-memoria-portavel/</link>
  <pubDate>2008-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/alinhamento-de-memoria-portavel/</guid>
  <description>&lt;p&gt;Como vimos durante o seminário CCPP, o alinhamento de memória pode ser problemático durante momentos críticos, como migração de plataforma (16 para 32 bits) e de ambiente (compilador novo). A forma como a memória é alinhada influi diretamente em algoritmos de criptografia, por exemplo, fazendo com que o que funcionava antes não funcione mais sem mexer uma única linha de código. Eu já vi isso. E isso não é bom.&lt;/p&gt;
&lt;p&gt;A raiz do problema é que, dependendo do alinhamento usado pelo compilador, o sizeof de uma variável pode mudar de valor, mesmo que o tamanho útil não mude. Por exemplo, vamos supor que temos uma dada estrutura que iremos encriptar:&lt;/p&gt;
&lt;p&gt;Se usarmos a construção &amp;quot;sizeof(EstruturaQueIremosEncriptar)&amp;quot;, podemos obter o valor 35 caso o alinhamento seja feito em 1 byte, ou podemos obter o valor 40 se o alinhamento estiver configurado em 8 bytes. E é aí que começa o problema.&lt;/p&gt;
&lt;p&gt;Já pensando nesse problema, os projetistas de vários compiladores suportam uma extensão não-padrão que permite definir, para um dado conjunto de estruturas e variáveis, o alinhamento que deve ser seguido. Isso de cara já resolve o problema, SE sua solução usar apenas compiladores que suportem essa idéia. No Visual C++ essa idéia é traduzida por uma diretiva pragma:&lt;/p&gt;
&lt;p&gt;A diretiva pragma está definida no padrão C (6.8.6) e C++ (16.6) e seu uso não torna um programa não-padrão. No entanto, o que vai depois da diretiva é dependente da implementação e não é garantido que irá funcionar.&lt;/p&gt;
&lt;p&gt;Pronto, nossa estrutura sempre terá 40 bytes ocupados na memória, pois o alinhamento foi forçado em 8 bytes. Resolvido.&lt;/p&gt;
&lt;p&gt;Existem aqueles compiladores que não suportam essa idéia da mesma forma, ou não suportam de jeito nenhum. Para esses casos, alguns desvios de comportamento são necessários. A grande pergunta é se isso é possível de ser feito de forma 100% padrão.&lt;/p&gt;
&lt;p&gt;Pelo que eu pude constatar, existe, sim.&lt;/p&gt;
&lt;p&gt;O código acima usa o conceito de união de estruturas (union) para fazer valer um alinhamento na marra (no caso, 8). Para os que não conhecem unions, é necessário uma breve explicação do conceito.&lt;/p&gt;
&lt;p&gt;Uma estrutura, como todos sabem, amontoa os seus membros um após o outro na memória. Dessa forma podemos tratar um bloco de memória com um leiaute que definimos com outros tipos:&lt;/p&gt;
&lt;p&gt;Em uma união, os membros não são amontoados um após o outro. Todos eles começam no mesmo ponto da memória. Eles se sobrescrevem. O tamanho da união sempre é o tamanho do seu maior membro, e não a soma de todos. É um tanto difícil de descrever esse leiaute, mas imagine que você tenha apenas uma posição na memória e queira chamá-la de vários nomes e tamanhos diferentes. Essa é a união.&lt;/p&gt;
&lt;p&gt;Como deve ser fácil de imaginar, uma união não tem tanto uso quanto uma estrutura, mas ainda assim faz parte da linguagem. Ela possibilita enxergar a mesma região de memória sob vários ângulos. Podemos descobrir a organização de um inteiro na memória, por exemplo, byte a byte:&lt;/p&gt;
&lt;p&gt;Dependendo se a plataforma onde o programa acima é compilado, a exibição do último printf pode mudar. Eis o motivo.&lt;/p&gt;
&lt;p&gt;Agora que sabemos o que são uniões fica fácil entender o esquema da solução portável. Eu simplesmente uso a segunda estrutura como uma auxiliar de alinhamento. Com ela do tamanho múltiplo do alinhamento desejado forçamos a união inteira a ter esse alinhamento, independente do tamanho da estrutura útil, a que iremos usar para armazenar dados.&lt;/p&gt;
&lt;p&gt;Tudo que temos que saber para fazer o alinhamento é o tamanho normal de nosso tipo útil (o Teste). A partir desse valor deduzimos o próximo número que seja múltiplo de 8, através da seguinte construção:&lt;/p&gt;
&lt;p&gt;Ou seja, se já for múltiplo de 8, é o próprio valor. Se não for, então dividimos por 8 e multiplicamos pelo mesmo valor adicionado de um, o que nos retorna o próximo múltiplo.&lt;/p&gt;
&lt;p&gt;É lógico que, como se trata de uma construção onde temos completo domínio dos tipos e valores envolvidos, transformar isso em um template é &amp;quot;pedaço de torta&amp;quot;.&lt;/p&gt;
&lt;p&gt;E essa é a melhor parte de descobrir um padrão em um tipo: o template nasce quase que naturalmente. A beleza da linguagem floresce.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como fazer merge de projetos distintos no Bazaar</title>
  <link>http://www.caloni.com.br/como-fazer-merge-de-projetos-distintos-no-bazaar/</link>
  <pubDate>2008-06-16</pubDate>
  
  <guid>http://www.caloni.com.br/como-fazer-merge-de-projetos-distintos-no-bazaar/</guid>
  <description>&lt;p&gt;O problema foi o seguinte: Nós iniciamos o controle de fonte pelo Bazaar na parte Linux do projeto, já que ela não iria funcionar pelo Source Safe, mesmo. Dessa forma apenas um braço do projeto estava no controle de fonte e o resto não.&lt;/p&gt;
&lt;p&gt;No segundo momento da evolução decidimos começar a migrar os projetos para o Bazaar, inclusive a parte daquele projeto que compila no Windows. Maravilha. Ambos sendo controlados é uma beleza, não é mesmo?&lt;/p&gt;
&lt;p&gt;Até que veio o dia de juntar.&lt;/p&gt;
&lt;p&gt;O processo de merge de um controle de fonte supõe que os branches começaram em algum ponto em comum; do contrário não há como o controlador saber as coisas que mudaram em paralelo. Pois é achando a modificação ancestral, pai de ambos os branches, que ele irá medir a dificuldade de juntar as versões novamente. Se não existe ancestral, não existe análise. Como exemplificado na figura:&lt;/p&gt;
&lt;p&gt;Acontece que existe um plugin esperto que consegue migrar revisões (commits) entre branches sem qualquer parentesco. Não me pergunte como ele faz isso. Mas ele faz. E foi assim que resolvemos o problema dos branches órfãos.&lt;/p&gt;
&lt;p&gt;Para instalar o plugin do rebase, basta baixá-lo e copiar sua pasta extraída com um nome válido no Python (rebase, por exemplo). A partir daí os comandos do plugin estão disponíveis no prompt do Bazaar, assim como a instalação de qualquer plugin que cria novos comandos.&lt;/p&gt;
&lt;p&gt;O comando que usamos foi o replay, que não é comando principal do plugin, mas que resolve esse problema de maneira quase satisfatória. Como era tudo o que tínhamos, valeu a pena.&lt;/p&gt;
&lt;p&gt;O processo que usei foi de usar esse comando n vezes para buscar revisões de um branch e colocar no outro. Um grande problema com ele é que ao encontrar merges no branch origem ele se perde e o usuário tem que fazer as modificações &amp;quot;na mão&amp;quot;. Deu um pouco de trabalho, mas conseguimos migrar nossos commits mais importantes e deixar o projeto inteiro, Linux+Windows, em um branch só.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Guia básico de repositórios no Bazaar</title>
  <link>http://www.caloni.com.br/guia-basico-de-repositorios-no-bazaar/</link>
  <pubDate>2008-06-10</pubDate>
  
  <guid>http://www.caloni.com.br/guia-basico-de-repositorios-no-bazaar/</guid>
  <description>&lt;p&gt;Alguns conceitos-chave antes de trabalhar com o Bazaar são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Revision (Revisão). Um snapshot dos arquivos que você está trabalhando.&lt;/li&gt;
&lt;li&gt;Working Tree (Árvore de Trabalho). Um diretório contendo seus arquivos controlados por versão e subdiretórios.&lt;/li&gt;
&lt;li&gt;Branch (Ramificação). Um grupo ordenado de revisões que descreve o histórico de um grupo de arquivos.&lt;/li&gt;
&lt;li&gt;Repository (Repositório). Um depósito de revisões.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agora vamos brincar um pouco com os conceitos.&lt;/p&gt;
&lt;p&gt;O uso mais simples que existe no Bazaar é o controle de uma pasta sozinha, conhecida como uma Standalone Tree. Como toda Working Tree, ela possui um repositório relacionado, que no caso está dentro dela mesmo, na pasta oculta &amp;quot;.bzr&amp;quot;.&lt;/p&gt;
&lt;p&gt;Pra criar uma Standalone Tree, tudo que precisamos é usar o comando init de dentro da pasta a ser controlada, quando é criado um repositório local. Adicionamos arquivos para o repositório com o comando add, e finalizamos nossa primeira versão com o comando commit.&lt;/p&gt;
&lt;p&gt;Feito. A partir daí temos um repositório onde podemos realizar o comando commit sempre que quisermos marcar um snapshot em nosso código-fonte.&lt;/p&gt;
&lt;p&gt;Se quisermos fazer uma alteração muito grande em nosso pequeno projeto seria melhor termos outro diretório onde trabalhar antes de realizar o commit na versão estável. Para isso podemos usar o comando branch, que cria uma nova pasta com todo o histórico da pasta inicial até esse ponto. Os históricos em um branch estão duplicados em ambas as pastas, e portanto são independentes. Você pode apagar a pasta original ou a secundária que terá o backup inteiro no novo branch.&lt;/p&gt;
&lt;p&gt;Criar um novo branch totalmente duplicado pode se tornar um desperdício enorme de espaço em disco (e tempo). Para isso foi criado o conceito de Shared Repository, que basicamente é um diretório acima dos branchs que trata de organizar as revisões em apenas um só lugar, com a vantagem de otimizar o espaço. Nesse caso, antes de criar o projeto, poderíamos usar o comando init-repo na pasta mãe de nosso projeto, e depois continuar com o processo de init dentro da pasta do projeto.&lt;/p&gt;
&lt;p&gt;Se compararmos o tamanho, veremos que o repositório compartilhado é que detém a maior parte dos arquivos, enquanto agora o &amp;quot;.bzr&amp;quot; que está na pasta do projeto possui apenas dados de controle. A mesma coisa irá acontecer com qualquer branch criado dentro da pasta de repositório compartilhado.&lt;/p&gt;
&lt;p&gt;Mas já criamos nossos dois branches cheios de arquivos, certo? Certo. Como já fizemos isso, devemos criar uma nova pasta como repositório compartilhado e criar dois novos branches dentro dessa pasta, cópias dos dois branches gordinhos:&lt;/p&gt;
&lt;p&gt;Isso irá recriar esses dois branches como os originais, mas com a metade do espaço em disco, pois seus históricos estarão compartilhados na pasta project1-repo.&lt;/p&gt;
&lt;p&gt;O SubVersion é um sistema de controle centralizado. O Bazaar consegue se comportar exatamente como o SubVersion, além de permitir carregar o histórico inteiro consigo. Quem decide como usá-lo é apenas você, pois cada usuário do sistema tem a liberdade de escolher a melhor maneira.&lt;/p&gt;
&lt;p&gt;Os comandos para usar o Bazaar à SubVersion são os mesmos do SubVersion: checkout e commit. No entanto, um checkout irá fazer com que seu commit crie a nova revisão primeiro no seu servidor (branch principal) e depois localmente. Se você não deseja criar um histórico inteiro localmente, pode criar um checkout leve (parâmetro --lightweight), que apenas contém arquivos de controle. No entanto, se o servidor de fontes não estiver disponível, você não será capaz de ações que dependam dele, como ver o histórico ou fazer commits.&lt;/p&gt;
&lt;p&gt;Na verdade, o Bazaar vai além, e permite que um branch/checkout específico seja conectado e desconectado em qualquer repositório válido. Para isso são usados os comandos bind e unbind. Um branch conectado faz commits remotos e locais, enquanto um branch unbinded faz commits apenas locais. É possível mudar esse comportamento com o parâmetro --local, e atualizar o branch local com o comando update.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Bazaar User Guide&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bazaar User Reference&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Declaração x definição</title>
  <link>http://www.caloni.com.br/declaracao-x-definicao/</link>
  <pubDate>2008-06-06</pubDate>
  
  <guid>http://www.caloni.com.br/declaracao-x-definicao/</guid>
  <description>&lt;p&gt;Uma diferença que eu considero crucial na linguagem C/C++ é a questão da declaração/definição (em inglês, declaration/definition). É a diferença entre esses dois conceitos que permite, por exemplo, que sejam criadas estruturas prontas para serem conectadas a listas ligadas:&lt;/p&gt;
&lt;p&gt;Por outro lado, e mais importante ainda, é ela que permite que as funções sejam organizadas em unidades de tradução (cpps) distintas para depois se unirem durante o link, mesmo que entre elas exista uma relação de dependência indissociável:&lt;/p&gt;
&lt;p&gt;Existem diversas formas de entender esses dois conceitos. Eu prefiro explicar pela mesma experiência que temos quando descobrimos a divisão hardware/software:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardware é o que você chuta&lt;/li&gt;
&lt;li&gt;Software é o que você xinga&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Exatamente. Hardware é algo paupável, que você pode até chutar se quiser. Por exemplo, a sua memória RAM! No entanto, software é algo mais abstrato, que nós, seres humanos, não temos a capacidade de dar umas boas pauladas. Portanto, nos abstemos a somente xingar o maldito que fez o programa &amp;quot;buggento&amp;quot;.&lt;/p&gt;
&lt;p&gt;Da mesma forma, uma declaração em C/C++ nos permite moldar como será alguma coisa na memória, sem no entanto ocupar nem um mísero byte no seu programa:&lt;/p&gt;
&lt;p&gt;Por outro lado, a definição, o hardware da história, sempre ocupará alguma coisa na memória RAM, o que, de certa forma, permite que você chute uma variável (embora muitas outras também irão para o saco).&lt;/p&gt;
&lt;p&gt;Dessa comparação só existe uma pegadinha: uma definição também é uma declaração. Por exemplo, nos exemplos acima, além de definir func, tst e x, o código também informa ao compilador que existe uma função chamada func, que existe uma variável tst do tipo Teste e uma variável x do tipo int.&lt;/p&gt;
&lt;p&gt;Informa ao compilador? Essa é uma outra ótima maneira de pensar a respeito de declarações: elas sempre estão conversando diretamente com o compilador. Por outro lado, nunca conversam diretamente com o hardware, pois ao executar seu código compilado, as declarações não mais existem. Foi apenas um interlúdio para que o compilador conseguisse alocar memória da maneira correta.&lt;/p&gt;
&lt;p&gt;Complicado? Talvez seja, mesmo. Mas é algo que vale a pena fixar na mente. Isso, é claro, se você quiser ser um programador C/C++ mais esperto que os outros e resolver pequenos problemas de compilação que muitos perdem horas se perdendo.&lt;/p&gt;
&lt;p&gt;Então por que diabos a separação declaração/definição consegue definir coisas como listas ligadas, como no código acima? A resposta é um pouco ambígua, mas representa regra essencial na sintaxe da linguagem: após a definição do nome e do tipo de declaração envolvida podemos referenciá-la como declaração, ou seja, não ferindo a limitação de que não sabemos o tamanho de uma variável do tipo declarado. Dessa forma, é perfeitamente legal definirmos um ponteiro para uma estrutura que ainda não se sabe muita coisa, além de que é uma estrutura:&lt;/p&gt;
&lt;p&gt;Dessa forma, o começo de uma definição de estrutura já declara o nome da estrutura antes de terminar a declaração do tipo inteiro. Bizarro, não? De qualquer forma, isso permite a construção clássica de lista ligada:&lt;/p&gt;
&lt;p&gt;Se vermos pelo lado prático, de qualquer forma seria impossível definir uma variável dentro dela mesma, pois isso geraria uma recursão infinita de definições, e, como sabemos, os recurso da máquina são finitos.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Launchpad e a democracia do código-fonte</title>
  <link>http://www.caloni.com.br/launchpad-e-a-democracia-do-codigo-fonte/</link>
  <pubDate>2008-06-04</pubDate>
  
  <guid>http://www.caloni.com.br/launchpad-e-a-democracia-do-codigo-fonte/</guid>
  <description>&lt;p&gt;Após a publicação dos projetos que ando mexendo no próprio saite do Caloni.com.br, recebi uma enxurrada de downloads e quase atingi meu limite de fluxo mensal no provedor.&lt;/p&gt;
&lt;p&gt;Devido a esse problema inesperado, irei fazer o inevitável: publicar os projetos em um repositório sério. E aproveitando que já estou usando o Bazaar, nada melhor que usar o Launchpad.net.&lt;/p&gt;
&lt;p&gt;O Launchpad nada mais é do que um lugar onde é possível publicar seus projetos de fonte aberto para que pessoas possam ter livre acesso ao seu histórico de mudanças, assim como a liberdade de criar sua própria ramificação (branch). O esquema todo é organizado no formato comunidade, o que permite o compartilhamento não só de código, mas de bugs, traduções e, principalmente, idéias.&lt;/p&gt;
&lt;p&gt;A idéia é uma das primeiras que usa a modalidade de controle de fonte distribuído, e permite o uso do Bazaar como o controlador oficial, ou importação de outros controles de fonte, em um processo conhecido como espelhamento. Tudo foi feito de forma a amenizar o processo de migração dos sistemas de controle de código centralizado, como CVS e Subversion.&lt;/p&gt;
&lt;p&gt;Para ter acesso aos meus projetos iniciais é simples: basta usar o mesmo comando que é usado para obter um novo branch de um projeto do Bazaar:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MouseTool - Simulador de clique de mouse&lt;/li&gt;
&lt;li&gt;Influence Board - Complemento ao Winboard que mostra a influência das peças&lt;/li&gt;
&lt;li&gt;Conversor Houaiss Babylon - Converte de um dicionário para o outro&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Como o Bazaar foi feito integrado com o Launchpad, também é possível usar um comando bem mais fácil:&lt;/p&gt;
&lt;p&gt;Assim como é possível usar comandos de repositório, também é possível navegar pelo histórico de mudanças do projeto simplesmente usando os linques acima no navegador de sua preferência. E é nessa hora que começa a ficar interessante publicar seu projeto na web. Por falar nisso, que tal aprender como&lt;/p&gt;
&lt;p&gt;Tudo que precisamos é de um login, facilmente obtido na página principal, e de registrar um projeto. Para criar o primeiro branch e fazermos alterações precisaremos também de um par de chaves pública e privada para a conexão SSH criada automaticamente pelo Bazaar. Tudo isso é facilmente possível com o uso das ferramentas do Putty, um cliente SSH para Windows.&lt;/p&gt;
&lt;p&gt;Dessa forma os passos são os seguintes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Criar um login&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Registrar um projeto&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Criar um par de chaves através do PuTTYgen&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ATENÇÃO
Devido a alguns problemas, recomendo que use o texto exibido na tela do gerador de chaves em vez de copiar diretamente do arquivo da chave pública para o cadastro no saite. Guarde bem essas chaves com você, pois você as usará sempre que necessário fazer uma modificação no projeto.&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;Atualizar no cadastro do saite (item &amp;quot;Update SSH keys&amp;quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Usar o Pageant para carregar a chave privada na memória&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Use os comandos do Bazaar passando o usuário e o branch:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Simples e direto. E funciona!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como criar uma LIB no Visual Studio</title>
  <link>http://www.caloni.com.br/como-criar-uma-lib-no-visual-studio/</link>
  <pubDate>2008-05-29</pubDate>
  
  <guid>http://www.caloni.com.br/como-criar-uma-lib-no-visual-studio/</guid>
  <description>&lt;p&gt;Quando se está começando no ramo, alguns detalhes nunca vêm à tona para o programador novato. Ele simplesmente vai codando até se sentir satisfeito com o prazer que é proporcionado pela prática da arte dos deuses de silício.&lt;/p&gt;
&lt;p&gt;Isso, em termos práticos, quer dizer que todo o fonte vai ser escrito no mesmo &amp;quot;.c&amp;quot;, que aliás talvez nem se dê ao luxo de possuir seu próprio &amp;quot;.h&amp;quot;: pra quê, se as funções são todas amigas de infância e todas se conhecem?&lt;/p&gt;
&lt;p&gt;No começo não existe nenhum problema, mesmo. O fonte vai ser pequeno. A coisa só complica quando não dá mais pra se achar no meio de tantos gotos e ifs aninhados. Talvez nessa hora o programador já-não-tão-novato até tenha descoberto que é possível criar vários arquivos-fonte e reuni-los em um negócio chamado projeto, e que existem IDEs, como o Visual Studio, que organizam esses tais projetos.&lt;/p&gt;
&lt;p&gt;A partir daí, para chegar em uma LIB, já é meio caminho andado.&lt;/p&gt;
&lt;p&gt;Boa pergunta. Uma LIB, ou biblioteca, nada mais é do que um punhado de &amp;quot;.obj&amp;quot; colocados todos no mesmo arquivo, geralmente um &amp;quot;.lib&amp;quot;. Esses &amp;quot;.obj&amp;quot; são o resultado da compilação de seus respectivos &amp;quot;.c&amp;quot; de origem.&lt;/p&gt;
&lt;p&gt;Alguns acreditam ser esse negócio de LIB uma pura perda de tempo, pois existem trocentas configurações diferentes (e incompatíveis) e trocentas compilações diferentes para gerenciar. Outros acham que o problema está no tempo de compilação, enquanto outros defendem o uso dos &amp;quot;.obj&amp;quot; de maneira separada. Esse artigo não presume que nem um nem outro seja melhor. Apenas ensina o que você precisa saber para criar sua primeira LIB usando o Visual Studio Express.&lt;/p&gt;
&lt;p&gt;Vamos lá?&lt;/p&gt;
&lt;p&gt;Após abrir o VS, tudo que precisamos fazer é ir em New, Project, e escolher a configuração de &amp;quot;Win32 Project&amp;quot;:&lt;/p&gt;
&lt;p&gt;A seguir, escolhemos nas opções do assistente criar uma &amp;quot;Static library&amp;quot;, e desmarcamos a opção de &amp;quot;Precompiled header&amp;quot; para evitar má sorte logo no primeiro projeto de LIB (má sorte significa horas procurando erros incríveis que você só irá fazer desaparecer se recompilar tudo com o uso do famigerado &amp;quot;Rebuild All&amp;quot;; espero que isso dê certo para você, para mim não tem funcionado).&lt;/p&gt;
&lt;p&gt;E pronto! Temos um projeto de LIB completo, funcional e... um tanto inútil. Mas, calma lá. Ainda não terminamos.&lt;/p&gt;
&lt;p&gt;Conforme o programador consegue se livrar das maldições das mil dependências, aos poucos ele vai conseguindo novas funções genéricas e encaixáveis para colocar em sua coleção de objs.  Essa com certeza não é uma tarefa fácil, mas ei, quem disse que esse trampo de programador seria fácil?&lt;/p&gt;
&lt;p&gt;Vamos imaginar que você é muito do sem imaginação (típico de pessoas que mantêm blogues) e criou duas funções lindíssimas que somam e multiplicam dois números:&lt;/p&gt;
&lt;p&gt;Não são aquelas coisas, mas são genéricas e, até certo ponto, &amp;quot;úteis&amp;quot; para o nosso exemplo.&lt;/p&gt;
&lt;p&gt;Agora, tudo que temos que fazer é criar dois arquivos: mymath.c e mymath.h. No mymath.c, colocamos   as funções acima exatamente como estão. No mymath.h, colocamos apenas as declarações dessas duas funções, apenas para avisar outros &amp;quot;.c&amp;quot; que existem duas funções que fazem coisas incríveis nessa nossa LIB.&lt;/p&gt;
&lt;p&gt;Adicionamos esses dois arquivos ao projeto (se já não estão), e voilà!&lt;/p&gt;
&lt;p&gt;Para usar uma LIB temos inúmeras maneiras de fazê-lo. A mais simples que eu conheço é criar um novo projeto no mesmo Solution de sua LIB. Um console, por exemplo:&lt;/p&gt;
&lt;p&gt;Se você seguiu todos os passos direitinho, e eu estou assumindo que você já sabia como criar um projeto console, sua saída da compilação talvez seja mais ou menos essa:&lt;/p&gt;
&lt;p&gt;Dois erros! Ele não achou os símbolos mult e sum. Mas eles estão logo ali! E agora?&lt;/p&gt;
&lt;p&gt;Nada a temer: tudo que temos que fazer é falar para o Solution que o projeto myfirstcmd depende do projeto myfirstlib:&lt;/p&gt;
&lt;p&gt;Isso resolve o problema de organização e compilação quando temos dezenas de &amp;quot;.c&amp;quot; espalhados pelo projeto. Existem melhores alternativas, mais bem organizadas e estruturadas, inclusive lingüisticamente falando. No entanto, tudo tem sua hora, e só se deve preocupar-se com isso quando sua solução tiver algumas dezenas de &amp;quot;.lib&amp;quot;. Até lá!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>How to run anything as a service</title>
  <link>http://www.caloni.com.br/how-to-run-anything-as-a-service/</link>
  <pubDate>2008-05-27</pubDate>
  
  <guid>http://www.caloni.com.br/how-to-run-anything-as-a-service/</guid>
  <description>&lt;p&gt;The biggest advantage running an application as a service, interactive or not, is to allow its start before a logon be performed. An example that happens to me is the need of debugging a GINA. In order to do this, I need the Visual Studio remote debugger be started before logon. The easiest and fastest solution is to run Msvcmon, the server part of debugging, as a service.&lt;/p&gt;
&lt;p&gt;Today I&#39;ve figured out a pretty interesting shortcut to achieve it.&lt;/p&gt;
&lt;p&gt;An Alex Ionescu article talks about this command line application used to create, initiate and remove services. Even not being the article focus, I found the information pretty useful, since I didn&#39;t know such app. Soon some ideas starting to born in my mind:&lt;/p&gt;
&lt;p&gt;&amp;quot;What if I used this guy to run notepad?&amp;quot;&lt;/p&gt;
&lt;p&gt;Well, the Notepad is the default test victim. Soon, the following line would prove possible to run it in the system account:&lt;/p&gt;
&lt;p&gt;However, as every service, it is supposed to communicate with the Windows Service Manager. Since Notepad even &amp;quot;knows&amp;quot; it is now a superpowerful service, the service initialization time is expired and SCM kills the process.&lt;/p&gt;
&lt;p&gt;As would say my friend Thiago, &amp;quot;not good&amp;quot;.&lt;/p&gt;
&lt;p&gt;&amp;quot;Yet however&amp;quot;, SCM doesn&#39;t kill the child processes from the service-process. Bug? Feature? Workaround? Whatever it is, it can be used to initiate our beloved msvcmon:&lt;/p&gt;
&lt;p&gt;Now, when we start Msvcmon service, the process cmd.exe will be create, that on the other hand will run the msvcmon.exe target process. Cmd in this case will only wait for its imminent death.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Aprendendo rapidamente conceitos essenciais do WinDbg</title>
  <link>http://www.caloni.com.br/aprendendo-rapidamente-conceitos-essenciais-do-windbg/</link>
  <pubDate>2008-05-23</pubDate>
  
  <guid>http://www.caloni.com.br/aprendendo-rapidamente-conceitos-essenciais-do-windbg/</guid>
  <description>&lt;p&gt;Todo o poder e flexibilidade do pacote Debugging Tools da Microsoft pode ser ofuscado pela sua complexidade e curva de aprendizagem. Afinal de contas, usar o depurador do Visual Studio é muito fácil, quando se começa a usar, mas mesmo assim conheço muitos programadores que relutam em depurar passo-a-passo, preferindo a depuração por meio de &amp;quot;MessageBoxes&amp;quot; ou saídas na tela. Imagine, então, a dificuldade que não é para quem conseguiu às duras penas aprender a tornar um hábito a primeira passada do código novo em folha através do F10 começar a fazer coisas como configurar símbolos e digitar comandos exdrúxulos em uma tela em modo texto. Para piorar a questão, existem aqueles que defendem o uso unificado de uma ferramenta que faça tudo, como um telefone celular. Eu discordo. Quando a vantagem competitiva de uma ferramenta sobre outra é notável, nada pior que ficar preso em um ambiente legalzinho que faz o mínimo para você, mas não resolve o seu problema de deadlock.&lt;/p&gt;
&lt;p&gt;Foi pensando nessa dificuldade que foi escrita uma apresentação nota dez por Robert Kuster que explica todas as minúcias importantes para todo programador iniciante e experiente na arte de &amp;quot;WinDbgear&amp;quot;. &amp;quot;WinDbg. From A to Z!&amp;quot; é uma ferramenta tão útil quanto o próprio WinDbg, pois explica desde coisas simples que deve-se saber desde o início, como configurar símbolos, quanto assuntos mais avançados, como depuração remota. Até para quem já está no nível avançado vale a pena recapitular algumas coisas que já foram ditas no  AWD.&lt;/p&gt;
&lt;p&gt;Mesmo tentando ser sucinto, o assunto ocupou um conjunto de 111 transparências que demoram de uma a duas horas de leitura cuidadosa, se você não fizer testes durante o trajeto. Entre as coisas que eu li e reli, segue uma lista importante para nunca ser esquecida (entre parênteses o número das transparências que considero mais importantes):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;O que é são as bibliotecas de depuração do Windows e como elas podem te ajudar (6 e 9)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O que são símbolos de depuração (11, 12, 14)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Como funciona a manipulação de exceções e como depurar (18, 19, 85)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Como configurar seu depurador para funcionar globalmente (20)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tipos de comandos no WinDbg (22)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Configurando símbolos e fontes no WinDbg (24, 25)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Interagindo com as janelas do WinDbg (33)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Informações sobre processos, pilhas e memória (29, 41, 43, 45, 66)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Informações sobre &lt;em&gt;threads&lt;/em&gt; e &lt;em&gt;locks&lt;/em&gt; (31, 55)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Comandos úteis com _strings _e memórias (66)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Avaliando expressões no WinDb: MASM e C++ (70, 71)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Usando _breakpoints _no WinDbg (básico) (81)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Usando _breakpoints _no WinDbg (complicado) (83, 84)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Depuração remota (muito útil!) (87)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Escolhendo a melhor ferramenta para o problema (fantástico!) (108)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Além da enchurrada de informações, o autor ainda explica a teoria com comandos digitados no próprio WinDbg, dando um senso bem mais prático à ferramenta. Ou seja, é útil tanto para os que aprendem por definições abstratas e lista de comandos quanto os que preferem já colocar a mão na massa e massacrar o bom e velho notepad.exe.&lt;/p&gt;
&lt;p&gt;No final, duas dicas importantíssimas do autor para quem deseja se aventurar nesse mundo: leia a documentação do WinDbg (que também é ótima, apesar de bem mais extensa) e aprenda assembly (simplesmente essencial para resolver muitos problemas).&lt;/p&gt;
&lt;p&gt;Se você ainda não teve tempo de se dedicar à depuração avançada em Windows e pensa que nunca terá, dedique duas horinhas divididas em períodos de 15 minutos por dia para explorar esse fantástico tutorial, que com certeza, se bem aplicado, reduzirá exponencialmente seu tempo de resolução de problemas.&lt;/p&gt;
&lt;p&gt;Eu recomendo.&lt;/p&gt;
&lt;p&gt;Existe uma tradução para inglês desse texto no saite do próprio Robert Kuster, que usou-o como uma espécie de introdução.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>MouseTool: clique automático do seu rato</title>
  <link>http://www.caloni.com.br/mousetool-clique-automatico-do-seu-rato/</link>
  <pubDate>2008-05-21</pubDate>
  
  <guid>http://www.caloni.com.br/mousetool-clique-automatico-do-seu-rato/</guid>
  <description>&lt;p&gt;Bem, como a maioria de você já sabe, eu realmente não gosto de mouses. Apesar disso respeito os usuário que usam-no e até gostam dele. Essa é a razão por que estou escrevendo mais uma vez sobre isso. Dessa vez, irei mostrar um programa que eu uso todos os dias: MouseTool, para os usuários que  não usam o mouse, mas gostam dele [1].&lt;/p&gt;
&lt;p&gt;O principal objetivo do programa é evitar de clicar no mouse, simulando um clique toda vez que o usuário pára de mover o ponteiro. E é só isso: simples, eficiente e mouseless =).&lt;/p&gt;
&lt;p&gt;Existem algumas outras opções como arrastar-e-soltar e clique-duplo, ambas disponíveis pelo próprio programa através de atalhos do teclado ou mudança de estado, situação onde o usuário antes pousa o ponteiro sobre a ação desejada e depois pousa o ponteiro sobre o alvo, dessa forma alternando entre os três modos.&lt;/p&gt;
&lt;p&gt;O MouseTool originalmente foi uma ferramente de fonte aberto. Isso significa que a última versão do código-fonte está disponível, certo? Errado. Na verdade, eu não consegui, por mais que tentasse achar,  a versão para baixar do código.&lt;/p&gt;
&lt;p&gt;Felizmente meu amigo Marcio Andrey [2] já havia baixado o fonte algum tempo atrás e, assim como eu, ele gostaria de torná-lo disponível para todos que gostassem de usá-lo e alterá-lo. Por isso que estou publicando-o aqui. Ele é gratuito e aberto. Façam o que quiserem com ele =).&lt;/p&gt;
&lt;p&gt;Vamos aproveitar o código-fonte e mostrar como explorar um código não escrito por nós. Normalmente as primeiras coisas a fazer são: baixar o arquivo compactado e descompactá-lo dentro de uma nova pasta. Dessa forma encontramos o arquivo de projeto (nesse caso, MouseTool.dsw) e tentamos abri-lo. Falhando de início miseravelmente porque acredito que ninguém mais utilize a versão do Visual Studio que abre isso.&lt;/p&gt;
&lt;p&gt;Normalmente programadores de projetos de fonte aberto estão acostumados a obter os arquivos-fonte, modificá-los, publicá-los e assim por diante. Porém isso não é quase nunca verdade para programadores Windows de aplicativos estritamente comerciais. É necessário se reajustar à nova cultura para aproveitar os benefícios da política de fonte aberto.&lt;/p&gt;
&lt;p&gt;Por exemplo, dados os arquivos-fonte, nós podemos explorar algumas partes interessantes de coisas que gostaríamos de fazer em nossos próprios programas. São trechos pequenos de código que fazem coisas úteis que gastaríamos algumas horas/dias para pesquisar na internet e achar a resposta procurada. Através de um projeto de fonte aberto, conseguimos usar um programa e ao mesmo tempo aprender seu funcionamento. E a principal parte é: nós temos o fonte, mas não os direitos autorais.&lt;/p&gt;
&lt;p&gt;Clique no link no final do post [3] para baixar o programa, e faça bom uso dele.&lt;/p&gt;
&lt;p&gt;PS: MouseTool agora tem uma versão Linux em um projeto no Source Forge! Seu nome é GMouseTool, projeto criado por Márcio de Oliveira [2].&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://blog.codinghorror.com/going-commando-put-down-the-mouse/&#34;&gt;https://blog.codinghorror.com/going-commando-put-down-the-mouse/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;http://marcioandreyoliveira.blogspot.com/search/label/GMouseTool&#34;&gt;http://marcioandreyoliveira.blogspot.com/search/label/GMouseTool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;https://github.com/Caloni/mtool&#34;&gt;https://github.com/Caloni/mtool&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Busca do Google com atalhos</title>
  <link>http://www.caloni.com.br/busca-do-google-com-atalhos/</link>
  <pubDate>2008-05-19</pubDate>
  
  <guid>http://www.caloni.com.br/busca-do-google-com-atalhos/</guid>
  <description>&lt;p&gt;Eu adoro atalhos de teclado. Desde meus primeiros anos usando computadores, atalhos têm se tornado minha obsessão. Sempre faço minha pesquisa pessoal de tempos em tempos, colecionando e usando novos atalhos descobertos. Por um bom tempo eu evitei ter que usar o mouse, treinando-me para lembrar de todas as seqüências de teclas que conhecia.&lt;/p&gt;
&lt;p&gt;Eu não tenho nada contra o uso do mouse nem as pessoas que o usam. Eu apenas não sou tão entusiástico em usar o mouse. Por algum tempo, eu até acreditei que o ponteiro do cursor estava me atrapalhando, então eu desenvolvi um programa para tirá-lo da tela (usando um atalho de teclado, claro). Porém, mais uma vez, não sou contra seu uso. Eu mesmo uso-o de vez em quando (quando eu preciso).&lt;/p&gt;
&lt;p&gt;Até algum tempo atrás a web não era muito convidativa para usuários de atalhos. Então surgiu o Google e as suas aplicações que suportavam essa característica, o que me deu uma razão a mais para passar a usar seu cliente de e-mail e leitor de notícias sem pressionar constantemente a tecla tab. No entanto, ainda faltava a mesma funcionalidade para seu buscador. Felizmente, isso não é mais verdade.&lt;/p&gt;
&lt;p&gt;Ainda em teste, eu comecei a usar os novos atalhos de teclado na busca do Google disponíveis no saite Google Experimental Search. Até agora existem atalhos para próximo resultado (J), resultado anterior (K), abertura da busca (O ou enter) e colocação do cursor na caixa de busca (/). Eles funcionam exatamente como o Gmail e o Google Reader. Eu fiquei tão empolgado com a idéia que mudei o complemento de busca do Google de dentro do meu Firefox. E agora vou contar como isso pode ser feito facilmente (nota: minhas dicas servem para usuário de Windows apenas).&lt;/p&gt;
&lt;p&gt;Provavelmente seu complemento de busca estará em uma das duas pastas abaixo:&lt;/p&gt;
&lt;p&gt;O arquivo do complemento tem o nome google.xml e você pode editá-lo usando o Bloco de Notas ou qualquer outro editor de texto simples (sem formatação). Abaixo está o ponto onde você deve inserir a nova linha que irá ativar os atalhos dentro da página de buscas do Google.&lt;/p&gt;
&lt;p&gt;É isso aí. Agora você pode ter o melhor dos dois mundos: o melhor buscador da internete com atalhos. Existirá maneira de se tornar ainda mais produtivo?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Aquele do-while engraçado</title>
  <link>http://www.caloni.com.br/aquele-do-while-engracado/</link>
  <pubDate>2008-05-15</pubDate>
  
  <guid>http://www.caloni.com.br/aquele-do-while-engracado/</guid>
  <description>&lt;p&gt;Nesses últimos dias andei conversando com um amigo que está estudando sistemas operacionais na faculdade. Melhor ainda, vendo o código real de um sistema operacional em funcionamento. A conseqüência é que, além de aprender um bocado de como as coisas funcionam de verdade debaixo dos panos, acaba-se aprendendo alguns truquezinhos básicos e tradicionais da linguagem C.&lt;/p&gt;
&lt;p&gt;Por exemplo, é um hábito conhecido o uso de construções do-while quando existe a necessidade de definir uma macro que possui mais de um comando em vez de usar a igualmente conhecida { construção de múltiplos comandos entre chaves }.&lt;/p&gt;
&lt;p&gt;O que talvez não seja tão conhecido é o porquê das coisas serem assim.&lt;/p&gt;
&lt;p&gt;Vamos imaginar uma macro de logue que é habilitada em compilações debug, mas é mantida em silêncio em compilações release:&lt;/p&gt;
&lt;p&gt;Nada de mais, e parece até funcionar. Porém, como veremos nas próximas linhas, esse é realmente um exemplo de código &amp;quot;buguento&amp;quot;, já que uma chamada dentro de uma construção if-else simplesmente não funciona.&lt;/p&gt;
&lt;p&gt;Por que isso? Para responder a essa questão nós precisamos olhar um pouco mais de perto no resultado do preprocessador da linguagem, que apenas troca nossa macro pelo pedaço de código que ela representa:&lt;/p&gt;
&lt;p&gt;Dessa forma, podemos ver o porquê. Quando chamamos a macro, geralmente usamos a sintaxe de chamada de função, colocando um sinal de ponto-e-vírgula logo após a chamada. Essa é a maneira correta de se chamar uma função, mas no caso de uma macro, dessa macro, é um desastre, porque ela cria dois comandos em vez de um só (um ponto-e-vírgula vazio, apesar de não fazer nada, é um comando válido). Então, isso é o que o compilador faz:&lt;/p&gt;
&lt;p&gt;; /* uma instrução nova! ok, sem else desa vez */&lt;/p&gt;
&lt;p&gt;Pense sobre o comando vazio como se ele fosse um comando real, o que é a maneira mais fácil de entender o erro de compilação que recebemos ao compilar o código abaixo:&lt;/p&gt;
&lt;p&gt;printf(&amp;quot;here we go&amp;quot;);&lt;/p&gt;
&lt;p&gt;Por essa razão, a maneira tradicional de escapar desse erro comum é usar uma construção válida que peça de fato um ponto-e-vírgula no final. Felizmente nós, programadores C/C++, temos essa construção, e ela é... muito bem, o do-while!&lt;/p&gt;
&lt;p&gt;;&lt;/p&gt;
&lt;p&gt;Assim nós podemos reescrever nossa macro de logue da maneira certa (e todas as 549.797 macros já escritas em nossa vida de programador). E, apesar de ser uma construção um tanto bizarra, ela funciona melhor do que nossa tentativa inicial:&lt;/p&gt;
&lt;p&gt;Ao usar um do-while (com uma expressão que retorna falso dentro do teste, de maneira que o código seja executado apenas uma vez) a construção if-else consegue funcionar perfeitamente:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Kernel Mode &gt;&gt; User Mode</title>
  <link>http://www.caloni.com.br/kernel-mode-user-mode/</link>
  <pubDate>2008-05-13</pubDate>
  
  <guid>http://www.caloni.com.br/kernel-mode-user-mode/</guid>
  <description>&lt;p&gt;Existem algumas situações onde um depurador WYSIWYG é artigo de luxo.&lt;/p&gt;
&lt;p&gt;Imagine o seguinte: temos um serviço que inicia automagicamente antes do login do Windows, e possivelmente antes mesmo do ambiente gráfico. Esse serviço tem algum problema que impede que ele funcione sob as circunstâncias de inicialização do sistema. O que fazer?  Atachar o WinDbg no processo?&lt;/p&gt;
&lt;p&gt;Mas que mané WinDbg? Que mané atachar? Nessa hora nós temos bem menos do que nossos sentidos são capazes de enxergar.&lt;/p&gt;
&lt;p&gt;Nessas horas o único que pode nos ajudar é o kernel debugger.&lt;/p&gt;
&lt;p&gt;Os depuradores do pacote Debugging Tools (especialmente o ntsd e o cdb) suportam o funcionamento em modo proxy, ou seja, eles apenas redirecionam a saída e os comandos entre as duas pontas da depuração (o depurador e o depurado). Isso é comumente usado em depuração remota e depuração de kernel, quando o sistema inteiro está congelado. O objetivo aqui é conseguir os dois: depurar remotamente um processo em um sistema que está travado.&lt;/p&gt;
&lt;p&gt;Para isso podemos nos utilizar do parâmetro -d, que manda o depurador redirecionar toda saída e controle para o depurador de kernel. Para que isso funcione o depurador já deve estar atachado no sistema-alvo. A coisa funciona mais ou menos assim:&lt;/p&gt;
&lt;p&gt;Com essa configuração temos a vantagem de ter o sistema congelado só pra nós, ao mesmo tempo que conseguimos depurar nosso processo fujão, passo-a-passo.&lt;/p&gt;
&lt;p&gt;A única desvantagem é não ter uma GUI tão poderosa quando o &amp;quot;WinDbg fonte colorido, tooltips, etc&amp;quot;. Pra quem não liga pra essas frescuras, é possível depurar processos de maneira produtiva utilizando esse cenário.&lt;/p&gt;
&lt;p&gt;Para ativar qualquer programa que irá rodar nesse modo, basta usar o aplicativo gflags:&lt;/p&gt;
&lt;p&gt;É preciso dar uma lida bem profunda na ajuda do Debugging Tools para entender como as coisas estão funcionando nessa configuração milagrosa que estamos usando. Procure por &amp;quot;Controlling the User-Mode Debugger from the Kernel Debugger&amp;quot;. Também é possível ouvir falar parcamente sobre isso no livro Advanced Windows Debugging na parte &amp;quot;Redirecting a User Mode Debugger Through a Kernel&amp;quot;. A vantagem é que vem de brinde uma bela figura para pendurar em um quadro no escritório (embora eu possa jurar que já vi essa figura na ajuda do WinDbg):&lt;/p&gt;
&lt;p&gt;Como podemos notar, o controlador de tudo é o kernel debugger. Assim que o depurador de processo entra em ação, ele se comunica com o depurador de kernel que entra no modo user mode prompt, pedindo entrada para ser redirecionada ao depurador de processo. Existem alguns caminhos para sair de um estado e entrar em outro, como o comando .breakin e o .sleep.&lt;/p&gt;
&lt;p&gt;É necessário recomentar: estamos nos comunicando com um depurador e o seu processo depurado em um sistema totalmente travado. Isso quer dizer que o acesso a coisas como código-fonte e símbolos é extremamente limitado, porém não impossível. Apenas mantenha-os localmente na máquina-vítima, pois uma comunicação pela rede não irá funcionar.&lt;/p&gt;
&lt;p&gt;A depuração com a linha atual no código-fonte demarcando onde estamos também não é possível, uma vez que o WinDbg da ponta de cá apenas faz o papel de garoto de recados para o &amp;quot;depurador de verdade&amp;quot; do outro lado (no nosso exemplo, o ntsd). Isso quer dizer que a forma mais &amp;quot;fácil&amp;quot; de ir passo-a-passo é usar o comando p (step) ou t (trace), além de habilitar o uso de fonte em 100%.&lt;/p&gt;
&lt;p&gt;Um tipo de problema que só pode ser depurado dessa maneira enfatiza a importância do uso de unit tests, além de um controle de qualidade mais aguçado antes de liberar uma versão para o cliente.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como tratar um merge no Bazaar</title>
  <link>http://www.caloni.com.br/como-tratar-um-merge-no-bazaar/</link>
  <pubDate>2008-05-09</pubDate>
  
  <guid>http://www.caloni.com.br/como-tratar-um-merge-no-bazaar/</guid>
  <description>&lt;p&gt;Hoje fizemos um merge de duas versões que entraram em conflito em nosso projeto-piloto usando bzr. Isso geralmente ocorre quando alguma coisa mudou no mesmo arquivo em lugares muito próximos um do outro. Veremos um exemplo de código para ter uma idéia de quão fácil é o processo:&lt;/p&gt;
&lt;p&gt;A execução do programa contém uma saída parecida com as linhas abaixo:&lt;/p&gt;
&lt;p&gt;Parece que está faltando algumas quebras de linha. Além de que sabemos que nossos arquivos de entrada poderão conter até 200 caracteres por linha, o que pode gerar um desastre em nosso buffer de 100 bytes. Buffer overflow!&lt;/p&gt;
&lt;p&gt;Para corrigir ambos os problemas foram criados dois branches, seguindo as melhores práticas de uso de um controle de fonte distribuído:&lt;/p&gt;
&lt;p&gt;Feitas as correções devidas, o branch linebreak fica com a seguinte cara:&lt;/p&gt;
&lt;p&gt;Em vermelho podemos notar as linhas alteradas. Uma mudança diferente foi feita para o bug do buffer overflow, em seu branch correspondente:&lt;/p&gt;
&lt;p&gt;Agora só temos que juntar ambas as mudanças no branch principal.&lt;/p&gt;
&lt;p&gt;Com toda razão, pensa o programador que está corrigindo o bug da quebra de linha, olhando sorrateiramente a função do meio, intocada, DoAnotherJob.&lt;/p&gt;
&lt;p&gt;Então ele resolve fazer um pequeno fix &amp;quot;de brinde&amp;quot;, desconhecendo que mais alguém andou alterando essas linhas:&lt;/p&gt;
&lt;p&gt;Pronto. Um fonte politicamente correto! E que vai causar um conflito ao juntar essa galera. Vamos ver na seqüência:&lt;/p&gt;
&lt;p&gt;Ops. Algo deu errado no segundo pull. O Bazaar nos diz que os branches estão diferentes, e que termos que usar o comando merge no lugar.&lt;/p&gt;
&lt;p&gt;Usamos merge no lugar do pull e ganhamos agora um conflito no arquivo bzppilot.cpp, nosso único arquivo. Vamos ver a bagunça que fizemos?&lt;/p&gt;
&lt;p&gt;A última coisa que um controle de fonte quer fazer é confundir ou chatear o usuário. Por isso mesmo, a maioria dos conflitos que o Bazaar encontrar nos fontes serão resolvidos usando o algoritmo &amp;quot;se só um mexeu, então coloca a mudança&amp;quot;. A tabela do guia do usuário ilustra esse algoritmo em possibilidades:&lt;/p&gt;
&lt;p&gt;conflito!!!&lt;/p&gt;
&lt;p&gt;O ancestral é a última modificação em comum dos dois branches que estamos fazendo merge. Do ancestral pra frente cada um seguiu seu caminho, podendo existir quantas modificações quisermos.&lt;/p&gt;
&lt;p&gt;Como podemos ver, o conflito só ocorre se ambos os usuário mexerem na mesma parte do código ao mesmo tempo. Eu disse na mesma parte do código, e não apenas no mesmo arquivo. Isso porque se a mudança for feita no mesmo arquivo, porém em locais diferentes, o conflito é resolvido automaticamente.&lt;/p&gt;
&lt;p&gt;Em todos os conflitos de texto desse tipo, o Bazaar cria três arquivos de suporte e modifica o arquivo em conflito. Isso para cada conflito.&lt;/p&gt;
&lt;p&gt;Podemos fazer o merge da maneira que quisermos. Se vamos usar nossa versão de qualquer jeito é só sobrescrever o arquivo.cpp pelo arquivo.cpp.THIS. Se vamos fazer troca-troca de alterações, abrimos os arquivos .THIS e .OTHER e igualamos suas diferenças, copiando-as para arquivo.cpp.&lt;/p&gt;
&lt;p&gt;Recomendo primeiramente olhar o que o Bazaar já fez. Se houver dúvidas sobre a integridade das mudanças, comparar diretamente os arquivos THIS e OTHER.&lt;/p&gt;
&lt;p&gt;Vamos dar uma olhada na versão criada pelo Bazaar:&lt;/p&gt;
&lt;p&gt;Ora, vemos que ele já fez boa parte do trabalho para nós: as quebras de linha já foram colocadas e o novo define já está lá. Tudo que temos que fazer é trocar o define por 200 e tirar os marcadores, que é a junção das duas mudanças feitas no mesmo local, e que só um ser humano (AFAIK) consegue juntar:&lt;/p&gt;
&lt;p&gt;Resolvido o problema, simplesmente esquecemos das versões .BASE, .THIS e .OTHER e falamos pro Bazaar que está tudo certo.&lt;/p&gt;
&lt;p&gt;O controle de fonte apaga automaticamente os arquivos THIS, BASE e OTHER, mantendo o original como a mudança aceita.&lt;/p&gt;
&lt;p&gt;Após as correções dos conflitos, temos que fazer um commit que irá ser o filho dos dois branches que estamos juntando.&lt;/p&gt;
&lt;p&gt;A versão do branch alternativo é 1.1.1, indicando que ele saiu da revisão número 1, é o primeiro alternativo e foi o único commit. Se houvessem mais modificações neste branch, elas seriam 1.1.2, 1.1.3 e assim por diante. Se mais alguém quisesse juntar alguma modificação da revisão 1 ela seria 1.2.1, 1.3.1, 1.4.1 e assim por diante.&lt;/p&gt;
&lt;p&gt;Um erro comum que pode acontecer é supor que o arquivo original está do jeito que deixamos e já usar o comando resolve diretamente. É preciso tomar cuidado, pois se algum conflito é detectado quer dizer que o Bazaar deixou para você alguns marcadores no fonte original, o que quer dizer que ele simplesmente não vai compilar enquanto você não resolver seus problemas.&lt;/p&gt;
&lt;p&gt;Enfim, tudo que temos que lembrar durante um merge do Bazaar é ver os conflitos ainda não resolvidos direto no fonte e alterá-los de acordo com o problema. O resto é codificar.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Acessando memória física no WinDbg</title>
  <link>http://www.caloni.com.br/acessando-memoria-fisica-no-windbg/</link>
  <pubDate>2008-05-01</pubDate>
  
  <guid>http://www.caloni.com.br/acessando-memoria-fisica-no-windbg/</guid>
  <description>&lt;p&gt;Como muitos devem saber, acessar memória virtual no WinDbg é coisa de criança, assim como em todo depurador decente. Se estamos falando de kernel mode então, nem se fala! A memória virtual é parte integrante do sistema operacional. Podemos saber mais sobre isso lendo o artigo do Strauss sobre gerenciamento de memória no Windows.&lt;/p&gt;
&lt;p&gt;Porém, existem situações, como a que passei essa semana, onde é preciso saber e alterar o conteúdo da memória de verdade, mesmo. Quando eu falo &amp;quot;de verdade mesmo&amp;quot; estou falando em acessar a memória através do seu endereçamento real, que conta do zero até o final da sua memória RAM, sem divisão de processos e sem proteções de acesso.&lt;/p&gt;
&lt;p&gt;Para isso é que serve um depurador de verdade, mesmo.&lt;/p&gt;
&lt;p&gt;No modo real, onde vivem sistemas como o MS-DOS e programas como o Turbo C, a memória é acessada através do par de coordenadas conhecido como segmento e offset. Entre outros motivos, isso acontece porque em um determinado momento da história o 8086 possuía 16 bits em seus registradores, mas conseguia endereçar até seiscentos e quarenta quilobytes, o que resulta em seiscentos e quarenta vezes mil e vinte e quatro, ou seja, seiscentos e cinquenta e cinco mil, trezentos e sessenta bytes, um número dez vezes maior do que sessenta e cinco mil, quinhentos e trinta e seis, ou dois elevado a dezesseis, o maior número representado por dezesseis bits.&lt;/p&gt;
&lt;p&gt;Dessa forma, foi necessário o uso de mais 4 bits para fazer a coisa funcionar, pois como podemos notar logo abaixo, a representação do último byte de 640 KB exige isso:&lt;/p&gt;
&lt;p&gt;Para conseguir esses 4 bits adicionais foram usados dois registradores em conjunto, o segmento e o offset. Funciona assim: o segmento é multiplicado por 16 (ou deslocado 4 bits à esquerda) e logo depois é somado com o offset, resultando no endereçamento desejado:&lt;/p&gt;
&lt;p&gt;Ou seja, para acessar o byte de número 595764, ou 0x91734, podemos usar o segmento 0x9022 com o offset 0x1514. A soma desses dois com o segmento deslocado irá resultado no endereço flag, ou seja, aquele que obtemos se contarmos a memória do zero até o final da RAM.&lt;/p&gt;
&lt;p&gt;Na época, a RAM não costumava ser de valores como 2GB ou até 4GB, mas em KB mesmo. Isso explica a limitação do 8086 em endereçar até 640 KB.&lt;/p&gt;
&lt;p&gt;Se nós repararmos bem, veremos que esse método implica em conseguirmos acessar o mesmo byte com um conjunto de segmentos e offsets diferentes, já que a soma pode ser resultado de operandos diversos. Esse é o chamado efeito de overlapping da memória segmentada, onde os programadores em assembly daquela época tinham que tomar alguns cuidados básicos para não atravessar a memória dos outros. No nosso exemplo acima, por exemplo, seria bem mais fácil chamar nosso bytezinho de segmento 0x9000, offset 0x1734.&lt;/p&gt;
&lt;p&gt;É verdade! Então, o WinDbg possui alguns comandos extendidos e formas de representar essa memória real, atualmente limitada não mais em 640 KB, mas até onde seus pentes de RAM agüentarem. Os mais comuns são os que imitam os nossos conhecidos dumps de memória: db, dc, dd... Temos daí as extensões !db, !dc, !dd... (note a exclamação do início).&lt;/p&gt;
&lt;p&gt;Simples, assim.&lt;/p&gt;
&lt;p&gt;Infelizmente, o WinDbg não nos permite ler certas regiões da memória por conta do cacheamento feito pelo processador. Para permitir a leitura em todas as condições, existem  três flags que podem ser utilizados:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;c lê da memória cacheada&lt;/li&gt;
&lt;li&gt;uc lê da memória não-cacheada&lt;/li&gt;
&lt;li&gt;wc lê da memória de escrita combinada&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nesse caso é possível, embora fique por sua conta e risco, ler qualquer memória não-cacheada usando-se a flag uc.&lt;/p&gt;
&lt;p&gt;É possível fazer mais brincadeiras usando os comandos comuns do WinDbg e uma notação diferente da memória. No entanto, é preciso tomar alguns cuidados quando mexer com isso. É recomendado o uso de uma máquina-vítima para esses testes, e não depuração local como estou fazendo.&lt;/p&gt;
&lt;p&gt;É isso aí. Não espero que você use muitas vezes essa forma de acessar memória. Só que eu usei e... nunca se sabe =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Bazaar e Fedora 8: a saga</title>
  <link>http://www.caloni.com.br/bazaar-e-fedora-8-a-saga/</link>
  <pubDate>2008-04-29</pubDate>
  
  <guid>http://www.caloni.com.br/bazaar-e-fedora-8-a-saga/</guid>
  <description>&lt;p&gt;Seria bom se as coisas simples da vida fossem simples, não é mesmo?&lt;/p&gt;
&lt;p&gt;Ontem, sexta passada e quinta passada, no meio de outras tarefas &amp;quot;urgentes&amp;quot;, tentava desesperadamente conseguir instalar o Bazaar na minha VM de desenvolvimento, um Fedora 8 todinho configurado.&lt;/p&gt;
&lt;p&gt;Para azar da minha pessoa, o guia simples e rápido de instalação do Bazaar não funcionava para minha distribuição Linux. Na verdade, funciona. Porém, é instalada uma versão tão antiga (0.91!) que o formato do banco de dados já se tornou incompatível.&lt;/p&gt;
&lt;p&gt;O pior, no entanto, foi tentar encontrar uma solução para o problema. Fiz mil e uma pesquisas com palavras-chave que nem imaginava que seria capaz de formular. E nada. A princípio minha idéia era apenas atualizar a lista de pacotes do repositório gerenciado pelo yum, o gerenciador de pacotes oficial do Fedora. Entre minhas buscas, encontrei os seguintes itens:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Um FAQ do Fedora (que não conseguiu responder à minha pergunta)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O sítio do projeto do yum, gerenciador de pacotes (cujo FAQ não conseguiu responder o mínimo)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Uma lista enorme de sítios explicando como criar seu próprio repositório (sem comentários)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Enfim, a coisa não estava saindo do lugar. E o cronograma apertando até o dia final. Até que decidi usar o caminho mais rápido e pentelho: perguntar para quem entende do assunto. A resposta foi simples e direta:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Por que você não instala direto dos fontes?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Uia! E não é que é mais simples, mesmo?&lt;/p&gt;
&lt;p&gt;E foi isso! É a segunda vez que tento fazer algo simples no Linux e me dou mal. Com certeza os dias futuros serão melhores. Mas me bate aquela sensação que as coisas poderiam já estar em um nível mais fácil de se mexer. Opinião pessoal.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Ode ao C&#43;&#43;</title>
  <link>http://www.caloni.com.br/ode-ao-c/</link>
  <pubDate>2008-04-21</pubDate>
  
  <guid>http://www.caloni.com.br/ode-ao-c/</guid>
  <description>&lt;p&gt;Strauss: lembra quando nós conversávamos sobre o assunto &amp;quot;Por que C++?&amp;quot;, há muitas décadas atrás, e seu blogue era um dos primeiros no Brasil que não ficava relatando o que o autor comia no café da manhã, além de falar sobre programação? Pois é, eu estava reorganizando meus g-mails e reencontrei nossa conversa e, pior, seu artigo &amp;quot;derivado&amp;quot; dela, que irei republicar aqui pois, assim como antes, acredito em tudo que escrevi naquela época.&lt;/p&gt;
&lt;p&gt;Cristiano -- Olá! Sou programador em basic (Vbasic/Qbasic), fico indignado, com pessoas que sabem entender a linguagem C++, assembler... Como podem? Eu acho isto coisa de outro mundo! Será que eu tenho chances de aprender a linguagem?&lt;/p&gt;
&lt;p&gt;Strauss -- A resposta é simples: estudando. Eu tb comecei com QBasic e VB. Arrume um livro de C++ e estude. Treine bastante. E hoje em dia é mais fácil do que quando eu comecei, pq eu não tinha acesso à Internet. É simples assim... :-)&lt;/p&gt;
&lt;p&gt;Caloni -- Você pode ir tão longe quanto queira, mas pra isso a primeira coisa que vc tem que fazer é querer  =).&lt;/p&gt;
&lt;p&gt;Strauss -- Acho que vou fazer um post sobre isso. &amp;quot;Por que C++&amp;quot; :-) Vc podia me ajudar...&lt;/p&gt;
&lt;p&gt;Caloni -- Escrevi um textículo sobre o assunto da escolha, mas não visando o mercado:&lt;/p&gt;
&lt;p&gt;Strauss -- Legal. Vou colocar minha água mercadológica no feijão e colocar no site.&lt;/p&gt;
&lt;p&gt;Não quis alterar o texto original, mas colocaria, além de rapidez, o título economia de recursos. É incrível o quanto progredimos no quesito hardware todos esses anos, e mesmo assim, existem linguagens e ambientes que parecem ter fome suficiente para consumir tudo e deixar um computador de última geração parecer um micro &amp;quot;meio lerdinho&amp;quot;. Felizmente não preciso dar nome aos bois, pois todos sabem ou conhecem pelo menos uma linguagem com essa característica.&lt;/p&gt;
&lt;p&gt;Também não quis generalizar. C e C++ não são as duas únicas opções quando se fala em bom desempenho. Existe também assembly e linguagens de script, que chegam inclusive a ser mais flexíveis e rápidas (além de mais produtivas).&lt;/p&gt;
&lt;p&gt;Ainda acredito em tudo isso que C++ proporciona e irá continuar proporcionando por muto tempo. Para os que não seguiram o linque do artigo do Strauss, existe uma modesta lista de programas escritos nessa linguagem ao redor do planeta. Muitos são conhecidíssimos e usados nos quatro cantos do mundo, muitas vezes em mais de um sistema operacional. C++ está morto? Longe disso... talvez pareça assim em território nacional, mas esse é o motivo de meus votos de sucesso no início de nosso grupo C++.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Crash Dump Analysis</title>
  <link>http://www.caloni.com.br/crash-dump-analysis-o-livro/</link>
  <pubDate>2008-04-17</pubDate>
  
  <guid>http://www.caloni.com.br/crash-dump-analysis-o-livro/</guid>
  <description>&lt;p&gt;Para quem acabou de terminar o Advanced Windows Debugging (como eu) e não consegue ler no computador os complicados artigos de Dmitry Vostokov (como eu), &amp;quot;seus problemas acabaram-se&amp;quot;: acabou de ser lançado o Memory Dump Analysis Volume 1 em hardware! Em modelos portáveis (paperback) e desktop (hardcover).&lt;/p&gt;
&lt;p&gt;Se você perder um pouco de tempo lendo o índice online, perceberá que boa parte do conteúdo (se não todo) está em seu sítio, disponível gratuitamente. Porém, não há nada como ter um livro organizado para ler no conforto do ônibus para o serviço (ou do metrô para casa). Ainda mais depois de ter aguçado os sentidos com o livro de Mario Hewardt e Daniel Pravat.&lt;/p&gt;
&lt;p&gt;Selecionei alguns tópicos que acredito que por si só já valeria a pena a aquisição do livro:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Crashes and Hangs Differentiated&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Minidump Analysis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Raw Stack Data Analysis&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Symbols and Images&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;X64 Interrupts&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trap Commands (on x86 and x64)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bugchecks Depicted&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Manual Stack Trace Reconstruction&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WinDbg Tips and Tricks&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WinDbg Scripts&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crash Dump Analysis Patterns&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Origin of Crash Dumps&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UML and Device Drivers&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Enfim, estou coçando os dedos para comprar logo um exemplar. Já sei pelo menos que com certeza serã a versão em brochura, pois não agüento mais fazer exercício muscular com o mais novo integrante da minha maleta.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Guia básico de controle de código (Mercurial)</title>
  <link>http://www.caloni.com.br/guia-basico-de-controle-de-codigo-mercurial/</link>
  <pubDate>2008-04-15</pubDate>
  
  <guid>http://www.caloni.com.br/guia-basico-de-controle-de-codigo-mercurial/</guid>
  <description>&lt;p&gt;Houve um bom motivo para que, semana passada, eu estivesse caçando inúmeras versões de um projeto desenvolvido fora da empresa: falta de controle de código. Esse tipo de lapso pode consumir de horas a dias de tempo perdido, dependendo de em quantas cópias de máquinas virtuais ficou espalhado o código.&lt;/p&gt;
&lt;p&gt;Já escrevi a respeito da importância de controlar e gerenciar o código-fonte para que a falta de um histórico exato das alterações não seja motivo de recorreções de problemas, binários no cliente sem contraparte para ajustes, além de uma série de dores de cabeça que costumam começar a ocorrer assim que nos damos conta que nosso software está uma bagunça que dói.&lt;/p&gt;
&lt;p&gt;Na época, discursei brevemente sobre alguns exemplos de gerenciadores de fonte que utilizam modelo centralizado, e nos exemplos práticos usamos o famigerado Source Safe, velho amigo de quem já programa ou programou Windows por alguns anos. Além dele, temos os conhecidíssimos CVS e Subversion, ambos largamente utilizados no mundo todo.&lt;/p&gt;
&lt;p&gt;No entanto, uma nova forma de controlar fontes está nascendo já há algum tempo, com relativo sucesso e crescentes esperanças: o modelo distribuído. Nesse tipo de gerenciamento, a liberdade aumenta exponencialmente, permitindo coisas que no modelo antigo seriam muito difíceis de serem implementadas. Não vou me delongar explicando a teoria por trás da idéia, sabendo que, além de existir um ótimo texto explicando as vantagens em cima do modelo centralizado disponível na web, o próprio sítio das implementações atuais explica a idéia de maneira muito convincente. E são elas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git. Conhecido como o controlador de fontes do &lt;em&gt;kernel&lt;/em&gt; do Linux. Escrita a versão inicial por Linux Torvalds em C e módulos de Perl pendurados, hoje em dia tem como principal desvantagem a falta de suporte nos ambientes Windows, impactando negativamente em projetos portáveis. Sua principal vantagem, no entanto, é a rapidez: é o controle de fonte mais rápido do oeste.&lt;/li&gt;
&lt;li&gt;Mercurial (ou hg). Sem dúvida o mais fácil de usar. Bem documentado e com comandos intuitivos para o usuário, vem ganhando mais adeptos a cada dia. Seu desempenho é comparável ao do Git, e seu sistema de arquivos é bem eficiente.&lt;/li&gt;
&lt;li&gt;Bazaar (ou bzr). O irmão mais próximo do Mercurial, com comandos bem parecidos. Um costuma lembrar os comandos do outro, com pequenas diferenças. Seu desempenho não chega a ser comparável aos dois acima, mas sua robustez compensa, pois é o único, de acordo com testes e estudos, que suporta o controle total de operações de renomeação de arquivos e pastas. Recentemente seu projeto tem evoluído muito.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nos sistemas centralizados o repositório de fontes fica em um lugar definido, de onde as pessoas pegam a última versão e sobem modificações, ou não, caso não tenham direito para isso.&lt;/p&gt;
&lt;p&gt;Nos sistemas distribuídos, o histórico e ramificações ficam todos locais. Como assim locais? Bom, locais do jeito que eu estou falando quer dizer: na própria pasta onde se está desenvolvendo.&lt;/p&gt;
&lt;p&gt;É lógico que pode existir uma versão de ramificações no servidor, que no caso do controle distribuído é mais um membro da rede peer-to-peer de ramificações, já que cada colaborador possui seu próprio repositório local, capaz de trocar revisões entre colaboradores e subir revisões os servidores que interessarem.&lt;/p&gt;
&lt;p&gt;Além disso, o conceito de ramificações (branches) e consolidação de versões (merging) é muito mais presente do que em sistemas como o Subversion, onde o commit (ato de enviar as revisões de um código para o repositório central) ocorre de forma controlada. Da maneira distribuída, é comum criar um branch para cada problema ou feature sendo desenvolvida, e ir juntando tudo isso imediatamente após terminado, gerando um histórico bem mais detalhado e livre de gargalos com modificações temporárias.&lt;/p&gt;
&lt;p&gt;Porém, a maior vantagem em termos de desenvolvimento acaba sendo a liberdade dos usuários, que podem trocar modificações de código entre si, sem existir a figura centralizadora do branch oficial. Ela pode existir, mas não é mais uma condição sine qua non para modificações no fonte.&lt;/p&gt;
&lt;p&gt;Comecei a usar em meus projetos pessoais o Mercurial por ter ouvido falar dele primeiro. Achei a idéia fantástica, pois já estava à procura de um substituto para meu velho Source Safe, meio baleado das tantas inovações de controle de fonte que surgiram nos projetos de fonte aberto. Outro motivo para desistir do Source Safe foi o fato de ser uma solução comercial que custa dinheiro e não chega a ser absurdamente mais fácil de usar a ponto de valer a pena usá-lo.&lt;/p&gt;
&lt;p&gt;O princípio de uso de uma ferramenta distribuída é muito simples: se você tiver um diretório de projeto já criado, basta, dentro dessa pasta, iniciar o repositório de fontes.&lt;/p&gt;
&lt;p&gt;Após isso, será criada uma pasta com o nome .hg. Dentro dela é armazenado todo o histórico dos fontes. Podemos inicialmente adicionar os arquivos do projeto existente e fazer o primeiro commit, que irá começar a controlar os arquivos adicionados dentro dessa pasta e subpastas:&lt;/p&gt;
&lt;p&gt;Se o programa não disse nada ao efetuar o commit, é porque está tudo certo. Agora podemos controlar as mudanças de nosso código usando o comando status. Para vermos o histórico usamos o comando log.&lt;/p&gt;
&lt;p&gt;Como vimos, ao alterar um arquivo controlado este é mostrado pelo comando status como alterado (o M na frente do Main.cpp). Também existem controles para cópia e exclusão de arquivos.&lt;/p&gt;
&lt;p&gt;Esse é o básico que se precisa saber para usar o Mercurial. Simples, não? O resto também é simples: fazer branches e juntá-los é uma questão de costume, e está entre as boas práticas de uso. Eu recomendo fortemente a leitura do tutorial &amp;quot;Entendendo o Mercurial&amp;quot;, disponível no sítio do projeto, até para entender o que existe por trás da idéia do controle descentralizado de fontes. Existe uma tradução muito boa feita pelo meu amigo Márcio.&lt;/p&gt;
&lt;p&gt;Como usuário de Windows, posso dizer que a versão funciona muito bem, e é possível fazer coisas como, por exemplo, usar o WinMerge para juntar branches ou comparar versões automaticamente, o que por si só já mata toda a necessidade que eu tinha do Source Safe.&lt;/p&gt;
&lt;p&gt;Testei o Mercurial por cerca de três meses desde que o conheci. Esse fim-de-semana conheci mais a fundo o Bazaar, e pretendo começar a testá-lo também para ter uma visão dos dois mundos e optar por um deles. Ambos são projetos relativamente novos que prometem muito. De uma forma ou de outra, os programadores solitários agora possuem um sistema de controle de fontes sem frescura e que funciona para todos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leia o tutorial passo-a-passo do Mercurial&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leia o tutorial passo-a-passo do Bazaar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Comece a usá-los em projetos simples e pequenos&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Comece a comparar seu uso ao do Subversion; identifique prós e contras&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trace um roteiro de migração e mão à massa&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Aprendendo assembly com o depurador</title>
  <link>http://www.caloni.com.br/aprendendo-assembly-com-o-depurador/</link>
  <pubDate>2008-04-11</pubDate>
  
  <guid>http://www.caloni.com.br/aprendendo-assembly-com-o-depurador/</guid>
  <description>&lt;p&gt;Além de servir para corrigir alguns bugs escabrosos, o nosso bom e fiel amigo depurador também possui uma utilidade inusitada: ensinar assembly! A pessoa interessada em aprender alguns conceitos básicos da arquitetura do 8086 pode se exercitar na frente de um depurador 16 ou 32 bits sem ter medo de ser feliz.&lt;/p&gt;
&lt;p&gt;Vamos ver alguns exemplos?&lt;/p&gt;
&lt;p&gt;Para quem está começando, recomendo usar um depurador simples, 16 bits e que existe em todo e qualquer Windows: o debug. Já usado para depurar a MBR no Caloni.com.br, poderá agora ser usado para ensinar alguns princípios da plataforma de uma maneira indolor. Basta iniciá-lo na linha de comando:&lt;/p&gt;
&lt;p&gt;Os comandos mais úteis são o r (ver ou alterar registradores), o t/p (executar passo-a-passo), o d (exibir memória), o u (desmontar assembly) e o a (montar assembly). Ah, não se esquecendo do ? (ajuda).&lt;/p&gt;
&lt;p&gt;Outro ensinamento bem interessante diz respeito à pilha. Aprendemos sempre que a pilha cresce de cima pra baixo, ou seja, de endereços superiores para valores mais baixos. Também vimos que os registradores responsáveis por controlar a memória da pilha são o sp (stack pointer) e o ss (stack segment). Pois bem. Vamos fazer alguns testes para ver isso acontecer.&lt;/p&gt;
&lt;p&gt;Como vemos, ao empilhar coisas na pilha, o valor do registrador sp diminui. E ao fazermos um dump do valor de sp conseguimos ver os valores empilhados anteriormente. Isso é muito útil na hora de depurarmos chamadas de funções. Por exemplo, no velho teste do Windbg x Bloco de notas:&lt;/p&gt;
&lt;p&gt;Aposto que você sabe em qual dos três botões eu cliquei =)&lt;/p&gt;
&lt;p&gt;Depurar é um processo que exige dedicação (experiência) tanto ou mais do que o próprio desenvolvimento. Por isso, fazer um esforço para descobrir algum problema em algum software pode ser vantajoso no futuro, pois você terá mais capacidade de entender o que está acontecendo à sua volta.&lt;/p&gt;
&lt;p&gt;Básico a intermediário:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Guia básico para programadores de primeiro breakpoint&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Brincando com o WinDbg&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Encontrando as respostas do Flash Pops&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Intermediário a avançado:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hook de API no WinDbg&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hook de COM no WinDbg&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Detectando hooks globais no WinDbg&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Analisando dumps com WinDbg e IDA&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Blogues que eu acho superinteressantes sobre debugging (do mais essencial para o mais avançado):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Debugging Toolbox&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mark&#39;s Blog&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Advanced Windows Debugging&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crash Dump Analysis&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Linux e o DHCP</title>
  <link>http://www.caloni.com.br/linux-e-o-dhcp/</link>
  <pubDate>2008-04-09</pubDate>
  
  <guid>http://www.caloni.com.br/linux-e-o-dhcp/</guid>
  <description>&lt;p&gt;Quando procuramos no google por &amp;quot;linux dhcp&amp;quot;, o que vem em resposta são diversas dicas, tutoriais, documentos oficiais e palpites sobre como configurar um servidor Linux.&lt;/p&gt;
&lt;p&gt;Muito bem. E a outra ponta da história?&lt;/p&gt;
&lt;p&gt;[Testes feitos em um Fedora 8, não me pergunte mais detalhes]&lt;/p&gt;
&lt;p&gt;O primeiro linque útil encontrado foi a documentação da Red Hat. Além disso seguem alguns macetes que eu descobri no decorrer do percurso. A primeira coisa a ser configurada é o arquivo /etc/sysconfig/network. Nele devemos, em uma configuração simplista, colocar uma única linha:&lt;/p&gt;
&lt;p&gt;Tive alguns problemas com a entrada NETWORKINGIPV6, ou algo do gênero. A comunicação com o servidor DHCP da rede simplesmente não funcionava com essa linha, deixando o computador sem IP durante o boot. Má configuração do servidor? Pode até ser. Porém, não quis entrar nesses meandros.&lt;/p&gt;
&lt;p&gt;Por isso, se houver a linha sobre IPV6 e você tiver problemas, comente-a temporariamente.&lt;/p&gt;
&lt;p&gt;O passo seguinte é configurar a interface de rede, que é no fim das contas a representação da sua placa. Para isso temos alguns arquivos em /etc/sysconfig/network-scripts no formato ifcfg-nome-da-interface. Se você digitar ifconfig na linha de comando terá os nomes de interface disponíveis. No meu caso, eth0.&lt;/p&gt;
&lt;p&gt;Note que o valor BOOTPROTO é realmente BOOTPROTO, com um O no final. Tive alguns problemas de soletrar também nesse caso, o que me gerou mais alguns reboots mal-sucedidos.&lt;/p&gt;
&lt;p&gt;Bem, o que isso faz? Basicamente, manda o Linux utilizar o protocolo DHCP, procurando na rede algum servidor que lhe dê algum IP válido. Só isso. O resto ele faz dinamicamente.&lt;/p&gt;
&lt;p&gt;Inclusive alterar automaticamente o arquivo /etc/resolv.conf. Nele estão definidas algumas coisas como o domínio de nomes que estamos e os IPs de onde buscar a resolução de nomes.&lt;/p&gt;
&lt;p&gt;Feito isso, como se costuma dizer, voilà! Temos um cliente DHCP funcionando contente e feliz. Eu reiniciei a máquina para tudo dar certo, mas provavelmente devem existir maneiras mais saudáveis de reiniciar a rede (talvez um ifdown seguido de ifup resolvesse).  E agora eu posso finalmente ter acesso aos pacotes de instalação que precisava.&lt;/p&gt;
&lt;p&gt;Notas de um Linux padawan =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Conversor de Houaiss para Babylon - parte 2</title>
  <link>http://www.caloni.com.br/conversor-de-houaiss-para-babylon-parte-2/</link>
  <pubDate>2008-04-08</pubDate>
  
  <guid>http://www.caloni.com.br/conversor-de-houaiss-para-babylon-parte-2/</guid>
  <description>&lt;p&gt;Após algumas semanas de suspense, chegamos finalmente à nossa segunda e última parte da saga do dicionário Houaiss.&lt;/p&gt;
&lt;p&gt;Como devem estar lembrados, a primeira parte se dispôs a desmontar a ofuscação usada nos arquivos do dicionário para permitir nossa posterior análise, com o simples e justo objetivo de importá-lo para o Babylon, cujas funcionalidades de busca são bem superiores.&lt;/p&gt;
&lt;p&gt;Feito isso, agora nos resta entender a estrutura interna do Houaiss para montar um conversor que irá ajudar o Babylon Builder a construir nosso Houaiss-Babylon. Simples, não?&lt;/p&gt;
&lt;p&gt;A primeira parte de toda análise é a busca por padrões com um pouco de bom senso. O Houaiss armazena suas definições em um conjunto de arquivos de nome deahNNN.dhx (provavelmente deah de Dicionario Eletrônico Antônio Houaiss). Os NNN variam de 001 - o maior arquivo - até 065, com algumas poucas lacunas, em um total de 53 arquivos originais.&lt;/p&gt;
&lt;p&gt;O nosso rústico importador fez o trabalho de desofuscar todos os 53 arquivos usando a mesma lógica encontrada pelo WinDbg: somar o valor 0x0B para cada byte do arquivo. Dessa forma foram gerados 53 arquivos novos no mesmo diretório, porém com a extensão TXT.&lt;/p&gt;
&lt;p&gt;Partindo do bom senso, abriremos o arquivo maior, deah001.txt, e abriremos o próprio dicionário Houaiss, em busca de um padrão que faça sentido. Como poderemos ver na figura abaixo, o padrão inicial não é nem um pouco complicado.&lt;/p&gt;
&lt;p&gt;As duas primeiras observações do formato do arquivo nos dizem que (1) o primeiro caractere de cada linha indica o conteúdo dessa linha, e que (2) a formatação dos caracteres é feita dentro de um par de chaves {}.&lt;/p&gt;
&lt;p&gt;Dessa forma, podemos começar a construir nosso interpretador de arquivos do Houaiss em seu formato básico.&lt;/p&gt;
&lt;p&gt;Simples e funcional. Com esse código já é possível extrair o básico que precisamos de um dicionário: os vocábulos e suas definições.&lt;/p&gt;
&lt;p&gt;Para conseguir mais, é necessário mais trabalho.&lt;/p&gt;
&lt;p&gt;A formatação segue o estilo já identificado, de forma que podemos aos poucos montar um interpretador de formatação para HTML, que é o formato reconhecido pelo Babylon Builder. Podemos seguir o seguinte molde, chamado no exemplo de código anterior:&lt;/p&gt;
&lt;p&gt;Algumas partes ainda estão feias, eu sei. Mas, ei, isso é um código de ráquer, não é mesmo? Além do mais, se isso não é desculpa suficiente, estamos trabalhando em uma versão beta.&lt;/p&gt;
&lt;p&gt;A partir dessas duas funções é possível dissecar o primeiro arquivo do dicionário, e assim, construirmos a primeira versão interessante do Houaiss no Babylon.&lt;/p&gt;
&lt;p&gt;Como é normal a qualquer dicionário do Babylon, podemos instalá-lo simplesmente clicando duas vezes no arquivo (em uma máquina com Babylon previamente instalado).&lt;/p&gt;
&lt;p&gt;O projeto atual está um tanto capenga, mas já desencripta os arquivos do Houaiss e gera o projeto do Babylon Builder sozinho. Em anexo já está um projeto do Babylon Builder. Basta copiar o arquivo Houaiss.txt para a pasta do projeto e gerar o projeto do Babylon.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Try-catch flutuante</title>
  <link>http://www.caloni.com.br/try-catch-flutuante/</link>
  <pubDate>2008-04-03</pubDate>
  
  <guid>http://www.caloni.com.br/try-catch-flutuante/</guid>
  <description>&lt;p&gt;Esse detalhe da linguagem quem me fez descobrir foi o Yorick, que costuma comentar no blogue (na época que o blogue tinha comentários) e tive o prazer de conhecer no 4o. EPA-CCPP.&lt;/p&gt;
&lt;p&gt;É possível, apesar de bizarro, colocar um bloco try-catch em torno da lista de inicialização de variáveis de um construtor. Essa característica da linguagem permite que possamos capturar alguma exceção lançada por algum construtor de algum membro da classe. A construção em código ficaria no estilo abaixo:&lt;/p&gt;
&lt;p&gt;Apesar dessa capacidade, não conseguimos parar o lançamento da exceção. Após seu lançamento, caímos no bloco catch abaixo do corpo do construtor e a exceção é lançada novamente, como se houvesse uma intrução throw no final do catch.&lt;/p&gt;
&lt;p&gt;O exemplo abaixo demonstra um código de uma classe que captura a exceção durante a inicialização dos membros. Na seguida o catch da função main é executada, provando que a exceção de fato não é &amp;quot;salva&amp;quot; no primeiro bloco.&lt;/p&gt;
&lt;p&gt;Testei esse código nos seguintes compiladores:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Visual Studio 6. Falhou, demonstrando desconhecer a sintaxe.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Borland C++ Builder 5. Falhou, demonstrando desconhecer a sintaxe.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Borland Developer Studio 4. Falhou, com o mesmo erro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Visual Studio 2003. Comportamento esperado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Visual Studio 2005. Comportamento esperado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Visual Studio 2008. Comportamento esperado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G++ (no Cygwin). Comportamento esperado.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A saída esperada é a seguinte:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Backup de pobre</title>
  <link>http://www.caloni.com.br/backup-de-pobre/</link>
  <pubDate>2008-03-28</pubDate>
  
  <guid>http://www.caloni.com.br/backup-de-pobre/</guid>
  <description>&lt;p&gt;O backup - ato de fazer cópia(s) de segurança de dados considerados importantes -, como tudo na vida, para se tornar efetivo e transformador deve antes se tornar um hábito.&lt;/p&gt;
&lt;p&gt;Hábitos, por definição, ao serem realizados repetidamente muitas vezes, podem se tornar poderosos catalisadores de tarefas, sejam elas cozinhar um bolo, compilar um programa ou fazer backups. Por isso é muito importante que o backup, antes de ser 100% seguro, seja 100% previsível e habitual.&lt;/p&gt;
&lt;p&gt;Minhas restrições para que algo vire um hábito em minha vida, quando tarefas, são que a tarefa seja, antes de tudo,:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Simples de fazer. Quero conseguir efetuar a tafefa sem ter que toda vez preparar um ritual em noite de lua cheia, sacrificar uma virgem para os deuses pagãos e lembrar de todas as palavras proparoxítonas que terminam com x e rimam com fênix.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fácil de executar. É um complemento do primeiro item. Com isso eu quero dizer que, além de simples, eu não precise despender grande força e energia diariamente para efetuar a tarefa. Limpar uma pasta de arquivos temporários pode ser simples; mas é fácil?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fácil de lembrar. Se eu tenho que fazer um esforço mental diário tão grande para lembrar do que fazer então muito provavelmente será difícil transformá-lo em um hábito.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Passado por esse checklist, podemos montar um esquema tão simples que qualquer bobo que tem um blogue (por exemplo, eu) conseguirá executar diariamente, ou pelo menos quando tiver vontade. A freqüência dependerá se isso irá se transformar em um hábito ou não.&lt;/p&gt;
&lt;p&gt;Ele pode não parecer, mas é beeem mais antigo do que parece. Nós, veteranos, que possuímos mais anos de vida em frente ao monitor que gostaríamos de admitir (copyright  =&amp;gt; DQ), usávamos o xcopy para copiar pastas e disquetes inteiros no MS-DOS, um sistema operacional predecessor do Windows Vista que vinha em preto e branco e sem User Account Control.&lt;/p&gt;
&lt;p&gt;No entanto, esse pequeno grande aplicativo sobreviveu todos esses anos, atingiu a maioridade, e hoje permite a nós, programadores de mouse, fazer nossos backups com um simples arquivo de batch e um pouco de imaginação.&lt;/p&gt;
&lt;p&gt;Aos mocinho e mocinhas presentes: os arquivos de batch, de extensão .bat ou .cmd, são, assim como o MS-DOS, coisas de veteranos do velho oeste.  São arquivos de script que contém um conjunto de comandos que pode-se digitar manualmente na tela preta. Seu objetivo principal é otimizar e facilitar a digitação de tarefas complexas e torná-las mais simples, fáceis de executar e de lembrar.&lt;/p&gt;
&lt;p&gt;O uso do programa pode ser aprendido dando-se uma olhada em sua ajuda (xcopy /?)&lt;/p&gt;
&lt;p&gt;Algumas opções bem úteis para efetuar cópias de segurança de arquivos modificados:&lt;/p&gt;
&lt;p&gt;/M - copia somente arquivos com atributo de arquivamento; após a cópia, desmarca atributo. Ao escrever novamente em um arquivo copiado com esse método, o arquivo volta a ter o atributo de arquivamento, e irá ser copiado novamente se especificada essa opção. Se nunca mais for mexido, não será mais copiado.&lt;/p&gt;
&lt;p&gt;/D - copia arquivos mais novos na origem. Não costumo usar pelos problemas que podem ocorrer em sistemas com horas diferentes, mas, dependendo da ocasião, pode ser útil. Também é possível especificar uma data de início da comparação.&lt;/p&gt;
&lt;p&gt;/EXCLUDE - permite excluir arquivo(s) de uma cópia coletiva. Isso pode ser muito útil se você não deseja gastar tempo copiando arquivo que são inúteis dentro de pastas que contém arquivos importantes. É possível especificar um arquivo que irá conter uma lista de nomes-curinga, um por linha, que irá servir como filtro da cópia. Teremos um exemplo logo abaixo.&lt;/p&gt;
&lt;p&gt;/E - copia pastas e subpastas, mesmo que vazias. Essa opção é básica, e ao mesmo tempo essencial. Não se esqueça dela quando for criar seu script de backup!&lt;/p&gt;
&lt;p&gt;/C - continua copiando, mesmo com erros. Se é mais importante copiar o máximo que puder do que parar no primeiro errinho de acesso negado, essa opção deve ser usada. É possível redirecionar a saída para um arquivo de log, que poderá ser usado para procurar por erros que ocorreram durante a operação.&lt;/p&gt;
&lt;p&gt;/Q - não exibe nome de arquivos ao copiar. Às vezes imprimir o nome de cada arquivo na saída do prompt de comando acaba sendo mais custoso que copiar o próprio arquivo. Quando a cópia envolve muitos arquivos pequenos, é recomendável usar esta opção.&lt;/p&gt;
&lt;p&gt;/Y - suprime perguntas para o usuário. Muito útil em arquivos batch, já que o usuário geralmente não estará lá para apertar enter quando o programa pedir.&lt;/p&gt;
&lt;p&gt;/Z - copia arquivos da rede em modo reiniciável. Muito importante quando estiver fazendo backup pela rede. Às vezes ela pode falhar, e essa opção permite continuar após pequenas quedas de desempenho.&lt;/p&gt;
&lt;p&gt;Para a cópia do patrimônio mais valioso de um programador, os fontes, podemos usar um conjunto bem bolado das 0pções acima, além de generalizar um script para ser usado em outras situações. Inicialmente vamos definir que queremos um backup que altere o atributo de arquivamento, sobrescreva cópias antigas e que possa ser copiado pela rede sem maiores problemas. Além disso, não iremos copiar as pastas Debug e Release existentes geradas pela saída de algum compilador (ex: saída do Visual Studio), nem arquivos temporários muito grandes (ex: arquivos de navegação de símbolos).&lt;/p&gt;
&lt;p&gt;O resultado é o que vemos abaixo:&lt;/p&gt;
&lt;p&gt;O conteúdo de sources.flt (extensão escolhida arbitrariamente) pode ser o seguinte:&lt;/p&gt;
&lt;p&gt;Só isso já basta para um backup simples, pequeno e fácil de executar. Só precisamos copiar a chamada ao xcopy em um arquivo de extensão .bat ou .cmd e executarmos sempre que acharmos interessante termos um backup quentinho em folha. Por exemplo, podemos manter os fontes do projeto atual em um pen drive e, ao acessarmos uma máquina confiável, rodar um backup que copia os arquvos-fonte para um ambiente mais seguro e estável.&lt;/p&gt;
&lt;p&gt;Note que esse procedimento não anula a necessidade de termos um sistema de versionamento e controle de fontes. O backup é para aquelas projetos que demoram um tempinho para efetuar commit, projetos temporários ou então sistemas de controle de fonte distribuído, em que podemos ter inúmeras pastas com diversos branchs locais.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>WinDbg a distância</title>
  <link>http://www.caloni.com.br/windbg-a-distancia/</link>
  <pubDate>2008-03-26</pubDate>
  
  <guid>http://www.caloni.com.br/windbg-a-distancia/</guid>
  <description>&lt;p&gt;Acho que o que mais me impressionou até hoje a respeito do WinDbg é a sua capacidade de depuração remota. Não há nada como depurar problemas sentado confortavelmente na sua cadeira de programador em frente à sua mesa de programador.&lt;/p&gt;
&lt;p&gt;Já é fato consumado que os maiores problemas da humanidade ocorrem sempre no cliente, com uma relação de dificuldade diretamente proporcional ao cargo ocupado pelo usuário da máquina que está dando problemas. Se esse cliente por acaso mora em um lugar tão tão distante, nada mais justo do que conhecermos algumas técnicas de depuração remota para continuar a mantê-lo tão tão distante.&lt;/p&gt;
&lt;p&gt;O ambiente de desenvolvimento (em teoria) não se deve confundir com o ambiente de testes, um lugar onde o desenvolvedor deveria colocar o pé somente quando fosse chamado e quando existisse um problema na versão Release. Por isso e portanto, a única coisa permitida em um ambiente de testes é (deveria ser) um servidor de depuração.&lt;/p&gt;
&lt;p&gt;O servidor de depuração nada mais é do que um processo que deixa alguma porta aberta  na máquina de testes para que o desenvolvedor consiga facilmente depurar problemas que ocorreram durantes os testes de produção. Ele pode ser facilmente configurado através da instalação do pacote Debugging Tools for Windows.&lt;/p&gt;
&lt;p&gt;Existem alguns cenários muito comuns de depuração remota que serão abordados aqui. O resto dos cenários se baseia nos exemplos abaixo, e pode ser montado com uma simples releitura dos tópicos de ajuda do WinDbg sobre o assunto (procure por dbgsrv.exe).&lt;/p&gt;
&lt;p&gt;Nesse caso podemos supor que a máquina tem total acesso e controle do desenvolvedor. Tudo o que temos que fazer é iniciar um WinDbg na máquina-vítima e outro WinDbg na máquina-programador. O WinDbg da máquina-vítima deve ser iniciado no modo-servidor, enquanto o da máquina-programador no modo-cliente.&lt;/p&gt;
&lt;p&gt;A vantagem dessa técnica é que tanto o WinDbg da máquina-vítima quanto o da máquina-programador podem emitir comandos, e todos vêem os resultados. Uma possível desvantagem é que os símbolos devem estar disponíveis a partir da máquina-vítima.&lt;/p&gt;
&lt;p&gt;Se for necessário, é possível convidar mais gente pra festa, pois o WinDbg permite se transformar em uma instância servidora pelo comando .server, que possui a mesma sintaxe da linha de comando. Para a comunicação entre todos esses depuradores ambulantes um comando muito útil é o .echo.&lt;/p&gt;
&lt;p&gt;Nesse ambiente muito mais hostil, é salutar e recomendável utilizar um servidor genérico que não imprima coisa alguma na tela &amp;quot;do outro lado&amp;quot;. Após iniciar o depurador na máquina que está dando o problema, o programador tem virtualmente uma série de comandos úteis que podem ser executados remotamente, como iniciar novos processos, se anexar a processos já existentes, copiar novas versões de executáveis, etc.&lt;/p&gt;
&lt;p&gt;O nome do processo do lado servidor para modo usuário é dbgsrv.exe. Para o modo kernel é kdsrv.exe. Os parâmetros de execução, felizmente, são os mesmos que os do WinDbg (e CDB, NTSD e KD), o que evita ter que decorar uma nova série de comandos.&lt;/p&gt;
&lt;p&gt;Para iniciar o servidor de depuração e deixar as portas abertas para o depurador temos apenas que iniciar o processo dbgsrv.exe:&lt;/p&gt;
&lt;p&gt;Para iniciar o processo depurador, a sintaxe é quase a mesma, só que no lugar de remote especificamos premote:&lt;/p&gt;
&lt;p&gt;Caso não se saiba a porta usada para iniciar o servidor, ou queira-se listar todos os servidores disponíveis em uma determinada máquina, usa-se o comando -QR.&lt;/p&gt;
&lt;p&gt;É importante notar que o dbgsrv.exe não é um depurador esperto, no sentido que ele não vai carregar os símbolos para você. Isso é importante na hora de definir qual estratégia utilizar, pois nem sempre os símbolos estarão disponíveis na máquina com problemas, e nem sempre estarão com o desenvolvedor.&lt;/p&gt;
&lt;p&gt;Uma organização mais esperta dos ambientes de teste e desenvolvimento tomaria conta de outros problemas como símbolos e fontes com o uso de outras features poderosas do Debugging Tools como servidor de símbolos e servidor de fontes. Porém, a complicação envolvida na configuração desses dois me leva a crer que eles merecem um outro artigo. E é por isso que paramos por aqui.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Depuração da MBR</title>
  <link>http://www.caloni.com.br/depuracao-da-mbr/</link>
  <pubDate>2008-03-24</pubDate>
  
  <guid>http://www.caloni.com.br/depuracao-da-mbr/</guid>
  <description>&lt;p&gt;Dando continuidade a um artigo beeeem antigo sobre depuração da BIOS usando SoftIce, como já vimos, podemos igualmente depurar a MBR após a chamada da INT13. Porém, devo atentar para o fato que, em algumas VMs, e sob determinadas condições do tempo e quantidade de ectoplasma na atmosfera, é possível que a máquina trave após o hot boot iniciado pelo depurador. Isso provavelmente tem cura usando o espaço de endereçamento alto da memória com a ajuda de aplicativos como LH e UMB.&lt;/p&gt;
&lt;p&gt;Porém, estou aqui para contar uma nova forma de depurar essa partezinha do código que pode se tornar um tormento se você só se basear em tracing na tela (ou na COM1): usando o aplicativo debug do DOS.&lt;/p&gt;
&lt;p&gt;O debug é um programa extremamente antigo, criado antes mesmo do MS-DOS pertencer à Microsoft e do Windows Vista ter sido criado. Como todo sistema operacional, é essencial que exista um programa para verificar problemas em outros programas. Essa foi a &amp;quot;motivação&amp;quot; para a criação do Debug.&lt;/p&gt;
&lt;p&gt;Com o passar do tempo e com a evolução dos depuradores modernos, o uso do debug foi diminuindo até a chegada dos 32 bits, quando daí ele parou de vez de ser usado. Com um conjunto limitado de instruções, a versão MS é incapaz de decodificar o assembly de 32 bits, mostrar os registradores extendidos e de depurar em modo protegido.&lt;/p&gt;
&lt;p&gt;O FreeDOS é um projeto de fonte aberto que procura criar uma réplica do sistema MS-DOS, com todos seus aplicativos (e um pouco mais). Entre eles, podemos encontrar o Debug refeito e melhorado. A versão com código-fonte possui suporte às instruções &amp;quot;novas&amp;quot; dos processadores 32 e suporta acesso à memória extendida, modo protegido e melhorias na &amp;quot;interface com o usuário&amp;quot; (como repetição de comandos automática, mudança no valor dos registradores em uma linha, etc). Enfim, nada mau.&lt;/p&gt;
&lt;p&gt;É por isso que comecei a utilizá-lo e é nele que me baseio o tutorial logo abaixo.&lt;/p&gt;
&lt;p&gt;Para conseguirmos essa proeza é necessário reiniciarmos a máquina com algum sistema 16 bits, de preferência que caiba em um disquete. Junto com ele basta uma cópia do debug.com. Após reiniciarmos e aparecer o prompt de comando, podemos chamar o depurador e começar a diversão:&lt;/p&gt;
&lt;p&gt;A MBR fica localizada no primeiro setor do HD ativo (master). A BIOS automaticamente procura esse HD e faz a leitura usando a INT13, função da própria BIOS para leitura de disquetes e derivados.&lt;/p&gt;
&lt;p&gt;Lembre-se que nem sempre existirá um MS-DOS para usarmos a INT21, tradicionalmente reservada para este sistema operacional. Portanto, se acostume com as &amp;quot;limitações&amp;quot; das funções básicas da BIOS.&lt;/p&gt;
&lt;p&gt;O debug.com inicialmente começa a execução em um espaço de memória baixa. Podemos escrever um assembly qualquer nessa memória e começar a executar. Isso é exatamente o que iremos fazer, e a instrução escolhida será a INT13, pois iremos ler o primeiro setor do HD para a memória e começar a executá-lo. Isso é a depuração da MBR.&lt;/p&gt;
&lt;p&gt;Para fazer isso, algumas informações são necessárias, e tudo está disponível no sítio muito simpático e agradável de Ralf Brown, o cara que enumerou todas as interrupções conhecidas, além de diversas outras coisas.&lt;/p&gt;
&lt;p&gt;Como queremos ler um setor do disco, a função da interrupção que devemos chamar é a AH=02:&lt;/p&gt;
&lt;p&gt;Muito bem. Tudo que temos a fazer é preencher os registradores com os valores corretos:&lt;/p&gt;
&lt;p&gt;Essa é a maneira em que as coisas são. Você certamente poderia usar outro endereço, mas estamos tentando deixar a emulação de um boot o mais próximo possível  de um boot de verdade. E, tradicionalmente, o endereço de execução da MBR é em 0000:7E00. Para recordar disso, basta lembrar que o tamanho de um setor é de 0x200 bytes, e que dessa forma a MBR vai parar bem no final do endereçamento baixo (apenas offset).&lt;/p&gt;
&lt;p&gt;Essa organização é diferente do endereço inicial da BIOS, que é por padrão 0xFFFF0.&lt;/p&gt;
&lt;p&gt;Após definir corretamente os registradores, tudo que temos que fazer é escrever uma chamada à INT13 no endereço atual e executar. O conteúdo inicial do disco será escrito no endereço de memória 0000:7E00. Após isso trocamos o IP atual para esse endereço e começamos a depurar a MBR, como se estivéssemos logo após o boot da máquina.&lt;/p&gt;
&lt;p&gt;Além da MBR, muitas vezes é preciso depurar a própria BIOS para descobrir o que está acontecendo. Nesse caso, tudo que precisamos fazer é colocar o ponteiro de próxima instrução para a região de memória 0xFFFF0, que traduzido para segmento/offset fica f000:fff0 (mais explicações sobre isso talvez em um futuro artigo).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como rodar qualquer coisa como serviço</title>
  <link>http://www.caloni.com.br/como-rodar-qualquer-coisa-como-servico/</link>
  <pubDate>2008-03-20</pubDate>
  
  <guid>http://www.caloni.com.br/como-rodar-qualquer-coisa-como-servico/</guid>
  <description>&lt;p&gt;A maior vantagem de se rodar um aplicativo como serviço, interativo ou não, é permitir que ele seja iniciado antes que seja feito um logon na máquina. Um exemplo que acontece comigo é a necessidade de depurar a GINA. Para isso, preciso que o depurador remoto do Visual Studio seja iniciado antes do logon. A solução mais fácil e rápida é rodar o Msvcmon, a parte servidora da depuração, como um serviço.&lt;/p&gt;
&lt;p&gt;Hoje eu descobri um atalho bem interessante para isso.&lt;/p&gt;
&lt;p&gt;Um artigo do Alex Ionescu falava sobre esse aplicativo linha de comando usado para criar, iniciar e apagar serviços. Mesmo não sendo o foco do artigo, achei muito útil a informação, pois não conhecia esse utilitário. Logo começaram a borbulhar idéias na minha mente:&lt;/p&gt;
&lt;p&gt;&amp;quot;E se eu usasse esse carinha para iniciar o notepad?&amp;quot;&lt;/p&gt;
&lt;p&gt;Bem, o Bloco de Notas é a vítima padrão de testes. Logo, a linha a seguir provaria que é possível rodá-lo na conta de sistema:&lt;/p&gt;
&lt;p&gt;Porém, como todo serviço, é esperado que ele se comunique com o Gerenciador de Serviços do Windows. Como o Bloco de Notas mal imagina que agora ele é um motta-fucka service, expira o timeout de inicialização e o SCM mata o processo.&lt;/p&gt;
&lt;p&gt;Como diria meu amigo Thiago, &amp;quot;não bom&amp;quot;.&lt;/p&gt;
&lt;p&gt;Porém porém, o SCM não mata os processos filhos do processo-serviço. Bug? Feature? Gambi? Seja o que for, pode ser usado para iniciar o nosso querido msvcmon:&lt;/p&gt;
&lt;p&gt;Agora, quando iniciarmos o serviço Msvcmon, o processo cmd.exe será criado, que por sua vez irá rodar o msvcmon.exe que queríamos, e ficará esperando inocentemente pela sua &amp;quot;funesta morte&amp;quot; pelo SCM.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Influence Board</title>
  <link>http://www.caloni.com.br/influence-board/</link>
  <pubDate>2008-03-14</pubDate>
  
  <guid>http://www.caloni.com.br/influence-board/</guid>
  <description>&lt;p&gt;Há muito tempo sou enxadrista não-praticante. Acho que os anos de programação me deixaram mais viciado em codar do que pensar no xeque-mate. No entanto, sempre que posso, dou uma escapulida do Visual Studio e jogo uma partida ou duas na rede, quase sempre, é claro, tomando um piau psicológico.&lt;/p&gt;
&lt;p&gt;A falta de prática e estudos pesa muito para um enxadrista amador, já que facilmente esquecemos das combinações mortíferas que podemos aplicar e levar. É muito difícil ter em mente aquelas três dúzias de aberturas que já são batidas (e suas variantes), ou então as regrinhas de praxe de como detonar nas finais com um cavalo e um bispo.&lt;/p&gt;
&lt;p&gt;Por isso mesmo aprendi em um livro uma técnica universal e independente de decoreba que levei pra vida toda, e tem me trazido algumas partidas no mínimo interessantes. Se trata de analisar o esquema de influências em cima do tabuleiro. Influências, nesse caso, se refere ao poder de fogo das peças amigas e inimigas. O interessante é que deixa-se de lado a análise das próprias peças! Se estuda tão somente o tabuleiro, e apesar de parecer um método difícil, ele melhora sua percepção gradativamente, e é responsável por muitas das partidas simultâneas jogadas às cegas por alguns ilustres GMIs.&lt;/p&gt;
&lt;p&gt;Atenção: esse artigo trata sobre xadrez admitindo que o leitor saiba as regras básicas do jogo, assim como um pouco de estratégia. Se você chegou até aqui e está viajando, sugiro que pare de ler e vá jogar uma partida.&lt;/p&gt;
&lt;p&gt;Vamos supor que a posição no tabuleiro em um dado momento seja a seguinte:&lt;/p&gt;
&lt;p&gt;Ora, é um mate inevitável, não é? Agora imagine por um momento que você não tenha percebido isso, e precise de uma ajudinha para saber onde cada peça pode ir ou atacar no próximo lance.&lt;/p&gt;
&lt;p&gt;Agora ficou muito mais fácil de perceber que a única saída do rei não possui nenhuma proteção, já que tanto o peão quanto o próprio rei não podem fazer muita coisa se a dama atacar a diagonal vulnerável. E ela pode fazer isso.&lt;/p&gt;
&lt;p&gt;Essa maneira de mostrar as influências em um tabuleiro de xadrez eu apelidei de Influence Board, e criei um projeto em linha de comando para fazer as devidas considerações a respeito de uma posição determinada. Mas como ninguém hoje em dia gosta de usar o WinDbg pra jogar xadrez, transformei meu projeto em pseudo-plugin para o WinBoard, um famoso frontend de xadrez que costumo usar em minhas esporádicas partidas.&lt;/p&gt;
&lt;p&gt;Após compilado, basta copiar na pasta de instalação do programa, rodá-lo e habilitar a opção &amp;quot;Show Influence&amp;quot; do menu General. Voilà! É possível até jogar às cegas com esse brinquedinho (opção Blindfold).&lt;/p&gt;
&lt;p&gt;Bom divertimento!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O mistério das pilhas diferentes</title>
  <link>http://www.caloni.com.br/o-misterio-das-pilhas-diferentes/</link>
  <pubDate>2008-03-12</pubDate>
  
  <guid>http://www.caloni.com.br/o-misterio-das-pilhas-diferentes/</guid>
  <description>&lt;p&gt;Mal comecei a leitura do meu mais novo &amp;quot;mother-fucker&amp;quot; livro e já encontrei a solução para nunca mais viver o terror que vivi quando tive que testar minha engenharia reversa do artigo sobre o Houaiss. Se trata de uma simples questão que não sei por que não sigo todas as vezes religiosamente: configure seus símbolos corretamente.&lt;/p&gt;
&lt;p&gt;Esse é o primeiro ponto abordado pelo autor, por se tratar de algo que, caso não seja bem feito, pode dar dores de cabeça piores do que o próprio problema que originou a sessão de debugging. Por isso eu repito:&lt;/p&gt;
&lt;p&gt;Vamos acompanhar alguns momentos de tortura alheia?&lt;/p&gt;
&lt;p&gt;Tudo aconteceu quando inesperadamente perdi metade do artigo que estava escrevendo para explicar o processo de engenharia reversa no dicionário Houaiss. Tive que refazer todos os meus testes que havia feito no laptop. Como a preguiça é a mãe de todas as descobertas, não estava com ele ligado no momento do &amp;quot;reteste&amp;quot; e por isso acabei usando a máquina desktop, mesmo.&lt;/p&gt;
&lt;p&gt;A análise inicial consistia simplesmente em verificar as entradas e saídas da função ReadFile, na esperança de entender a formatação interna do dicionário. Repetindo a seqüência:&lt;/p&gt;
&lt;p&gt;Se notarmos no artigo anterior, veremos que o conteúdo do arquivo lido não é em texto claro, sendo necessário passar por mais algumas instruções assembly para descobrir a função responsável por embaralhar o conteúdo na memória. Contudo, ao rodar esses comandos novamente, eis que a saída do ReadFile já vem toda legível, como se o dicionário não estivesse mais encriptado.&lt;/p&gt;
&lt;p&gt;A leitura foi feita e o texto direto do arquivo veio em claro? O que está acontecendo? Quando abro pelo comando type ele aparece todo obscuro...&lt;/p&gt;
&lt;p&gt;Sim, alguma coisa não-trivial acaba de acontecer. Testei esse procedimento no laptop e no desktop, sendo que esse problema aconteceu apenas no desktop. Dessa vez a curiosidade falou mais alto que a preguiça, e tive que abrir as duas máquinas e comparar os resultados.&lt;/p&gt;
&lt;p&gt;Depois de um pouco de cabeçadas rastreando o assembly executado, descobri que o ponto onde o breakpoint havia parado não era o retorno da chamada a ReadFile. Isso eu não vou demonstrar aqui pois se trata de raciocínio de passo-a-passo no assembly até descobrir a diferença. É enfadonho e sujeito a erros. Sugiro que tente um dia desses. Para mim, o resultado lógico de tudo isso é a saída que segue:&lt;/p&gt;
&lt;p&gt;Como podemos ver pelos comandos acima, o pseudo-registrador $ra não está mostrando o valor corretamente!&lt;/p&gt;
&lt;p&gt;A primeira coisa que se faz numa hora dessas é comparar as versões dos componentes do depurador de ambos os ambientes. Para isso usamos o comando version.&lt;/p&gt;
&lt;p&gt;OK. A versão instalada no desktop é bem antiga. Pode ser um indício. Fiz então a atualização e comparei novamente a saída de version.&lt;/p&gt;
&lt;p&gt;Tudo igual.&lt;/p&gt;
&lt;p&gt;Decidi então usar aquela lógica cética que é desenvolvida por quem costuma depurar coisas sinistras e esotéricas por anos e anos e não duvida de mais nada, mas também acredita piamente que tudo tem um motivo. Se não está aparente, basta descobri-lo. E foi o que eu fiz. Gerei dois dumps distintos, um no laptop e outro no desktop. Ambos estavam com os ponteiros de instrução apontados exatamente para a entrada da função ReadFile, início de todo esse problema. Copiei o dump do desktop para o laptop e vice-versa.&lt;/p&gt;
&lt;p&gt;Abri o dump do desktop no laptop: tudo funcionando. Abri o dump do laptop no desktop: mesmo erro.&lt;/p&gt;
&lt;p&gt;Conclusão óbvia: é algo relacionado com o WinDbg no desktop, uma vez que o estado da pilha que era mostrado corretamente no laptop em ambos os dumps falhava duplamente na máquina desktop.&lt;/p&gt;
&lt;p&gt;Isso com certeza não cheira bem. Ainda mais porque do outro lado do hemisfério, meu laptop estava configurado com toda a rigidez que um laptop de WinDbgeiro deve ter:&lt;/p&gt;
&lt;p&gt;E aí estava uma diferença plausível. Consertados os diretórios de símbolos, tudo voltou ao normal.&lt;/p&gt;
&lt;p&gt;Procure primeiro verificar as coisas mais simples. Depois você tenta consertar o universo. Mas, primeiro, antes de tudo, veja se o cabo de rede está conectado. Ou no nosso cado de debugueiro: Configure Seus Símbolos Corretamente.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Sed, Grep e afins</title>
  <link>http://www.caloni.com.br/sed-grep-e-afins/</link>
  <pubDate>2008-03-10</pubDate>
  
  <guid>http://www.caloni.com.br/sed-grep-e-afins/</guid>
  <description>&lt;p&gt;Esse artigo é resultado de eu ter me matado para conseguir encontrar a forma correta de usar o aplicativo sed para fazer uma filtragem simples nos resultados de uma listagem de arquivos.&lt;/p&gt;
&lt;p&gt;Primeiramente, eu gostaria de expressar minha total surpresa ao não conseguir encontrar um guia simples e confiável de uso dessas ferramentas na web. Existem três teorias: ou eu não sei usar as palavras mágicas certas no Google, ou a indexação das páginas realmente importantes sobre o assunto não funcionam com o Google, ou de fato não existe documentação fácil sobre o tema.&lt;/p&gt;
&lt;p&gt;Como esta é uma exceção em anos de &amp;quot;googadas&amp;quot;, eu fico com a terceira opção.&lt;/p&gt;
&lt;p&gt;Existem algumas ferramentas que já salvaram minha vida uma dúzia de vezes e devo admitir que são tão poderosas e flexíveis quanto difíceis de usar:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Grep. Use esta se quiser fazer uma busca, qualquer busca, em um arquivo, um conjunto de arquivos ou uma enxurrada de caracteres do prompt de comando.&lt;/li&gt;
&lt;li&gt;Sed. Use esta se quiser processar a entrada de um arquivo, um conjunto de arquivos ou uma enxurrada de caracteres do prompt de comando.&lt;/li&gt;
&lt;li&gt;Sort. Use esta se quiser ordenar qualquer coisa da entrada padrão (inclusive arquivos, conjunto de arquivos...).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Essas ferramentas são nativas do ambiente Linux, mas podem ser instaladas no Windows através do Cygwin, do Mingw ou nativamente através das ferramentas GnuWin32.&lt;/p&gt;
&lt;p&gt;O que eu queria era processar a saída de um programa de forma que eu tivesse a lista de todas as extensões dos arquivos. Por exemplo, para a seguinte entrada:&lt;/p&gt;
&lt;p&gt;Eu gostaria de uma saída no seguinte formato:&lt;/p&gt;
&lt;p&gt;Basicamente é isso.&lt;/p&gt;
&lt;p&gt;Sabendo que processamento de entrada estaria envolvido, logo pensei em utilizar o sed para a tarefa. Justiça seja feita, depois de eu perder uma hora e meia em pesquisa eu encontrei um tutorial muito bom para quem está começando a entender melhor o funcionamento do sed, e é nele que me baseei para resolver meu problema e escrever este artigo.&lt;/p&gt;
&lt;p&gt;Obs.: sim, eu conheço os tutoriais do Aurélio, e aprendi regex através do livro dele. Contudo, seu guia do sed não é tão bom quanto parece, e apesar de lê-lo de cabo a rabo, acabei precisando de ajuda extra.&lt;/p&gt;
&lt;p&gt;Para filtrar o path do arquivo, e ao mesmo tempo retirar seu nome, podemos usar o seguinte comando (fora outras trilhões de variantes):&lt;/p&gt;
&lt;p&gt;Após esse processamento, a saída é um monte de extensões vindas de um monte de arquivos:&lt;/p&gt;
&lt;p&gt;Como podemos ver e é óbvio de imaginar, muitas extensões irão se repetir. Para eliminar as repetições e ordenar a saída da saída corretamente, usamos o comando sort:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Os caracteres .*[]^$\ dão problemas se usados sem escape no sed, pois fazem parte dos comandos para procurar expressões regulares. Use-os com o caractere de escape .&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Para concatenar comandos no sed, use sempre -e &amp;quot;comando&amp;quot;. A ordem de execução dos comandos é a ordem em que eles são inseridos na linha de comando, ou seja, podemos confiar que no segundo comando o primeiro já terá sido executado e assim por diante.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Para fazer o escape das barras do caminho de um arquivo temos que usar o conjunto / (obs.: caminhos em formato Unix). Para evitar esse uso enfadonho podemos substituir o caractere de divisão do comando s colocando-o na frente:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;s#/path/muito/muito/muito/longo.cpp#/outropath/muito/muito/longo.cpp#&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Para agrupar expressõe, use sempre &amp;quot;(&amp;quot; e &amp;quot;)&amp;quot;. É o contrário do uso dos caracteres especiais. Coisas de Unix.&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Iteradores não são constantes</title>
  <link>http://www.caloni.com.br/iteradores-nao-sao-constantes/</link>
  <pubDate>2008-03-04</pubDate>
  
  <guid>http://www.caloni.com.br/iteradores-nao-sao-constantes/</guid>
  <description>&lt;p&gt;Um bug que já encontrei uma dúzia de vezes entre os novatos da STL é a utilização de iteradores como se eles não fossem mudar nunca. Porém, a verdade é bem diferente: iteradores se tornam inválidos sim, e com muito mais freqüência do que normalmente se imagina. Entre as situações em que iteradores podem mudar estão as seguintes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Inserção de novo elemento no contêiner&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Remoção de novo elemento no contêiner&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redimensionamento no tamanho do contêiner&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Por exemplo, o tradicional código do exemplo abaixo contém o tradicional erro de iterador inválido:&lt;/p&gt;
&lt;p&gt;Para operações como essa, o retorno geralmente nos dá uma dica de para onde vamos na varredura do contêiner. No caso do método erase, o retorno é o próximo iterador válido, ou o final (retornado pelo método end). Um código mais esperto gera um erro mais sutil:&lt;/p&gt;
&lt;p&gt;Algo de errado irá acontecer apenas se o elemento removido for o último localizado no contêiner.&lt;/p&gt;
&lt;p&gt;Esse é um erro comum para os acostumados com outros tipos de iteração (ex: ponteiros) e que não estudaram os princípios básicos da STL, entre eles o da reutilização de algoritmos. Se fosse usado este princípio, nada disso teria acontecido:&lt;/p&gt;
&lt;p&gt;Quando precisamos fazer algo nos elementos de um contêiner STL, é quase certo que existirá um algoritmo genérico para essa tarefa, seja no próprio contêiner ou na forma de função (header algorithm). Nunca se esqueça disso na hora de desenvolver seus próprios algoritmos e não precisará reinventar a roda todos os dias.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Quando o ponteiro nulo não é inválido</title>
  <link>http://www.caloni.com.br/quando-o-ponteiro-nulo-nao-e-invalido/</link>
  <pubDate>2008-02-29</pubDate>
  
  <guid>http://www.caloni.com.br/quando-o-ponteiro-nulo-nao-e-invalido/</guid>
  <description>&lt;p&gt;Pois bem. O mesmo amigo que me recomendou que escrevesse sobre o assunto do ponteiro nulo achou um livro sobre armadilhas em C com um exemplo que demonstra exatamente o contrário: dependendo da plataforma, ponteiros nulos são sim válidos.&lt;/p&gt;
&lt;p&gt;Nesse caso, se tratava de um programa que iria rodar em um microprocessador, daqueles que o DQ costuma programar. Pois bem. Quando o dito cujo ligava era necessário chamar uma rotina que estava localizada exatamente no endereço 0. Para fazer isso, o código era o seguinte:&lt;/p&gt;
&lt;p&gt;Nada mais simples: um cast do endereço 0 (apesar de normalmente inválido, 0 pode ser convertido para endereço) para ponteiro de função que não recebe parâmetros e não retorna nada, seguido de deferência (&amp;quot;o apontado de&amp;quot;) e chamada (a dupla final de parênteses).&lt;/p&gt;
&lt;p&gt;É bem o que o autor diz depois de jogar esta expressão: &amp;quot;expressions like these strike terror into the hearts of C programmers&amp;quot;. É lógico que isso não é bem verdade para as pessoas que acompanham este blogue =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Conversor de Houaiss para Babylon - parte 1</title>
  <link>http://www.caloni.com.br/conversor-de-houaiss-para-babylon-parte-1/</link>
  <pubDate>2008-02-27</pubDate>
  
  <guid>http://www.caloni.com.br/conversor-de-houaiss-para-babylon-parte-1/</guid>
  <description>&lt;p&gt;Este artigo é sobre desmontar e montar novamente. Iremos descobrir como as entradas do dicionário Houaiss eletrônico estão gravadas em um primeiro momento, para depois remontarmos essa informação de maneira que ela possa ser usada em outro dicionário de uso mais flexível, o Babylon. Ou seja, este não é um guia de vandalismo. Estava apenas querendo usar um dicionário de qualidade excelente em outro dicionário cuja interface é muito boa.&lt;/p&gt;
&lt;p&gt;Considero o Houaiss o melhor dicionário da atualidade, uso todo santo dia e tenho todo o respeito por ele. Possuo uma cópia legalizada exatamente por isso. Além, é óbvio, pelo escandaloso cinismo que seria se eu, desenvolvedor de software, pirateasse os que utilizo. Porém, acredito que tudo tenha um limite: respeito os direitos de quem desenvolve o programa se o programa se dá ao respeito de ser pago. Quer dizer, eu realmente uso muito esse dicionário, e ele é útil para mim. Logo, nada mais justo do que adquiri-lo como manda a lei.&lt;/p&gt;
&lt;p&gt;Assim como adquiri o Houaiss, também comprei o Babylon, um programa-dicionário, cuja interface permite buscar o significado das palavras lidas no computador simplesmente clicando nelas. A qualidade de seu dicionário português embutido é medíocre, mas o que ele ganha mesmo é em sua interface fácil para acessar palavras. Exatamente por faltar um dicionário em português de peso no Babylon, e eu ter adquirido outro muito melhor, quis que ambos funcionassem juntos, ou seja, acesso o Babylon e tenho o resultado adicional desse meu dicionário tupiniquim.&lt;/p&gt;
&lt;p&gt;O Babylon possui um mecanismo para criação de dicionários chamado Babylon Builder. É muito simples e fácil de usar (além de ser gratuito). Sabendo que possuo ambas as licenças desses dois programas me sinto mais aliviado em tentar desencriptar a base de dados do primeiro para construir um dicionário para o segundo, e assim realizar meu sonho de consumo: um Babylon com um dicionário de peso!&lt;/p&gt;
&lt;p&gt;É necessário que, na hora da instalação, seja escolhida a opção de copiar os arquivos para o disco. Estarei utilizando o path padrão de um Windows em português, que é &amp;quot;C:\Arquivos de Programas\Houaiss&amp;quot;.&lt;/p&gt;
&lt;p&gt;A estrutura de diretórios interna da instalação é bem simples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Raiz. Arquivos de ajuda, desinstalador, executável principal, etc.&lt;/li&gt;
&lt;li&gt;Quadros. Figuras com conhecimentos gerais, como calendários, signos, línguas mais faladas, etc.&lt;/li&gt;
&lt;li&gt;Dicionário. Provavelmente onde está todo o dicionário, cerca de 120 MB.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Se analisarmos o conteúdo dos arquivos dentro da pasta Dicionario vamos descobrir que ele se parece com &amp;quot;garbage nonsense&amp;quot;, apesar de existir um certo padrão. O padrão revela que pode se tratar de uma criptografia muito simples, talvez até um simples XOR.&lt;/p&gt;
&lt;p&gt;Sabendo que o conteúdo do dicionário está em arquivos localizados no disco, e que teoricamente o programa não deve copiar todo o conteúdo para a memória, iremos depurar o processo do dicionário de olho nas chamadas da função ReadFile.aspx) quando clicarmos em uma definição de palavra.&lt;/p&gt;
&lt;p&gt;Ao clicar na definição de &amp;quot;programa-fonte&amp;quot;, o breakpoint é ativado:&lt;/p&gt;
&lt;p&gt;Depois da leitura, não temos muitas alternativas a não ser fazer o tracking de chamadas até que o mesmo buffer esteja desencriptado. Esse é o caminho natural das coisas, mas poderia haver complicações secundárias, como uma cópia de buffer antes de seu uso. Estou usando passos simples porque realmente foi muito simples descobrir o segredo da ofuscação.&lt;/p&gt;
&lt;p&gt;Pois bem. Logo depois de chamar a função Houaiss2+0xb8a6c magicamente o buffer incompreensível se transformou no início da definição da palavra &amp;quot;programa-fonte&amp;quot;. Como não temos o programa-fonte do Houaiss, teremos que descer mais um nível no &amp;quot;assemblão&amp;quot;, mesmo.&lt;/p&gt;
&lt;p&gt;(Note que reexecutei os passos anteriores para cair na mesma condição)&lt;/p&gt;
&lt;p&gt;Estamos diante de um loop, que, ao analisar o valor de ecx, sabemos que se repete 0x200 vezes, que é exatamente o número de bytes lidos pela função ReadFile. Coincidência? Seria, se não estivesse bem no meio do loop a referência ao próprio buffer usado na leitura (08bbf1d0).&lt;/p&gt;
&lt;p&gt;Acredito que para todo profissional de engenharia reversa a parte mais emocionante é a descoberta do grande segredo por trás do desafio, o porquê das coisas estarem como estão e o que fazer para desfazer a mágica da segurança: a chave!&lt;/p&gt;
&lt;p&gt;Note que essa operação é realizada para cada byte lido do buffer usado na leitura do arquivo. Conseqüentemente, não é difício de imaginar que o valor 0x0B é a chave usada para ofuscar o dicionário em arquivo, subtraindo esse valor de cada byte. Para desfazer a ofuscação, portanto, basta adicionar novamente o mesmo valor, que é exatamente o que faz a instrução assembly acima, e o meu singelo código de desofuscação do dicionário Houaiss abaixo:&lt;/p&gt;
&lt;p&gt;Parte da mágica já foi feita, talvez a mais importante e divertida. Daqui pra lá deixaremos o WinDbg de lado e analisaremos o formato em que o texto do dicionário é armazenado, ignorando sua ofuscação básica, que não é mais um problema. Como o artigo já está extenso o suficiente, vou deixar a continuação dessa empreitada para uma futura publicação.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Códigos de entrevista - o ponteiro nulo</title>
  <link>http://www.caloni.com.br/codigos-de-entrevista-o-ponteiro-nulo/</link>
  <pubDate>2008-02-25</pubDate>
  
  <guid>http://www.caloni.com.br/codigos-de-entrevista-o-ponteiro-nulo/</guid>
  <description>&lt;p&gt;Bom, parece que o &amp;quot;mother-fucker&amp;quot; wordpress ferrou com meu artigo sobre o Houaiss. Enquanto eu choro as pitangas aqui vai um outro artigo um pouco mais simples, mas igualmente interessante.&lt;/p&gt;
&lt;p&gt;&amp;quot;Wanderley, tenho umas sugestões para teu blog.
A primeira:
Que tal analisar o código abaixo e dizer se compila ou não. Se não compilar, explicar porquê não compila. Se compilar, o que acontecerá e por quê.&amp;quot;&lt;/p&gt;
&lt;p&gt;O código é o que veremos abaixo:&lt;/p&gt;
&lt;p&gt;Bem, para testar a compilação basta compilar. Porém, se estivermos em uma entrevista, geralmente não existe nenhum compilador em um raio de uma sala de reunião senão seu próprio cérebro.&lt;/p&gt;
&lt;p&gt;E é nessas horas que os entrevistadores testam se você tem um bom cérebro ou um bom currículo.&lt;/p&gt;
&lt;p&gt;Por isso, vamos analisar passo a passo cada bloco de código e entender o que pode estar errado. Se não encontrarmos, iremos supor que está tudo certo.&lt;/p&gt;
&lt;p&gt;Dois includes padrões, ultranormal, nada de errado aqui.&lt;/p&gt;
&lt;p&gt;Duas ressalvas aqui: a primeira quanto ao retorno da função é void, porém a função retorna um inteiro. Na linguagem C, isso funciona, no máximo um warning do compilador. Em C++, isso é erro brabo de tipagem.&lt;/p&gt;
&lt;p&gt;A segunda ressalva diz respeito à linha obscura, sintaticamente correta, mas cuja semântica iremos guardar para o final, já que ainda falta o main para analisar.&lt;/p&gt;
&lt;p&gt;A clássica função inicial, nada de mais aqui. Retorna um int, e de fato retorn. Chama a função func, definida acima.&lt;/p&gt;
&lt;p&gt;A linha que guardamos para analisar contém uma operação de casting, atribuição e deferência, sendo o casting executado primeiro, operador unário que é, seguido pelo segundo operador unário, a deferência. Como sempre, a atribuição é uma das últimas. Descomprimida a expressão dessa linha, ficamos com algo parecido com as duas linhas abaixo:&lt;/p&gt;
&lt;p&gt;Não tem nada de errado em atribuir o valor 0 a um ponteiro, que é equivalente ao define NULL da biblioteca C (e C++). De acordo com a referência GNU, é recomendado o uso do define, mas nada impede utilizar o o &amp;quot;hardcoded&amp;quot;.&lt;/p&gt;
&lt;p&gt;Porém, estamos escrevendo em um ponteiro nulo, o que com certeza é um comportamento não-definido de conseqüências provavelmente funestas. O ponteiro nulo é um ponteiro inválido que serve apenas para marcar um ponteiro como inválido. Se escrevermos em um endereço inválido, bem, não é preciso ler o padrão para saber o que vai acontecer =)&lt;/p&gt;
&lt;p&gt;Alguns amigos me avisaram sobre algo muito pertinente: dizer que acessar um ponteiro nulo, portanto inválido, é errado e nunca deve ser feito. Como um ponteiro nulo aponta para um endereço de memória inválido, acessá-lo irá gerar uma exceção no seu sistema operacional e fazer seu programa capotar. Um ponteiro nulo é uma maneira padrão e confiável de marcar o ponteiro como inválido, e testar isso facilmente através de um if. Mais uma vez: ponteiros nulos apontando para um endereço de memória inválido (o endereço 0) nunca devem ser acessados, apenas atribuído a ponteiros.&lt;/p&gt;
&lt;p&gt;Em código. Isso pode:&lt;/p&gt;
&lt;p&gt;Isso &lt;strong&gt;não pode&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;Dito isso, me sinto melhor =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Configurando seus projetos no Visual Studio</title>
  <link>http://www.caloni.com.br/configurando-seus-projetos-no-visual-studio/</link>
  <pubDate>2008-02-21</pubDate>
  
  <guid>http://www.caloni.com.br/configurando-seus-projetos-no-visual-studio/</guid>
  <description>&lt;p&gt;Ao iniciar na arte da programação em C no Visual Studio, eventualmente o programador irá querer testar seus programas rodando em outra máquina que não seja a de desenvolvimento, mandar uma versão beta para amigos, pra namorada e pro seu cachorro. Geralmente, por padrão, existem algumas dependências do programa compilado com uma DLL de runtime da versão do ambiente em que foi compilado o dito cujo, dificultando um pouco a distribuição do seu motherfucker-program.&lt;/p&gt;
&lt;p&gt;Porém, seus &amp;quot;poroberemas se acabaram-se&amp;quot;. Com o inovador configurador de projetos do Visual Studio, tudo o que você queria é possível, e ainda mais!&lt;/p&gt;
&lt;p&gt;Nota do autor: isso não foi uma propaganda gratuita, apenas uma piada. Se fosse um verdadeiro anúncio das maravilhas do Visual Studio, eu agora estaria falando daquele tal código gerenciado e o tal do C++ CLI.&lt;/p&gt;
&lt;p&gt;Inicialmente, se compilarmos um programa em Debug no Visual Studio 2005 teremos as seguintes dependências:&lt;/p&gt;
&lt;p&gt;A DLL kernel32 é nativa e sempre estará presente no Windows. Porém, a msvcr80d não. Ela veio junto com o pacote do Visual Studio, e se não for distribuída em outras máquinas, você não conseguirá rodar seu programa, pois isso gerará o seguinte erro:&lt;/p&gt;
&lt;p&gt;Bem, para resolver isso, a partir da IDE, temos que ir em Project, Properties, Configuration Properties, C/C++, Code Generation, Runtime Library.&lt;/p&gt;
&lt;p&gt;Existem atualmente quatro tipos de runtime que você pode escolher:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Multi-threaded (/MT). Versão Release que não depende de DLL.&lt;/li&gt;
&lt;li&gt;Multi-threaded Debug (/MTd). Versão Debug que não depende de DLL.&lt;/li&gt;
&lt;li&gt;Multi-threaded DLL (/MD). Versão Release que depende de DLL.&lt;/li&gt;
&lt;li&gt;Multi-threaded Debug DLL (/MDd). Versão Debug que depende de DLL.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Essas runtimes são chamada de multi-threaded porque antigamente existiam versões single-threaded dessas mesmas runtimes.  Contudo, versões mais novas do Visual Studio só vêm com esse sabor mesmo.&lt;/p&gt;
&lt;p&gt;Note que, por padrão, existem dois tipos de configuração em seu projeto: Debug (para testes) e Release (para distribuição). Convém não misturar configurações Debug com DLLs Release e vice-versa, a não ser que você tenha certeza do que está fazendo.&lt;/p&gt;
&lt;p&gt;Pois bem. Para tirar a dependência da maldita DLL, tudo que temos que fazer é alterar a configuração, nesse caso Debug, de /MDd para /MTd. E recompilar.&lt;/p&gt;
&lt;p&gt;E testar.&lt;/p&gt;
&lt;p&gt;Além da dependência de DLLs, alguns casos especiais vão chiar por causa dos dados do manifesto embutidos no programa compilado. Por algum motivo que eu desconheço, o programa necessita que as DLLs estejam instaladas mesmo que no Dependency Walker não mostre nada. Nesses casos, uma arrancada do manifesto na versão Debug não fará mal algum.&lt;/p&gt;
&lt;p&gt;Acho que esses são os únicos empecilhos iniciais para testar seu programa em outras máquinas. Sempre que ver o erro exibido no começo desse artigo, desconfie de alguma dependência que não está presente na máquina. Nessas horas, ter um Dependency Walker na mão vale ouro.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Os diferentes erros na linguagem C</title>
  <link>http://www.caloni.com.br/os-diferentes-erros-na-linguagem-c/</link>
  <pubDate>2008-02-15</pubDate>
  
  <guid>http://www.caloni.com.br/os-diferentes-erros-na-linguagem-c/</guid>
  <description>&lt;p&gt;Uma coisa que me espanta de vez em quando é o total desconhecimento por programadores mais ou menos experientes dos níveis de erros que podem ocorrer em um fonte escrito em C ou C++. Desconheço o motivo, mas desconfio que o fato de outras linguagens não terem essa divisão de processos pode causar alguma nivelação entre as linguagens e fazer pensar que o processo de compilação em C é como em qualquer outra linguagem.&lt;/p&gt;
&lt;p&gt;Porém, para começar, só de falarmos em compilação já estamos pegando apenas um pedaço do todo, que é a geração de um programa executável em C. Tradicionalmente, dividimos esse processo em três passos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Preprocessamento&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compilação&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linkedição&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Vamos dar uma olhada mais de perto em cada um deles e descobrir erros típicos de cada processo.&lt;/p&gt;
&lt;p&gt;O preprocessamento é especificado pelos padrões C e C++, mas, tecnicamente, não faz parte da linguagem. Ou seja, antes que qualquer regra de sintaxe seja verificada no código-fonte, o preprocessamento já terá terminado.&lt;/p&gt;
&lt;p&gt;Essa parte do processo lida com substituição de texto e diretivas baseadas em arquivos e símbolos. Por exemplo, a diretiva de preprocessamento mais conhecida&lt;/p&gt;
&lt;p&gt;faz com que todo o conteúdo do arquivo especificado seja incluído exatamente no ponto onde for colocada essa diretiva. Isso quer dizer que, antes sequer do código-fonte ser compilado, todo o conteúdo desse header padrão estará no corpo do arquivo C.&lt;/p&gt;
&lt;p&gt;Para evitar que o mesmo header seja incluído inúmeras vezes dentro da mesma unidade em C, causando assim erros de redefinição, existe outra diretiva muito usada para cercar esses arquivos públicos:&lt;/p&gt;
&lt;p&gt;Esse conjunto de duas diretivas, por si só, é capaz de gerar os mais criativos e bizarros erros de compilação em C. E estamos falando de erros que ocorrem antes que sequer seja iniciado o processo de compilação propriamente dito. Obviamente que os erros serão capturados durante a compilação, mas o motivo deles terem ocorrido foi um erro decorrente do processo de preprocessamento. Por exemplo, vamos supor que um determinado fonte necessita de uma declaração de função contida em meuheader.h:&lt;/p&gt;
&lt;p&gt;Porém, num daqueles acasos da natureza, o header-do-mal.h define justamente o que não poderia definir jamais (obs.: e isso pode muito bem acontecer na vida real, se usamos definições muito comuns):&lt;/p&gt;
&lt;p&gt;Na hora do preprocessamento, o preprocessador não irá mais incluir o conteúdo dentro de header.h:&lt;/p&gt;
&lt;p&gt;Conseqüentemente, durante a compilação do código-fonte já preprocessado, sem a declaração da função meuheaderFunc, irá ocorrer o seguinte erro:&lt;/p&gt;
&lt;p&gt;Isso em fontes pequenos é facilmente identificável. Em fontes maiores, é preciso ter um pouco mais de cuidado.&lt;/p&gt;
&lt;p&gt;Após o processo de preprocessamento, de todos os arquivos indicados terem sido incluídos, de todas as macros terem sido substituídas, todas as constantes colocadas literalmente no código-fonte, temos  o que é chamado unidade de compilação, que será entregue ao compilador, que, por sua vez, irá começar a análise sintática de fato, descobrindo novos erros que podem ou não (como vimos) ter a ver com a fase anterior. A figura abaixo ilustra esse processo, com algumas trocas conhecidas:&lt;/p&gt;
&lt;p&gt;Dica: quando o bicho estiver pegando, e tudo o que você sabe sobre linguagem C não estiver te ajudando a resolver um problema, tente gerar uma unidade de compilação em C e analisar sua saída. Às vezes o que é claro no código pode se tornar obscuro após o preprocessamento. Para fazer isso no VC++ em linha de comando, use o parâmetro /E.&lt;/p&gt;
&lt;p&gt;Se você conseguir passar ileso para a fase de compilação, pode se considerar um mestre do preprocessamento.  Por experiência própria, posso afirmar que a maior parte do tempo gasto corrigindo erros de compilação, por ironia do destino, não terá origem na compilação em si, mas no preprocessamento e linkedição. Isso porque o preprocessamento confunde muito o que vimos no nosso editor preferido, e a linkedição ocorre em uma fase onde não importa mais o que está dentro das funções, mas sim o escopo de nomes, um assunto um pouco mais vago do que a linguagem C.&lt;/p&gt;
&lt;p&gt;Aqui você irá encontrar geralmente erros bem comportados, como conversão entre tipos, else sem if e esquecimento de pontuação ou parênteses.&lt;/p&gt;
&lt;p&gt;Um outro erro que já encontrei algumas vezes é quando a definição de uma classe tem um sizeof diferente do compilado em sua LIB, pela exclusão ou adição de novos membros. Isso pode (vai) fazer com que, durante a execução, a pilha seja corrompida, membros diferentes sejam acessados, entre outras traquinagens. Esses erros costumam acusar a falta de sincronismo entre os headers usados e suas reais implementações.&lt;/p&gt;
&lt;p&gt;Enfim, na vida real, é impossível catalogar todos os erros que podem ocorrer em um fonte em C. Se isso fosse possível, ou não existiriam bugs, ou pelo menos existiria uma ferramenta para automaticamente procurar por esses erros e corrigi-los.&lt;/p&gt;
&lt;p&gt;Criei uma solução no Visual Studio com alguns erros básicos, alguns demonstrados aqui, outros não, mas enfim, completamente configuráveis e divididos nessas três fases. É possível habilitar e desabilitar erros através do header cpperrors.h. Espero que gostem.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Funky do-while</title>
  <link>http://www.caloni.com.br/funky-do-while/</link>
  <pubDate>2008-02-13</pubDate>
  
  <guid>http://www.caloni.com.br/funky-do-while/</guid>
  <description>&lt;p&gt;It&#39;s a known habit to use do-while constructions when there&#39;s a need to define a macro that has more than one command instead of using the { simple multicommand brackets }. What was never clear is why this is so.&lt;/p&gt;
&lt;p&gt;Let&#39;s imagine a trace macro that&#39;s enabled in debug mode, whilst kept in silence in release builds:&lt;/p&gt;
&lt;p&gt;Nothing much, but it seems to work. But, as we going to see in the following lines, it is really a buggy piece of code, since a call inside an if-else construction simply doesn&#39;t work.&lt;/p&gt;
&lt;p&gt;Why&#39;s that? In order to answer this question, we need to look closer into the result code from the preprocessor, just replacing the macro for its piece of code:&lt;/p&gt;
&lt;p&gt;So, that&#39;s why. When we call a macro, generally we use the funcion-call syntax, putting a semicolon in the end. This is the right way to call a function, but in the macro case, it&#39;s a disaster, because it creates two commands instead of one (an empty semicolon, despite doing nothing, it&#39;s a valid command). So that&#39;s what the compiler does:&lt;/p&gt;
&lt;p&gt;Think about the empty command as if it was a real command, what is the easier way to realize the compiler error:&lt;/p&gt;
&lt;p&gt;printf(&amp;quot;here we go&amp;quot;);&lt;/p&gt;
&lt;p&gt;For this reason, the tradicional way to skip this common error is to use a valid construction who asks for a semicolon in the end. Fortunately, language C has such construction, and it is... right, the do-while!&lt;/p&gt;
&lt;p&gt;;&lt;/p&gt;
&lt;p&gt;So we can rewrite our trace macro the right way, even being a funcky one:&lt;/p&gt;
&lt;p&gt;Using a do-while (with a false expression inside the test to execute the block just once) the if-else construction is allowed and working properly:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Desconstruindo IOCCC</title>
  <link>http://www.caloni.com.br/desconstruindo-ioccc/</link>
  <pubDate>2008-02-11</pubDate>
  
  <guid>http://www.caloni.com.br/desconstruindo-ioccc/</guid>
  <description>&lt;p&gt;Como alguns devem saber, e outros não (ou não deveriam), existe uma competição internacional para escolher quem escreve o código em C mais ofuscado. Isso mesmo. O evento se chama The International Obfuscated C Code Contest (IOCCC resumidamente) e costuma premiar anualmente os melhores &amp;quot;do ramo&amp;quot; com a chamada &amp;quot;menção desonrosa&amp;quot;.&lt;/p&gt;
&lt;p&gt;Acredito que a real valia de um campeonato desse porte é fazer as pessoas pensarem mais a fundo sobre as regras da linguagem. Isso faz com que erros mais obscuros que encontramos no dia-a-dia se tornem mais fáceis. Claro que ninguém deveria programar como os caras desse torneio, mas a título de aprendizagem, é uma grande aula sobre C.&lt;/p&gt;
&lt;p&gt;Publico aqui a interpretação do primeiro programa a ganhar a tal menção desonrosa, em 1984. Se trata do batidíssimo &amp;quot;Hello World&amp;quot;, só que um pouco compactado e confuso. Vejamos o fonte original:&lt;/p&gt;
&lt;p&gt;Aparentemente o fonte é bem confuso, apesar de podermos já ver a famosa string escondida no meio do código. Depois de aplicar uma formatação mais adequada para nossa tarefa de desfazer o feito, o resultado é bem mais legível:&lt;/p&gt;
&lt;p&gt;Algumas construções são óbvias. Vamos então partir para as não-tão-óbvias.&lt;/p&gt;
&lt;p&gt;Como toda variável global inteira, é inicializada com zero. Logo, a linha acima é equivalente a &amp;quot;int i =0&amp;quot;.&lt;/p&gt;
&lt;p&gt;Aos programadores C++ desavisados de plantão, em C o valor de retorno padrão é int, e, caso não seja retornado nada, isso não constitui um erro, porém o comportamento é não-definido. Nada de mal, porém, pode ocorrer, a não ser o retorno de lixo da pilha.&lt;/p&gt;
&lt;p&gt;Outra coisa óbvia, mas não tanto, é um laço for sem corpo. Ele possui apenas um ponto-e-vírgula, que identifica uma instrução nula. Não faz nada no corpo, mas pode fazer coisas interessantes no cabeçalho, ou seja, na inicialização, no teste e no incremento. Como podemos ver, a inicialização também está vazia, contendo esse laço apenas o teste e o incremento. No teste temos a seguinte comparação:&lt;/p&gt;
&lt;p&gt;Ora, sabendo que a variável &amp;quot;i&amp;quot; inicialmente tem o valor zero, o que estamos vendo aqui é a mesma coisa que&lt;/p&gt;
&lt;p&gt;E uma vez que aprendemos algumas peculiaridades sobre o operador de subscrito em C, sabemos que a linha acima é equivalente a essa linha abaixo:&lt;/p&gt;
&lt;p&gt;Agora ficou mais fácil de entender. Se trocarmos a nossa string literal por uma variável (forma mais usual), temos um acesso típico a um dos caracteres de uma string:&lt;/p&gt;
&lt;p&gt;Só precisamos lembrar que a variável i é que define a posição, e por ser uma variável, pode mudar durante a execução:&lt;/p&gt;
&lt;p&gt;Pois bem. Agora sabemos que o laço irá ser testado pelo menos uma vez, o que quer dizer que a parte do incremento vai executar pelo menos uma vez. E essa parte é a seguinte:&lt;/p&gt;
&lt;p&gt;Uma chamada de função. Nada mais simples. Podemos anular algumas coisas por aqui. Por exemplo, se subtraímos um número dele mesmo encontramos zero, e se dividirmos um número por ele mesmo o resultado é um:&lt;/p&gt;
&lt;p&gt;Lembre-se de que um caractere em C é um tipo inteiro, e portanto, pode fazer parte de cálculos matemáticos. Depois dessa simplificação, temos&lt;/p&gt;
&lt;p&gt;Agora você deveria estar se perguntando (se ainda não encontrou a resposta) do porquê de eu ter dividido os três sinais de + dessa forma. Existem duas opções para a divisão:&lt;/p&gt;
&lt;p&gt;A primeira forma é a resposta correta devido à regra de precedência (deferida pela gramática). Antes os operadores unários, depois os binários. Dessa forma, um &amp;quot;i+&amp;quot; não quer dizer nada, mas &amp;quot;i++&amp;quot; é um operando com um operador unário.&lt;/p&gt;
&lt;p&gt;Voltando à expressão, imagino que a essa altura você já deva ter decifrado que i++ + &amp;quot;hello, world!\n&amp;quot; é o mesmo que:&lt;/p&gt;
&lt;p&gt;Ou seja, obtemos o endereço do primeiro caractere da string e incrementamos nossa variável &amp;quot;i&amp;quot; que, como sabemos, é usada no teste do laço for. Na primeira vez, testamos se o primeiro caractere de &amp;quot;] &amp;lt; i; ++i ){--i;}&amp;quot; é diferente de zero. Na segunda iteração, portanto, iremos testar se o segundo caractere será zero. Sabendo disso, podemos deduzir que o laço irá correr por todos os caracteres da string de teste, até encontrar o zero finalizador de string. Ao mesmo tempo, iremos enviar para a função read sempre o endereço do i&#39;ésimo caractere da string &amp;quot;hello, world!\n&amp;quot;, pois essa string também é indexada pela variável &amp;quot;i&amp;quot;.&lt;/p&gt;
&lt;p&gt;Isso quer dizer que nosso laço irá terminar exatamente no final de ambas as strings! (Note, que para comparar as strings, usamos as strings originais do programa, sem melhorar a formatação).&lt;/p&gt;
&lt;p&gt;Também devemos lembrar que o caractere de controle &#39;\n&#39; é representado apenas por um byte, apesar de no fonte parecer dois.&lt;/p&gt;
&lt;p&gt;Em um passado bem longínquo, o padrão ANSI C não existia, e outras funções dominavam o ambiente UNIX. Muitas dessas funções foram adaptadas, e outras completamente copiadas para a formação do padrão. No entanto, ainda que o padrão não tenha colocado algumas funções clássicas, elas continuaram sendo usadas e suportadas. Um bom exemplo disso são as funções read e write, que, apesar de não estarem no padrão, estão no livro de K&amp;amp;R, no capítulo sobre fluxos (streams) em UNIX, provando que são bem populares.&lt;/p&gt;
&lt;p&gt;Dentro desse mundo paralelo, existem identificadores de fluxos padrões para a entrada e a saída padrão. Melhor ainda, esses identificadores são inteiros que estão especificados da seguinte maneira (tirado da referência GNU da linguagem C, meu grifo):&lt;/p&gt;
&lt;p&gt;&amp;quot;There are also symbolic constants defined in unistd.h for the file descriptors belonging to the standard streams stdin, stdout, and stderr; see Standard Streams.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STDINFILENO This macro has value 0, which is the file descriptor for standard input.&lt;/li&gt;
&lt;li&gt;STDOUTFILENO This macro has value 1, which is the file descriptor for standard output.&lt;/li&gt;
&lt;li&gt;STDERRFILENO This macro has value 2, which is the file descriptor for standard error output.&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agora podemos voltar ao fonte. Vejamos como é implementada a função read, chamada dentro do laço for. Como todos sabem, se uma função já é definida em sua própria unidade, não haverá uma busca por referências externas, o que quer dizer que a implementação padrão de read não atrapalha a implementação local.&lt;/p&gt;
&lt;p&gt;Ótimo. A função read chama a função (essa sim, padrão) write. Sabemos que tanto o primeiro quanto o último parâmetro da função será sempre constante no laço for:&lt;/p&gt;
&lt;p&gt;O que quer dizer que o primeiro argumento passado para write será sempre o mesmo:&lt;/p&gt;
&lt;p&gt;Além da constante óbvia passada no último argumento:&lt;/p&gt;
&lt;p&gt;Isso quer dizer que a chamada para write pode ser resumida para:&lt;/p&gt;
&lt;p&gt;O decremento da variável &amp;quot;i&amp;quot; (dentro de read) nunca é usado, uma vez que é uma variável local. E subtrair &amp;quot;j&amp;quot; é inócuo, uma vez que o valor de &amp;quot;j&amp;quot; será sempre zero. Logo, o argumento do meio é sempre o parâmetro do meio, por mais idiota que isso possa parecer =)&lt;/p&gt;
&lt;p&gt;Pronto, já temos condições de interpretar o significado dessa chamada à write. Como já vimos, o número 1 identifica a saída padrão, o que quer dizer que estamos escrevendo algo na saída padrão. Esse algo é o parâmetro &amp;quot;i&amp;quot; que, como vimos, é o endereço do i&#39;ésimo caractere da string &amp;quot;hello, word!\n&amp;quot;. O último argumento é o número de bytes a serem escritos, que será sempre um. O que quer dizer que o laço em for chamada a função read strlen(&amp;quot;hello, world!\n&amp;quot;) vezes passando o endereço do próximo caractere de cada vez. A função read, por sua vez, escreve este caractere na saída padrão. O resultado, como todos que compilarem o fonte e rodarem poderão comprovar, é a impressão da mensagem mais famosa do mundo da computação:&lt;/p&gt;
&lt;p&gt;E voilà =)&lt;/p&gt;
&lt;p&gt;Abaixo um código-fonte equivalente, devidamente desencriptado:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Silly regex trick: finding the project who failed inside a big VS solution</title>
  <link>http://www.caloni.com.br/silly-regex-trick-finding-the-project-who-failed-inside-a-vs-big-solution/</link>
  <pubDate>2008-02-07</pubDate>
  
  <guid>http://www.caloni.com.br/silly-regex-trick-finding-the-project-who-failed-inside-a-vs-big-solution/</guid>
  <description>&lt;p&gt;I know what you going to think about this one: &amp;quot;silly trick&amp;quot;. That&#39;s why I just put it in the title. Anyway, that is something I use everyday, so I thought it might be useful to who cares about productivity.&lt;/p&gt;
&lt;p&gt;Let&#39;s say you have to manage a big solution in Visual Studio made of more than 30 projects, and needs to rebuild all them. Suddenly, something goes wrong. The question is: how to discover, in a heartbeat, what project has failed?&lt;/p&gt;
&lt;p&gt;Note that you need to enable &amp;quot;Regular Expressions&amp;quot; option in the Find Dialog (not shown here).&lt;/p&gt;
&lt;p&gt;What I&#39;m saying inside this regex is &amp;quot;find the first number different from zero followed by a space and the letters err&amp;quot;. This lead us to the first project who has at least one error:&lt;/p&gt;
&lt;p&gt;If you think &amp;quot;what about when a project generates more than 9 errors? the regex wouldn&#39;t be able to catch this case&amp;quot;, well, you&#39;re right. Anyway, that&#39;s the quicker form to search for the unsuccessful project inside a big solution. A more complex yet complete regex would be:&lt;/p&gt;
&lt;p&gt;For me, the first version is enough. It is faster to type, simpler to catch and solves my problem. I hope it can solve yours =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Process Monitor e o monopólio malcriado</title>
  <link>http://www.caloni.com.br/process-monitor-e-o-monopolio-malcriado/</link>
  <pubDate>2008-02-05</pubDate>
  
  <guid>http://www.caloni.com.br/process-monitor-e-o-monopolio-malcriado/</guid>
  <description>&lt;p&gt;Essa é uma regra básica, mas não é fácil de cumpri-la.  Só quem já tentou fazer isso sabe do que estou falando. Inúmeros programas mal-escritos vão tentar, de uma hora pra outra, acessar áreas do sistema de arquivos e registro que não possuem acesso, pois agora estão rodando em uma conta mais restrita. E não são programas de administração ou manutenção do sistema. Estou falando de programas de escritório e jogos. Aqui vai um singelo exemplo que tive que lidar esse fim-de-semana.&lt;/p&gt;
&lt;p&gt;Primeiramente, quero deixar bem claro que jogamos Monopoly por mais ou menos dois meses sem ter qualquer tipo de problema, em três computadores diferentes. Até que resolvemos usar uma conta mais restrita. Foi o bastante para o programinha inocente começar a chiar.&lt;/p&gt;
&lt;p&gt;Mau garoto. Bons tempos em que quando um jogo travava o máximo que tínhamos que fazer era apertar um botão.&lt;/p&gt;
&lt;p&gt;Para encontrar problemas desse tipo, sempre uso o Process Monitor, que tem virado minha ferramenta básica para muitas coisas. Para os que não conhecem, o Process Monitor é uma ferramenta de auditoria de operações no sistema operacional, ou seja, tudo que alguém ler e escrever em arquivos e no registro será logado.&lt;/p&gt;
&lt;p&gt;Sua função é mostrar tudo, absolutamente tudo que o sistema está fazendo em um determinado espaço no tempo. Isso pode ser ruim por um lado, já que será bem difícil encontrar alguma informação útil no meio de tanto lixo que pode ser gerado em um log de poucos momentos. Para ter uma idéia do que eu estou falando, tente abrir o Procmon sem qualquer filtro e deixá-lo rodando por 30 segundos sem fazer nada. No meu sistema, isso deu aproximadamente 20 000 linhas de eventos de log. Nada mau para um sistema ocioso.&lt;/p&gt;
&lt;p&gt;É por isso que ele vem &amp;quot;de fábrica&amp;quot; já com uma série de filtros, que evitam lotar o log de eventos com informação sempre gerada pelo sistema, mas quase sempre inútil. Além dos filtros-padrão, podemos inserir nossos próprios filtros. É isso que faremos aqui para pegar o monopólio malcriado (sem trocadilhos).&lt;/p&gt;
&lt;p&gt;Como podemos ver, iremos mostrar em nosso log todos os eventos cujo nome do processo seja monopolyclassic.exe (o nosso amigo faltoso) e iremos excluir do log qualquer evento cujo resultado tenha sido sucesso (se deu certo, provavelmente não é um erro).&lt;/p&gt;
&lt;p&gt;Executamos novamente o jogo, dessa vez com o Process Monitor capturando todos seus movimentos.&lt;/p&gt;
&lt;p&gt;Agora, uma pequena ressalva: eu estou cansado de ver isso, mas para quem nunca viu, pode não ser tão óbvio. Como eu disse no início do artigo, programas mal-escritos costumam tentar acessar áreas do sistema que não são acessíveis para usuários comuns. Isso quer dizer que, se o problema que está acontecendo com o jogo tem a ver com essa peculiaridade, a primeira coisa a procurar é por erros de acesso negado.&lt;/p&gt;
&lt;p&gt;A primeira busca retorna uma chave no registro referente às propriedades de joystick. Como não estou usando joysticks, podemos ignorar este erro por enquanto e passar adiante.&lt;/p&gt;
&lt;p&gt;O próximo erro diz respeito a uma tentativa de acesso ao arquivo Monopoly.log localizado no diretório de instalação do jogo, o que já é mais sugestivo. Podemos fazer um pequeno teste alterando o acesso desse arquivo.&lt;/p&gt;
&lt;p&gt;Como podemos ver, o que é muito natural, um arquivo dentro da pasta de instalação de programas permite acesso de somente leitura para usuários comuns a seus arquivos, inclusive o Monopoly.log. Para fazer o teste, podemos simplesmente adicionar controle total a apenas esse arquivo, e rodar novamente o jogo.&lt;/p&gt;
&lt;p&gt;Ora essa, estou conseguindo rodar o jogo! Isso quer dizer que nosso único problema, o acesso a esse arquivo, foi resolvido. Sabendo que um arquivo de log provavelmente não será executado por nenhuma conta privilegiada, podemos deixá-lo com acesso irrestrito para todos.&lt;/p&gt;
&lt;p&gt;Para ter certeza que isso resolveu o problema, uma segunda auditoria de execução executada pelo Process Monitor pode nos revelar mais detalhes.&lt;/p&gt;
&lt;p&gt;Moral da história: se algum dia você vier a escrever um programa inocente, deixe que pessoas inocentes consigam utilizá-lo.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Compartilhando variáveis com o mundo v2</title>
  <link>http://www.caloni.com.br/compartilhando-variaveis-com-o-mundo-v2/</link>
  <pubDate>2008-02-01</pubDate>
  
  <guid>http://www.caloni.com.br/compartilhando-variaveis-com-o-mundo-v2/</guid>
  <description>&lt;p&gt;Nota de desempenho: esse artigo finaliza (finalmente) a republicação de todos os artigos do antigo blogue. Isso quer dizer que a partir de agora eu sou obrigado a trabalhar, e, se quiser manter meu ritmo atual, vou ter que fazer mais do que cinco cliques do mouse.&lt;/p&gt;
&lt;p&gt;Como todas as coisas que fazemos e pensamos depois, descobrimos que sempre existe uma outra maneira de fazer a mesma coisa. Se é melhor ou não, pode ser uma questão de gosto, estética, objetivos de vida, etc. Com a implementação das variáveis mapeadas globais não foi diferente. Bem, é isso que se espera fazer com código experimental: experimentos. E deu no que deu: SharedVar versão 2.0 alpha Enterprise Edition.&lt;/p&gt;
&lt;p&gt;Quando comentei no final do artigo anterior que existem pessoas que só conseguem gerar código dentro de uma classe, não estava brincando. Existem linguagens, inclusive, que suportam apenas o paradigma de orientação a objetos, e levam isso muito a sério. C++ com certeza não é uma dessas linguagens, o que quer dizer que você tem a liberdade e a responsabilidade de tomar o melhor caminho para determinado problema.&lt;/p&gt;
&lt;p&gt;Nessa segunda solução do nosso programa alocador de variáveis globais, pra variar, vamos utilizar uma classe. E pra entrar de vez no mundo POO vamos utilizar de quebra tratamento de erro orientado a exceções. Como vamos notar, aplicadas adequadamente, essas duas características da linguagem conseguirão um código mais simples de entender, embora não se possa dizer o mesmo da implementação &amp;quot;under the hood&amp;quot;.&lt;/p&gt;
&lt;p&gt;Como podemos notar, em programação &amp;quot;nada se cria, tudo se reutiliza&amp;quot;. Reutilização é boa quando podemos acrescentar características adicionais ao código sem deturpar seu objetivo original. E isso é bom.&lt;/p&gt;
&lt;p&gt;Note que nossa classe tenta fazer as coisas logo no construtor, já que seu único objetivo é representar uma variável da memória cachê. Se ela não for bem-sucedida em sua missão, ela explode, porque não há nada que ela possa fazer para garantir a integridade do objeto sendo criado e ela não tem como saber qual o melhor tratamento de erro para o usuário da classe. Geralmente o melhor - ou pelo menos o mais adequado - é o tratamento que o usuário dá ao seu código, porque o usuário da classe é que deve saber o contexto de execução do seu código.&lt;/p&gt;
&lt;p&gt;Bem, como o código agora está em uma classe e o erro é baseado em exceção, o código cliente muda um pouco:&lt;/p&gt;
&lt;p&gt;Existem duas mudanças significativas: 1. a variável sozinha já representa a memória compartilhada; 2. o tratamento de erro agora é centralizado em apenas um ponto. Se pra melhor ou pior, eu não sei. Tratamento de exceções e classes são duas &amp;quot;modernisses&amp;quot; que podem ou não se encaixar em um projeto de desenvolvimento. Tudo vai depender de tudo. Por isso a melhor saída depende de como será a entrada.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Compartilhando variáveis com o mundo</title>
  <link>http://www.caloni.com.br/compartilhando-variaveis-com-o-mundo/</link>
  <pubDate>2008-01-30</pubDate>
  
  <guid>http://www.caloni.com.br/compartilhando-variaveis-com-o-mundo/</guid>
  <description>&lt;p&gt;Desde que comecei a programar, para compartilhar variáveis entre processo é meio que consenso usar-se a milenar técnica do crie uma seção compartilhada no seu executável/DLL. Isso funciona desde a época em que o Windows era em preto e branco. Mas, como tudo em programação, existem mil maneiras de assar o pato. Esse artigo explica uma delas, a não-tão-milenar técnica do use memória mapeada nomeada misturada com templates.&lt;/p&gt;
&lt;p&gt;Era comum (talvez ainda seja) fazer um código assim:&lt;/p&gt;
&lt;p&gt;Aquele pragma do começo garante que qualquer instância do mesmo executável, mas processos distintos, irão compartilhar qualquer variável definida dentro da seção &amp;quot;shared&amp;quot;. O nome na verdade não importa muito - é apenas usado para clareza - , mas o atributo do final, sim.&lt;/p&gt;
&lt;p&gt;Algumas desvantagens dessa técnica são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Não permite compartilhamento entre executáveis diferentes, salvo se tratar-se de uma DLL carregada por ambos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;É um compartilhamento estático, que permanece do início do primeiro processo ao fim do último.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Não possui proteção, ou seja, se for uma DLL, qualquer executável que a carregar tem acesso à área de memória.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Muitas vezes essa abordagem é suficiente, como em hooks globais, que precisam apenas de uma ou duas variáveis compartilhadas. Também pode ser útil como contador de instâncias, do mesmo jeito que usamos as variáveis estáticas de uma classe em C++ (vide sharedptr do boost, ou a CString do ATL, que usa o mesmo princípio).&lt;/p&gt;
&lt;p&gt;Houve uma vez em que tive que fazer hooks direcionados a threads específicas no sistema, onde eu não sabia nem qual o processo host nem quantos hooks seriam feitos. Essa é uma situação onde fica muito difícil usar a técnica milenar.&lt;/p&gt;
&lt;p&gt;Foi daí que eu fiz um conjunto de funções alfa-beta de compartilhamento de variáveis baseado em template e memória mapeada:&lt;/p&gt;
&lt;p&gt;Como pode-se ver, o seu funcionamento é muito simples: uma função-template que recebe uma referência para um ponteiro de ponteiro do tipo da variável desejada, o seu nome global e retorna uma variável alocada na memória de cachê do sistema. Como contraparte existe uma função que abre essa memória baseada em seu nome e faz o cast (coversão de tipo) necessário. Ambas as chamadas devem chamar uma terceira função para liberar o recurso.&lt;/p&gt;
&lt;p&gt;O segredo para entender mais detalhes dessa técnica é pesquisar as funções envolvidas: CreateFileMapping, OpenFileMapping, MapViewOfFile e UnmapViewOfFile. Bem, o CloseHandle também ;)&lt;/p&gt;
&lt;p&gt;Ah, é mesmo! Fiz especialmente para o artigo:&lt;/p&gt;
&lt;p&gt;Preciso lembrar que essa é uma versão inicial ainda, mas que pode muito bem ser melhorada. Duas idéias interessantes são: parametrizar a proteção da variável (através do SECURITYATTRIBUTES) e transformá-la em classe. Uma classe parece ser uma idéia bem popular. Afinal, tem tanta gente que só se consegue programar se o código estiver dentro de uma.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MSDN Library - by Microsoft&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Code Project - by Developers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Google - by Google&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>RmThread: rode código em processo vizinho</title>
  <link>http://www.caloni.com.br/rmthread-rode-codigo-em-processo-vizinho/</link>
  <pubDate>2008-01-28</pubDate>
  
  <guid>http://www.caloni.com.br/rmthread-rode-codigo-em-processo-vizinho/</guid>
  <description>&lt;p&gt;Aproveitando que utilizei a mesma técnica semana passada para desenvolver um vírus para Ethical Hacking, republico aqui este artigo que já está mofando no Code Projet, mas que espero que sirva de ajuda pra muita gente que gosta de fuçar nos internals do sistema. Boa leitura!&lt;/p&gt;
&lt;p&gt;RmThread é um projeto que fiz baseado em uma das três idéias do artigo de Robert Kuster , &amp;quot;Three Ways to Inject Your Code into Another Process&amp;quot;. No entanto, não utilizei código algum. Queria aprender sobre isso, pesquisei pela internet, e me influenciei pela técnica CreateRemoteThread &amp;amp; LoadLibrary. O resto foi uma mistura de &amp;quot;chamada de funções certas&amp;quot; e MSDN.&lt;/p&gt;
&lt;p&gt;O projeto que fiz é útil para quem precisa rodar algum código em um processo vizinho, mas não quer se preocupar em desenvolver a técnica para fazer isso. Quer apenas escrever o código que vai ser executado remotamente. O projeto de demonstração, RmThread.exe, funciona exatamente como a técnica citada anteriormente. Você diz qual o processo a ser executado e a DLL a ser carregada, e ele inicia o processo e carrega a DLL em seu contexto. O resto fica por conta do código que está na DLL.&lt;/p&gt;
&lt;p&gt;Para fazer a DLL, existe um projeto de demonstração que se utiliza de uma técnica que descobri para fazer rodar algum código a partir da execução de DllMain sem ficar escravo de suas limitações (você só pode chamar com segurança funções localizadas na kernel32.dll).&lt;/p&gt;
&lt;p&gt;Existem três funções que poderão ser utilizadas pelo seu programa:&lt;/p&gt;
&lt;p&gt;Eis a rotina principal simplificada demonstrando como é simples a utilização das funções:&lt;/p&gt;
&lt;p&gt;A parte mais complicada talvez seja o que fazer quando a sua DLL é carregada. Considerando que ao ser chamada em seu ponto de entrada, o código da DLL possui algumas limitações (uma já citada; para mais, vide a ajuda de DllMain no MSDN), fiz uma &amp;quot;execução alternativa&amp;quot;, criando uma thread na função DllMain:&lt;/p&gt;
&lt;p&gt;A função da thread, por sua vez, é esperar pela finalização da thread DllMain (temos o handle dessa thread armazenado em ghThrDllMain), fazer o que tem que fazer, e retornar, liberando ao mesmo tempo o handle da DLL criado para si:&lt;/p&gt;
&lt;p&gt;A marca TODO é aonde seu código deve ser colocado (você pode tirar o MessageBox, se quiser). Como DllMain já foi previamente executada, essa parte do código está livre para fazer o que quiser no contexto do processo vizinho.&lt;/p&gt;
&lt;p&gt;Um detalhe interessante é que é necessária a chamada de FreeLibraryAndExitThread. Do contrário, após chamar FreeLibrary, o código a ser executado depois (um simples return) estaria em um endereço de memória inválido, já que a DLL não está mais carregada. O resultado não seria muito agradável.&lt;/p&gt;
&lt;p&gt;Um problema chato (que você poderá encontrar) é que, se a DLL não for carregada com sucesso, não há uma maneira trivial de obter o código de erro da chamada de LoadLibrary. Uma vez que a thread inicia e termina nessa função API, o LastError se perde. Alguma idéia?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Endereço do artigo (e fontes) no Code Project&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Keychanger de criança</title>
  <link>http://www.caloni.com.br/keychanger-de-crianca/</link>
  <pubDate>2008-01-24</pubDate>
  
  <guid>http://www.caloni.com.br/keychanger-de-crianca/</guid>
  <description>&lt;p&gt;Às vezes na vida a vontade de fazer alguma coisa besta acaba sendo mais forte do que o senso de ridículo. Então, resolvi ressuscitar o quase apodrecido RusKey, um programa que fiz para trocar letras digitadas no teclado. A idéia é muito simples: o sujeito digita &#39;i&#39; e sai um &#39;c&#39;, digita um &#39;f&#39; e sai um &#39;u&#39;, e assim por diante. Se estiver programando e for criar um if, por exemplo, no lugar da palavra if vai aparecer... bom, não é exatamente um if que vai aparecer na tela =).&lt;/p&gt;
&lt;p&gt;Mas se analisarmos dessa maneira pode parecer até coisa de &amp;quot;ráquer&amp;quot;, o que certamente não é. Na verdade, se trata de um programa didático que visa ensinar a digitação em leiautes de teclados diferentes do normal em idiomas latinos. Pelo menos essa foi a intenção original.&lt;/p&gt;
&lt;p&gt;Na época eu estava às voltas com o leiaute do famoso teclado russo (percebeu a origem do nome do programa?). Eu havia estudado cirílico e estava na hora de pôr em prática no computador. Mas, como quase nunca treinava, quando tentava procurar uma palavra no Babylon ou arriscar uma expressão nas conversas com minha amiga de Moscou me perdia completamente para encontrar as letras. A necessidade é a mãe da invenção e foi aí que começou o desenvolvimento.&lt;/p&gt;
&lt;p&gt;Um alfabeto é uma das muitas maneiras de representar as palavras de uma língua por escrito. Uma palavra escrita é um conjunto de letras que representa os sons que usamos para falar essa palavra. Cada som usado é chamado de fonema.&lt;/p&gt;
&lt;p&gt;Assim sendo, embora o alfabeto russo seja diferente do alfabeto latino muitos fonemas são compartilhados. Isso quer dizer que podemos pegar algumas letras do cirílico e traduzir diretamente para algumas letras do nosso alfabeto, e outras letras não. Exemplos de letras que podemos fazer isso:&lt;/p&gt;
&lt;p&gt;Porém, após a tradução de uma letra no teclado, a posição dela geralmente não é a mesma posição do nosso teclado. Daí temos uma letra de nosso alfabeto em outro lugar. Se for feita uma tradução aproximada entre os dois alfabetos, nossas letras em um teclado russo ficariam dispostas assim:&lt;/p&gt;
&lt;p&gt;Bem diferente do QWERT ASDFG que estamos acostumados, não?&lt;/p&gt;
&lt;p&gt;Ao digitar usando esse pseudo-leiaute o treino do leiaute do teclado russo estaria sendo feito mesmo escrevendo com o alfabeto latino. Legal, não? Poderia programar com as letras todas trocadas, porque a saída final é a mesma. Basta treinar os dedos para acertarem as mesmas letras nos novos lugares. Assim, quando precisasse escrever no alfabeto cirílico saberia melhor onde cada letra fica.&lt;/p&gt;
&lt;p&gt;A idéia é simples, e o código também não é nada complexo. Só preciso de um EXE e uma DLL. No EXE chamo uma função exportada pela DLL que por sua vez instala um hook de mensagens:&lt;/p&gt;
&lt;p&gt;Nas chamadas da função de callback da DLL, manipulo a mensagem WMCHAR, que corresponde à digitação de caracteres, para trocar os caracteres originais do teclado pelos caracteres que deveriam existir no recém-inventado formato latino-russo, totalmente fora dos padrões e normas de segurança existentes:&lt;/p&gt;
&lt;p&gt;Simples assim. E temos um keylogger que troca caracteres! É impressionante como as coisas mais simples podem se transformar nos momentos mais divertidos de um programador em um feriado.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Endereço do artigo (e fontes) no Code Project&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Otimização em funções recursivas</title>
  <link>http://www.caloni.com.br/otimizacao-em-funcoes-recursivas/</link>
  <pubDate>2008-01-18</pubDate>
  
  <guid>http://www.caloni.com.br/otimizacao-em-funcoes-recursivas/</guid>
  <description>&lt;p&gt;O livro que estou lendo fala sobre algoritmos em C. Os primeiros capítulos são praticamente uma revisão para quem já programou em C, pois tratam de coisas que programadores com mais de cinco anos de casa devem ter na memória cachê (listas, pilhas, recursão, etc). Porém, tive uma agradável surpresa de achar um truque muito sabido que não conhecia, chamado de tail recursion. Fiz questão de testar nos dois compiladores mais conhecidos e eis o resultado.&lt;/p&gt;
&lt;p&gt;Imagine uma função recursiva que calcula o fatorial de um número. Apenas para lembrar, o fatorial de um número n é igual a n * n-1 * n-2 * n-3 até o número 1. Existem implementações iterativas (com um laço for, por exeplo) e recursivas, que no caso chamam a mesma função n vezes.&lt;/p&gt;
&lt;p&gt;Para ver o overhead de uma função dessas, compilamos com a opção de debug e depuramos no CDB.&lt;/p&gt;
&lt;p&gt;Ou seja, conforme chamamos a função recursivamente, a pilha tende a crescer. Agora imagine todo o overhead da execução, que precisa, a cada chamada, gerar um stack frame.&lt;/p&gt;
&lt;p&gt;A mesma coisa podemos notar se compilarmos o mesmo fonte no GCC e depurarmos pelo GDB. Aliás, a primeira participação especial do GDB nesse blogue =)&lt;/p&gt;
&lt;p&gt;Isso acontece porque o compilador é obrigado a montar um novo stack frame para cada chamada da mesma função, já que os valores locais precisam manter-se intactos até o retorno recursivo da função. Porém, existe uma otimização chamada de tail recursion, que ocorre se, e somente se (de acordo com meu livro):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A chamada recursiva é a última instrução que será executada no corpo da função.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O valor de retorno da chamada não é parte de uma expressão.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note que ser a última instrução não implica em ser a última linha da função, o importante é que seja a última linha executada. No nosso exemplo, isso já é fato, só que usamos o retorno em uma expressão.&lt;/p&gt;
&lt;p&gt;Por isso é necessário desenvolver uma segunda versão do código, que utiliza dois parâmetros para que aconteça a situação de tail recursion.&lt;/p&gt;
&lt;p&gt;Nessa segunda versão, a chamada da função recursiva não mais é parte de uma expressão, e continua sendo a última instrução executada. Agora só temos que compilar com a opção de otimização certa em ambos os compiladores e testar.&lt;/p&gt;
&lt;p&gt;Para o Visual Studio, podemos usar a flag /Og (otimização global).&lt;/p&gt;
&lt;p&gt;Como podemos ver, após n chamadas, a pilha continua apenas com uma chamada a factorial.&lt;/p&gt;
&lt;p&gt;Para o GCC, a opção é mais explítica, e funciona da mesma forma.&lt;/p&gt;
&lt;p&gt;Voilà!&lt;/p&gt;
&lt;p&gt;PS: De brinde uma versão que permite passar o número via linha de comando para facilitar os testes (e você vai reparar que há um problema em calcular o fatorial de 1000: ele é estupidamente grande! Resolver isso fica como exercício =).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Encontrando as respostas do Flash Pops</title>
  <link>http://www.caloni.com.br/encontrando-as-respostas-do-flash-pops/</link>
  <pubDate>2008-01-16</pubDate>
  
  <guid>http://www.caloni.com.br/encontrando-as-respostas-do-flash-pops/</guid>
  <description>&lt;p&gt;Existe uma série de jogos no sítio da UOL onde você deve acertar o nome de filmes, programas de televisão, entre outros, que vão da década de 40 até a atualidade. É divertido e viciante fazer pesquisa na internet para encontrar os resultados, ainda mais quando já se é viciado em cinema. Ficamos jogando, eu e minha namorada, por semanas a fio. Quase chegamos a preencher tudo, e por um bom tempo ficamos travados para terminar. Então começamos a apelar para o Google e o IMDB até os limites do razoável. Nesse fim de semana, por exemplo, chegamos a assistir um filme de madrugada onde tocou rapidamente um trecho de uma das músicas que faltava no jogo sobre televisão. No dia seguinte procuramos a trilha sonora do filme, ouvimos faixa a faixa e procuramos o nome da música no Google, para finalmente encontrar o resultado.&lt;/p&gt;
&lt;p&gt;Essa foi a última resposta &amp;quot;honesta&amp;quot;. Depois resolvi apelar para o WinDbg =)&lt;/p&gt;
&lt;p&gt;A primeira coisa que pensei a respeito desse jogo foi que ele não seria tão ingênuo a ponto de colocar as respostas em texto aberto, do contrário, qual seria a graça, certo? Errado! Bom, no final das contas, um passo-a-passo bem simples me levou a encontrar a lista de respostas.&lt;/p&gt;
&lt;p&gt;A primeira coisa a fazer é carregar o jogo na memória do navegador. Em seguida, seguindo meu raciocínio inicial, digitei a primeira resposta do jogo.&lt;/p&gt;
&lt;p&gt;A partir daí, podemos &amp;quot;atachar&amp;quot; o WinDbg no processo do navegador e rastrear a memória do processo.&lt;/p&gt;
&lt;p&gt;[](/images/win-pan.mp3)Então, como eu dizia, não faça isso em casa enquanto estiver digitando um artigo de seu blogue dentro do navegador. Ele vai travar!&lt;/p&gt;
&lt;p&gt;OK. A primeira coisa é procurar pela string digitada, na esperança de achar a estrutura que escreve as respostas de acordo com a digitação. Isso pode ser feito facilmente graças ao WinDbg e ao artigo de Volker von Einem que ensina como procurar strings por toda a memória de um processo (mais tarde iremos também usar o comando-bônus do comentário de Roberto Farah).&lt;/p&gt;
&lt;p&gt;Interessante. Dois resultados. Olhando o primeiro deles, vemos que encontramos o que queríamos sem nem  mesmo tentar quebrar alguma chave de criptografia.&lt;/p&gt;
&lt;p&gt;O segundo, porém, não parece uma lista de respostas, mas sim a resposta que acabamos de digitar no navegador.&lt;/p&gt;
&lt;p&gt;Para se certificar, rodamos novamente o navegador, apagamos a resposta e refazemos a busca.&lt;/p&gt;
&lt;p&gt;De fato, a lista de respostas é tudo que encontramos.&lt;/p&gt;
&lt;p&gt;Assim como no artigo sobre carregamento de DLLs arbitrárias,  vamos usar o muito útil comando .foreach, que caminha em uma lista de resultados de um comando para executar uma lista secundária de comandos. Apenas para relembrar, a sintaxe do foreach é a seguinte:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Variable. Um nome que usamos no OutCommands. Representa cada &lt;em&gt;token&lt;/em&gt; do resultado de InCommands.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InCommands. Um ou mais comandos que executamos para gerar uma saída na tela. Essa saída será usada em OutCommands, onde Variable é substituído por cada &lt;em&gt;token&lt;/em&gt; da saída.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OutCommands. Um ou mais comandos executados usando a saída na tela de InCommands.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para o .foreach, um token é uma string separada por espaço(s). A saída dos comandos do WinDbg nem sempre vai gerar algo que podemos usar diretamente, como no caso da busca que fizemos inicialmente. Apenas para demonstração, vamos imprimir todos os tokens da saída de nosso comando.&lt;/p&gt;
&lt;p&gt;Isso acontece porque ele utilizada cada palavra separada por espaços da saída da busca.&lt;/p&gt;
&lt;p&gt;Por isso usamos a flag [1], que faz com que o comando imprima apenas o endereço onde ele encontrou a string.&lt;/p&gt;
&lt;p&gt;Enfim, vamos ao que interessa. Para imprimir todas as strings que representam as respostas, podemos simplesmente, no OutCommands, fazer uma nova busca por string, só que dessa vez genérica, dentro de uma faixa razoável (digamos, 4KB).&lt;/p&gt;
&lt;p&gt;Bom, vou parar o dump por aqui, já que, entre os leitores, pode haver quem queria se divertir primeiro do jeito certo =)&lt;/p&gt;
&lt;p&gt;Vimos que o jogo é facilmente quebrável porque armazena as respostas em texto claro. Uma solução alternativa seria utilizar um hash com colisão próxima de zero. Com isso bastaria trocar as respostas possíveis por hashs possíveis e armazená-los no lugar. Quando o usuário digitasse, tudo que o programa precisaria mudar era gerar um hash a partir da resposta do usuário e comparar com o hashs das respostas válidas.&lt;/p&gt;
&lt;p&gt;Por uma incrível coincidência, esse truquezinho eu aprendi com meu amigo Thiago há poucos dias, que está lendo Reversing. Simples, porém funcional.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Temas no WinDbg</title>
  <link>http://www.caloni.com.br/temas-no-windbg/</link>
  <pubDate>2008-01-14</pubDate>
  
  <guid>http://www.caloni.com.br/temas-no-windbg/</guid>
  <description>&lt;p&gt;Desde a versão 6.4.7.2 que o WinDbg fornece uma subpasta chamada Themes, onde lá estão diversos workspaces configurados. Existe até um passo-a-passo de como organizar esses temas e escolher o seu favorito. Segue algumas dicas de como transformar corretamente sua área de trabalho para depuração (e mantê-la).&lt;/p&gt;
&lt;p&gt;O WinDbg salva suas configurações no registro. Para apagar os valores previamente gravados, rode o seguinte comando:&lt;/p&gt;
&lt;p&gt;Você pode gravar um tema, rodar o WinDbg (sem parâmetros), ver se gosta do que viu, e tentar novamente. Quando estiver satisfeito com a aparência, fique com ela e comece o próximo passo.&lt;/p&gt;
&lt;p&gt;Nas depurações do dia-a-dia algumas configurações devem estar sempre muito bem configuradas, para que torne seus momentos de desespero porque nada está funcionando mais agradáveis. Por isso, assim que escolher seu tema preferido trate de configurar os seguintes itens:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Diretórios de símbolos. Você pode começar com .symfix, que vai montar uma string padrão, e adicionar mais diretórios com .sympath+.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Diretórios de código-fonte. Coloque a raiz dos seus projetos principais. Com o tempo, se você mexe muito nos seus diretórios, é necessário fazer uma manutenção desse valor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Diretórios de executáveis. Basicamente é o mesmo do diretório de símbolos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Depois de configurar tudo isso, ajuste as janelas na melhor maneira e proporção que achar mais agradável. Esse será o último passo, pois depois você irá fechar o WinDbg e salvar o workspace, que a partir daí será o padrão sempre que abrir o depurador.&lt;/p&gt;
&lt;p&gt;Como esses passos deram algum trabalho, trate de salvar as configurações, caso tenha que usá-las em outras máquinas ou restaurá-las caso algo de ruim aconteça com seu SO (como quando você depura seus drivers na mesma máquina em que desenvolve, por exemplo).&lt;/p&gt;
&lt;p&gt;Leia a documentação do WinDbg sobre temas (dentro de Themes, Themes.doc). Foi de lá que eu fiz a tradução e adaptação dos passos mais importantes. E esqueça do Visual Studio =)&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Analisando dumps com WinDbg e IDA</title>
  <link>http://www.caloni.com.br/analisando-dumps-com-windbg-e-ida/</link>
  <pubDate>2008-01-10</pubDate>
  
  <guid>http://www.caloni.com.br/analisando-dumps-com-windbg-e-ida/</guid>
  <description>&lt;p&gt;Apesar de ser recomendado que 100% dos componentes de um software esteja configurado corretamente para gerar símbolos na versão release, possibilitando assim a visualização do nome das funções internas através de um arquivo de dump (despejo) gerado na ocorrência de um crash, essa verdade só ocorre em 80% das vezes. Quis Murphy que dessa vez a única parte não &amp;quot;simbolizada&amp;quot; fosse a que gerou a tela azul em um Intel Quad Core que estou analisando esses dias.&lt;/p&gt;
&lt;p&gt;Para incluir um programa novo em nosso leque de opções, vamos usar dessa vez uma ferramenta chamada IDA, um disassembler estático cujo nome é uma clara homenagem à nossa primeira programadora da história. E, é lógico, o WinDbg não poderá ficar de fora, já que ele será nosso analisador de dumps.&lt;/p&gt;
&lt;p&gt;Tecnicamente falando, um dump nada mais é do que o conjunto de informações relevantes de um sistema em um determinado momento da execução, geralmente logo após um crash, onde tudo pára e morre. No caso do Windows, o crash é chamado de BSOD, Blue Screen Of Death, ou Tela Azul da Morte (bem macabro, não?). Do ponto de vista do usuário, é aquela simpática tela azul que aparece logo após o travamento da máquina.&lt;/p&gt;
&lt;p&gt;Em algumas máquinas, essa tela nem mais é vista, pois o Windows XP é configurado automaticamente para exibir um simpático reboot que joga todos os seus dados não-salvos naquele momento para o limbo (ou, como diria o Thiago, para o &amp;quot;céu dos dados não-salvos antes de uma tela azul&amp;quot;).&lt;/p&gt;
&lt;p&gt;Dumps podem ser abertos por um depurador que entenda o tipo de dump gerado (Visual Studio, WinDbg, OllyDbg, IDA, sd, etc). Se estamos falando de aplicativos que travaram, o Visual Studio pode dar conta do recado. Se é realmente uma tela azul, o WinDbg é o mais indicado.&lt;/p&gt;
&lt;p&gt;Para abrir um dump no WinDbg, tudo que temos que fazer é usar o item do menu &amp;quot;File, Open Crash Dump&amp;quot; ou digitar direto da linha de comando:&lt;/p&gt;
&lt;p&gt;Após alguns segundos, o WinDbg irá imprimir uma saída parecida com as linhas abaixo.&lt;/p&gt;
&lt;p&gt;Mini Kernel Dump File: Only registers and stack trace are available&lt;/p&gt;
&lt;p&gt;Geralmente a melhor idéia agora é seguir o conselho do WinDbg e usar o comando !analyze.&lt;/p&gt;
&lt;p&gt;Esse é o resultado de um dos minidumps recebidos.&lt;/p&gt;
&lt;p&gt;Um minidump contém apenas a pilha de chamada que causou a tela azul, o estados dos registradores e algumas informações sobre módulos carregados no kernel.&lt;/p&gt;
&lt;p&gt;A partir daí podemos extrair algumas informações úteis, que eu sublinhei na saída do WinDbg. Na ordem de chegada:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;O código do Bug Check. Esse é talvez o mais importante, pois pode resolver rapidamente o nosso problema. Procurando na ajuda do WinDbg pelo código do erro (obs: execute o link pelo explorer) conseguimos ter algumas dicas de como evitar esse erro:
&amp;quot;The MAXIMUMWAITOBJECTSEXCEEDED bug check has a value of 0x0000000C. This indicates that the current thread exceeded the permitted number of wait objects.&amp;quot;
Mais sobre isso pra depois.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Os dados da pilha. Pela pilha de chamadas, podemos não apenas saber se nosso driver está no meio com cara de culpado, como, através dos &lt;em&gt;offsets&lt;/em&gt;, descobrir em que função ele se enfiou para dar no que deu.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A última chamada do kernel antes do nosso driver pode indicar-nos que evento foi o responsável por iniciar todo o processo de cabum. Nesse caso, IopLoadDriver nos dá uma ótima dica: foi na hora de carregar o nosso driver.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Com isso em mãos, mesmo sem símbolos e nomes de funções no código, conseguiríamos achar o código responsável pelo BSOD. Porém, vamos imaginar por um momento que não foi tão fácil assim e fazer entrar em cena outra ferramenta indispensável nessas horas: o Interactive Disassembler.&lt;/p&gt;
&lt;p&gt;No sítio do IDA podemos encontrar o download para uma versão gratuita do IDA, isso se usado com objetivos não-comerciais. Ou seja, para você que está lendo esse blogue por aprendizado, não terá nenhum problema você baixar essa versão e fazer alguns testes com seu driver favorito.&lt;/p&gt;
&lt;p&gt;O funcionamento básico do IDA é bem básico, mesmo. Simplesmente escolhemos um executável para ele destrinchar e nos mostrar um assembly bem amigável, com todos os nomes de funções que ele puder deduzir. Como não temos os símbolos do próprio executável, as funções internas ganham &amp;quot;apelidos&amp;quot;, como sub6669, loc13F35 e por aí vai. Isso não importa, já que temos nomes amigáveis de APIs para pesquisar no código-fonte e tentar encontrar as funções originais em C.&lt;/p&gt;
&lt;p&gt;Pois bem. Como manda o figurino, o primeiro ponto do assembly que temos que procurar é o ponto em que uma função interna é chamada logo após IopLoadDriver, mydriver+0x4058. Por coincidência (ou não, já que essa é a função do IopLoadDriver), se trata da função inicial do executável, ou seja, provavelmente a função DriverEntry no código-fonte (obs: estamos analisando um driver feito para plataforma NT).&lt;/p&gt;
&lt;p&gt;Como podemos ver pela imagem acima, o ponto de retorno é logo após uma chamada à função sub113F0, que não sabemos qual é. No entanto, sabemos que logo no início é chamada a função IoIsWdmVersionAvailable, o que já nos permite fazer uma correlação com o código-fonte original. Após a chamada à IoIsWdmVersionAvailable, a próxima e última chamada de uma função é o que procuramos. Dessa forma, podemos ir caminhando até o ponto onde o driver chama o sistema operacional:&lt;/p&gt;
&lt;p&gt;Voilà! O caminho não foi tão longo. Chegamos rapidamente no ponto onde é chamada a função KeWaitForMultipleObject que, de acordo com o WinDbg e com a OSR, pode gerar uma tela azul se esperarmos por mais de três objetos e não especificarmos um buffer no parâmetro WaitBlockArray. Agora podemos olhar no fonte e ver por quantos objetos esperamos e tirar nossa própria conclusão do que está acontecendo:&lt;/p&gt;
&lt;p&gt;Ora, ora. O número de processadores influencia no número de objetos que estaremos esperando na função de espera. Esse seria um bom motivo para gerar um MAXIMUMWAITOBJECTSEXCEEDED em máquinas onde existe mais de 3 processadores ativos, não? Talvez seja uma boa hora para atualizar esse código e torná-lo compatível com os novos Quad Core.&lt;/p&gt;
&lt;p&gt;É importante, durantes os testes de desenvolvimento, sempre manter em dia uma versão debug (para o mundo kernel mode, versões checked) para que os primeiros problemas, geralmente os mais bestinhas, sejam pêgos de forma rápida e eficiente. No entanto, um bom desenvolvedor não se limita a depurar com código-fonte. Ele deve estar sempre preparado para enfrentar problemas de falta da versão certa, informação pela metade, situação não-reproduzível. Para isso que servem as ferramentas maravilhosas que podemos usar no dia-a-dia. O IDA é mais uma das que deve estar sempre no cinto de utilidades do bom &amp;quot;debugador&amp;quot;.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como ser um melhor desenvolvedor em 2008</title>
  <link>http://www.caloni.com.br/como-ser-um-melhor-desenvolvedor-em-2008/</link>
  <pubDate>2008-01-02</pubDate>
  
  <guid>http://www.caloni.com.br/como-ser-um-melhor-desenvolvedor-em-2008/</guid>
  <description>&lt;p&gt;Aproveitando que está se aproximando meu prazo final para minhas resoluções de seis meses atrás, e o DQ já fez o checklist dele, vou dar uma espiada na minha lista de desejos atual e fazer uma nova lista para 2008.&lt;/p&gt;
&lt;p&gt;Comecei, fiz vários exercícios, mas ainda não acabei todas as aulas. Descobri que a memória pode ser muito mais bem treinada do que realmente é, e existem técnicas bem pensadas que fazem isso sem muito mais esforço do que apenas tempo despendido. De fato todos nós já temos uma memória incrível, só precisamos treiná-la adequadamente.&lt;/p&gt;
&lt;p&gt;Como comecei e ainda não parei considero esta tarefa realizada (começar e ganhar ritmo é o mais difícil) e estendido para 2008 inteiro.&lt;/p&gt;
&lt;p&gt;Comecei, fiz quase todos os exercícios e terminei. De fato melhorou em muito minha capacidade de concentração na hora de ler um texto rápido, embora eu ainda fique com muito sono quando faço isso. O importante agora é nunca deixar de treinar, e melhorar cada vez mais o poder dos movimentos oculares.&lt;/p&gt;
&lt;p&gt;Não existe milagre, mas existem coisas que podemos fazer para ajudá-lo a acontecer. Foi isso que aprendi durante minhas inúmeras tentativas de dominar o tempo e o espaço no desenvolvimento de software. Aprendi muita coisa, inclusive que escritórios não foram criados para serem lugares produtivos, e quase sempre é necessário se defender dos riscos que a internet faz para a saúde.&lt;/p&gt;
&lt;p&gt;Enfim, essa tarefa também terminou. Agora é só manutenção constante e disciplinada.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;Por fim, considero se achar melhor depois de ter melhorado um ou dois itens da vida profissional uma &amp;quot;escrutinisse&amp;quot;, tão inútil quanto achar-se já um desenvolvedor muito bom. Porque a qualquer hora podemos cometer novamente aquelas besteiras que fazíamos há cinco anos, e a qualquer hora podemos ter idéias brilhantes. O importante, na minha opinião, é aprender exatamente por que erramos e por que acertamos. Aprender exatamente, e lembrar-se disso, pode ser um enorme catalisador de anos de depuração aleatória.&lt;/p&gt;
&lt;p&gt;Sem estar na lista previamente concebida, comecei a fazer outras coisas de maneira mais eficiente, seja relacionado ao trabalho ou não:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Aprender o leiaute do teclado Dvorak. Treino todo dia cinco minutos há três meses a digitação usando esse leiaute, porque é mais simples, mais rápido e dói menos os dedos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Anotar todas as coisas importantes. Seja uma idéia nova, uma idéia sobre uma idéia, ou até mesmo melhoramentos em algum software que dou manutenção, é importante manter tudo anotado, porque sabe-se lá quando isso vai ser usado. Mas, quando for, quem vai se lembrar?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bloguear constantemente. Apesar dos sacrifícios que isso às vezes causa, é edificante nunca &amp;quot;deixar a bola cair&amp;quot;. Minha regra é sempre publicar um artigo dia sim, dia não durante a semana. Em uma semana começo na segunda, em outra na terça, e assim sucessivamente. Tem funcionado desde que reiniciei o blogue há seis meses, e espero que continue assim.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Usar novo controle de versão em casa. Há um mês mais ou menos conheci o Mercurial, que é um sistema de controle de versão muito leve e não-centralizado, duas coisas que fazem uns sininhos soarem em minha cabeça. Ele é baseado conjunto de modificações e &lt;em&gt;merge&lt;/em&gt;, duas coisas a que não estou acostumado e me forcei a aprender.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Não é muito difícil definir essa lista, pois ela na verdade são as mesmas duas listas que citei anteriormente. Comecei a fazer essas coisas seis meses atrás. Para um fumante de fato parar, uns cinco anos de abstinência é um bom indicador. Acredito que, para um hábito se enraizar, um ano e meio pode ser de bom tamanho.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Gambi do dia: swap com apenas duas variáveis</title>
  <link>http://www.caloni.com.br/gambi-do-dia-swap-com-apenas-duas-variaveis/</link>
  <pubDate>2007-12-31</pubDate>
  
  <guid>http://www.caloni.com.br/gambi-do-dia-swap-com-apenas-duas-variaveis/</guid>
  <description>&lt;p&gt;Este artigo é uma reedição de meu blogue antigo, guardado para ser republicado durante minhas miniférias. Esteja à vontade para sugerir outros temas obscuros sobre a linguagem C ou C++ de sua preferência. Boa leitura!&lt;/p&gt;
&lt;p&gt;Essa interessantíssima questão veio do meu amigo Kabloc: como trocar o valor entre duas variáveis do tipo int sem utilizar uma variável intermediária? O algoritmo ordinário para um swap entre tipos inteiros é:&lt;/p&gt;
&lt;p&gt;Uma das soluções que eu conheço é utilizar o operador de ou exclusivo, o conhecido XOR. Esse operador binário tem a não pouco bizarra habilidade de armazenar dois padrões de bits dentro de um mesmo espaço de armazenamento. Se você tiver um dos dois padrões, conseguirá o segundo. Relembremos sua tabela verdade:&lt;/p&gt;
&lt;p&gt;Ou seja, imagine que temos o valor 1 e o valor 0. Armazenando os dois juntos com XOR obtemos 1, já que:&lt;/p&gt;
&lt;p&gt;Mais tarde, se quisermos obter o primeiro padrão, usamos o segundo:&lt;/p&gt;
&lt;p&gt;Para obter o segundo padrão é só utilizar o primeiro obtido:&lt;/p&gt;
&lt;p&gt;Calcule a mesma operação com as quatro combinações possíveis e verá que podemos sempre reaver os dados partindo de um dos padrões. Como o cálculo independe do número de bits, já que operadores bit a bit operam um bit de cada vez, podemos usar a mesma técnica para juntar dois inteiros, duas strings, dois &amp;quot;qualquer coisa armazenada numa seqüência de zeros e uns&amp;quot;:&lt;/p&gt;
&lt;p&gt;Essa técnica é uma das mais básicas - se não for a mais - de criptografia simétrica. O primeiro padrão faz o papel de texto aberto, o segundo banca a senha e o terceiro será o texto encriptado. Para &amp;quot;desencriptar&amp;quot; o texto é necessária a senha (e se você souber qual o texto original, saberá a senha).&lt;/p&gt;
&lt;p&gt;Mas, voltando ao nosso problema original, podemos trocar duas variáveis inteiras usando a técnica do XOR. Em claro:&lt;/p&gt;
&lt;p&gt;Bom, preciso dizer que isso é uma gambi das grossas? Preciso dizer que NÃO uso isso no meu dia a dia, até porque swap é uma função já consagrada da STL? Não? Então sem Postscript dessa vez. E sem bois-cornetas =).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Curiosidades inúteis: o operador de subscrito em C&#43;&#43;</title>
  <link>http://www.caloni.com.br/curiosidades-inuteis-o-operador-de-subscrito-em-c/</link>
  <pubDate>2007-12-27</pubDate>
  
  <guid>http://www.caloni.com.br/curiosidades-inuteis-o-operador-de-subscrito-em-c/</guid>
  <description>&lt;p&gt;Este artigo é uma reedição de meu blogue antigo, guardado para ser republicado durante minhas miniférias. Esteja à vontade para sugerir outros temas obscuros sobre a linguagem C ou C++ de sua preferência. Boa leitura!&lt;/p&gt;
&lt;p&gt;Em C e C++ as regras de sintaxe são extremamente flexíveis. Essa liberdade toda se manteve no decorrer dos tempos porque se trata de uma das idéias fundamentais da linguagem C, motivo de sua criação. Me lembro certa vez que, bitolado em C Standard 89, usei uma sintaxe não lá muito usual para acessar um elemento de um array. Foi apenas um experimento de estudante, coisa que nunca vi em código algum e queria comprovar.&lt;/p&gt;
&lt;p&gt;As regras de acesso a elementos de um array (subscrito) são definidas não em termos do array, mas em termos de um ponteiro e de um índice. &amp;quot;Me dê um ponteiro para T e um inteiro e te retorno um lvalue do tipo T&amp;quot;. Essa é a idéia geral. A mesma idéia, com pequenas alterações, se manteve em C++. Eis parte do parágrafo que fala sobre isso:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type &amp;quot;pointer to T&amp;quot; and the other shall have enumeration or integral type. The result is an lvalue of type &amp;quot;T&amp;quot;. (...) The expression E1 [ E2 ] is identical (by definition) to *( (E1) + (E2) ). - C++: International Standard ISO/IEC 14882 First Edition 1998-09-01&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Isso traduzido em miúdos quer dizer que com duas expressões formando a construção E1 [ E2 ], sendo uma delas do tipo ponteiro para um tipo e a outra do tipo integral, o resultado é equivalente a *( (E1) + (E2) ). Como no código abaixo:&lt;/p&gt;
&lt;p&gt;A teoria comprovada na prática: temos duas expressões no formato E1 [ E2 ] sendo uma do tipo ponteiro para char e a outra do tipo int, exatamente como a regra define. O detalhe obscuro que permaneceu durante a evolução dessas duas linguagens é que a regra de acesso a elementos não define a ordem das expressões. Assim sendo, me aproveito dessa flexibilidade e inverto os elementos do subscrito:&lt;/p&gt;
&lt;p&gt;Isso também compila e tem o mesmo resultado, pois também é equivalente a *( (E1) + (E2) ). No final dá na mesma. E do jeito que está a inversão nem dá tanto susto assim, pois estamos lidando com duas variáveis. A coisa começa a ficar mais IOCCC se colocarmos em vez de uma delas uma constante:&lt;/p&gt;
&lt;p&gt;Isso ainda é válido, certo? Os tipos das expressões estão de acordo com a regra. Fica simples de visualizar se sempre pensarmos no &amp;quot;equivalente universal&amp;quot; *( (E1) + (E2) ). Até coisas bizarras como essa acabam ficando simples:&lt;/p&gt;
&lt;p&gt;Nota do autor: esse tipo de &amp;quot;recurso obscuro&amp;quot; dificilmente passará por uma revisão de código, e com razão, dado que não é um método útil e muito menos conhecido. Sábio é saber evitar. Não acredito, porém, que o conhecimento de certos detalhes da linguagem em que se programa sejam completamente inúteis. Conhecimento nunca é demais, pois quanto mais se conhece maior é o número de ferramentas conceituais que se dispõe para resolver um certo problema. Em muitas vezes o &amp;quot;conhecimento inútil&amp;quot; de hoje se torna um guia sábio quando se precisa de bons conceitos sobre a coisa toda. No entanto, que não venha um boi-corneta me dizer que esse código fere as boas práticas de programação. Tenho dito.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>O que acontece quando o contador estoura</title>
  <link>http://www.caloni.com.br/o-que-acontece-quando-o-contador-estoura/</link>
  <pubDate>2007-12-25</pubDate>
  
  <guid>http://www.caloni.com.br/o-que-acontece-quando-o-contador-estoura/</guid>
  <description>&lt;p&gt;Dois conceitos de programação relacionados a limites computacionais são bem conhecidos do programador: o famigerado overflow e o não-tão-famoso underflow (embora seja fácil imaginar que ele é o oposto do primeiro). O primeiro ocorre quando somamos a uma variável inteira não-nula um valor cujo resultado não consegue ser representado pelo tamanho de memória usado para armazenar esse tipo inteiro (que pode ser um caractere, um inteiro curto, inteiro longo e por aí vai). O underflow, por outro lado (outro lado mesmo), é o resultado de uma subtração que não pode ser representado pelo número de bits do seu tipo inteiro.&lt;/p&gt;
&lt;p&gt;Nada melhor que um código para ilustrar melhor esses dois ilustres acontecimentos:&lt;/p&gt;
&lt;p&gt;O indicador de que algo está errado é simples: como diabos foi um número positivo virar negativo, já que eu somei ao invés de subtrair? No entanto, computacionalmente parece extremamente correto: o próximo número após o maior valor positivo possível é o menor número negativo possível.&lt;/p&gt;
&lt;p&gt;Nos computadores atuais tudo no final acaba sendo representado por zeros e uns, até o sinal de negativo dos números menores que zero. Por isso mesmo, para que consigamos usar números menores que zero, precisamos gastar um bit para indicar que este número é negativo. Existem muitas representações interessantes, dentre as quais a mais popular acabou sendo a de complemento de dois. A regra é simples:&lt;/p&gt;
&lt;p&gt;Toda representação binária que tiver o bit mais significativo ligado (o bit mais à esquerda) significa um número negativo cujo valor absoluto se obtém invertendo-se o resto dos bits e adicionando um.&lt;/p&gt;
&lt;p&gt;Quando o bit mais à esquerda não está ligado o valor absoluto é ele mesmo; ou seja, é um número positivo, incluindo o zero. Como vamos ver, isso facilita em muito os cálculos para o computador. Para nós, a coisa não fica lá muito difícil. Só precisamos lembrar que, em hexadecimal, todos os valores que tiverem o byte mais significativo igual ou maior que 8 (que é 1000 em binário) é negativo e temos que aplicar o método de complemento de dois para obter seu valor absoluto. Vejamos o valor -8, por exemplo:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Primeiro temos a representação real (em um byte): 1111 1000.&lt;/li&gt;
&lt;li&gt;O bit mais significativo está ligado: é um número negativo. Descartamos o sinal, fica 111 1000.&lt;/li&gt;
&lt;li&gt;Devemos agora inverter todos os bits: 111 1000 se torna 000 0111.&lt;/li&gt;
&lt;li&gt;Por fim, somamos um: 000 0111 + 1 = 000 1000.&lt;/li&gt;
&lt;li&gt;Como vimos no parágrafo anterior, 000 1000, ou simplesmente 1000, é 8. Na verdade, -8!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Se alterarmos o código acima para imprimir na saída os números hexadecimais, obteremos a seguinte saída:&lt;/p&gt;
&lt;p&gt;E o mais legal é que agora sabemos que o primeiro número é o maior valor positivo possível nesse tamanho de int, pois possui todos os bits ligados exceto o bit de sinal. Já o segundo número, o primeiro incrementado de 1, possui todos os bits desligados exceto o bit de sinal: é o menor número negativo possível!&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Banco de dados no C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/banco-de-dados-no-c-builder/</link>
  <pubDate>2007-12-21</pubDate>
  
  <guid>http://www.caloni.com.br/banco-de-dados-no-c-builder/</guid>
  <description>&lt;p&gt;Um banco de dados é qualquer lugar onde podemos ler e escrever informação geralmente persistente. Pode ser um arquivo INI, uma estrutura binária ou uma plantação de servidores para fazer busca na internet.&lt;/p&gt;
&lt;p&gt;O uso de banco de dados em programação é mais que essencial, pois permite que armazenemos os resultados de um processamento e utilizemos esses mesmos resultados em futuras execuções.&lt;/p&gt;
&lt;p&gt;Visando preencher algumas lacunas na internet sobre esse tema, iremos agora nos aventurar na configuração e uso de um banco de dados no C++ Builder.&lt;/p&gt;
&lt;p&gt;Obs. de camarada: banco de dados pode ser uma coisa bem chata. Contudo, a vida não é completa sem as partes chatas. O conhecimento dessa área é vital para a sobrevivência de muito desenvolvedores de software. Além do mais, pode se tornar bem mais interessante em algumas situações, como o estudo sobre normalização.&lt;/p&gt;
&lt;p&gt;Quase como um prêmio de consolação por participarmos de um sorteio que sabemos que não iremos ganhar nunca, a Caixa generosamente oferece a opção de baixarmos todos os resultados da Mega Sena desde seu início. Iremos utilizar esse banco de dados para criar uma interface de visualização de resultados no C++ Builder.&lt;/p&gt;
&lt;p&gt;Um problema inicial está no fato que o arquivo está no formato HTML, um formato mais difícil de usarmos no C++ Builder. Portanto, irei converter este formato em algo mais maleável, como um arquivo do Microsoft Access (manipulável pelo Open Office), o famoso MDB.&lt;/p&gt;
&lt;p&gt;Para a conversão, nada mais que algumas expressões regulares e macros de edição não resolvam em 5 minutos, sem contar a opção de importação do próprio Access.&lt;/p&gt;
&lt;p&gt;Neste tutorial vamos usar aquilo que é o configurador oficial de banco de dados no C++ Builder: o BDE. Se você ainda não observou, após a instalação do C++ Builder um novo item surgiu no Painel de Controle, o BDE Administrator. Vamos usá-lo para configurar uma base de dados baseada no nosso arquivo MDB recém-gerado .&lt;/p&gt;
&lt;p&gt;Criado o MDB, podemos clicar no BDE Administrator do Painel de Controle. A única coisa que precisamos fazer é criar uma nova base de dados, e especificar seus poucos parâmetros, como o tipo de base (MSACCESS) e o path de onde está o arquivo MDB.&lt;/p&gt;
&lt;p&gt;Ah, sim, claro, também é importante colocar um nome apropriado para a base de dados: MegaSena.&lt;/p&gt;
&lt;p&gt;A partir daí, clicando no botão Apply !BDE Apply, tudo deve fluir. Como em informática tudo quer dizer nada, eu deixo por conta do leitor a resolução de quaisquer problemas que acontecerem durante a configuração.&lt;/p&gt;
&lt;p&gt;Criado o banco e testado (experimente conectar pelo próprio BDE) podemos agora criar um novo projeto VCL e colocar alguns componentes interessantes feitos especialmente para banco de dados. São eles:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TDatabase: representa a própria base da dados, onde especificamos o nome da base de dados que vamos utilizar.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TTable: representa uma tabela de uma base de dados.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TDataSource: a origem dos dados que serão usados para popular seja lá o que quisermos popular.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Abaixo segue a configuração de cada um deles, ou seja, as propriedades que você deve mudar para que tudo funcione.&lt;/p&gt;
&lt;p&gt;Após todos esses componentes não-visuais terem sido inseridos no form, nada como colocar alguma coisa que o usuário veja: um TDBGrid.&lt;/p&gt;
&lt;p&gt;Com isso, nossa janela já exibe o conteúdo da tabela em tempo de design:&lt;/p&gt;
&lt;p&gt;E é isso! Se chegamos até aqui, já sabemos o arroz com feijão de usar banco de dados com o C++ Builder. Mais para a frente podemos nos aventurar em tópicos um pouco mais avançados, como fazer buscas, navegar item a item e essas coisas que as pessoas costumam fazer com um MDB.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Borland Developer Studio: baixe a versão gratuita para desenvolver programas Win32 nativos em RAD&lt;/li&gt;
&lt;li&gt;OpenOffice: uma suíte de escritório gratuita (para ler e escrever MDBs)&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Drag and drop no C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/drag-and-drop-no-c-builder/</link>
  <pubDate>2007-12-19</pubDate>
  
  <guid>http://www.caloni.com.br/drag-and-drop-no-c-builder/</guid>
  <description>&lt;p&gt;O sistema de drag and drop do C++ Builder é muito fácil de usar, integrado que está com o sistema de classes e objetos do framework. Tanto para o objeto de drag quanto para o objeto de drop tudo que temos que fazer é definirmos a propriedade DragMode para dmAutomatic como mostra a figura. Isso fará com que toda a troca de mensagens seja manipulada automaticamente pela VCL.&lt;/p&gt;
&lt;p&gt;A parte (ridídula) do código fica por conta da manipulação do evento de drop. Para aceitar um objeto, devemos tratar o evento OnDragOver. Basta isso para que a variável Accept tenha seu valor default definido para true. Podemos, entretanto, escolher se iremos ou não tratar um possível drop de um objeto. Verificando seu tipo, por exemplo:&lt;/p&gt;
&lt;p&gt;A parte mais interessante do código fica por conta da hora que o objeto é &amp;quot;jogado&amp;quot;, no evento OnDragDrop. Nela recebemos o ponteiro para o Sender (como sempre), que é o target object, e um Source. Geralmente para manipular o source object é necessário antes realizar um cast para um tipo mais conhecido.&lt;/p&gt;
&lt;p&gt;E mais uma vez voilà! Pouquíssimas linhas de código e um movimentador e empilhador de controles. Dois detalhes merecem ser destacados:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;O uso de dynamic_cast em cima dos ponteiros da VCL é uma maneira saudável de checar a integridade dos tipos recebidos - particularmente do Sender. O uso do primeiro parâmetro dos tratadores de eventos também torna o código menos preso à componentes específicos do formulário;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;O método FindChildControl é deveras útil quando não temos certeza da existência de um controle. Geralmente é uma boa idéia confiar no sistema de gerenciamento de componentes da VCL. Não é à toa que existe um &lt;em&gt;framework&lt;/em&gt; por baixo do ambiente RAD.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Sizeof (de novo)</title>
  <link>http://www.caloni.com.br/sizeof-de-novo/</link>
  <pubDate>2007-12-17</pubDate>
  
  <guid>http://www.caloni.com.br/sizeof-de-novo/</guid>
  <description>&lt;p&gt;Algumas coisas em C parecem tão simples na programação do dia-a-dia que em alguns momentos podem existir situações confusas e misteriosas. O uso obscuro do operador sizeof, por exemplo, pode dar margens a interpretações erradas a respeito do que está acontecendo por baixo dos panos. Apesar do padrão ter sido elaborado para tentar tornar a linguagem uma coisa intuitiva e de fácil dedução, isso não acontece todas as vezes.&lt;/p&gt;
&lt;p&gt;Vamos tomar, por exemplo, o seguinte minicódigo:&lt;/p&gt;
&lt;p&gt;A pergunta ingênua: quantos bytes são copiados para buf?&lt;/p&gt;
&lt;p&gt;A resposta ingênua: er... o tamanho de &amp;quot;A simple string&amp;quot;?&lt;/p&gt;
&lt;p&gt;Agora vamos supor que você é um pouco mais esperto e começa a pensar: &amp;quot;mas, peraí, estou passando na realidade um ponteiro para sizeof, o que quer dizer que, se meus cálculos estiverem corretos, e estivermos em uma plataforma de 32 bits, sizeof deve retornar 4, o que quer dizer que acabei de achar um bug escabroso, uhuu!&amp;quot;.&lt;/p&gt;
&lt;p&gt;Muito bem, o raciocínio é perfeito. Afinal de contas, &amp;quot;A simple string&amp;quot; é um ponteiro para um array de caracteres terminados em zero, certo?&lt;/p&gt;
&lt;p&gt;Estou quase certo disso. Porém, isso quer dizer que já deixei vários bugs escabrosos há uns 4 anos atrás em trechos de código parecidos com esse. Será que eu estava errado e não me dei conta, ou sabia de algo que esqueci faz muito tempo?&lt;/p&gt;
&lt;p&gt;Eu e meu amigo demos uma olhada no padrão da linguagem C de 89 (revisão de 90), que diz duas coisas muito importantes nesse momento: o que é um sizeof e o que é uma string constante (chamada no padrão de string literal):&lt;/p&gt;
&lt;p&gt;A character string literal is a sequence of zero or more multibyte characters enclosed in double-quotes, as in &amp;quot;xyz&amp;quot;. A wide string literal is the same, except prefixed by the letter L. (...) The multibyte character sequence is then used to initialize an array of static storage duration and lenght just sufficient to contain the sequence.&lt;/p&gt;
&lt;p&gt;Em C++ (padrão ISO de 98) o texto é muito parecido, apenas abragendo também o conceito de type-id (desnecessário explicar para o contexto deste artigo):&lt;/p&gt;
&lt;p&gt;A string literal is a sequence of characters (as defined in 2.13.2) surrounded by double quotes, optionally beginning with the letter L, as in &amp;quot;...&amp;quot; or L&amp;quot;...&amp;quot;. (...) An ordinary string literal has type &amp;quot;array of n const char&amp;quot; and static storage duration (...).&lt;/p&gt;
&lt;p&gt;Os grifos são meus, para demonstrar que o operador sizeof irá retornar o número de bytes baseado no tipo do operando, e que o tipo de uma string literal é de array de caracteres com o tamanho justo para caber a string.&lt;/p&gt;
&lt;p&gt;Bem, todos sabemos o resultado das linhas abaixo:&lt;/p&gt;
&lt;p&gt;Nesse caso é simples de observar que o operador sizeof irá retornar 100, que é o número em bytes para abrigar o tipo do operando, que é de &amp;quot;array de 100 caracteres&amp;quot;. Podemos, então, imaginar que a nossa idiomática expressão do início é no fundo um resumo das linhas que se seguem.&lt;/p&gt;
&lt;p&gt;Ou seja, o tipo de nossa string é na verdade de array estático de caracteres, como se uma variável tivesse sido definida anteriormente com o conteúdo da string, que deve estar em algum lugar da memória do programa. Visto dessa forma fica bem mais simples de entender o que acontece na versão resumida.&lt;/p&gt;
&lt;p&gt;O mais encorajador desse problema do sizeof é que a resposta ingênua estava certa, ou seja, pelo menos dessa vez, o padrão conseguiu através de suas regras seguir a intuição do programador.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Debug remoto no C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/debug-remoto-no-c-builder/</link>
  <pubDate>2007-12-13</pubDate>
  
  <guid>http://www.caloni.com.br/debug-remoto-no-c-builder/</guid>
  <description>&lt;p&gt;Esse é um detalhe que pode passar despercebido da maioria da população Borland, mas o Builder, assim como o Visual Studio, possui sua suíte para depuração remota. E tudo o que você precisa fazer é instalar um pacote no cliente.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;No CD de instalação, existe uma pasta chamada RDEBUG.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Na máquina cliente, execute o arquivo setup.exe contido nesta pasta. De preferência, não instale como um serviço (a menos que tenha um motivo).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crie uma aplicação tosca de teste (ou use uma aplicação tosca existente).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lembre-se que as DLLs do Builder não estarão disponíveis na máquina remota. Para não depender delas, utilize as opções &amp;quot;Use dynamic RTL&amp;quot; (aba Link) e &amp;quot;Build with runtime packages&amp;quot; (aba Packages) do seu projeto.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copie a aplicação para a máquina remota ou torne-a acessível através de mapeamento.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Em Run, Parameters, habilite na aba Remote a opção &amp;quot;Debug project on remote machine&amp;quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Em Remote Path especifique o path de sua aplicação visto da máquina remota.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Em Remote Host especifique o nome ou o IP da máquina remota.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Execute o aplicativo através do Builder (certifique-se que o cliente do Builder está rodando na máquina remota).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bom proveito!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Infelizmente essa opção não está disponível nas versões Standard do produto, assim como não está o debugging remoto no Visual Studio Express. Porém, a nova versão do Builder, renomeada para Borland Turbo C++, é gratuita a possui essa feature embutida. O único porém é que a instalação não é automatizada, e os arquivos devem ser copiados &amp;quot;na mão&amp;quot;, seguindo um dos tópicos da ajuda. Melhor que nada.&lt;/p&gt;
&lt;p&gt;Para os que utilizam o Visual Studio Express, realmente ainda não achei solução a não ser usar o bom, velho e fiel companheiro WinDbg. Não saia de casa sem ele.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Gerenciamento de janelas em C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/gerenciamento-de-janelas-em-c-builder/</link>
  <pubDate>2007-12-11</pubDate>
  
  <guid>http://www.caloni.com.br/gerenciamento-de-janelas-em-c-builder/</guid>
  <description>&lt;p&gt;As janelas criadas no C++ Builder são equivalentes às janelas criadas pela API, com o detalhe que a VCL gerencia tudo automaticamente. Isso não quer dizer que não podemos tomar controle de tudo. Quer dizer que não precisamos.&lt;/p&gt;
&lt;p&gt;Abra o Builder. Um projeto padrão é criado. Agora no menu File, vá em New, Form. Isso adicionará um novo formulário ao projeto padrão. Pronto! Temos dois formulários. Agora se formos dar uma passeada no WinMain, vemos que o código para iniciar a VCL se alterou conforme a música:&lt;/p&gt;
&lt;p&gt;Porém, se rodarmos a aplicação nesse momento, podemos notar que o programa exibe apenas a janela correspondente ao primeiro formulário. De fato, ao chamar o método Application-&amp;gt;Run(), apenas o primeiro form criado é exibido. Isso não significa, é claro, que o segundo form não tenha sido criado. Para demonstrar como ele está lá, coloque o seguinte evento no clique de um botão do Form1:&lt;/p&gt;
&lt;p&gt;Agora ao clicar do botão a janela correspondente ao formulário número 2 também aparece. Podemos fechá-la e abri-la quantas vezes quisermos que o aplicativo continua rodando. Apenas ao fechar a janela no. 1 o aplicativo realmente encerra. Esse comportamento segue o mesmo padrão da função main() na forma clássica das linguagens C/C++:&lt;/p&gt;
&lt;p&gt;Podemos, também como em C/C++ padrão, finalizar explicitamente a aplicação chamando o método Application-&amp;gt;Terminate. O MainForm em tempo de execução é uma propriedade de somente leitura de Application. Em tempo de design, ele pode ser alterado pela ordem de criação dos formulários no código ou pela IDE em Project, Options, Forms. Lá você também escolhe quais forms serão criados automaticamente.&lt;/p&gt;
&lt;p&gt;Esse funcionamento e automação na criação de janelas da VCL foi feita para facilitar a vida do programador. Contudo, nunca estamos presos a somente isso. As maneiras das coisas funcionarem apenas refletem o uso mais comum no ambiente e não tem como função limitar a criatividade do desenvolvedor.&lt;/p&gt;
&lt;p&gt;Para exemplificar, vamos inverter as coisas. Coloque um botão no segundo formulário que finalize o programa de maneira explítica:&lt;/p&gt;
&lt;p&gt;Agora, no evento de OnClose (acho que você conhece o Object Inspector, não? Bom, se não conhece, talvez isso mereça um artigo à parte) do TForm1 insira o seguinte código:&lt;/p&gt;
&lt;p&gt;Pronto! Agora você decide onde termina e onde acaba sua aplicação.&lt;/p&gt;
&lt;p&gt;Se dermos uma olhada bem de perto no que acontece por dentro de um aplicativo que usa a VCL descobriremos que o método Run de Application nada mais é que o loop de mensagens que já conhecemos.&lt;/p&gt;
&lt;p&gt;Para analisarmos melhor o que ocorre nos internals da coisa, criei um projeto simplista que possui dois forms, ambos com quatro botões: 1) mostrar o outro form, 2) esconder a si mesmo, 3) fechar a si mesmo e 4) terminar aplicação. Os dois formulários são tão parecidos que desconfio que sejam gêmeos.&lt;/p&gt;
&lt;p&gt;Além disso, iremos precisar do nosso velho e fiel amigo WinDbg, o que o trás de volta à cena do crime depois de alguns artigos de jejum.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;não-fique-de-fora&#34;&gt;Não fique de fora!&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;Para saber mais sobre o WinDbg e dar suas &amp;quot;WinDbgzadas&amp;quot;, dê uma olhada em alguns artigos interessantes sobre depuração usando WinDbg.&lt;/p&gt;
&lt;p&gt;A primeira coisa que um loop de mensagens deveria fazer seria chamar a função GetMessage, que obtém a primeira mensagem em espera na fila de mensagens da thread chamadora. Portanto, vamos dar uma olhada nas chamadas dessa função:&lt;/p&gt;
&lt;p&gt;E o resultado é... nada! Mesmo mexendo com a janela e apertando seus botões não há uma única ocorrência do GetMessage. Bruxaria? Programação oculta?&lt;/p&gt;
&lt;p&gt;Nem tanto. Uma alternativa ao GetMessage, que captura a primeira mensagem da fila de mensagens e a retira, é o PeekMessage, que captura a primeira mensagem da fila, mas mantém a mensagem na fila. Por algum motivo, os programadores da Borland fizeram seu loop de mensagens usando PeekMessage.&lt;/p&gt;
&lt;p&gt;Agora, sim!&lt;/p&gt;
&lt;p&gt;Analisando os parâmetros da função PeekMessage podemos obter algumas informações interessantes sobre uma mensagem, como seu código e a janela destino:&lt;/p&gt;
&lt;p&gt;Podemos bater essas informações com as do aplicativo Spy++, que captura janelas e suas mensagens:&lt;/p&gt;
&lt;p&gt;Normalmente esses dois rodando juntos podem causar alguns conflitos internos. Por isso, quando for usar o Spy++, procure desabilitar seus breakpoints. Após mexer no Spy++, feche-o antes de continuar depurando.&lt;/p&gt;
&lt;p&gt;Como podemos ver, nesse caso a janela encontrada foi justamente a que não aparece: TApplication! Sim, a classe principal da VCL é representada em runtime por uma janela escondida, que controla algumas mensagens específicas da aplicação.&lt;/p&gt;
&lt;p&gt;Tem tudo a ver! Mais do que simplesmente programar interfaces, esses conhecimentos permitem fazer a análise de qualquer aplicativo que possua um loop de mensagens. O importante descoberto aqui é que o C++ Builder, assim como o .NET, o Java e o &amp;quot;próximo framework gerenciado&amp;quot;, não pode escapar da fatal realidade de que, para exibir janelas, o aplicativo deverá dançar a música da API Win32.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Interação entre controles no C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/interacao-entre-controles-no-c-builder/</link>
  <pubDate>2007-12-05</pubDate>
  
  <guid>http://www.caloni.com.br/interacao-entre-controles-no-c-builder/</guid>
  <description>&lt;p&gt;Para essa proeza precisaremos de:&lt;/p&gt;
&lt;p&gt;Bom, sabemos já como colocar esses caras no form principal. Apenas espalhe-os de maneira que eles não fiquem uns em cima dos outros (essa técnica de espalhamento chama-se design).&lt;/p&gt;
&lt;p&gt;Agora no evento default do Button1 (duplo-clique nele) colocaremos o seguinte código:&lt;/p&gt;
&lt;p&gt;Percebeu? Não? Então rode e note o que acontece quando você aperta o botão.&lt;/p&gt;
&lt;p&gt;Agora iremos fazer algo mais interessante ainda com o segundo botão. Coloque no evento default o seguinte código:&lt;/p&gt;
&lt;p&gt;Mais simples, impossível. E com um pouco de imaginação, o mais besta dos aplicativos pode se tornar uma utilidade do dia a dia. Até sua mãe vai adorar.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Conceitos básicos na programação com C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/conceitos-basicos-na-programacao-com-c-builder/</link>
  <pubDate>2007-12-03</pubDate>
  
  <guid>http://www.caloni.com.br/conceitos-basicos-na-programacao-com-c-builder/</guid>
  <description>&lt;p&gt;No projeto que é criado quando iniciamos a IDE três arquivos-fonte são gerados: Project1.cpp, Unit1.cpp e Unit1.h. Desses três, vamos analisar o primeiro:&lt;/p&gt;
&lt;p&gt;Sim, existe um WinMain e ele não está escondido! Nele você pode fazer o que quiser. A IDE apenas auxilia você a gerenciar seus forms. Note que também existe a inclusão de um cabeçalho chamado vcl.h (obrigatório), o que nos leva diretamente para a base de toda a programação Delphi/Builder.&lt;/p&gt;
&lt;p&gt;A VCL é o framework usado tanto no Builder quanto no Delphi para a programação RAD nesses ambientes. Considere como a MFC geração C++ da Borland (antes era o OWL). Todos os controles que você vê na paleta da IDE - Button, Label, CheckBox, Timer - são criados e gerenciados através da VCL. Com os mesmos nomes acrescidos do prefixo T (TButton, TCheckBox...) você tem as classes que representam em código o que você vê no ambiente RAD. Através da VCL pode-se criar novos componentes extendidos dos originais, e eles serão gerenciados pela IDE, que aliás é feita usando VCL.&lt;/p&gt;
&lt;p&gt;Voltando ao código: o Application é um objeto visível em todo os módulos do processo e representa a aplicação em execução. Através dele você cria e destrói forms e inicia a execução da VCL. Ah, sim, é bom lembrar que todos os objetos VCL devem ser criados no heap (usando o operador new ou algum método de um objeto VCL já criado, como o CreateForm do Application). Essa e mais algumas restrições foram impostas na criação de classes VCL para que seu comportamento fosse similar/compatível com tecnologias como COM e CORBA (além das vantagens do polimorfismo e gerenciamento automático de objetos).&lt;/p&gt;
&lt;p&gt;Olhando para o outro fonte, Unit1.h, podemos ver a definição da classe que representa o form principal:&lt;/p&gt;
&lt;p&gt;A classe deriva de TForm, que é uma classe da VCL que representa uma janela padrão do Windows. Como se nota, um objeto da classe é criado automaticamente, exatamente o utilizado no WinMain para a criação da janela principal.&lt;/p&gt;
&lt;p&gt;Na classe existe um escopo extendido chamado published. Nele são colocados os membros da classe que podem ser gerenciados pela IDE. Considere como um public dinâmico. Coloque um TButton no form e note que um novo membro é criado na classe, dentro do escopo gerenciado pela IDE:&lt;/p&gt;
&lt;p&gt;Esses membros são iniciados automaticamente pela VCL. Contudo, você ainda pode criar objetos em tempo de execução e entregar o gerenciamento de seu tempo de vida para a VCL (o que significa chamar new e nunca um delete). Para essa proeza, todos os construtores de componentes devem receber um ponteiro para o seu Owner, que será o responsável por destruir o objeto. Veja como é ridículo criar um controle novo e definir algumas propriedades:&lt;/p&gt;
&lt;p&gt;O Parent é o component que abriga a representação visual do objeto dentro de si. Parent e Owner são dois conceitos distintos. Pra frente veremos como as janelas são gerenciadas pela VCL e pela IDE.&lt;/p&gt;
&lt;p&gt;É claro! O Borlando C++ Builder é coisa do passado, assim como Delphi e VB como os conhecemos. A versão nova do C++ Buider chama-se Turbo C++ (até semana passada, pelo menos). Nele as coisas são iguais mas diferentes. Ou seja, os conceitos aqui apresentados ainda valem. Só estão com uma cara diferente.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Desenhando em C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/desenhando-em-c-builder/</link>
  <pubDate>2007-11-29</pubDate>
  
  <guid>http://www.caloni.com.br/desenhando-em-c-builder/</guid>
  <description>&lt;p&gt;Uma das partes mais fáceis e divertidas de se mexer no C++ Builder é a que lida com gráficos. A abstração da VCL toma conta da alocação e liberação dos objetos gráficos da GDI e nos fornece uma interface para desenhar linhas e figuras geométricas, mexer com bitmaps, usar fontes etc. Concomitantemente, temos acesso ao handles &amp;quot;crus&amp;quot; da Win32 API para que possamos chamar alguma função esotérica necessária para o seu programa, o que nos garante flexibilidade suficiente.&lt;/p&gt;
&lt;p&gt;Vamos fazer da área da janela principal uma tela onde possamos desenhar. Para isso, só precisamos fazer duas coisas em nosso programa: saber quando o mouse está com algum botão pressionado e desenhar quando ele estiver sendo &amp;quot;arrastado&amp;quot;.&lt;/p&gt;
&lt;p&gt;Saber o estado dos botões é trivial, podemos capturar isso nos eventos OnMouseDown e OnMouseUp e guardar em alguma variável.&lt;/p&gt;
&lt;p&gt;Saber quando o mouse está sendo arrastado também é um passo trivial, uma vez que temos esse evento (OnMove) para tratar no controle da janela.&lt;/p&gt;
&lt;p&gt;Para desenhar, todo formulário e mais alguns controles gráficos possuem um objeto chamado Canvas, do tipo TCanvas (duh). Essa classe representa uma superfície de desenho que você pode acessar a partir de seus métodos. Isso é a abstração do conhecido device context da GDI, tornando a programação mais fácil. O desenho de uma linha, por exemplo, é feito literalmente em uma linha de código.&lt;/p&gt;
&lt;p&gt;O método LineTo() desenha uma linha do ponto onde está atualmente a caneta de desenho até a coordenada especificada. Esse é o motivo pelo qual no evento OnMouseDown alteramos a propriedade PenPos do Canvas para o ponto onde o usuário pressiona o botão do mouse.&lt;/p&gt;
&lt;p&gt;Voila! Temos o nosso Personal PaintBrush, com toda a tosquisse que menos de 10 linhas de código podem fazer. OK, ele não é perfeito, admito, mas pode ser melhorado. Temos o código-fonte =).&lt;/p&gt;
&lt;p&gt;Um dos problemas nele reflete o comportamento de gráficos em janelas no Windows. Seja o que for que tenhamos desenhado sobre uma janela, seu conteúdo é perdido ao ser sobrescrito por outra janela. Isso porque a memória de vídeo da área de trabalho é compartilhada entre todas as janelas do sistema (isso muda com o advento do &amp;quot;Avalon&amp;quot;). Precisamos, então, sempre repintar o que é feito durante a execução do programa.&lt;/p&gt;
&lt;p&gt;Se precisamos repintar, logo precisamos saber tudo o que o usuário fez até então. Uma das técnicas mais baratas no quesito memória para salvar o estado gráfico de uma janela é guardar um histórico das operações realizadas sobre sua superfície e executá-las novamente ao repintar a janela. A GDI é rápida o bastante para que o custo de processamento não seja sentido na maioria dos casos. Para o nosso Paint, apenas um array de coordenadas origem-destino já dá conta do recado:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Carregando DLLs arbitrárias pelo WinDbg - parte 2</title>
  <link>http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg-parte-2/</link>
  <pubDate>2007-11-27</pubDate>
  
  <guid>http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg-parte-2/</guid>
  <description>&lt;p&gt;Como pudemos ver no artigo anterior, o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Por esse motivo, e para tornar as coisas mais divertidas, resolvi transformar tudo aquilo em um simples script que pode ser executado digitando apenas uma linha.&lt;/p&gt;
&lt;p&gt;Se trata do meu primeiro script grande para o WinDbg, por isso, peço que tenham dó de mim =).&lt;/p&gt;
&lt;p&gt;Um script no WinDbg nada mais é que uma execução em batch: um arquivo texto cheio de comandos que poderíamos digitar manualmente, mas que preferimos guardar para poupar nossos dedos.&lt;/p&gt;
&lt;p&gt;Existem quatro maneiras diferentes de chamar um script no WinDbg, todas muito parecidas, variando apenas se são permitidos espaços antes do nome do arquivo e se os comandos são condensados, isto é, as quebras de linhas substituídas por ponto-e-vírgula para executar tudo em uma linha só.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$&amp;lt;nome-do-arquivo - não permite espaços e condensa comandos.&lt;/li&gt;
&lt;li&gt;$&amp;gt;&amp;lt;nome-do-arquivo - não permite espaços e não condensa comandos.&lt;/li&gt;
&lt;li&gt;$$&amp;lt;nome-do-arquivo - permite espaços e condensa comandos.&lt;/li&gt;
&lt;li&gt;$$&amp;gt;&amp;lt;nome-do-arquivo - permite espaços e não condensa comandos.&lt;/li&gt;
&lt;li&gt;$$&amp;gt;a&amp;lt;nome-do-arquivo - igual ao anterior, e ainda permite passar argumentos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OBS: a ajuda do WinDbg descreve as diferenças dos comandos acima de forma adversa, afirmando que os comandos &#39;&amp;lt;&#39;  não condensam as linhas e os &#39;&amp;gt;&amp;lt;&#39; o fazem, quando na realidade é o contrário. Não se deixe enganar por esse detalhe.&lt;/p&gt;
&lt;p&gt;No caso do script desse artigo, utilizaremos a última forma, pois precisamos de um argumento para funcionar: o nome da DLL. Caso você não digite esse argumento, a ajuda do script será impressa:&lt;/p&gt;
&lt;p&gt;Não há qualquer dificuldade. Tudo que você tem que fazer é baixar o script que carrega DLLs e salvá-lo em um lugar de sua preferência. Depois é só digitar o comando que carrega scripts, o path de nosso script e o nome da DLL a ser carregada em uma das três formas exibidas. Eu costumo criar uma pasta chamada &amp;quot;scripts&amp;quot; dentro do diretório de instalação do Debugging Tools, o que quer dizer que posso simplesmente chamar todos meus scripts (ou seja, 1) dessa maneira:&lt;/p&gt;
&lt;p&gt;Abaixo um pequeno teste que fiz carregando a DLL do Direct Draw (ddraw.dll) na nossa vítima de plantão:&lt;/p&gt;
&lt;p&gt;Simples e indolor.&lt;/p&gt;
&lt;p&gt;Vamos agora dar uma olhada no script completo e dissecar as linhas pausadamente. Dessa forma entenderemos como a função inteira funciona e como usar os comandos isoladamente para criar novos scripts.&lt;/p&gt;
&lt;p&gt;Como podemos ver, ele é um pouco grandinho. Por isso mesmo que ele é um script, já que não precisamos, sempre que formos usar este comando, ficar olhando para o fonte.&lt;/p&gt;
&lt;p&gt;Por falar em olhar, uma primeira olhada revela a seguinte estrutura:&lt;/p&gt;
&lt;p&gt;Qualquer semelhança com as instruções em C não é mera coincidência. Essa estrutura de fato verifica se o resultado dentro do .if é verdadeiro. No caso o script verifica se o primeiro parâmetro foi passado, já que os argumentos são acessíveis através dos alias (apelidos) $arg1 - $argn. Essa maneira de usar os argumentos passados no WinDbg ainda não foi documentada, mas encontrei essa dica em um artigo do Roberto Farah, um grande escritor de scripts para o WinDbg.&lt;/p&gt;
&lt;p&gt;Da mesma forma, o que não deve ser nenhuma surpresa, o WinDbg suporta comentários. Todas as linhas que contêm &#39;$$&#39; isoladamente são comentários, e seu conteúdo da direita é ignorado, salvo se for encontrado um ponto-e-vírgula.&lt;/p&gt;
&lt;p&gt;A primeira coisa que fazemos para carregar a DLL é salvar o estado do registrador IP, que indica onde está a próxima instrução:&lt;/p&gt;
&lt;p&gt;Feito isso, usamos um comando não tão comum, mas que pode ser muito útil nos casos em que precisamos capturar algum dado da saída de um comando do WinDbg e usá-lo em outro comando.&lt;/p&gt;
&lt;p&gt;A estrutura do .foreach deixa o usuário especificar dois grupos de comandos: o primeiro grupo irá gerar uma saída que pode ser aproveitada no segundo grupo.&lt;/p&gt;
&lt;p&gt;A opção &amp;quot;/pS 5&amp;quot; diz ao comando para pular 5 posições antes de capturar o token que será usado no próximo comando. Os tokens são divididos por espaço. Sendo a saída de &amp;quot;.dvalloc 0x1000&amp;quot;&lt;/p&gt;
&lt;p&gt;Pulando 5 posições iremos capturar o endereço onde a memória foi alocada. E é isso mesmo que queremos!&lt;/p&gt;
&lt;p&gt;O sinônimo do endereço (alias) se torna &amp;quot;addr&amp;quot;, apelido que usamos ao executar o segundo comando, que armazena o endereço no registrador temporário $t0:&lt;/p&gt;
&lt;p&gt;Após alocada a memória, gravamos o parâmetro de LoadLibrary, o path da DLL a ser carregada, em seu início.&lt;/p&gt;
&lt;p&gt;O código assembly que irá chamar fica um ponto à frente, mas na mesma memória alocada.&lt;/p&gt;
&lt;p&gt;Conforme as técnicas vão cada vez ficando mais &amp;quot;não-usuais&amp;quot;, mais difícil fica achar um nome para a coisa. Essa técnica de escrever o assembly de um código através de escritas em hexadecimal dentro de um script do WinDbg eu chamei de &amp;quot;script assembly&amp;quot;. Se tiver um nome melhor, não se acanhe em usá-lo. E me deixe saber =).&lt;/p&gt;
&lt;p&gt;Cada comentário de uma instrução em assembly é seguido pela escrita dessa instrução usando o comando e. Se trata de um código bem trivial, fora alguns detalhes que merecem mais atenção.&lt;/p&gt;
&lt;p&gt;Os comandos acima servem para salvar e restaurar o estado dos registradores e das flags de execução. Isso permite que possamos executar o código virtualmente em qualquer posição que pararmos no código depurado, já que retornamos tudo como estava ao final da execução do LoadLibrary. É claro que isso não garante que o código estará 100% estável em todas as condições, mas já ajuda um bocado.&lt;/p&gt;
&lt;p&gt;Uma chamada através do opcode call (código em hexa 0xe80c) é bem comum e se trata de uma chamada relativa, baseada no estado do Instruction Pointer atual mais o valor especificado. Por isso mesmo que fazemos o cálculo usando o endereço de onde será escrita a próxima instrução, que é o valor que teremos em IP quando este call for executado:&lt;/p&gt;
&lt;p&gt;Quando o código estiver completamente escrito na memória alocada, um disassembly dele retornará algo parecido com o código abaixo:&lt;/p&gt;
&lt;p&gt;Você pode ver com seus próprio olhos se editar o script comentando o último comando (g), executando o script e executando o disassembly do IP.&lt;/p&gt;
&lt;p&gt;Somos um script bem comportado (na medida do possível) e por isso colocamos um breakpoint temporário no final para, quando retornarmos para o código atual, desalocarmos a memória usada para a escrita e execução das instruções.&lt;/p&gt;
&lt;p&gt;Eu não me responsabilizo por qualquer (mau) uso do script aqui disponibilizado, assim como as eventuais perdas de código-fonte, trilhas de HD e placas de memória RAM pela sua execução. Assim sendo, bom divertimento.&lt;/p&gt;
&lt;p&gt;O criador do DriverEntry me questionou se não seria mais fácil, em vez de escrever todos os opcodes em hexa, usar o comando a, que permite entrar o código assembly diretamente a partir de um endereço especificado. Essa realmente é uma ótima idéia, e de fato eu tentei isso no começo de meus testes. Porém, infelizmente para scripts isso não funciona bem. A partir do comando a o prompt fica esperando uma entrada do usuário, não lendo o assembly que estaria no próprio script. Pior ainda, a escrita do assembly não permite usar os registradores temporários, como $t0 ou $t1, o que nos força a escrever um código dependende de valores constantes. Por esses motivos, tive que apelar para o comando e, que é a forma mais confusa de escrever e entender assembly. Nesse tipo de edição é vital comentar bem cada linha que se escreve.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Carregando DLLs arbitrárias pelo WinDbg</title>
  <link>http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg/</link>
  <pubDate>2007-11-23</pubDate>
  
  <guid>http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg/</guid>
  <description>&lt;p&gt;Durante meus testes para a correção de um bug me deparei com a necessidade de carregar uma DLL desenvolvida por mim no processo depurado. O detalhe é que o processo depurado é de terceiros e não possuo o fonte. Portanto, as opções para mim mais simples são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Usar o projeto RmThread para injetar a DLL (nesse caso iniciando o processo através dele).&lt;/li&gt;
&lt;li&gt;Fazer um módulo &lt;em&gt;wrapper&lt;/em&gt; para uma DLL qualquer e ser carregado de brinde.&lt;/li&gt;
&lt;li&gt;Usar o WinDbg e brincar um pouco.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Por um motivo desconhecido a terceira opção me pareceu mais interessante =).&lt;/p&gt;
&lt;p&gt;A seqüência mais simples para carregar uma DLL através do WinDbg é chamar kernel32!LoadLibrary através de um código digitado na hora, o que podemos chamar de live assembly (algo como &amp;quot;assembly ao vivo&amp;quot;). Porém, essa simples seqüência contém um pouco mais que uma dúzia de passos.&lt;/p&gt;
&lt;p&gt;Primeiro devemos parar a execução, voltar para um ponto seguro do código e armazenar o local seguro em um registrador temporário (o WinDbg tem 20 deles, $t0 até $t19).&lt;/p&gt;
&lt;p&gt;Parada a execução em um local seguro e armazenado o IP, em seguida podemos alocar memória para entrar o código em assembly da chamada, além do seu parâmetro, no caso o path da DLL a ser carregada.&lt;/p&gt;
&lt;p&gt;Note que estamos usando a versão ANSI do LoadLibrary, aquela que termina com A. Sendo assim, escrevemos uma string ANSI como parâmetro usando o comando eza.&lt;/p&gt;
&lt;p&gt;O último passo é chamar a função previamente &amp;quot;editada&amp;quot;. Para isso basta mudarmos o endereço da próxima instrução para o começo de nosso código e mandar executar, pois ele irá parar automaticamente no breakpoint que definimos &amp;quot;na mão&amp;quot;, o int 3 digitado. Após a execução devemos voltar o ponteiro usando nosso backup no registrador $t0.&lt;/p&gt;
&lt;p&gt;Como pudemos ver pela saída, a DLL foi carregada e agora temos a possibilidade de chamar qualquer código que lá esteja. Como fazer isso? Provavelmente usando o mesmo método aqui aplicado. Live-assembly é o que manda 8).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Usando a LIBC nativa do Windows</title>
  <link>http://www.caloni.com.br/usando-a-libc-nativa-do-windows/</link>
  <pubDate>2007-11-21</pubDate>
  
  <guid>http://www.caloni.com.br/usando-a-libc-nativa-do-windows/</guid>
  <description>&lt;p&gt;Por padrão, todo projeto no Visual Studio depende da LIBC. Isso quer dizer que, mesmo que você não use nem um mísero printf em todos os projetos criados, está atrelado a essa dependência. Em tempos onde fazer um &amp;quot;Hello World&amp;quot; pode custar 56 KB em Release - Visual Studio 2005, configuração padrão sem &amp;quot;buffer security check&amp;quot; - vale a pena economizar alguns KBytes que não se vão usar. Principalmente se essa possibilidade existe desde o cavernoso Windows 95.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Crie um novo projeto console Win32 vazio (&lt;em&gt;File, New, Project&lt;/em&gt;, blá blá blá)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crie um arquivo CPP no projeto (Project, Add New Item, etc)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crie um código parecido com o código abaixo (parecido == usando apenas LIBC básica)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Troque a configuração para &lt;em&gt;Release&lt;/em&gt;, pois &lt;em&gt;Debug&lt;/em&gt; não tem graça (Build, Configuration Manager, Release)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mude a runtime para estática (Project, Properties, C/C++, Code Generation, Multi-threaded)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compile e &lt;em&gt;link&lt;/em&gt; (Build, Build Solution)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pronto, após esses passos temos um projeto ordinário que compila um executável console ordinário que não depende de runtimes novas com exatos (pelo menos aqui) 57.344 bytes.&lt;/p&gt;
&lt;p&gt;Agora a parte divertida =).&lt;/p&gt;
&lt;p&gt;Desde o Windows 95, existe uma DLL com a maioria das funções da LIBC disponíveis para link dinâmico. Só que, com o uso padrão do Visual C++, é usada sempre a biblioteca que vem junto com o ambiente, com suas trocentas funções (e conseqüentes bytes enche-lingüiça). Porém, é possível utilizar diretamente a msvcrt.dll distribuída no diretório do sistema se criarmos uma LIB de importação para ela.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Copie a msvcrt.dll diretamente de um Windows 95 (diretório System) para evitar funções que não existam desde a primeira distribuição&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Utilizando essa versão da DLL e o &lt;em&gt;prompt&lt;/em&gt; de comando do Visual Studio, execute:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Utilizando o editor do seu coração, retire as linhas desnecessárias (aquelas do início do comando)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Retire as colunas desnecessárias (todas menos a com o nome das funções)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Retire os nomes bizarros que você não vai usar (todos os primeiros e que começam com &#39;?&#39;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ainda no ambiente console do VC execute o seguinte comando:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ótimo. Geramos a LIB que precisávamos e agora só falta integrar com o projeto. Para isso, mais alguns passos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Copie o msvcrt.lib para o diretório do projeto.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No projeto, coloque o arquivo na lista de LIBs a serem incluídas (Properties, Linker, Input, Additional Dependencies).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ignore o resto das LIBs colocadas por padrão no projeto (Linker, Input, Ignore All Default Libraries).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ignore as firulas de checagem (C/C++, Code Generation, Buffer Security Check, e Basic Runtime Checks em Debug).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Explicite o entry-point para a função main (Linker, Advanced, Entry Point).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compile e linke!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;E agora o tamanho final de nosso executável passou para espantosos 2KB! Isso a princípio parece ótimo e dá vontade de usar em todos os projetos, mas existe um porém ainda não resolvido: as limitações da falta de um runtime. Para isso que existe a próxima seção.&lt;/p&gt;
&lt;p&gt;Essa é uma solução bem bobinha que não tem nada a ver com uma solução profissional 100% garantida e com suporte técnico 24 horas. Algumas coisas não vão funcionar, como inicialização de variáveis estáticas, exceções, redirecionamento de entrada/saída, etc. Contudo, para projetos simples e pequenos, isso não deverá ser um problema. No entanto, eu não garanto qualquer coisa que advier de compilações inspiradas neste artigo.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Reduce EXE and DLL Size with LIBCTINY.LIB - Matt Pietrek&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Creating the smallest possible PE executable&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 5.1</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-51/</link>
  <pubDate>2007-11-19</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-51/</guid>
  <description>&lt;p&gt;Chega às lojas no dia 25 de outubro de 2001 a unificação entre as plataformas de uso doméstico e corporativo do sistema. O Windows XP usa o kernel de 32 bits de seus antecessores Windows NT e Windows 2000. É vendido em duas edições: Home e Professional Edition. O design do sistema foi totalmente remodulado para suportar ao mesmo tempo a facilidade de uso do usuário doméstico e a robustez e confiabilidade dos clientes corporativos.&lt;/p&gt;
&lt;p&gt;Do ponto de vista da arquitetura, pouca coisa mudou, e essa versão mudou internamente de 5.0 (Windows 2000) para 5.1 (Windows XP) . Ou seja, praticamente um patch de correção.&lt;/p&gt;
&lt;p&gt;Agora, além do sistema 32 bits que todos já conheciam, é lançada a primeira versão 64 bits do Windows, o Windows XP 64-bit Edition. Na época a Intel se preparava para o fracasso de mercado que foi o Intel IA-64 e esse Windows suportava essa nova arquitetura. Na verdade, o projeto foi além das expectativas e aplicou sua primeira versão do Windows-on-Windows 64-bit (WOW64), que permitia a execução de aplicativos 32 bits (x86) em cima da nova plataforma. Isso era feito pela tradução literal do código do assembly &amp;quot;antigo&amp;quot; para o assembly novo, além de outras técnicas auxiliares.&lt;/p&gt;
&lt;p&gt;Atualmente essa versão do Windows não é mais suportada.&lt;/p&gt;
&lt;p&gt;Como se tornou uma prática desde os tempos do Windows NT, a versão para servidores é sempre lançada algum tempo depois da versão para estações de trabalho. Assim foi com o Windows NT Server, o Windows 2000 Server e agora com o Windows XP, rebatizado em sua versão servidores para Windows 2003 Server, cujo código é uma evolução do XP original.&lt;/p&gt;
&lt;p&gt;Da mesma forma, com o lançamento da versão 64 para a plataforma x86, uma nova versão do Windows foi criada: a Windows XP Professional x64 Edition. Baseada no código do Windows 2003 Server SP1, essa nova versão se aproveitava da compatibilidade do x86-64 com a velha plataforma e otimizava a interação e execução dos velhos aplicativos 32, usando uma versão melhorada do WOW64, que se aproveitava da possibilidade de ficar trocando entre os modos 32 e 64 durante a execução dos aplicativos.&lt;/p&gt;
&lt;p&gt;No decorrer da história do Windows avançamos uns bons 20 anos até agora. Muita coisa que deveria ter sido falada não foi, e muita coisa que não merecia ser mencionada, foi. Abaixo podemos vislumbrar por onde passamos, onde chegamos e para onde vamos.&lt;/p&gt;
&lt;p&gt;Como podemos ver, não falarei mais aqui sobre a &amp;quot;outra ramificação&amp;quot; do Windows , aquela constituída por Windows 95, 98 e ME. Não falarei do processo antitruste contra a Microsoft por conta da venda do sistema operacional com o Internet Explorer e Media Player embutidos; não discursarei sobre os protestos dos consumidores quando a Microsoft cobrou pela versão de atualização do Windows 98, o Second Edition; muito menos esbravejarei sobre a raiva dos usuários pelo superaquecimento do processador por conta do Windows ME e sua duvidável interface revolucionária.&lt;/p&gt;
&lt;p&gt;Pelo contrário. Acho que é uma boa hora para adentrar mais ainda nas entranhas da arquitetura NT e entender algumas coisas até então pouco exploradas.&lt;/p&gt;
&lt;p&gt;Na eterna briga entre sistemas operacionais, uma categoria bem abastada (principalmente as discussões Tanenbaum x Torvalds) diz respeito aos sistemas monolíticos e aos baseados em microkernel. Basicamente os sistemas monolíticos possuem todo o seu código executando em modo privilegiado, inclusive os device drivers. Nos sistemas baseados em microkernel, no entanto, existe apenas uma fina camada de interface rodando em modo privilegiado, que serve de interação entre todos os serviços, driver e aplicativos e o hardware.&lt;/p&gt;
&lt;p&gt;O problema em si não é a organização dos componentes do sistema operacional em torno de um ou de outro design, mas o que isso implica em termos de eficiência.&lt;/p&gt;
&lt;p&gt;Abaixo podemos ver o esboço do que seria um sistema operacional com kernel monolítico, com todos acessando todos em modo kernel:&lt;/p&gt;
&lt;p&gt;Ao ser projetado, o objetivo do Windows nunca foi ser um sistema operacional de microkernel, embora umas boas almas tenham clamado o contrário. No entanto, a organização monolítica acima foi feita de tal forma que uma visão lógica do sistema operacional nos diria que a tentativa original foi dividir os serviços em camadas e componentes (servidores), de forma que as camadas superiores pudessem confiar nos serviços das camadas inferiores, tal como é em uma pilha TCP/IP.&lt;/p&gt;
&lt;p&gt;Porém, as coisas não são tão simples assim. O SO inteiro não é feito dessa forma. Foram usados diversos modelos para a organização do sistema, e é fácil perceber isso se enxergamos o todo através de várias visões.&lt;/p&gt;
&lt;p&gt;A visão acima, o caos, é o que temos quando só pensamos em módulos acessando módulos e código arbitrário rodando em kernel mode. Contudo, abaixo, por exemplo, podemos ver o resultado lógico da divisão em camadas em um kernel monolítico. Existe organização, embora esta esteja toda em código privilegiado.&lt;/p&gt;
&lt;p&gt;O acesso, porém, não é protegido, e eventuamente vão existir existir diversos atalhos (documentados ou não) para alcançar as coisas de maneira mais rápida, para o bem da velocidade.&lt;/p&gt;
&lt;p&gt;Uma última e terceira visão, baseada em componentes, divide o código em gerenciadores e provedores de serviços. Conceitualmente  essa divisão permitiria a migração de todo o código não-crítico para user mode, embora não seja o que ocorre.&lt;/p&gt;
&lt;p&gt;Essa divisão foi feita inicialmente e mantida apenas para serviços não-críticos que pudessem rodar em código não-privilegiado e a manutenção dos subsistemas: Win32, POSIX, MS-DOS. Nessa última visão conseguimos ainda visualizar um microkernel, mas é importante notar que não estamos falando aqui do conceito puro e formal que definimos no início da explicação.&lt;/p&gt;
&lt;p&gt;O esboço final, dessa forma, ficou sendo um sistema operacional dividido em componentes, com a maioria rodando em modo privilegiado (kernel mode), cuja divisão lógica primária tende a ser em camadas. É muito importante ter essa visão da coisa conforme nos aprofundamos nos mistérios do ring0.&lt;/p&gt;
&lt;p&gt;Para a organização dos recursos do sistema foi adotado um outro modelo, semelhante (embora não seja) ao conceito de orientação a objetos. Nesse modelo, os recursos são organizados em entidades identificáveis em sua maioria por um ponteiro opaco (kernel) ou um identificador, chamado de handle (user mode). Todos os recursos recebem o mesmo tratamento, embora se refiram a coisas extremamente diferentes, como um arquivo, uma porta de rede, um pedaço de memória, um processo e uma janela.&lt;/p&gt;
&lt;p&gt;Essa organização foi adotada principalmente pela sua grande vantagem de minimizar mudanças, uma vez que as informações sobre os recursos são armazenadas em estruturas opacas, isto é, elas existem, porém não são acessíveis a todos. Isso permite que elas sofram mudanças internas no decorrer do tempo sem impactar para seus usuários.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Artigos sobre a história do Windows no Caloni.com.br&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>SDelete</title>
  <link>http://www.caloni.com.br/sdelete/</link>
  <pubDate>2007-11-15</pubDate>
  
  <guid>http://www.caloni.com.br/sdelete/</guid>
  <description>&lt;p&gt;Minha vida tem que ser portátil. Existem pelo menos três lugares diferentes onde costumo ficar com um computador (não o mesmo). Por causa disso, os dados mais relevantes e que precisam fazer parte do meu sistema biológico eu carrego comigo pra cima e pra baixo em meu PenDrive/MP3Player.&lt;/p&gt;
&lt;p&gt;Até aí tudo bem. Quer dizer, mais ou menos. Dados relevantes costumam ser sensíveis, e busco sempre manter todos os arquivos sensíveis encriptados ou com uma senha específica do programa que o abre. O grande problema mesmo é que eu sei que operações no sistema de arquivos costumam deixar lastros do que já foi escrito um dia, e que é possível reaver esses dados com um pouco de persistência e sorte. É nessa hora que entra a praticidade do SDelete.&lt;/p&gt;
&lt;p&gt;Desde a versão NT, o Windows segue as diretivas de segurança do C2, o que entre outras coisas quer dizer que o a reutilização de um objeto no sistema operacional será protegida. Um objeto aqui está para representar recursos da máquina em geral, como páginas de memória e setores do disco. Quando um programa pede um setor de disco livre (ou uma página de memória) para uso próprio, o Windows apaga qualquer conteúdo remanescente naquele espaço de memória, evitando assim que exista uma maneira do atacante obter dados de terceiros (e.g. arquivos protegidos ou memória do sistema) sem autorização.&lt;/p&gt;
&lt;p&gt;Ou seja, desde que o Windows esteja no comando, os dados escritos por um programa não estarão disponíveis ao usuário por meio do reaproveitamento dos setores. Ficou claro?&lt;/p&gt;
&lt;p&gt;Se ficou claro, deve ter notado o &amp;quot;desde que o Windows esteja no comando&amp;quot;. Essa é uma condição sine qua non, mas que nem sempre é verdadeira. Um atacante que tenha acesso físico ao dispositivo de armazenamento (e.g. meu PenDrive) pode certamente usar outro sistema operacional (ou até mesmo o Windows em condições especiais) e vasculhar os dados que eu já apaguei, pois estes, como mostra a figura, não são apagados de fato até que um programa peça o espaço ocupado por eles.&lt;/p&gt;
&lt;p&gt;Para esse tipo de problema eu costumo usar um programinha esperto chamado SDelete (de Secure Delete). O que ele faz é zerar os setores não usados, da mesma forma com que o Windows faz quando um programa pede um setor não usado. Para isso, basta especificar um ou mais arquivos:&lt;/p&gt;
&lt;p&gt;Uma outra coisa que ele faz, muito útil quando comecei a usá-lo, é apagar todos os setores não usados que existem no disco inteiro (ou uma pasta inteira). Com isso podemos começar uma vida nova. Apenas tome muito cuidado nessa hora para especificar o comando, pois um errinho no comando pode realmente fazer você começar uma vida nova.&lt;/p&gt;
&lt;p&gt;O SDelete segue o padrão DOD 5220.22-M, o que quer dizer que ele está dentro das especificações da indústria que garantem a confidencialidade dos dados apagados. Além do mais, você pode especificar quantas &amp;quot;passadas&amp;quot; nos setores você deseja, para evitar aqueles ataques mais rebuscados em que é analisada a impedância das trilhas físicas de um disco magnético para obter os dados que uma vez estavam lá. É claro que isso não deve valer muito a pena se você está usando um PenDrive com memória flash =).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>MouseTool</title>
  <link>http://www.caloni.com.br/mousetool/</link>
  <pubDate>2007-11-13</pubDate>
  
  <guid>http://www.caloni.com.br/mousetool/</guid>
  <description>&lt;p&gt;Well, as most of you already know, I really don&#39;t like mice. Nevertheless I respect the users who use it and like it. That is the reason why I am writing a little more about it. This time, I going to show a program I use every day: MouseTool, for the users who does not use the mouse and like it.&lt;/p&gt;
&lt;p&gt;The program main purpose is to avoid clicking the mouse, simulating a click every time the user stops to move the cursor. Just this: simple, efficient and mouseless =).&lt;/p&gt;
&lt;p&gt;There are some options like drag-and-drop and double-click, both available through the program. You can choose to use a keyboard shortcut or the mode state, where you can switch the program default among simple-click, double-click and drag-and-drop.&lt;/p&gt;
&lt;p&gt;MouseTool was originally a open source tool. That means the lastest open source code is available, right? Wrong. Actually, I was unable to find it in every place I looked for.&lt;/p&gt;
&lt;p&gt;Fortunately, my friend Marcio Andrey [2] has got the source, and just like me, he wanted to make it available to everyone who would like to use it and change it. That&#39;s why I&#39;m publishing it here. It&#39;s free, and it&#39;s 4all =).&lt;/p&gt;
&lt;p&gt;Let&#39;s make use of this source and show how to explore a code not written by us. Normally the first things to do are: download the compacted file and extract the files into a new folder. So we find the project file (in this case, MouseTool.dsw) and try to open it. The result is a total failure, because I believe no one use the Visual Studio version that opens this kind of file (it will convert it to another one).&lt;/p&gt;
&lt;p&gt;Normally open source projects programmers are used to get the source code files, modify them, use them, publish them and all. But this is not always true about strict Windows commercial programmers.&lt;/p&gt;
&lt;p&gt;Given the source files, we can explore some interesting parts we&#39;d like to do someday in our own programs. And the main part is: we have the source, but not the copyright.&lt;/p&gt;
&lt;p&gt;Click in the link in the end of the post and make good use of it [3].&lt;/p&gt;
&lt;p&gt;PS: MouseTool now has a home page and a Source Forge project! Its new name is GMouseTool [2].&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://blog.codinghorror.com/going-commando-put-down-the-mouse/&#34;&gt;https://blog.codinghorror.com/going-commando-put-down-the-mouse/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;http://marcioandreyoliveira.blogspot.com/search/label/GMouseTool&#34;&gt;http://marcioandreyoliveira.blogspot.com/search/label/GMouseTool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;https://github.com/Caloni/mtool&#34;&gt;https://github.com/Caloni/mtool&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Detectando hooks globais no WinDbg</title>
  <link>http://www.caloni.com.br/detectando-hooks-globais-no-windbg/</link>
  <pubDate>2007-11-09</pubDate>
  
  <guid>http://www.caloni.com.br/detectando-hooks-globais-no-windbg/</guid>
  <description>&lt;p&gt;Nada como um comando prático para aprender rapidamente uma técnica. Nesse caso, tive que usar o comando abaixo para localizar o momento em que um executável instala um hook global:&lt;/p&gt;
&lt;p&gt;Vamos analisar cada um dos subcomandos novos um a um.&lt;/p&gt;
&lt;p&gt;No WinDbg é possível definir um ou mais comandos que são executados quando um breakpoint é acionado. Esses comandos ficam entre aspas duplas e podem conter as mesmas coisas que digitamos na linha de comando. Alguns comandos, porém, são mais úteis que outros nesse contexto. Por exemplo, o comando &amp;quot;.echo&amp;quot;. Podemos digitar .echo na linha de comando do WinDbg. O que acontece?&lt;/p&gt;
&lt;p&gt;Exatamente o que o comando se dispõe a fazer: imprimir seus argumentos na tela. E qual a vantagem nisso? Nenhuma, se estamos na linha de comando. Mas muita se estivermos colocando um breakpoint onde queremos contar o número de vezes que passamos por lá, o comando tem serventia:&lt;/p&gt;
&lt;p&gt;Se essa mensagem fosse exibida mais de uma vez, poderíamos supor que é possível existir algum tipo de infecção na execução do aplicativo, como quando o código inicial carrega o original e volta a executar o mesmo ponto.&lt;/p&gt;
&lt;p&gt;O objetivo aqui é &amp;quot;preparar o terreno&amp;quot; (ficar residente) antes que o código original seja executado. Com um simples breakpoint e um simples .echo conseguimos visualizar esse tipo de ataque. Outra possibilidade é que se trata daqueles executáveis &amp;quot;empacotados&amp;quot; por meio de algum encriptador de códigos como UPX, que desempacota o código e reexecuta o ponto de entrada do executável.&lt;/p&gt;
&lt;p&gt;Claro, esse é apenas um uso que podemos fazer desses comandos.&lt;/p&gt;
&lt;p&gt;Aprendi o comando j antes do .if, por isso acabo usando mais o primeiro, mas ambos possuem similaridades. O formato desse comando é exatamente como um &amp;quot;if-else&amp;quot;:&lt;/p&gt;
&lt;p&gt;Se Expression for verdadeiro, Command1 será executado; do contrário, Command2 será. Se você não precisa do else basta usar um comando vazio &#39; &#39;. A escolha é sua em usar aspas simples ou nada. Se usar aspas simples, é possível colocar mais de um comando, que foi o que eu fiz no else:&lt;/p&gt;
&lt;p&gt;Tudo depende do uso que você fizer desde comando. Algumas peculiaridades existem com relação ao uso de aspas duplas, simples, sem aspas, com ponto-e-vírgula, etc, mas são coisas que, como diz o Thiago, &amp;quot;só se aprende na dor&amp;quot;.&lt;/p&gt;
&lt;p&gt;Lembram-se de nossa peregrinação pela pilha de chamadas quando fizemos um hook na função MessageBox pelo WinDbg? Aqui é a mesma coisa, pois estou analisando um parâmetro passado na pilha (esp): o ID da thread para onde vai o hook:&lt;/p&gt;
&lt;p&gt;Relembrando nosso passeio pela pilha, ao entrar em uma função stdcall, os primeiros 4 bytes são o endereço de retorno, os próximos o primeiro parâmetro e assim por diante. O que quer dizer que:&lt;/p&gt;
&lt;p&gt;É o apontado do quarto parâmetro (4&lt;em&gt;4) que está sendo verificado. Concluindo, se o parâmetro dwThreadId for igual a zero, estamos diante de um hook global, e é o momento em que meu .echo vai exibir na tela &amp;quot;&lt;/em&gt;** GLOBAL HOOK ***&amp;quot;. Do contrário, a execução vai continuar silenciosamente.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Ponteiro de método: qual this é usado?</title>
  <link>http://www.caloni.com.br/ponteiro-de-metodo-qual-this-e-usado/</link>
  <pubDate>2007-11-07</pubDate>
  
  <guid>http://www.caloni.com.br/ponteiro-de-metodo-qual-this-e-usado/</guid>
  <description>&lt;p&gt;Depois de publicado o artigo anterior sobre ponteiros de métodos surgiu uma dúvida muito pertinente do autor do blogue CodeBehind, um escovador de bits disfarçado de programador .NET: qual objeto que vale na hora de chamar um método pelo ponteiro?&lt;/p&gt;
&lt;p&gt;Isso me estimulou a desdobrar um pouco mais os mistérios por trás dos ponteiro de métodos e de membros, e descobrir os detalhes mais ocultos desse lado esotérico da linguagem.&lt;/p&gt;
&lt;p&gt;Para entender por inteiro o que acontece quando uma chamada ou acesso utilizando ponteiros dependentes de escopo, algumas pequenas mudanças foram feitas no nosso pequeno FuzzyCall.&lt;/p&gt;
&lt;p&gt;O novo código chama através do mesmo ponteiro o mesmo método (duh), mas através de três objetos diferentes. Se observarmos a saída veremos que cada instância da classe guardou uma pedra diferente do saco de bingo para si (até porque, no jogo do bingo, não é possível existir mais de uma pedra com o mesmo número):&lt;/p&gt;
&lt;p&gt;Cada compilador e plataforma tem a liberdade de implementar o padrão C++ da maneira que quiser, mas o conceito no final acaba ficando quase a mesma coisa. No caso de ponteiros de métodos, o ponteiro guarda realmente o endereço da função que pertence à classe. Porém, como todo método não-estático em C++, para chamá-lo é necessário possuir um this, ou seja, o ponteiro para a instância:&lt;/p&gt;
&lt;p&gt;Em assembly (comando &amp;quot;cl /Fafuzzycall3.asm fuzzycall3.cpp&amp;quot; para gerar a listagem), teremos algo assim:&lt;/p&gt;
&lt;p&gt;Além do ponteiro de métodos, também é possível no C++ apontar para membros de um dado objeto. Para tanto, como vimos no código, basta declarar um tipo de ponteiro de membro de acordo com o tipo desejado:&lt;/p&gt;
&lt;p&gt;Nesse caso, a técnica de usar o próprio enderenço não funciona, já que cada objeto possui um membro próprio em um lugar de memória próprio. Porém, assim como os ponteiros de métodos, os ponteiros de membros exigem um objeto para serem acessados, o que já nos dá a dica de onde o objeto começa. Sabendo onde ele começa, fica fácil saber onde fica o membro através do seu offset, ou seja, a distância dele a partir do início da memória do objeto. Só que para isso precisamos do offset armazenado em algum lugar. E adivinha onde que ele fica armazenado?&lt;/p&gt;
&lt;p&gt;Podemos acompanhar este código no WinDbg (ou alguma outra IDE mais pomposa, se preferir) e veremos que o conteúdo do eax irá refletir o offset do membro dentro da classe FuzzyCall.&lt;/p&gt;
&lt;p&gt;Como podemos ver, não é nenhuma magia negra a responsável por fazer os ponteiros de métodos e de membros funcionarem em C++. Porém, eles não são ponteiros ordinário que costumamos misturar a torto e a direito. Essa distinção na linguagem é importante para manter o código &amp;quot;minimamente sadio&amp;quot;.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Ponteiros de método: conceito fundamental</title>
  <link>http://www.caloni.com.br/ponteiros-de-metodo-conceito-fundamental/</link>
  <pubDate>2007-11-05</pubDate>
  
  <guid>http://www.caloni.com.br/ponteiros-de-metodo-conceito-fundamental/</guid>
  <description>&lt;p&gt;Diferente de ponteiros de função (funções globais ou estáticas) - que são a grosso modo ponteiros como qualquer um - os ponteiros de método possuem uma semântica toda especial que costuma intimidar até quem está acostumado com a aritmética de ponteiros avançada. Não é pra menos: é praticamente uma definição à parte, com algumas limitações e que deixa a desejar os quase sempre criativos programadores da linguagem, que vira e mexe estão pedindo mudanças no C++0x.&lt;/p&gt;
&lt;p&gt;Três regras iniciais que devem ser consideradas para usarmos ponteiros para métodos são:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A semântica para lidar com ponteiros de método é totalmente diferente de ponteiros de função.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ponteiros de método de classes distintas nunca se misturam.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Para chamarmos um ponteiro de método precisamos sempre de um objeto da classe para a qual ele aponta.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Visto isso, passemos a um exemplo simples, um chamador de métodos aleatórios, que ilustra o princípio básico de utilização:&lt;/p&gt;
&lt;p&gt;Como podemos ver, para o typedef de ponteiros de método é necessário especificar o escopo da classe. Com isso o compilador já sabe que só poderá aceitar endereços de métodos pertencentes à mesma classe com o mesmo protótipo.&lt;/p&gt;
&lt;p&gt;Na hora de atribuir, usamos o operador de endereço e o nome do método (com escopo, se estivermos fora da classe). É importante notar que, diferente de ponteiros de função, o operador de endereço é obrigatório. Do contrário:&lt;/p&gt;
&lt;p&gt;E, por fim, a chamada. Como é a chamada de um método, é quase intuitiva a necessidade de um objeto para chamá-la. Do contrário não teríamos um this para alterar o objeto em qualquer método não-estático, certo? Daí a necessidade do padrão C++ especificar dois operadores especialistas para esse fim, construídos a partir da combinação de operadores já existentes em C:&lt;/p&gt;
&lt;p&gt;Esses operadores obrigam o programador a sempre ter um objeto e um ponteiro. Daí não tem como errar. Infelizmente, devido à ordem de precedência, temos que colocar os parênteses em torno da expressão para chamar o método. Pelo menos fica equivalente ao que precisávamos fazer antes da padronização da linguagem C.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Desenvolvendo em linha de comando</title>
  <link>http://www.caloni.com.br/desenvolvendo-em-linha-de-comando/</link>
  <pubDate>2007-11-01</pubDate>
  
  <guid>http://www.caloni.com.br/desenvolvendo-em-linha-de-comando/</guid>
  <description>&lt;p&gt;Desde uns tempos para cá o Visual Studio tem se tornado uma das ferramentas mais pesadas de desenvolvimento já criadas. Como se não bastasse, a compilação de pequenos trechos de código é algo desnecessariamente complicado no ambiente. Por esse motivo estou ganhando o costume de usar a linha de comando para esse tipo de tarefa. Afinal de contas,  na maioria das  vezes a única coisa que eu preciso fazer é abrir o atalho &amp;quot;Visual Studio Command Prompt&amp;quot; e digitar uma linha:&lt;/p&gt;
&lt;p&gt;O problema é ter que &amp;quot;andar&amp;quot; do diretório padrão de início até a pasta onde está o código-fonte que desejo compilar. Porém, isso é facilmente resolvido com uma linha (no registro):&lt;/p&gt;
&lt;p&gt;A partir daí, o comando &amp;quot;Console&amp;quot; existe no menu de contexto de qualquer pasta que clicarmos no Windows Explorer.&lt;/p&gt;
&lt;p&gt;Note que é possível criar outros comandos, como é o meu caso, onde preciso de vez em quando compilar utilizando o Visual Studio 2005 (o comando Console) e o Visual Studio 2003 (o comando VS2003). Ao escolher a opção, um prompt de comando é aberto com o ambiente de compilação montado e (adivinhe) com a pasta padrão sendo a que foi clicada no explorer.&lt;/p&gt;
&lt;p&gt;Nossos projetos aqui na empresa costumam ser divididos em inúmeras soluções do Visual Studio para evitar a bagunça que seria (foi) ter que abrir uma solução de 10^24324 projetos. O problema é que, se abrir um Visual Studio já pesa, imagine abrir cinco de uma vez.&lt;/p&gt;
&lt;p&gt;Por isso mesmo que, aproveitando que agora tenho uma linha de comando personalizada com o ambiente de compilação, faço uso da compilação de soluções em modo console que o devenv (a IDE do Visual Studio) oferece:&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;dica-para-programadores-profissionais&#34;&gt;Dica para programadores profissionais&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;Além de ser rápido, pode ser usado em builds automatizados, coisa que já fazemos. O que quer dizer que podemos matar os itens 2 e 3 do teste do Joel, nos deixando um passo mais próximo do purgatório.&lt;/p&gt;
&lt;p&gt;Tudo bem, mas eu preciso depurar o código! Você não quer que eu use o NTSD, ou quer?&lt;/p&gt;
&lt;p&gt;Sabe que não é uma má idéia?&lt;/p&gt;
&lt;p&gt;Porém, se você prefere algo mais amigável, mais ainda que o WinDbg, você pode iniciar o depurador do Visual Studio por linha de comando:&lt;/p&gt;
&lt;p&gt;Daí não tem jeito: você economiza no start, mas o Visual Studio vai acabar subindo. Ou um ou outro.&lt;/p&gt;
&lt;p&gt;Por isso eu recomendo aprender a usar o WinDbg ou até o NTSD. Quer dizer, é muito melhor do que esperar por uma versão mais light do Visual Studio no próximo ano.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Brincando com o WinDbg</title>
  <link>http://www.caloni.com.br/brincando-com-o-windbg/</link>
  <pubDate>2007-10-30</pubDate>
  
  <guid>http://www.caloni.com.br/brincando-com-o-windbg/</guid>
  <description>&lt;p&gt;No primeiro artigo sobre o WinDbg usamos o aplicativo Logger para verificar as funções APIs que são chamadas por um determinado programa. Agora iremos dar um passo adiante e depurar de fato um aplicativo qualquer, com o detalhe que não teremos o código-fonte.&lt;/p&gt;
&lt;p&gt;Existem duas maneiras de depurar um programa localmente usando o WinDbg: iniciá-lo pelo próprio WinDbg ou conectar o depurador (attach) em um programa já em execução. Podemos especificar o que faremos direto na linha de comando ou pela sua interface.&lt;/p&gt;
&lt;p&gt;Pela linha de comando:&lt;/p&gt;
&lt;p&gt;Pela interface:&lt;/p&gt;
&lt;p&gt;Para variar, iremos depurar o Bloco de Notas, o maravilhoso editor de textos da Microsoft e plataforma de testes para serviços, GINAs e drivers. Para começar, poderemos usar quaisquer das opções anteriores, o que nos levará para uma saída parecida com a seguinte:&lt;/p&gt;
&lt;p&gt;Não se preocupe, nada aconteceu de errado. Essa é apenas a maneira do WinDbg de dizer &amp;quot;oi, estou aqui, positivo e operando&amp;quot;.&lt;/p&gt;
&lt;p&gt;Vamos destrinchar as informações iniciais para evitar confusão:&lt;/p&gt;
&lt;p&gt;Muito bem. Agora vamos explicar resumidamente o que cada parte significa:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Version: versão que está sendo executada do WinDbg (duh).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CommandLine: linha de comando que foi usada ao executar o depurador.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ModLoad: sempre que um módulo é carregado no processo (DLLs ou o próprio executável) o WinDbg informa os endereços inicial e final de carregamente e o nome do módulo. Para rever a lista de módulos carregados usa-se o comando lm.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pid.tid: Break instruction exception - code 8000003 (first chance)_. Qualquer informação específica de uma &lt;em&gt;thread&lt;/em&gt; é informada dessa maneira no WinDbg. No caso, foi a exceção de &lt;em&gt;breakpoint&lt;/em&gt; (parada na execução) acionada no começo da depuração (e é por isso que o notepad ainda não está aparecendo).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Explicado o começo, o resto é fácil. Para continuar a execução do bloco de notas basta usarmos o comando g (Go), ou pressionar F5, ou ir no menu &amp;quot;Debug, Go&amp;quot;, ou ainda apertar este botão:&lt;/p&gt;
&lt;p&gt;Na maioria dos comandos mais comums você terá todas essas opções ao seu dispor. Na maioria dos comandos mais incomuns tudo o que você terá será o prompt de comando do WinDbg e a ajuda, acionada por F1 ou pelo comando .hh tópico. Geralmente os comandos do WinDbg possuem milhares de parâmetros, e é considerada atitude sábia olhar de vez em quando o que alguns desses parâmetros significam para que, aos poucos, aprenda-se alguns truques até a chegada da iluminação completa, onde seu espírito irá fluir livremente pela memória de todos os processos do sistema.&lt;/p&gt;
&lt;p&gt;Por enquanto, basta apertar g e .&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A tempo: após executar g e mais um monte daquelas mensagens cheias de caracteres irão aparecer. Não se preocupe. Elas realmente não são importantes no momento, mas é importante saber o básico, que é &amp;quot;o WinDbg está avisando você de tudo o que ocorre&amp;quot;. No momento certo, saberemos usar as informações na tela quando houver necessidade.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vamos fazer algo não tão esperto para ver como o bloco de notas reage. Tente abrir um arquivo com um nome inexistente:&lt;/p&gt;
&lt;p&gt;Como podemos ver, o Bloco de Notas exibe uma mensagem de erro indicando que o arquivo cujo nome você digitou não existe, pede para você verificar a &amp;quot;orografia&amp;quot; e tudo o mais. O importante aqui não é que você não sabe digitar nomes de arquivos, mas sim que a função que o notepad usa para exibir sua mensagem de erro é a conhecida API MessageBox, cujo protótipo é o seguinte:&lt;/p&gt;
&lt;p&gt;Algumas coisas a serem notadas nessa API:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Como (quase) toda API no Windows, a convenção de chamada é WINAPI, o que significa que quem chama empilha todos os parâmetros na pilha. Eu estou falando apenas de Windows 32 bits.&lt;/li&gt;
&lt;li&gt;A função recebe 4 parâmetros e, de acordo com a convenção de chamada, podemos supor que esses parâmetros são empilhados na seguinte ordem (invertida): uType, lpCaption, lpText, hWnd, endereço-de-retorno.&lt;/li&gt;
&lt;li&gt;As &lt;em&gt;strings&lt;/em&gt; para as quais os dois parâmetros do meio apontam são do tipo LPCTSTR, o que significa que, além de constantes, podem ser ANSI ou UNICODE, dependendo da versão que estamos utilizando.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;ansi-x-unicode&#34;&gt;ANSI x UNICODE&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;O sistema operacional utiliza internamente a codificação UNICODE. Contudo, para manter compatibilidade com versões anteriores de outros SOs, como Windows 95, 98 e ME, as APIs são desenvolvidas em duplas, com versões UNICODE (final W), que repassam a chamada diretamente para o sistema operacional, e ANSI (final A), que fazem a conversão de strings para daí (normalmente) chamar sua irmã em UNICODE.&lt;/p&gt;
&lt;p&gt;Sabendo que tudo converge para UNICODE, vamos colocar um singelo breakpoint nessa função API. Para parar a execução do notepad, podemos digitar &amp;quot;Ctrl + Break&amp;quot; ou ir no menu &amp;quot;Debug, break&amp;quot; ou ainda... bem, você pegou o espírito da coisa.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;faça-do-modo-inteligente&#34;&gt;Faça do modo inteligente&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;Note que utilizei o prefixo user32! para especificar que a função está no módulo user32.dll, mas não seria necessário já que o WinDbg procura por qualquer função digitada na sua lista de funções exportadas e símbolos atuais. Contudo, fazer isso torna as coisas mais rápidas e evita perder tempo à toa.&lt;/p&gt;
&lt;p&gt;Agora podemos efetuar a mesma operação de abrir um arquivo inexistente no bloco de notas que a execução irá parar no início da função MessageBoxW da API:&lt;/p&gt;
&lt;p&gt;Vamos exibir o estado da pilha atual (no registrador esp) no formato de double words, a palavra padrão em sistemas 32 bits:&lt;/p&gt;
&lt;p&gt;A primeira coluna (cujo primeiro valor é 0007cfa0) exibe o endereço da pilha, sendo que o resto das colunas são os valores encontrados a partir do topo da pilha. Sabendo que a pilha cresce &amp;quot;ao contrário&amp;quot;, de valores maiores de endereço para menores, os parâmetros empilhados invertidos aparecem agora na ordem do protótipo da função. Complicado? Nem tanto. Os parâmetros são empilhados na ordem inversa do protótipo em C, como tínhamos observado: uType, lpCaption, lpText, hWnd e por fim endereço-de-retorno, que é empilhado ao ser executada a instrução call.&lt;/p&gt;
&lt;p&gt;Ao chegar em user32!MessageBoxW o estado da pilha reflete o protótipo, pois é o inverso do inverso (a pilha cresce &amp;quot;para baixo&amp;quot;, porém os parâmetros são empilhados do último para o primeiro).&lt;/p&gt;
&lt;p&gt;Para referenciarmos os parâmetros através do WinDbg, de forma genérica, tudo que precisamos é adicionar 4 bytes para pularmos de parâmetro em parâmetro:&lt;/p&gt;
&lt;p&gt;Baseado nesse princípio básico, podemos agora exibir o conteúdo de cada parâmetro passado usando o comando d (Dump) do WinDbg, aliado ao comando poi (pointer), que deferencia um determinado endereço (&amp;quot;o apontado de&amp;quot;).&lt;/p&gt;
&lt;p&gt;Note que se estivéssemos tentando exibir uma string Ansi iríamos usar o comando da. O WinDbg possui inúmeros comandos parecidos que começam com d, cuja lista pode ser consultada pelo comando .hh d.&lt;/p&gt;
&lt;p&gt;Como último passo em nosso passeio, vamos especificar alguns comandos para serem executados quando o breakpoint do MessageBox for acionado. O que iremos fazer aqui é trocar a mensagem de erro e seguir em frente (um breakpoint que não pára).&lt;/p&gt;
&lt;p&gt;Para trocar a mensagem de erro usamos o comando e (Edit), semelhante ao d.&lt;/p&gt;
&lt;p&gt;Para continuar a execução, como já vimos, usamos o comando g (Go), e é nessas horas que apenas o comando do prompt pode nos salvar:&lt;/p&gt;
&lt;p&gt;O comando bp (BreakPoint) permite que sejam especificados comandos para serem executados automaticamente sempre que o breakpoint for ativado. Por isso, ao passar em user32!MessageBoxW colocamos dois comandos (separados por ponto-e-vírgula): ezu, que Edita uma string Unicode com outra string terminada em Zero, e o comando g, que já estamos carecas de saber. O resultado é óbvio, mas divertido de ver:&lt;/p&gt;
&lt;p&gt;Repare que colocamos esse breakpoint diretamente na função API, ou seja, qualquer outro ponto do notepad em que ele tiver vontade de chamar a mesma API irá ativar o mesmo breakpoint e exibir a mesma mensagem, o que pode ser um pouco importuno da parte dele. Um bom exercício pós-leitura seria tratar as condições em que a mensagem será trocada, talvez se baseando na mensagem recebida. Mas isso já é lição de casa, e paramos por aqui.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Proteção dos membros protected</title>
  <link>http://www.caloni.com.br/protecao-dos-membros-protected/</link>
  <pubDate>2007-10-26</pubDate>
  
  <guid>http://www.caloni.com.br/protecao-dos-membros-protected/</guid>
  <description>&lt;p&gt;Quando queremos que um membro de nossa classe seja visível apenas dentro dos métodos da classe e dentro dos métodos das classes derivadas dessa classe usamos o nível de proteção protected. Isso, é claro, não quer dizer que uma classe derivada vá ter acesso aos membros protegidos de outra:&lt;/p&gt;
&lt;p&gt;Esse é o motivo fundamental do porquê não podermos fazer isso:&lt;/p&gt;
&lt;p&gt;Ao acessar membros protegidos é importante o tipo da expressão que está do lado esquerdo do &amp;quot;.&amp;quot; ou &amp;quot;-&amp;gt;&amp;quot;. Afinal, o nível de proteção se baseia no escopo, e as classes são um escopo. É por isso que consigo acessar os membros protegidos de um outro objeto de minha classe, mesmo sendo outro objeto:&lt;/p&gt;
&lt;p&gt;A definição do escopo é tudo o que o compilador dispõe para saber se acessa ou não acessa um membro. Podemos ter acesso a mprotected enquanto somos do tipo Derived, mas não quando o mesmo objeto é usado como Base:&lt;/p&gt;
&lt;p&gt;Essa proteção parece desnecessária - e até mesmo incoerente - quando lidamos com o mesmo objeto que acessa. Afinal, somos nós mesmos! Só que o compilador não sabe disso, e ele deve desconfiar de tudo e de todos para evitar esse tipo de &amp;quot;ataque&amp;quot;:&lt;/p&gt;
&lt;p&gt;Agora a proteção do compilador faz sentido. Parece um detalhe frívolo, mas depois que vi alguns programadores de respeito se debatendo pela &amp;quot;burrice&amp;quot; do compilador, imaginei que talvez houvesse mais pessoas com a mesma dúvida de se existe ou não um &amp;quot;bug na linguagem&amp;quot;.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Typeid e os perigos do não-polimorfismo</title>
  <link>http://www.caloni.com.br/typeid-e-os-perigos-do-nao-polimorfismo/</link>
  <pubDate>2007-10-24</pubDate>
  
  <guid>http://www.caloni.com.br/typeid-e-os-perigos-do-nao-polimorfismo/</guid>
  <description>&lt;p&gt;Quando usamos o operador typeid geralmente desejamos conhecer informações sobre o tipo exato do objeto que temos em mãos, independente da hierarquia de herança a qual seu tipo pertença. Só que por ignorar, assim como o sizeof, que esse operador possui duas caras, às vezes damos com os burros n&#39;água e compramos gato por lebre. Não é pra menos. Uma sutil diferença entre classes polimórficas e estáticas pode dar aquele susto que só C++ pode proporcionar.&lt;/p&gt;
&lt;p&gt;Eis um exemplo singelo, sem dramatização (com dramatização == &amp;quot;500 linhas de código de produção além do código abaixo&amp;quot;).&lt;/p&gt;
&lt;p&gt;O typeid usado nesse exemplo será o estático, no estilo typeid(type), porque o tipo do objeto para a função é de &amp;quot;ponteiro para objeto de classe não-polimórfica&amp;quot;, ou seja, sem nenhuma função virtual. É importante lembrar que o polimorfismo em C++ só é aplicado se houver razão para tal, pois na linguagem a regra é que &amp;quot;não existe sobrecarga de execução sem que o programador queira&amp;quot;.&lt;/p&gt;
&lt;p&gt;Se o esperado pelo programador fosse um class Deriv na última linha da saída, ou seja, que o typeid utilizado fosse a versão dinâmica, então a nossa classe Base tem que ser polimórfica:&lt;/p&gt;
&lt;p&gt;Esse é um erro equivalente ao chamar o operador delete usando o ponteiro recebido em func. Se isso fosse feito, seria chamado apenas o destrutor da classe Base. Por falar nisso, temos nesse exemplo um leak de memória (percebeu pela saída que os destrutores não são chamados?). Mas esse é um erro bem menos sutil que o visto pelo nosso amigo typeid amigo-da-onça ;).&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Guia básico para programadores de primeiro breakpoint</title>
  <link>http://www.caloni.com.br/guia-basico-para-programadores-de-primeiro-breakpoint/</link>
  <pubDate>2007-10-22</pubDate>
  
  <guid>http://www.caloni.com.br/guia-basico-para-programadores-de-primeiro-breakpoint/</guid>
  <description>&lt;p&gt;Aproveitando um dos últimos artigos que fala sobre conceitos básicos de programação, lembro que, tão importante quanto, é possuir habilidades básicas de depuração, uma arte por muitos programadores ignorada.&lt;/p&gt;
&lt;p&gt;É interessante notar como muitos programadores e instituições de ensino ignoram a utilidade e conveniência das tradicionais e poderosas ferramentas de depuração passo-a-passo. O motivo pode ser puro desdém ou ignorância (no sentido de desconhecimento). Se for pelo segundo, aí vão algumas dicas para dar uma passada geral no seu programa e, quem sabe, encontrar um ou outro bug pelo caminho.&lt;/p&gt;
&lt;p&gt;É o comando primário. Simplesmente inicia uma nova execução de seu programa. Geralmente você deve utilizar esse comando quando já tiver definido seus breakpoints (mais abaixo). Do contrário o programa vai iniciar, executar e sair, sem sequer você notar.&lt;/p&gt;
&lt;p&gt;Na ordem: Start/Continue, Break, Stop, Restart, Show Next Statement, Step Into, Over e Out.&lt;/p&gt;
&lt;p&gt;Esse comando avança uma linha de código-fonte, parando na seguinte, de uma maneira iterativa. É a chamada execução passo-a-passo. Com ele você consegue, com a ajuda das janelas de watch e variáveis locais, analisar passo-a-passo a execução do fluxo de seu programa variando de acordo com as condições do sistema.&lt;/p&gt;
&lt;p&gt;Parente bem próximo do Step Over, com a importante diferença de entrar dentro das funções que são chamadas em cada linha de execução. Geralmente é usado quando você pretende revisar todo o fluxo de execução porque escreveu código novo ou porque ainda não chegou na situação que pretende simular ou ainda porque usou o Step Over antes e descobriu que existe algum problema na função X que você passou direto.&lt;/p&gt;
&lt;p&gt;É o complemento dos dois comandos acima. Ele vai sair executar todo o resto da função onde você está e parar exatamente uma linha após a chamada dessa função. Em suma: você já viu o que queria ver dentro da função atual e quer continuar a execução um ou mais níveis acima na pilha de chamadas.&lt;/p&gt;
&lt;p&gt;Você não precisa passar por todo o seu código e todos os seus loops/laços de 500 iterações até chegar ao ponto que quer analisar. Existe um comando nativo do sistema que é dos mais úteis para o programador, capaz de parar o fluxo de execução em um ponto específico do código. O depurador torna disponível para você esse comando que pode ser engatilhado em qualquer linha, geralmente em uma quantidade razoável. Para controlar todos os breakpoints definidos existe uma janela com essa lista que indica, entre outras coisas, se estão habilitados ou não, se possuem alguma condição de quebra, quantas vezes devem parar, etc. Costuma existir um ótimo controle sobre breakpoints nos depuradores, pois esse é um comando muito usado em programação (e dos mais antigos).&lt;/p&gt;
&lt;p&gt;Praticamente qualquer ferramenta de debug possui um mecanismo para que você consiga ver o que está dentro das variáveis de seu programa. Basicamente temos uma janela de watch, ou inspection, onde podemos inserir as variáveis que queremos espiar. Em um nível mais sofisticado, temos as janelas de locals e autos (o nome pode variar), onde podemos ver, respectivamente, as variáveis dentro da função e as variáveis mais próximas do ponto onde o código está parado (as que foram usadas na última linha e as que serão usadas na próxima, por exemplo). Claro que cada ambiente te fornece o que melhor ajudar durante a depuração, assim como o Delphi e o C++ Builder possuem o magnífico Object Inspector, uma janela com todas as propriedades de um objeto qualquer do sistema (uma janela, um botão, uma classe, etc).&lt;/p&gt;
&lt;p&gt;Essa é a pilha de chamadas da thread atual. Com ela você consegue ver o nome da função que chamou a função que chamou a função que chamou... até a função inicial (por exemplo, o nosso conhecido main, a primeira função de um programa &amp;quot;normal&amp;quot; em C/C++).&lt;/p&gt;
&lt;p&gt;No caso de seu programa ser multithreading, ou seja, possuir várias linhas de execução, fluxos distintos de código rodando, existirá uma janela onde você pode ver qual a thread atual (a que está sendo depurada e destrinchada nas outras janelas) e quais as outras threads. Muitos ambientes permitem que com essa janela seja feito um switch de threads, que é a troca da thread atual, o que irá alterar a janela de pilha de chamadas, de variáveis locais, e muito provavelmente a janela do código-fonte atualmente em execução.&lt;/p&gt;
&lt;p&gt;Depurar esteve sempre ligado à programação desde os primórdios da humanidade. Por isso hoje em dia os depuradores estão muito evoluídos, geralmente integrados em um ambiente de desenvolvimento (exs: Visual Studio, KDE Develop) e possuem comandos e mais comandos e mais comandos. Existem comandos, por exemplo, para pular fluxo sem executar, definir um breakpoint temporário, visualizar registradores da máquina, visualizar páginas de memória, controle de exceções, misturar assembly com código-fonte, etc. Enfim, cada comando deve ser usado conforme a necessidade e conveniência. Não adianta querer usar tudo e entender tudo de uma vez. Os comandos acima já são um ótimo começo para uma depuração poderosa o suficiente para pegar alguns bugs.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Por que minha DLL travou?</title>
  <link>http://www.caloni.com.br/por-que-minha-dll-travou/</link>
  <pubDate>2007-10-18</pubDate>
  
  <guid>http://www.caloni.com.br/por-que-minha-dll-travou/</guid>
  <description>&lt;p&gt;Saiu um documento da Microsoft alertando sobre os perigos em colocar código no DllMain. É algo mais completo e didático do que as simples observações do help do MSDN. Vale a pena dar uma lida, especialmente por causa das explicações sobre o loader lock e seus efeitos colaterais.&lt;/p&gt;
&lt;p&gt;O resumo da ópera é que o código do Windows chamador do DllMain das DLLs carregadas/descarregadas utiliza um objeto de acesso exclusivo (leia &amp;quot;mutex&amp;quot;) para sincronizar as chamadas. O resultado é que, em um processo, apenas um DllMain é chamado em um dado momento. Esse objeto é chamado de &amp;quot;loader lock&amp;quot; na documentação da Microsoft.&lt;/p&gt;
&lt;p&gt;O código abaixo é besta, mas representa o que já vi em muito código-fonte, e muitas vezes não consegui perceber o que estava acontecendo (tanto porque desconhecia a existência desse loader lock quanto o código estava obscuro demais pra entender mesmo). Os comentários dizem tudo:&lt;/p&gt;
&lt;p&gt;Uma simples vítima disso pode ser um pobre executável usando uma pobremente escrita DLL, assim como no código abaixo:&lt;/p&gt;
&lt;p&gt;Para ver o problema de lock em ação, copie os fontes da DLL e do EXEcutável e use os comandos abaixo para gerar os arquivos:&lt;/p&gt;
&lt;p&gt;É importante sempre lembrar que a Microsoft acha feio, muito feio você ficar dependendo do DllMain pra fazer alguma coisa, &lt;strong&gt;mas&lt;/strong&gt; admite que em alguns casos o único lugar onde podemos rodar código é no DllMain. Nesses casos - e em alguns outros - &lt;strong&gt;utilize uma comunicação paralela com sua thread travadona&lt;/strong&gt;, por meio de um evento ou algo do gênero, antes que ela realmente saia. Com isso a thread pode ainda não ter saído, mas pode avisar a thread principal que o que ela precisava fazer já foi feito.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NT Loader (MSJ Sep 99) - Matt Pietrek&lt;/li&gt;
&lt;li&gt;mgrier&#39;s WebLog - NT Loader team participant&lt;/li&gt;
&lt;/ol&gt;
</description>
</item>

     
        <item>
  <title>Guia básico para programadores de primeiro int main</title>
  <link>http://www.caloni.com.br/guia-basico-para-programadores-de-primeiro-int-main/</link>
  <pubDate>2007-10-16</pubDate>
  
  <guid>http://www.caloni.com.br/guia-basico-para-programadores-de-primeiro-int-main/</guid>
  <description>&lt;blockquote&gt;
&lt;p&gt;Vou aproveitar que meu amigo DQ publicou um artigo muito bom sobre como fazer programas fáceis de manter (merece ser lido!) e vou republicar um artigo do blogue antigo sobre o básico do básico para quem deseja entender como os programas funcionam. Não é nada sofisticado, apenas alguns conceitos comuns que, se você deseja ser programador, deveria procurar saber.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A primeira coisa a saber é o que é um programa. Podemos imaginá-lo como um arquivo que vai ser interpretado pelo computador. Essa interpretação chamamos de execução. Quando um programa está sendo executado também é comum dizermos que ele está rodando. Teoricamente ele pode rodar eternamente, mas o que acontece em casos normais é que ele tem um fim previsto, seja quando o usuário fechar a janela principal (evento externo) ou quando ele terminar o que tinha que fazer (lógica interna).&lt;/p&gt;
&lt;p&gt;E do que é feito um programa? Basicamente de duas coisas: dados de entrada e instruções (ou código). Os dados podem estar no próprio programa ou serem lidos de algum outro lugar (do teclado, de outro arquivo, da internet, etc). As instruções do seu programa é o que será interpretado pelo computador. E o que ele fará? Basicamente alterar os dados de entrada. O objetivo fundamental de um programa é gerar dados de saída. Esses dados são escritos/exibidos para algum outro lugar (para a tela, para um arquivo, para a internet, etc).&lt;/p&gt;
&lt;p&gt;Vamos analisar essas abstrações em exemplos da vida real:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Exemplo&lt;/th&gt;
&lt;th&gt;Dados de entrada&lt;/th&gt;
&lt;th&gt;Processamento&lt;/th&gt;
&lt;th&gt;Dados de saída&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Bloco de Notas&lt;/td&gt;
&lt;td&gt;Digitação do usuário&lt;/td&gt;
&lt;td&gt;Leitura do teclado&lt;/td&gt;
&lt;td&gt;Texto exibido na tela&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MSN&lt;/td&gt;
&lt;td&gt;Envio de mensagem&lt;/td&gt;
&lt;td&gt;Conexão com a internet&lt;/td&gt;
&lt;td&gt;Seu amigo recebe a mensagem&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PaintBrush&lt;/td&gt;
&lt;td&gt;Movimento do mouse&lt;/td&gt;
&lt;td&gt;Interpretação de movimento&lt;/td&gt;
&lt;td&gt;Retângulo desenhado&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Firefox&lt;/td&gt;
&lt;td&gt;Clique do mouse em uma URL&lt;/td&gt;
&lt;td&gt;Conexão com o site&lt;/td&gt;
&lt;td&gt;Exibição da nova página&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Counter Strike&lt;/td&gt;
&lt;td&gt;Clique no botão de tiro&lt;/td&gt;
&lt;td&gt;Cálculo do projétil&lt;/td&gt;
&lt;td&gt;Inimigo acertado&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Compilador&lt;/td&gt;
&lt;td&gt;Código do programador&lt;/td&gt;
&lt;td&gt;Interpretação das instruções&lt;/td&gt;
&lt;td&gt;Código de máquina (seu programa!)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Como podemos ver, podemos abstrair esse lance de &amp;quot;dados de entrada + processamento = dados de saída&amp;quot; com qualquer tipo de programa que usarmos. Basta relacionar o que fazemos (digitar algo, arrastar o mouse, apertar um botão, etc) para obtermos a saída desejada (texto/gráfico na tela, no arquivo, na impressora, etc). O programa é o elemento que fica no meio fazendo essa &amp;quot;mágica&amp;quot;.&lt;/p&gt;
&lt;p&gt;Existem informações intermediárias que precisamos guardar em um programa em execução para que no final consigamos apresentar a saída desejada ao usuário. Essas informações intermediárias também são dados, só que o usuário não os enxerga. A elas chamamos de variáveis. Entenda uma variável como &amp;quot;um lugar na memória onde o programa armazena alguma informação durante o processamento&amp;quot;.&lt;/p&gt;
&lt;p&gt;Toda variável é apenas memória interpretada de uma maneira peculiar. Essa maneira de interpretar a memória é chamada de tipo. Cada variável possui o tipo que lhe convém. Basicamente, existem dois tipos de variáveis: número (ou inteiro) e texto (ou string).&lt;/p&gt;
&lt;p&gt;Imagine um programa sendo executado do começo ao fim. A ordem em que um programa é executado é chamado de fluxo de execução. A tendência natural de um programa é ser executado pelo computador da sua primeira instrução até a última, sempre nessa ordem. Ou seja, linha 1, linha 2, linha 3, ...., linha n. Pronto. Acabou.&lt;/p&gt;
&lt;p&gt;Porém, se fosse sempre assim, isso quer dizer que o programa seria executado sempre do mesmo jeito, e os dados de saída seriam sempre os mesmos, independente dos dados de entrada. Mas isso não acontece, certo? Quer dizer, se você não mirar direito e apertar o botão certo, o inimigo não vai cair no chão. Isso faz um certo sentido, não?&lt;/p&gt;
&lt;p&gt;Seguindo esse raciocínio, podemos deduzir que um programa deve tomar decisões para saber o que fazer. E para tomar essas decisões ele usa o que recebeu como entrada, que são exatamente os dados de entrada. Nesse contexto, tomar decisão significa alterar o fluxo de execução. Ou seja, a ordem não necessariamente será sempre linha 1, linha 2, linha 3, etc, mas poderá ser, por exemplo, linha 1, linha 52, linha 237643, linha 52 de novo, linha 890, e assim por diante.&lt;/p&gt;
&lt;p&gt;Note que existem várias perguntas que o programa precisa responder para seguir em frente. Para respondê-las, o programa pede a ajuda do computador para fazer comparações entre variáveis. E aí está o uso desses dados internos.&lt;/p&gt;
&lt;p&gt;Bem, até aqui você já aprendeu um montão de coisas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Programas podem ser armazenados em arquivos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Quando executados, o computador interpreta suas instruções.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Um programa usa dados de entrada para gerar dados de saída.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Para tomar decisões, ele utiliza variáveis internas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A ordem das instruções é chamado fluxo de execução.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A tomada de decisões altera o fluxo de execução de um programa.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para concluir, vamos dar uma espiada nas estruturas de comparação de um programa em C e suas conseqüentes mudanças de fluxo. Note também que as comparações são feitas com variáveis internas.&lt;/p&gt;
&lt;p&gt;If significa &amp;quot;se&amp;quot;, ou seja, faz uma comparação, e retorna se a comparação é verdadeira (sim!) ou não (não!). Porém, o if apenas faz alguma coisa se o resultado for sim.&lt;/p&gt;
&lt;p&gt;Else significa &amp;quot;senão&amp;quot;, ou seja, é o complemento do if. Lembra-se que o if só faz alguma coisa se o resultado da comparação for sim? Pois bem, o else permite fazer outra coisa se o resultado for não.&lt;/p&gt;
&lt;p&gt;While significa &amp;quot;enquanto&amp;quot;, e é o nosso primeiro exemplo de laço, ou loop. Um loop faz constantemente a mesma coisa enquanto o resultado da comparação for sim. Uma vez que for não (pode ser a primeira, inclusive), ele não faz mais nada e o programa continua seu fluxo natural.&lt;/p&gt;
&lt;p&gt;For significa &amp;quot;por&amp;quot;, com o mesmo sentido que em &amp;quot;ele me chutou por 5 vezes seguidas&amp;quot;. Ele pode ter muitos usos, mas o tradicional é fazer n vezes alguma coisa, sabendo que n é um número de vezes já conhecido. Nesse caso, o loop serve apenas para repetir um determinado número de vezes uma ação, sem nunca variar esse número de vezes.&lt;/p&gt;
&lt;p&gt;Programar não tem segredo. É tudo uma questão de gostar, aprender, executar, aprender, gostar mais, aprender mais, executar mais, etc. Não exatamente nessa ordem. Tudo vai depender dos seus dados de entrada. Mas o fluxo já começou sua execução...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A inteligência do if - parte 1&lt;/li&gt;
&lt;li&gt;A inteligência do if - parte 2&lt;/li&gt;
&lt;li&gt;Arquitetura de von Neumann&lt;/li&gt;
&lt;li&gt;Máquina de Turing&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>A Linguagem de Programação C</title>
  <link>http://www.caloni.com.br/the-c-programming-language/</link>
  <pubDate>2007-10-12</pubDate>
  
  <guid>http://www.caloni.com.br/the-c-programming-language/</guid>
  <description>&lt;p&gt;O clássico de Ritchie e Kernighan, criadores da linguagem C, não foi meu primeiro livro de programação. E nem deveria ser. Não o recomendo para iniciantes, pois é necessário possuir algun conhecimento e prática para realmente aproveitar os conceitos desse livro.&lt;/p&gt;
&lt;p&gt;Então, o que ler antes disso? Existem tantos livros bons para iniciantes (e tantos livros péssimos). Eu comecei com C Completo e Total, de Herbert Schildt. Não me arrependi. O autor vai descrevendo C para quem já tentou fazer algumas coisas, já programou outras e está afim de tirar as principais dúvidas sobre essa linguagem que tantos abominam por ser difícil, e tantos idolatram por ser poderosa. As práticas do livro já são um bom início para quem quer pensar, entender e programar.&lt;/p&gt;
&lt;p&gt;Depois de Schildt, passei a ler os livros da Viviane, os famosíssimos módulos do Treinamento em Linguagem C. São ótimos para a prática e para reafirmar os conceitos lidos no primeiro livro. Para uma linguagem tão importante, uma segunda opinião é sempre bem-vinda.&lt;/p&gt;
&lt;p&gt;Então chegou a hora. Passei algumas das minhas melhores horas na biblioteca lendo como os próprios criadores da linguagem a ensinam, e como o padrão ANSI é definido (em termos bem simplificados, condição perfeita para entender a lógica do compilador). Com o livro é possível perceber claramente que a linguagem é tão simples quanto poderosa, lembrando (quem diria!) o mais abominado ainda assembly.&lt;/p&gt;
&lt;p&gt;Vamos aos capítulos.&lt;/p&gt;
&lt;p&gt;O começo é quase sempre o mesmo. Os autores explicam um programa simples na linguagem, fazem alguns testes e explicam linha a linha o que cada coisa significa. O importante aqui é esquecer que existe um sistema operacional rodando por baixo de nosso programa e entender que a linguagem foi desenhada para independer disso. É tão genérica a ponto de independer dela mesma. Explico: enquanto a maioria das linguagens considera sua biblioteca parte integrante da mesma, a linguagem C faz questão de separar as coisas, reafirmando sempre que uma coisa é o preprocessamento, outra é a compilação, outra é a linkedição e nenhuma delas precisa de uma biblioteca, apesar de uma ter sido definida no padrão (baseada no uso comum da linguagem em diversos ambientes).&lt;/p&gt;
&lt;p&gt;Se você nunca teve contato com C ou deseja ter uma aproximação mais simplificada e quer entender como as coisas mais simples funcionam na linguagem, este capítulo é imperdível.&lt;/p&gt;
&lt;p&gt;Essa é a hora ideal para separar dois conceitos que muitas vezes ficam grudados na mente dos precoces programadores para o resto de suas vidas: uma coisa é um tipo e outra coisa é uma expressão. Uma expressão possui um tipo, que define seu comportamento de acordo com o operador usado. Tudo é explicado muito bem com exemplos bem escritos e que são realmente úteis, como strlen, atoi, strcat (presentes na biblioteca padrão) e até um contador de bits.&lt;/p&gt;
&lt;p&gt;Se quiser entender o que cada fragmento de lógica na linguagem significa por completo (e não apenas uma expressão jogada na correria da programação do dia-a-dia) esse capítulo irá explicar. Depois de entendê-lo, nunca mais vai achar bizarro aqueles problemas de precedência que permeiam código pouco sensato.&lt;/p&gt;
&lt;p&gt;Apenas após ter explicado os conceitos que regem qualquer linha de código operacional em C os autores se dedicam a explanar as diversas formas de controlar o fluxo do seu programa. Nessa hora a linguagem se desdobra, se torna mágica, simples, flexível e poderosa.&lt;/p&gt;
&lt;p&gt;Não basta apenas possuir lógica de programação. Para escrever bons programas é necessário saber como construir os blocos funcionais que irão traduzir seus comandos para o computador. É nesse ponto que é fundamental o domínio de qualquer construção em C, seja um simples if ou uma combinação maluca de switches, whiles e breaks.&lt;/p&gt;
&lt;p&gt;Entendidos os princípios básicos de criação e execução de qualquer programa em C, chegou a hora de explicar como a linguagem suporta a organização de seu código através de funções, módulos e diretivas de preprocessamento. Note que os autores partem do princípio minimalista da linguagem e imagina o que acontece conforme seus programas vão se tornando cada vez maiores. Para isso explicam o mesmo princípio que foi utilizado ao desenhar a linguagem, que até hoje é usada para escrever dezenas de milhares de código em um único projeto, ou até milhões (como em sistemas operacionais).&lt;/p&gt;
&lt;p&gt;No desenvolvimento de software a organização é um dos pilares que irá transformar o programador em um mestre da arquitetura de seu próprio código. Não negligencie a lógica das partes maiores do seu código, só se importando com os pequenos pedaços de blocos dentro de uma função. Antes de ser cientista, seja um desenvolvedor nato.&lt;/p&gt;
&lt;p&gt;A dificuldade com que muitos programadores C têm com essas duas características da linguagem fizeram com que fosse dedicado um capítulo inteiro para explicar e reexplicar como os arrays (vetores) e ponteiros funcionam e qual a relação intrínseca entre eles. É também explicada a relação strings x arrays, já que em C uma string é uma cadeia de caracteres.&lt;/p&gt;
&lt;p&gt;Se você programa em C e até hoje tem dificuldades para entender completamente esse assunto, sugiro que largue o que você está fazendo agora e leia esse capítulo até o final. Será bem mais proveitoso que ficar zanzando no meio de um monte de blogues (como este aqui).&lt;/p&gt;
&lt;p&gt;A estrutura é uma composição complexa em C, mas permite um organização melhor dos dados, da mesma maneira com que as funções organizam melhor o código.&lt;/p&gt;
&lt;p&gt;Aparentemente o tema estrutura é mais simples que ponteiros, e deveria ser tratado antes. Porém, fazer isso impediria abordar o tema de listas ligadas e outras estruturas que dependem do uso de ponteiros para que estruturas referenciem elas mesmas, algo extremamente recorrente no mundo da programação.&lt;/p&gt;
&lt;p&gt;É sempre bom lembrar que o uso de estruturas foi o nascimento do C++, que prima pela elegância na organização e harmonia entre seu código e dados. A linguagem C também não fica para trás, mas é importante saber usar.&lt;/p&gt;
&lt;p&gt;Para finalizar é abordado o tema da interface com o mundo exterior da linguagem. Desde sempre suportando a maneira mais básica, genérica e portátil de qualquer sistema operacional, o console, talvez hoje essa característica seja um tanto menosprezada pelos usuários de ambientes gráficos. Contudo, não deixa de ter seu valor ainda hoje, nem que seja para escrever programas de teste.&lt;/p&gt;
&lt;p&gt;Os adendos são incrivelmente úteis e os utilizo ainda hoje como referência. Cá entre nós, o padrão formal da linguagem é algo chato de se ler, e muitos detalhes são perfeitamente ignoráveis para quem não está desenvolvendo um compilador. Contudo, acredito que a maioria dos bons programadores deveria se preocupar em entender como os compiladores entendem seu código, pois muitos dos erros podem ser facilmente resolvidos através do desenvolvimento de uma certa empatia com a linguagem. É por isso que considero o Apêndice A o mais útil de todos.&lt;/p&gt;
&lt;p&gt;Por outro lado, sempre fui contra a reinvenção da roda. O que quer dizer que sempre fui a favor do pleno conhecimento da biblioteca padrão, pois ela fornece funções das mais usadas no dia-a-dia, e algumas outras que poderão ter sua serventia um dia desses. Mas para isso elas devem ser conhecidas. Isso quer dizer que uma passada de olhos no Apêndice B não faz mal a ninguém.&lt;/p&gt;
&lt;p&gt;O Apêndice C hoje é um pequeno guia dos curiosos para as mudanças que foram infligidas na linguagem quando esta foi padronizada. Como fã incondicional de C, não pude deixar de ler e reler essa parte, já que me dedico também a conhecer os primórdios dessa linguagem. Contudo, é parte opcional para as pessoas práticas (a não ser que você esteja com problemas com código legado do século passado).&lt;/p&gt;
&lt;p&gt;Livros vêm, livros vão, mas apenas os clássicos permanecerão. A Linguagem de Programação C é um clássico, sem sombra de dúvida, e nunca irá perder seu valor para a linguagem. A maioria dos livros usa-o como referência, assim como os livros tão amados da comunidade C++ sempre usam Stroustrup como referência. Portanto, se puder, reserve um tempo para o passado.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Engenharia reversa para principiantes</title>
  <link>http://www.caloni.com.br/engenharia-reversa-para-principiantes/</link>
  <pubDate>2007-10-10</pubDate>
  
  <guid>http://www.caloni.com.br/engenharia-reversa-para-principiantes/</guid>
  <description>&lt;p&gt;Dei uma reformada em minha última palestra sobre engenharia reversa. O tema escolhido foi tentar abranger os níveis de conhecimento que uma pessoa disposta a se dedicar à engenharia reversa de programas deveria ter, desde programação, passando pelo sistema operacional e terminando no uso de ferramentas. Achei interessante abordar esse tipo de conteúdo pelo fato de existirem pessoas que gostariam de começar ou já começaram e não sabem para onde ir.&lt;/p&gt;
&lt;p&gt;Outra coisa que fiquei receoso de colocar (mas coloquei) foi a lista de tarefas para usar o conhecimento aprendido. Pode ser frustrante tentar procurar emprego nessa área aqui no Brasil e não adianta nada aprender e não usar. A engenharia reversa, assim como a área de segurança da informação, para ser efetiva, deve levar em conta como as coisas são feitas, o que quer dizer que fazer vírus e quebrar proteção de software faz parte do aprendizado.&lt;/p&gt;
&lt;p&gt;Se houverem interessados o suficiente poderei ministrar uma palestra online, para ilustrar os slides e tirar dúvidas. Lembrando que isso não inclui as perguntas &amp;quot;como eu quebro o programa X&amp;quot; ou &amp;quot;faz um vírus pra mim&amp;quot;.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 5.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-50/</link>
  <pubDate>2007-10-08</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-50/</guid>
  <description>&lt;p&gt;Em novembro de 1998 (apenas para parceiros Microsoft) é lançada a versão 5.0 do Windows NT, conhecida como Windows 2000. Melhorias significativas foram feitas no acesso à internet, intranet e extranet. Aplicações de gerenciamento se integram fortemente e a grande novidade em termos de estruturação de dados é o Active Directory, uma tecnologia compatível com o conceito de Distributed File System, que viabiliza uma nova forma das empresas organizarem seus dados de maneira mais transparente à rede.&lt;/p&gt;
&lt;p&gt;Vamos aproveitar que a versão NT foi melhorada para dar uma recapitulada geral de como as coisas funcionam internamente no sistema operacional.&lt;/p&gt;
&lt;p&gt;A ilustração abaixo divide os módulos que fazem parte do sistema operacional. É importante sempre ter essa imagem indelével em nossa mente para entender como as coisas funcionam.&lt;/p&gt;
&lt;p&gt;É importante notar que essa distribuição já existia desde a primeira versão do NT, sendo que apenas alguns itens foram adicionados (como o Gerenciador de Plug &amp;amp; Play e o Gerenciador de Energia).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Um outro item importantíssimo que foi movido da versão 3.51 para a 4.0 é a GDI, responsável pelo gráfico. Inicialmente ela estava no modo de usuário, mas a necessidade de aumentar o desempenho do sistema fez com que ela fosse incorporada ao núcleo do sistema.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Agora vamos dissecar as partes interessantes.&lt;/p&gt;
&lt;p&gt;As aplicações que rodam sobre o sistema operacional preferencialmente são feitas para rodar no Windows. Mas não precisa ser assim. A abstração inicial que se fez foi o uso de subsistemas que suportam um ambiente de execução. Essa foi a maneira escolhida pelos projetistas para que existisse compatibilidade com outros sistemas operacionais, como o OS/2 e Posix (um padrão de aplicativo utilizado em ambientes Unix/Linux). A mesma abstração permite que se rodem aplicativos 16 bits em cima do ambiente NT, que é todo feito em 32.&lt;/p&gt;
&lt;p&gt;Os subsistemas são serviços do sistema operacional que fornecem o ambiente de execução adequado para cada tipo de aplicação. Quando o usuário executa um arquivo, o loader do Windows detecta o tipo de aplicação tentando rodar e carrega o subsistema necessário. Dessa forma a execução de aplicativos MS-DOS e Windows 3.11 se torna transparente para o usuário. No entanto, as proteções necessárias (e.g. acesso a interrupções) serão respeitadas.&lt;/p&gt;
&lt;p&gt;Além dos subsistemas que irão fornecer os mecanismos necessários para a execução dos aplicativos dependendo de seu formato, existem aqueles subsistemas que tomam conta de alguns detalhes cruciais para a correta execução das tarefas do sistema operacional. Entre eles o mais importante é a parte de segurança, responsável por realizar o login dos usuários.&lt;/p&gt;
&lt;p&gt;Isso basicamente é o conjunto de funções que estão disponíveis no modo de usuário para realizar operações mais complexas no núcleo do sistema, como leitura/escrita em arquivo, criação de threads, chamada direta de um driver, etc. Mais basicamente ainda, se trata de um vetor de ponteiros de funções que são chamadas em kernel mode quando o modo de usuário chama uma interrupção ou comando em assembly específico para realizar uma chamada de sistema.&lt;/p&gt;
&lt;p&gt;É um componente muito usado toda hora no sistema, pois ele trata de chamadas de leitura/escrita em qualquer dispositivo, seja um arquivo, uma porta serial ou uma placa de vídeo. Como conceitualmente as requisições do sistema operacional foram organizadas como operações de entrada e saída, o I/O Manager é essencial para a maioria das operações com dispositivos, sejam físicos, lógicos ou virtuais.&lt;/p&gt;
&lt;p&gt;A memória virtual é parte integrante e indispensável para o desempenho e normal funcionamento do sistema operacional. Entre suas responsabilidades estão a necessidade de dividir a memória entre os diferentes processos de acordo com o uso e protegê-la contra leituras, escritas e execuções não autorizadas.&lt;/p&gt;
&lt;p&gt;Parte integrante do Gerenciador de Memória, embora freqüentemente visto como um módulo separado por sua lógica, o Gerenciador de Cachê (Cache Manager) se concentra mais em estabelecer as diretizes usadas para paginar partes da memória para o disco e tornar a carregá-las na memória principal (RAM).&lt;/p&gt;
&lt;p&gt;Possuem funções mais periféricas, mas não menos importantes. O Gerenciador de Processos cria novos processos e mantém a relação entre eles. O Gerenciador de PnP (Plug and Play), novo no Windows 2000, de um modo geral gerencia a adição e remoção de dispositivos que são plugáveis enquanto a máquina está ligada. O Gerenciador de Energia, também novo, teve sua importância aumentada com o advindo do uso massivo de laptops. É ele que controla coisas como a hibernação do sistema operacional.&lt;/p&gt;
&lt;p&gt;O Gerenciador de Objetos também é parte central e obrigatória do sistema operacional, pois ele gerencia todos os recursos disponíveis tanto em kernel quanto em user mode (espelhado pelo kernel). No Windows, qualquer recurso é representado por um objeto, seja um arquivo, uma thread, um processo, um evento, uma interrupção, etc. Sendo que tudo é representado como um objeto, esse módulo foi especialmente criado para gerenciar todos os recursos de uma vez. Dessa forma tipos de controle global, como o controle de acesso, pôde ser centralizado em apenas um lugar no código, assim como o gerenciamento de handles, que são manipuladores de recursos que existem em modo de usuário.&lt;/p&gt;
&lt;p&gt;O microkernel pode ser entendido como a parte que faz coisas muito básicas em um sistema operacional. Tão básicas quanto executar as threads, gerenciar interrupções e abstrair pequenas diferenças entre arquiteturas.&lt;/p&gt;
&lt;p&gt;Faz par com o microkernel, e pode ser escrito pela Microsoft ou por fabricantes de dispositivos. São eles os responsáveis por controlar o hardware que está atrás do sistema, como o disco, a porta serial, a rede, a placa de vídeo, a própria CPU, etc. Muitos podem ser lógicos, como os filtros e os drivers de sistema de arquivos e, acredite se quiser, costumam ser mais complexos que os que controlam diretamente o hardware.&lt;/p&gt;
&lt;p&gt;A HAL é totalmente dependente de plataforma. Por causa disso, ela é totalmente isolada do resto do sistema operacional, tornando a portabilidade mais fácil de ser suportada. Em alguns casos a HAL é implementada como um conjunto de macros, o que quer dizer que você terá que recompilar seus drivers para mudar de plataforma (x86 para x64, por exemplo). Além disso, existe um conjunto de DLLs compiladas para cada plataforma, que é renomeada (para hal.dll) e copiada durante a instalação. Isso explica porque em algumas situações se você copia a instalação do Windows de uma máquina para outra com diferenças relevantes de arquitetura pode ser que as coisas não saiam exatamente como você esperava.&lt;/p&gt;
&lt;p&gt;A não ser que estejamos falando do Xbox, o hardware é feito por terceiros, como a Intel, a AMD e a NVIDIA, e é onde você instala o seu sistema operacional do coração para rodar seus aplicativos do coração. O bom de um sistema operacional do coração é que você não percebe sua existência quando está rodando seu jogo do coração. Pelo menos não deveria.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Outros artigos sobre a história do windows&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Debug da BIOS com o SoftIce 16 bits</title>
  <link>http://www.caloni.com.br/debug-da-bios-com-o-softice-16-bits/</link>
  <pubDate>2007-10-02</pubDate>
  
  <guid>http://www.caloni.com.br/debug-da-bios-com-o-softice-16-bits/</guid>
  <description>&lt;p&gt;Para quem ainda acha que não desceu demais o nível, existe um ótimo artigo de ShalomZ, do Code Project, sobre como construir seu próprio sistema operacional. É simples, direta e empolgante a maneira com que ele explica e trata os detalhes básicos, desde quando o computador é ligado até quando o boot loader carrega e entrega o controle de execução. Eu mesmo fiz o teste com a imagem que foi disponibilizada para download e funcionou direitinho. Agora esse meu artigo se dispõe a explicar como você pode fazer para depurar o processo de load do seu primeiro sistema operacional.&lt;/p&gt;
&lt;p&gt;Primeiro, precisamos de uma ferramenta fundamental para esse tipo de depuração: o SoftIce versão 16 bits. Desconheço algum outro depurador de sistema em 16 bits, mas se você souber de algum, pode usá-lo com esse tutorial com as devidas adaptações.&lt;/p&gt;
&lt;p&gt;Passado o desafio inicial de encontrar essa versão do SoftIce e saber usá-la, o resto é fácil:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Crie uma nova VMWare, Virtual PC, VMSbrubles configurada para bootar pelo disquete.&lt;/li&gt;
&lt;li&gt;Formate dois disquetes de MS-DOS, FreeDos, Sbrubles-DOS.&lt;/li&gt;
&lt;li&gt;Copie o setor de &lt;em&gt;boot&lt;/em&gt; disponível no artigo do CP para o disquete usando o programa disponível em um dos disquetes.&lt;/li&gt;
&lt;li&gt;Copie o SoftIce no outro disquete.&lt;/li&gt;
&lt;li&gt;Efetue o &lt;em&gt;boot&lt;/em&gt; com o disquete do SoftIce.&lt;/li&gt;
&lt;li&gt;Execute o SoftIce (é só rodar, ele permanece residente e é ativado com Ctrl + D).&lt;/li&gt;
&lt;li&gt;Coloque um &lt;em&gt;breakpoint&lt;/em&gt; na int 0x13 (disco) na função 2 (leitura) (faz-se assim: bpint 13 ah=2).&lt;/li&gt;
&lt;li&gt;Troque o disquete do Softice pelo disquete com o setor de &lt;em&gt;boot&lt;/em&gt; do artigo do CP.&lt;/li&gt;
&lt;li&gt;Efetue novamente o &lt;em&gt;boot&lt;/em&gt; na máquina em modo &amp;quot;quente&amp;quot; (usando o próprio SoftIce, comando boot).&lt;/li&gt;
&lt;li&gt;A execução deve ser paralisada exatamente no ponto onde o código da BIOS lê o setor de boot do seu disquete.&lt;/li&gt;
&lt;li&gt;Digite p ret e em seguida F10 ou T e seja feliz.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Pelo softice 16 bits conseguimos parar a execução nas interrupções da BIOS e ainda especificar qual das funções será executada, definida no registrador AH (mais detalhes sobre layout de memória do 8086 no artigo do DQ).&lt;/p&gt;
&lt;p&gt;Quando o código da BIOS é executado, ele precisa, entre outras coisas, fazer três:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Encontrar o dispositivo padrão de &lt;em&gt;boot.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Ler o primeiro setor desse dispositivo para o endereço 0x7C00.&lt;/li&gt;
&lt;li&gt;Entregar a execução para o código em 0x7C00.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;O item 2 é justamente o que utiliza essa interrupção para ler do disco. Eu prefiri colocar o breakpoint no item 2, mas nada impediria de você colocá-lo no item 3 e já iniciar a depuração no código do boot loader. Mas, como eu já passei por problemas encontrados no código da BIOS que impediam o sistema de entregar a execução para o setor de boot, já dei a dica de lambuja caso você também tenha a oportunidade de se divertir em um cliente depurando a BIOS de algum laptop desajustado.&lt;/p&gt;
&lt;p&gt;Pela imagem acima sabemos que após o boot foi executada a interrupção 0x13, função 2 e que se trata de leitura em disquete, pois o conteúdo do registrador DL está em 0 (veja a referência das interrupções da BIOS em Ralf Brown&#39;s Interrupt List).&lt;/p&gt;
&lt;p&gt;É mais ou menos o step out do SoftIce 32. Ou seja, ele avança a execução até a função retornar. No caso do SoftIce 16, ele irá avançar até o próximo ret/iret. Por isso que também precisamos executar a próxima instrução (o próprio ret) para cair onde queremos. É nesse ponto que o &amp;quot;nosso&amp;quot; código começa a executar e onde conseguimos colocar breakpoints &amp;quot;de verdade&amp;quot; (lembre-se que o código da BIOS está em uma memória de somente leitura, pelo menos durante a execução).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Building your own operating system - ShalomZ&lt;/li&gt;
&lt;li&gt;Ralf Brown&#39;s Interrupt List&lt;/li&gt;
&lt;li&gt;Gerenciamento de memória 386 - Daniel Quadros&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Introdução ao C&#43;&#43; Builder...Turbo C&#43;&#43;</title>
  <link>http://www.caloni.com.br/introducao-ao-c-builderturbo-c/</link>
  <pubDate>2007-09-26</pubDate>
  
  <guid>http://www.caloni.com.br/introducao-ao-c-builderturbo-c/</guid>
  <description>&lt;p&gt;Após mais de um ano de tentativas, finalmente consegui instalar e iniciar com sucesso o Borland Developer Studio. Esse foi o nome pomposo dado pela Borland para a &amp;quot;continuação&amp;quot; do velho C++ Builder e seus parentes, o Delphi e o C# Builder.&lt;/p&gt;
&lt;p&gt;Existem muitas coisas novas ainda para ver, mas não é a usabilidade. Assim como a IDE antiga, é fácil de sair mexendo e fazendo janelas, no bom estilo WYSIWYG dos produtos da Borland.&lt;/p&gt;
&lt;p&gt;Para quem começa a desenvolver aplicativos com interface para Windows, deve saber que uma das coisas mais produtivas que já inventaram foi o Visual Basic. De fato, o VB permite que virtualmente qualquer pessoa com conhecimentos mínimos de informática torne-se um gabaritado programador de telinhas.&lt;/p&gt;
&lt;p&gt;Porém, com o tempo você percebe que cada ferramenta tem suas vantagens e desvantagens. Uma desvantagem do VB era a falta de flexibilidade. Outra era que a linguagem usada não favorecia muito aqueles que se aventuravam chamando a Win32 API diretamente dos seus programas. Era possível, sim, mas enfadonho e nem sempre as coisas funcionavam como o esperado.&lt;/p&gt;
&lt;p&gt;Para as pessoas que chegam nesse nível de necessidade, existem basicamente duas escolhas:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Permanecer no mundo Microsoft e usar MFC + Win32 API, passando a programar na linguagem em que foi feito o Windows (C/C++).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tentar usar o Delphi, a evolução do Turbo Pascal para Windows, da Borland, que pode ser considerado mais flexível que o VB, mas ainda assim usa uma linguagem alienígena (no sentido de que ainda não é a linguagem nativa do SO).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mudar de sistema operacional e esquecer esse negócio de &lt;em&gt;loop&lt;/em&gt; de mensagens (eu disse duas escolhas, certo?)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Bom, eis que surge o C++ Builder: uma ferramenta idêntica ao Delphi, contudo que oferece a linguagem C++ para que todas aquelas pessoas recém-saídas da faculdade e ansiosas por entrar no mercado de trabalho esqueçam aquele papo de Pascal e passem a usar a linguagem da indústria. Pelo jeito, era mais ou menos essa a visão da Borland quando lançaram o produto.&lt;/p&gt;
&lt;p&gt;Desde o princípio, o C++ Builder foi lançado em revistas de informática em versões para estudantes, o que estimulava as pessoas financeiramente menos capacitadas (estudantes, como eu) a cada vez mais utilizar essa ferramenta de programação para desenvolver aplicativos Windows, já que, além de não ser pago como o Visual Basic e o Visual C++, não era nem tão limitado quando o primeiro nem tão complicado quanto o segundo. E estava sempre entre os programas completos para serem testados na revista que acabou de chegar na banca. Nossa, como era divertido programar por prazer!&lt;/p&gt;
&lt;p&gt;O mais impressionante no Builder era que desde o começo, na versão 1, já tínhamos aquela palheta maravilhosa cheio de todos os controles que já faziam parte do Windows 95. Tudo isso por causa de uma estratégia simples e eficaz: os componentes são os mesmos do Delphi. O que o C++ Builder adicionou foi uma camada de interface para que C++ e Object Pascal conversassem. O resultado disso é espantoso: é possível programar em C++ puro, chamar APIs diretamente, e ainda usar os componentes em Delphi, além de também poder desenvolver em Delphi e mesclar ambas as linguagens em um projeto. É possível até usar herança entre componentes escritos em Delphi e C++ Builder.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Quando entrei na Scua comecei a trabalhar profissionalmente com o C++ Builder, ao desenvolver o aplicativo de administração do software de controle de acesso. Na época não tínhamos muito tempo para perder desenvolvendo tudo em Win32 API ou usar algo mais rústico como a MFC, que é mais parecido com a finada biblioteca OWL do que com a VCL (a biblioteca visual de componentes usada pela Borland para Delphi e Builder). E não, usar Visual Basic não era uma alternativa. Como a produtividade estava em jogo, hoje tenho certeza que fizemos uma boa escolha.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Eu gostava do C++ Builder antigo: sem frescura de registrar componentes e sem necessidade de instalação. Até hoje uso a versão 1.0 para brincar de vez em quando, pois é relativamente pequena; apenas copio para uma pasta e ainda funciona muito bem.&lt;/p&gt;
&lt;p&gt;Mas desde que o mundo gerenciado veio à tona, para instalar esse singelo produto da Borland você vai precisar de alguns pré-requisitos da Microsoft:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Microsoft .NET Framework SDK 1.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Visual J# .NET Redistributable Package 1.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Microsoft XML 4.0 SP2 Parser and SDK&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Se for necessária mais alguma instalação, não se preocupe: o Borland Turbo C++ Instalation Wizard irá te avisar no momento da instalação, que deverá ser a última a ser realizada.&lt;/p&gt;
&lt;p&gt;Após tudo isso instalado, finalmente conseguiremos rodar nossa ferramenta RAD. Aliás, antes que eu me esqueça, RAD é uma abreviação para Rapid Application Development.&lt;/p&gt;
&lt;p&gt;Se você nunca usou essa ferramenta, ao abrir o ambiente, irá se deparar com vários elementos que precisam ser nomeados e explicados para fazer algum sentido. Mesmo que muitas coisas sejam novas, algumas devem estar sempre gravadas em sua memória:&lt;/p&gt;
&lt;p&gt;Sempre que você clicar em algum componente gráfico para ser editado - como uma janela, um botão, uma lista - o Object Inspector será o lugar para editá-lo. Ele está dividido em propriedades e eventos. Propriedades são as características gráficas e comportamentais do componente que está sendo editado. Eventos especificam métodos para tratar as ações recebidas de algum componente (ex: clique de um botão).&lt;/p&gt;
&lt;p&gt;A palheta é onde estão todos os componentes que podem ser usados no momento para a edição do programa. Existe uma infinidade deles, tais como: botões, menus, caixas de seleção, listas de itens, barras de rolagem, listas de ações, imagens, rótulos, grupos de botões, e assim vai a valsa. Para usá-los, basta arrastar para uma janela e editar suas propriedades.&lt;/p&gt;
&lt;p&gt;Onde estão todos os meus arquivos? O Gerenciador de Projetos está aí para ajudá-lo. Todas as units (unidades de código) e forms (janelas) que você criar no projeto estará visível para fácil acesso. É muito importante saber organizar um projeto, pois conforme se avança, ele tende a se tornar maior e mais complexo. Junto do Gerenciador de Projetos existe o seu ajudante, o Structure. Na visão de design,  o Structure irá mostrar os controles inseridos nas janelas; na visão de unit, o Structure irá mostrar os includes, macros, classes e funções do código-fonte exibido no momento.&lt;/p&gt;
&lt;p&gt;Considerando que o Bloco de Notas é minha vítima preferida para testes (e a vítima preferida de outros, também), nada melhor que nosso projeto seja um Bloco de Notas simplificado, que leia, exiba e salve arquivo-texto. Para esse projeto iremos utilizar apenas 5 componentes e cerca de 10 linhas de código:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2 botões (abrir e salvar arquivo),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 &lt;em&gt;memo&lt;/em&gt; (para exibir o arquivo aberto),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2 caixas de diálogo comum (abrir e salvar arquivo).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Why is my DLL locked?</title>
  <link>http://www.caloni.com.br/why-is-my-dll-locked/</link>
  <pubDate>2007-09-24</pubDate>
  
  <guid>http://www.caloni.com.br/why-is-my-dll-locked/</guid>
  <description>&lt;p&gt;There is a document from Microsoft alerting about the hazards in putting your code inside a DllMain function. what is more comprehensive and easier to read than the MSDN observations. It is worth reading, even because the explanations about the loader lock and its side effects can do very good for your code health.&lt;/p&gt;
&lt;p&gt;In short, the Windows code responsible to call DllMain for each loaded/unloaded DLLs uses an exclusive access object (the so-called &amp;quot;mutex&amp;quot;) to synchronize its calls. The result is that inside a process just one DllMain can be called at a given moment. This object-mutex is called &amp;quot;loader lock&amp;quot; into the Microsoft documentation.&lt;/p&gt;
&lt;p&gt;The code below is silly, but represents quite well what I&#39;ve seen in lots of production code. For many times I was unable to realize what was going on (whether because I didn&#39;t know about the loader lock or the code readability was too bad). The comments say by themselves:&lt;/p&gt;
&lt;p&gt;A simple victim of all this can be an executable using a poorly written DLL, just like the code above:&lt;/p&gt;
&lt;p&gt;In order to the see the locking code in action, copy the DLL and EXE source files and use the following commands to generate the executable files:&lt;/p&gt;
&lt;p&gt;It is important to remember that a DllMain dependant code is a very, very bad thing. Nevertheless, there are some particular cases the only place to run our code is inside DllMain. In these cases, when detected, try to run a side by side communication with your locked thread using an event object (or equivalent) before it really returns. Using this craft the thread can warn the waiting thread that the important thing to be done is done, and the waiting thread can go to sleep and stop waiting forever locked threads.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NT Loader (MSJ Sep 99) - Matt Pietrek&lt;/li&gt;
&lt;li&gt;mgrier&#39;s WebLog - NT Loader team participant&lt;/li&gt;
&lt;/ol&gt;
</description>
</item>

     
        <item>
  <title>A mobilidade das variáveis no printf</title>
  <link>http://www.caloni.com.br/a-mobilidade-das-variaveis-no-printf/</link>
  <pubDate>2007-09-20</pubDate>
  
  <guid>http://www.caloni.com.br/a-mobilidade-das-variaveis-no-printf/</guid>
  <description>&lt;p&gt;O printf (e derivados) tem sérios problemas por conta de sua falta de tipagem. Não vou aqui dizer que cout é a alternativa óbvia e melhorada porque não é. Mas isso é uma discussão que eu não deveria começar aqui. E não começarei. Portanto, ignorem essa linha =).&lt;/p&gt;
&lt;p&gt;O mais comum de todos é a passagem de tipo na string de formatação diferente da variável passada:&lt;/p&gt;
&lt;p&gt;Isso costuma ser mais comum quando existem centenas de milhares de parâmetros na chamada, o que confunde o programador (e o leitor de certos blogues especializados em confundir):&lt;/p&gt;
&lt;p&gt;O segundo que me lembro que costuma dar muitos problemas é a passagem de tipo inteiro de tamanho diferente:&lt;/p&gt;
&lt;p&gt;É mais sutil, também costuma confundir no meio de vários parâmetros, e pode ser detectado utilizando a técnica de transformar tudo em assembly, pois com isso temos dica de tipagem ao empilhar os argumentos na saída do arquivo asm.&lt;/p&gt;
&lt;p&gt;É claro que hoje em dia existem compiladores muito espertos, que detectam na hora o que você está digitando e a cagada que isso vai dar depois de compilado. Mas, assumindo que você não tem toda essa tecnologia ao seu dispor, ou está mesmo interessado em entender como as coisas funcionam, e não apenas seguir o manual do seu ambiente de desenvolvimento preferido, essa é uma maneira interessante de analisar o que ocorre com o seu código. Agora, a pergunta que não quer calar: por que isso acontece?&lt;/p&gt;
&lt;p&gt;Conforme o printf interpreta a string de formatação, ele vai &amp;quot;comendo&amp;quot; (no bom sentido) os argumentos passados na pilha. Se a string informa que existe um int de 32 bits, mas na verdade existe um de 64, ele vai comer apenas 32 bits da pilha, deixando os próximos 32 para o desastre iminente. Como os próximos 32 bits de nosso int64 estão zerados, faz sentido o printf imprimir (null) no lugar da string, pois este é o comportamento padrão da função quando o ponteiro é nulo. Agora, se tivéssemos um int realmente grande - vulgo &amp;quot;intão&amp;quot; - daí as coisas seriam diferentes:&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Hook de COM no WinDbg</title>
  <link>http://www.caloni.com.br/hook-de-com-no-windbg/</link>
  <pubDate>2007-09-18</pubDate>
  
  <guid>http://www.caloni.com.br/hook-de-com-no-windbg/</guid>
  <description>&lt;p&gt;Continuando com o tema hooks no WinDbg, vamos aqui &amp;quot;hookear&amp;quot; e analisar as chamadas de métodos de um objeto COM. O que será feito aqui é o mesmo experimento feito para uma palestra de engenharia reversa que apresentei há um tempo atrás [1], mas com as opções de pause, rewind, replay e câmera lenta habilitadas.&lt;/p&gt;
&lt;p&gt;Antes de começar, se você não sabe nada sobre COM, não deveria estar aqui, mas aqui, aqui e aqui.&lt;/p&gt;
&lt;p&gt;Pra começar, vamos dar uma olhada na representação da interface IUnknown em UML e em memória:&lt;/p&gt;
&lt;p&gt;Como podemos ver, para implementar o polimorfismo, os endereços das funções virtuais de uma classe são colocados em uma tabela, a chamada vtable, famosa tanto no COM quanto no C++. Existe uma tabela para cada classe-base polimórfica, e não para cada objeto. Se fosse para cada objeto não faria sentido deixar esses endereços &amp;quot;do lado de fora&amp;quot; do leiaute. E não seria nada simples e elegante fazer uma cópia desse objeto.&lt;/p&gt;
&lt;p&gt;Assim, quando você chama uma função virtual de um objeto, o código em assembly irá chamar o endereço que estiver na posição correspondente ao método chamado dentro da vtable. Se você chama AddRef, por exemplo, que é o segundo método na tabela, será chamado o endereço da posição número dois. Com isso, mesmo desconhecendo de que tipo é o objeto a função certa será chamada, porque existe um ponteiro para essa tabela no início da interface.&lt;/p&gt;
&lt;p&gt;Sabendo de tudo isso, agora sabemos como teoricamente proceder para colocar uns breakpoints nessas chamadas:&lt;/p&gt;
&lt;p&gt;Note que o breakpoint não é colocado dentro da tabela, o que seria absurdo. Uma tabela são dados e dados geralmente não são executados (eu disse geralmente). Porém, usamos a tabela para saber onde está o começo da função para daí colocar a parada nesse endereço, que por fazer parte do código da função é (quem diria!) executado.&lt;/p&gt;
&lt;p&gt;Agora vamos sair da teoria e tentar fazer as coisas mais ou menos parecidas na prática.&lt;/p&gt;
&lt;p&gt;O nosso sorteado desse artigo foi o IMalloc, a interface de alocação de memória do COM, que existe desde a época em que não se sabia direito pra que esse tal de COM iria servir. O IMalloc é definido como se segue:&lt;/p&gt;
&lt;p&gt;Nesse experimento, como iremos interceptar quando alguém aloca ou desaloca memória, nossos alvos são os métodos Alloc e Free. Para saber onde eles estão na tabela, é só contar, começando pelos métodos do IUnknown, que é de quem o IMalloc deriva. Se houvessem mais derivações teríamos que contar da primeira interface até a última. Portanto: QueryInterface um, AddRef dois, Release três, Alloc quatro, Realloc cinco, Free seis. OK. Contar foi a parte mais fácil.&lt;/p&gt;
&lt;p&gt;Agora iremos precisar interceptar primeiro a função que irá retornar essa interface, pois do contrário não saberemos onde fica a vtable. Nesse caso, a função é a ole32!CoGetMalloc. Muitas vezes você irá usar a ole32!CoCreateInstance(Ex) ou a CoGetClassObject diretamente na DLL que pretende interceptar. Outras vezes, você receberá o ponteiro em alguma ocasião diversa. O importante é conseguir o ponteiro de alguma forma.&lt;/p&gt;
&lt;p&gt;Nesse exemplo iremos obter o ponteiro através de um aplicativo de teste trivial, ignorando todas aquelas proteções antidebugging que podem estar presentes no momento da reversa, feitos por alguém que lê meu blog (quanta pretensão!):&lt;/p&gt;
&lt;p&gt;Vamos fazer de conta que é desnecessário dizer como se compila o fonte acima.&lt;/p&gt;
&lt;p&gt;WinDbg. Na opção &amp;quot;File, Open Executable&amp;quot; selecionamos a nossa vítima, cujo nome você escolhe na hora de compilar o fonte acima. Aqui, ele irá chamar imalloc-hook.exe. A seguir, colocamos um breakpoint na função da ole32, mandamos rodar, e esperamos a parada do código:&lt;/p&gt;
&lt;p&gt;Maravilha. Alguém chamou a função que queríamos (quem será?). Agora podemos dar uma olhada na pilha e no protótipo da CoGetMalloc:&lt;/p&gt;
&lt;p&gt;Como podemos ver nos parâmetros da pilha, o nosso chamador passou certinho o valor 1 no campo reservado e um ponteiro no segundo parâmetro para uma área onde, se der tudo certo, será escrito o endereço de um IMalloc, que podemos chamar carinhosamente de this. De início vemos que a variável está zerada. Agora vamos executar a função até a saída e examinar os resultados.&lt;/p&gt;
&lt;p&gt;E não é que tudo deu certo? A variável foi preenchida, e partir dela demos uma espiadela nos endereços das funções da vtable. Nós pegamos o valor da variável que foi preenchida (o endereço da interface) e obtemos os seus primeiros 4 bytes (o endereço da vtable) e listamos o seu conteúdo (a própria vtable!). Agora basta usarmos o resultados de nossas contagens lá em cima e colocarmos os breakpoints nas funções corretas. E mandar rodar. E analisar os resultados.&lt;/p&gt;
&lt;p&gt;Note que a função pode eventualmente ser chamada internamente (pelo próprio objeto) ou até por outro objeto que não estamos interessados em interceptar (lembre-se que os métodos de uma classe são compartilhados por todos os objetos). Por isso é importante sempre dar uma olhada no primeiro parâmetro, que é o this que obtemos primeiramente.&lt;/p&gt;
&lt;p&gt;Com isso termina o nosso pequeno experimento de como é possível interceptar chamadas COM simplesmente contando e usando o WinDbg. OK, talvez um pouquinho a mais, mas nada de quebrar a cabeça.&lt;/p&gt;
&lt;p&gt;Para saber mais: Engenharia Reversa para Principiantes.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Aquisição de recurso é inicialização</title>
  <link>http://www.caloni.com.br/aquisicao-de-recurso-e-inicializacao/</link>
  <pubDate>2007-09-14</pubDate>
  
  <guid>http://www.caloni.com.br/aquisicao-de-recurso-e-inicializacao/</guid>
  <description>&lt;p&gt;O título desse artigo é uma técnica presente no paradigma da programação em C++, razão pela qual não temos o operador finally. A idéia por trás dessa técnica é conseguirmos usar recursos representados por objetos locais de maneira que ao final da função esses objetos sejam destruídos e, junto com eles, os recursos que foram alocados. Podemos chamar de recursos aquele arquivo que necessita ser aberto para escrita, o bitmap que é exibido na tela, o ponteiro de uma interface COM, etc. O nosso exemplo é sobre arquivos:&lt;/p&gt;
&lt;p&gt;Ignorei tratamento de erros e a dor de cabeça que é a discussão sobre inicializações dentro do construtor, matéria para um outro artigo. Fora os detalhes, o que temos é: 1. uma classe que se preocupa em alocar os recursos que necessita e no seu fim desalocá-los, 2. uma função que usa um objeto dessa classe, alegremente apenas preocupada em usar e abusar do objeto. A demonstração da técnica reside no fato que a função não se preocupa em desalocar os recursos alocados pelo objeto config. Algo óbvio, desejável e esperado.&lt;/p&gt;
&lt;p&gt;Para vislumbrarmos melhor a utilidade dessa técnica convém lidarmos com as famigeradas exceções. A possibilidade de nossa função ou alguma função chamada por essa lançar uma exceção enquanto nosso objeto está ainda construído - e com o recurso alocado - faz com que seja vital a classe do objeto ter sido bem construída a ponto de prever essa situação e liberar os recursos no destrutor. Daí o uso da técnica se torna necessário.&lt;/p&gt;
&lt;p&gt;Por outro lado, ao usarmos objetos, devemos ter plena confiança nas suas capacidades de gerenciar os recursos que foram por eles alocados. Só assim se tem liberdade o suficiente para nos concentrarmos no código da função e solenemente ignorarmos a implementação da classe que estamos utilizando. Afinal, temos que considerar que muitas vezes o código-fonte não está disponível. Veja a mesma função com uma chance de desvio incondicional (o lançamento de uma exceção):&lt;/p&gt;
&lt;p&gt;Nesse exemplo tudo funciona, certo? Até se a exceção for lançada, o recurso será desalocado, pois o objeto é destruído. Isso ilustra como várias técnicas de C++ podem conviver harmoniosamente. Mais que isso, se ajudam mutuamente. O que seria das exceções se não existissem os construtores e destrutores? Da mesma forma, os recursos são alocados e desalocados baseado na premissa de construção e destruição de objetos. Por sua vez, essa premissa vale em qualquer situação, existindo ou não exceções.&lt;/p&gt;
&lt;p&gt;Agora, e se a exceção de BlowUpFunction é lançada e a classe File não está preparada para fechar o arquivo no destrutor? Esse é o caso da versão 2 de nossa classe File, logo abaixo. Apesar de ser a segunda versão ela foi piorada (acontece nas melhores famílias e classes):&lt;/p&gt;
&lt;p&gt;Nesse caso o código de UseFile2 acaba deixando um recurso alocado por conta de uma exceção que ocorreu em uma função secundária chamada lá pelas tantas em um momento delicado demais para ocorrerem exceções. Note que o destrutor de File2 é chamado assim como o de File, só que este não libera os recursos do objeto. Ele não usa a técnica RAII (Resource Acquisition Is Initialization, ou o título do artigo em inglês).&lt;/p&gt;
&lt;p&gt;Nesse tipo de classe o convívio com exceções gera um dilema: onde está o erro? Como consertá-lo? Se o problema é encontrado numa hora apertada e temos cinco minutos para revolver isso, capturar a exceção causada por BlowUpFunction é uma boa idéia. Só que nem sempre as soluções de cinco minutos são as mais maduras. Podemos não saber muito bem o que fazer com esse tipo de exceção, por exemplo. Isso geraria um tratamento de erro ou redundante - se tratarmos ali mesmo o Scatadush, já tratado em um escopo mais externo - ou fragmentado - se apenas desalocarmos o recurso de File2 e relançarmos a exceção. Eu nem diria fragmentado, pois estamos tratando um erro inventado, se considerarmos que é função dos objetos desalocarem os recursos que foram por eles mesmos alocados.&lt;/p&gt;
&lt;p&gt;A opção que dura mais de cinco minutos pode evitar futuras dores de cabeça: arregaçar as mangas e refazer a classe File2 observando o princípio de RAII. Possivelmente algo na interface deverá ser alterado, o que causará a alteração de mais códigos-fonte que utilizam essa classe. Alterar mais códigos-fonte significa testar novamente mais partes do software, algumas nem de perto relacionadas com o problema em si. Ou seja, não é cômodo, mas é íntegro. Sabendo que futuras funções que usarem essa classe já estarão corretas, mesmo que uma exceção seja lançada e não seja capturada, é um dado significativo: representa produtividade futura.&lt;/p&gt;
&lt;p&gt;A decisão sobre qual solução é a melhor está muito além do escopo desse artigo, pois obviamente cada caso é um caso. Mas não custa nada pensar um pouco sobre C++ quando se estiver programando. E &amp;quot;aquisição de recurso é inicialização&amp;quot; faz parte do modo de pensar dessa linguagem.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Guia básico de controle de código (Source Safe)</title>
  <link>http://www.caloni.com.br/guia-basico-de-controle-de-codigo-source-safe/</link>
  <pubDate>2007-09-12</pubDate>
  
  <guid>http://www.caloni.com.br/guia-basico-de-controle-de-codigo-source-safe/</guid>
  <description>&lt;p&gt;O primeiro passo para se passar no Teste do Joel é possuir algum tipo de controle de código. E ele está mais do que certo. Não existe nada mais frustrante do que não ter exatamente o código-fonte da versão que está rodando no cliente ou não saber o que mudou desde que a versão foi entregue. Esse tipo de coisa pode acabar com uma empresa ou fazer com que ela fique muito mal vista no mercado.&lt;/p&gt;
&lt;p&gt;Porém, independente do mercado, existe um bom motivo para o desenvolvedor possuir algum tipo de controle de código: controle. Se você ou sua equipe não conseguem corrigir todos os bugs, pelo menos saberão o que já foi feito. Se você achou um bug que não existia antes da versão 10, o histórico das mudanças entre a versão estável 9 e a versão não-tão-estável 10 vai te dar uma pista muito boa de onde o problema pode ter sido gerado. Visto dessa forma, não importa muito o tamanho da equipe ou da organização. O importante de um bom código é que suas mudanças estejam sempre registradas, visíveis e disponíveis a qualquer um.&lt;/p&gt;
&lt;p&gt;Um controle de código para uma pessoa só não precisa ser nada muito sofisticado, sendo que um amontoado de ZIPs pode dar conta do recado. Porém, a partir do momento em que o número de desenvolvedores aumenta para dois ou mais, aí o controle baseado em ZIPs começa a ruir, e é necessário usar uma ferramenta mais apropriada. Existem algumas opções, que vai do gosto e necessidades de cada um:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Visual Source Safe ou VSS: não é gratuito nem robusto o suficiente para agüentar toneladas de código-fonte, mas vem junto do Visual Studio e pode ser apropriado para empresas de porte pequeno ou médio (e empresas de um programador só).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Concurrent Version System ou CVS: é um sistema fonte aberto, gratuito e robusto. Suficiente para agüentar toneladas de código-fonte e equipes de vários andares. Atualmente está sendo substituído gradualmente pelo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Subversion ou SVN: é um substituto moderno do antigo CVS; igualmente gratuito e poderoso, está rapidamente se tornando a opção predominante.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vou explicar aqui os principais passos para começar a utilizar um controle de código usando como exemplo o Source Safe versão 2005 que, apesar de não ser gratuito, é muito usado em empresas que programam para Windows e já utilizam o Visual Studio há muito tempo.&lt;/p&gt;
&lt;p&gt;Antes de qualquer coisa é necessário criar uma base de dados onde estarão os fontes. Para isso a primeira execução do programa irá exibir um assistente que irá guiá-lo pelos poucos e simples passos para a criação de uma nova base.&lt;/p&gt;
&lt;p&gt;O processo é bem simples, baseado em Next, Next, até que você chega em momento de decisão, onde deve escolher qual dos dois métodos de controle de fonte irá utilizar:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Lock-Modify-Unlock Model. O modelo clássico do Source Safe, permite que apenas um programador altere um fonte de cada vez. Se você é novo nesse negócio de controle de fonte, recomendo essa opção, que é a mais indolor. Em equipes pequenas costuma funcionar. E esse é o modelo que iremos utilizar aqui.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Copy-Modify-Merge Model. Esse novo modelo segue o princípio do CVS e do Subversion. Nele todos podem alterar ao mesmo tempo qualquer código-fonte. Porém, na hora de subir as modificações de volta para a base é necessário um passo intermediário conhecido como &lt;em&gt;merge.&lt;/em&gt; É onde são resolvidos conflitos, caso algum desenvolvedor tenha feito modificações no mesmo local que você. Geralmente é escolhida uma ou mais pessoas para gerenciar essa parte do processo. Esse modelo tem funcionado bastante em projetos de fonte aberto e de empresas grandes.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agora que a base está criada, o próximo passo é torná-la disponível a todos. A maneira mais fácil de fazer isso é criando um compartilhamento na rede (de preferência oculto) e divulgando às pessoas interessadas. É claro que você, como bom administrador, irá ter que criar os usuários que irão acessar a base.&lt;/p&gt;
&lt;p&gt;Após esse processo de integração, os usuários podem começar a usar o Source Safe através da primeira opção do início do assistente (Database Selection).&lt;/p&gt;
&lt;p&gt;Antes de começar a mexer nos fontes, o Source Safe pede que você defina um diretório raiz onde começa a ramificação de pastas dos seus fontes. Isso pode ser feito pela opção File, Set Working Folder (Ctrl + D). A partir daí, cada pasta é chamada de projeto (project) no Source Safe. Para criar novos projetos/pastas, use a opção &amp;quot;File, Create Project&amp;quot;. Para adicionar novos arquivos, &amp;quot;File, Add Files&amp;quot;. Cada usuário pode definir seu próprio diretório de trabalho por máquina, mas geralmente é uma boa idéia mantê-los todos utilizando a mesma pasta.&lt;/p&gt;
&lt;p&gt;Após adicionar os arquivos do projeto, é possível fazer modificações usando a opção check-out. O check-out quer dizer que os fontes saem (OUT) da base e são copiados com direito de escrita para seu disco local. Após feitas as modificações, usa-se a opção check-in para subir as modificações para o banco. O check-in quer dizer que as modificações feitas no disco local entram (IN) na base. Cada operação feita com esses dois passos é armazenada no histórico do Source Safe, e podem ser utilizadas para voltar versões antigas, comparar versões antigas novas, etc.&lt;/p&gt;
&lt;p&gt;Quando todos os fontes que subirem constituirem uma alteração madura, compilável, testada pelo desenvolvedor e pronta para ser repassada para os testadores, deve-se criar um rótulo, ou label, para que futuramente essa versão possa ser facilmente identificada entre os milhões de modificações de fonte que sua equipe irá fazer ao longo do tempo. Se essa versão se tornar uma &amp;quot;entregável&amp;quot;, pode-se utilizar o rótulo para obter exatamente a versão entregue a qualquer momento, independente de quantas modificações terem sido feitas depois. Essa marcação de fontes pode ser muito útil na ocorrência de incêndios, e todos sabemos que eles ocorrem com mais freqüência do que gostaríamos. Por isso é importante estar preparado.&lt;/p&gt;
&lt;p&gt;Se você chegou até aqui, quer dizer que está realmente interessado em controlar seus fontes. Parabéns! O controle de fontes vem com algumas vantagens. Vamos supor que já exista uma versão estável no Source Safe e você precisa fazer alguma correção/teste como prova de conceito. Esse tipo de fonte normalmente seria descartável, mas agora que você possui uma ferramenta de controle de fonte funcionando, isso não é necessário.&lt;/p&gt;
&lt;p&gt;Se é necessário desenvolver uma prova de conceito, pode-se optar por criar uma ramificação do fonte, ou branch. Essa opção cria um novo projeto no Source Safe com fontes existentes, mantém o histórico de modificações, mas gera uma nova linha de vida do fonte. Qualquer modificação feita em um branch fica nesse branch, seja o principal ou secundário. É possível também no futuro juntar dois branchs.&lt;/p&gt;
&lt;p&gt;Agora, se a modificação é um simples teste durante a depuração, pode ser feito o check-out para modificações temporárias. Se mais tarde for decidido que as modificações não serão efetuadas na base, basta executar a opção undo check-out, que volta o fonte da base para o disco local e mantém a versão intacta. Use essa opção com cuidado, pois quaisquer modificações no disco local serão perdidas.&lt;/p&gt;
&lt;p&gt;Agora que os fontes estão vivendo tranqüilamente no controle de fontes, é possível executar builds automatizados de tempos em tempos. Isso garante a estabilidade do seu projeto, pois junto dos builds é possível fazer testes, tanto da compilação em si quanto depois de compilado.&lt;/p&gt;
&lt;p&gt;O Source Safe possui uma ferramenta em linha de comando que faz as mesmas operações que a versão gráfica, além de possuir uma série de interfaces COM que podem ser usadas para interagir com o controle de fontes através de scripts. Além de outras ferramentas de automação de builds que podem ser integradas, como o NAnt e o CruiseControl.&lt;/p&gt;
&lt;p&gt;O resumo da ópera é: cuide bem dos seus fontes. Muito trabalho, tempo e dinheiro são despendidos com desenvolvimento. Não cuidar do resultado de tudo isso é como botar fogo no estoque de uma fábrica.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Antidebug: detectando attach</title>
  <link>http://www.caloni.com.br/antidebug-detectando-attach/</link>
  <pubDate>2007-09-10</pubDate>
  
  <guid>http://www.caloni.com.br/antidebug-detectando-attach/</guid>
  <description>&lt;p&gt;Hoje foi um belo dia para engenharia reversa e análise de proteções. Dois ótimos programas vieram ao meu conhecimento: um monitor de chamadas de API e um monitor de chamadas de COM (complementando o primeiro, que não monitora funções depois que CoCreateInstance foi chamado). Além de que no sítio do primeiro programa - de algum entusiasta do bom e velho Assembly Win32, diga-se de passagem - encontrei o código-fonte para mais uma técnica antidebugging, o que nos leva de volta para a já consagrada série de técnicas antidepuração.&lt;/p&gt;
&lt;p&gt;O objetivo dessa proteção é detectar se, após o executável ter sido iniciado, algum depurador metido a besta tentou atachar-se no processo criado, ou seja, tentou iniciar o processo de depuração após o aplicativo já ter iniciada a execução. Isso é possível - de certa forma trivial - na maioria dos depuradores (se não todos), como o Visual Studio e o WinDbg. Diferente da técnica de ocupar a DebugPort, que impede a ação de attach, a proteção nesse caso não protege diretamente; apenas permite que o processo saiba do suposto ataque antes de entregar o controle ao processo depurador.&lt;/p&gt;
&lt;p&gt;O código que eu encontrei nada mais faz do que se aproveitar de uma peculiaridade do processo de attach: ao disparar o evento, a função ntdll!DbgUiRemoteBreakin é chamada. Ora, se é chamada, é lá que devemos estar, certo? E isso, como vemos abaixo, é relativamente fácil:&lt;/p&gt;
&lt;p&gt;Para compilar o código acima, basta chamar o compilador seguido do ligador. Obs.: precisamos da user32.lib para chamar a função API MessageBox:&lt;/p&gt;
&lt;p&gt;Após o programa ter sido executado, qualquer tentativa de attach irá exibir nossa mensagem de detecção, seguida pelo capotamento do programa.&lt;/p&gt;
&lt;p&gt;Sim, eu sei. Às vezes temos que apelar pra &amp;quot;ignorância&amp;quot; e fazer códigos obscuros como esse:&lt;/p&gt;
&lt;p&gt;Existem inúmeras maneiras de fazer a mesma coisa. O exemplo acima é o que é chamado comumente nas rodinhas de crackers de shellcode, que é um nome bonitinho para &amp;quot;array de bytes que na verdade é um assembly de um código que faz coisas interessantes&amp;quot;. Shellcode for short =).&lt;/p&gt;
&lt;p&gt;Maneiras alternativas de fazer isso são:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Declarar uma função &lt;em&gt;naked&lt;/em&gt; no Visual Studio, criar uma função vazia logo após e fazer continha de mais e menos para chegar ao tamanho que deve ser copiado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Criar uma estrutura cujos membros são &lt;em&gt;opcodes&lt;/em&gt; disfarçados. Dessa forma é possível no construtor dessa estrutura preencher os valores corretamente e usá-la como uma &amp;quot;função móvel&amp;quot;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ambas possuem prós e contras. Os contras estão relacionados com a dependência do ambiente. Na primeira alternativa é necessário configurar o projeto para desabilitar o &amp;quot;Edit and Continue&amp;quot;, enquanto no segundo é necessário alinhar a estrutura em 1 byte.&lt;/p&gt;
&lt;p&gt;Seja qual for a solução escolhida, ao menos temos a vantagem do impacto no sistema de nosso aplicativo ser praticamente nulo, pois isolamos em duas funções - AntiAttachAbort e InstallAntiAttach - um hook de uma API local (do próprio processo) que supostamente nunca deveria ser chamada em um binário de produção. Além do mais, existem maneiras mais a la C++ de fazer coisas como &amp;quot;live assembly&amp;quot;. Mas isso já é matéria para futuros e excitantes artigos =D.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 4.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-40/</link>
  <pubDate>2007-09-04</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-40/</guid>
  <description>&lt;p&gt;Em meio a uma febre de consumismo, no dia 24 de agosto de 1995, foi lançado a revolução no sistema gráfico da Microsoft: a interface do Windows 95. Ela foi considerada muito mais amigável que suas versões anteriores. Ainda possuía a vantagem de não necessitar mais de uma instalação prévia do DOS, passou a suportar nomes de arquivos longos, incluir suporte a TCP/IP e dial-up networking integrados. Muitas mudanças foram feitas no sistema em si, como a passagem para 32 bits (como já vimos, parcial) e o novo conceito de threads, que é o que veremos com mais detalhes nesse artigo.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bem, o &amp;quot;novo conceito&amp;quot; de threads já havia sido implementado no Windows NT desde o &amp;quot;scratch&amp;quot;. O conceito já existia no início do projeto, mas não no velho Windows 3. 1 de 16 bits, que foi a versão anterior ao 95. Parte dos requisitos do sistema foi que ele seria compatível com o NT no nível de aplicativo, o que de fato aconteceu.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Para esse milagre da multiplicação das threads acontecer a Microsoft foi obrigada a portar boa parte do código de 16 bits para 32 e entrar em modo protegido. Mesmo assim, um legado razoável do MS-DOS permaneceu debaixo dos panos, suportando o novo sistema operacional através de suas interrupções e código residente.&lt;/p&gt;
&lt;p&gt;Com o lançamento da nova versão do NT, foi necessário modernizar a interface para ser compatível com o Windows 95, o que fez com que o Windows 4.0 fosse mais bonitinho. No entanto, o núcleo dos dois sistemas era completamente diferente. Enquanto um era 32 bits puro desde o primeiro int main, o outro era um sistema de compatibilidade para fornecer um Windows caseiro que fosse vendável e desse à Microsoft o retorno financeiro esperado. Deu certo por um bom tempo, até a chegada do Windows XP, que uniu as duas famílias de sistemas operacionais, pois descontinuou o Windows ME e tornou o Windows 2000 Professional mais amigável para o uso geral.&lt;/p&gt;
&lt;p&gt;Uma thread é uma linha de execução de código. Ser um sistema multithreading significa que ele permite que múltiplas linhas de execução de código rodem em paralelo e, dependendo do número de processadores, ao mesmo tempo.&lt;/p&gt;
&lt;p&gt;Em uma plataforma com apenas um processador, como é natural supor, apenas uma thread roda de cada vez. Contudo, o tempo de execução das threads é dividido entre elas, de forma que aparentemente todas elas rodam ao mesmo tempo. Essa unidade de divisão do tempo de execução é conhecido como Quantum, ou Time Slice, e é caracterizado como o tempo em que uma thread fica rodando até que outra thread tome o seu lugar, ou seja, ocorra uma troca de contexto (switch context).&lt;/p&gt;
&lt;p&gt;Como podemos ver, quando uma thread é criada ela ganha seu primeiro time slice (se não iniciar suspensa) e divide o tempo de processamento com outras threads que executam no mesmo processador.&lt;/p&gt;
&lt;p&gt;Para exemplificar o uso de threads, resolvi fazer um programa que pode nos ser útil no futuro. Se trata de um quebrador de senhas por força bruta. Isso quer dizer que enquanto uma thread fica cuidando das mensagens da janela, como digitação e movimentação, uma segunda thread irá ficar constantemente tentanto descobrir sua senha digitada por tentativa e erro. Toda vez que é alterado um caractere na senha, a thread quebradora reinicia seu trabalho.&lt;/p&gt;
&lt;p&gt;Se você está apenas acompanhando estes artigos sem ter se aprofundado em um livro ou o MSDN, algumas coisas podem parecer novas demais, como a maneira que usei para criar a janela. Diferente de CreateWindow, podemos usar funções que criam o que é chamado de caixa de diálogo (dialog box), que nada mais é que uma janela modal, como a mostrada pelo MessageBox (ou até a System.Windows.Forms.MessageBox). Para isso é necessário desenhar uma janela através de um arquivo de resource, com a extensão rc. Porém, podemos ver que não é difícil entender como um arquivo de resources funciona:&lt;/p&gt;
&lt;p&gt;Também não deve ser muita surpresa saber que uma caixa de diálogo também possui sua função de janela, que é praticamente idêntica a do CreateWindow. A diferença está mais no tratamento das mensagens.&lt;/p&gt;
&lt;p&gt;A surpresa maior deve ficar por conta da nova thread, que é criada através da função da API CreateThread:&lt;/p&gt;
&lt;p&gt;Assim como na criação de janelas, é passada uma função de callback. Só que diferente de uma função de janela, essa função não é executada na mesma thread que criou a janela, mas é um novo &amp;quot;int main&amp;quot; para uma nova linha de execução, que irá rodar em paralelo com a primeira. Essa segunda linha de execução termina quando retornamos dessa função, que no nosso exemplo é nunca, mas poderia ser quando fosse terminada sua tarefa.&lt;/p&gt;
&lt;p&gt;Depois que uma thread termina, existem maneiras das outras threads ficarem sabendo e até obterem seu código de retorno. Isso pode ser feito utilizando-se o handle retornado pela função CreateThread, uma duplicação desse mesmo handle ou até a obtenção de um novo handle através do identificador da thread, o Thread Id (TID).&lt;/p&gt;
&lt;p&gt;Bom, acho que para explicar o uso de um sistema multithreading em um artigo só não basta. Mas para explicar por que sua senha deve ter mais de três caracteres, acho que é o bastante. Até a próxima.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Outros artigos sobre a história do windows&lt;/li&gt;
&lt;li&gt;Windows 95: quinze anos de grandes feitos e telas azuis&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Hook de API no WinDbg</title>
  <link>http://www.caloni.com.br/hook-de-api-no-windbg/</link>
  <pubDate>2007-08-29</pubDate>
  
  <guid>http://www.caloni.com.br/hook-de-api-no-windbg/</guid>
  <description>&lt;p&gt;Basicamente existem duas maneiras de um executável obter o endereço de uma função API do Windows: ou ele usa uma lib de interface com a DLL (o chamado &amp;quot;link estático&amp;quot;) ou ele chama a função kernel32!GetProcAddress explicitamente [1].&lt;/p&gt;
&lt;p&gt;Para conseguir saber as funções das quais um executável obtém o endereço através da primeira técnica podemos utilizar o mundialmente famoso Dependency Walker. Ele nos mostrará quais DLLs ele utiliza e quais funções por DLL ele quer o endereço. Ele também nos avisa sobre as DLLs que estão utilizando delay load, uma técnica inventada no Visual Studio para que os executáveis não dependam estaticamente de APIs muito novas que podem não existir em versões do Windows mais antigas. Com o Depends também é possível fazer hook de chamadas de API utilizando a opção profiling (F7), mas não costuma funcionar muito bem com trojans, pois eles capotam antes que alguma coisa interessante ocorra.&lt;/p&gt;
&lt;p&gt;O importante do Dependency Walker para o WinDbg é que com um editor é possível copiar todas as funções exibidas em sua interface para um editor, usar um pouco de regular expressions e criar uma batelada de breakpoints no WinDbg:&lt;/p&gt;
&lt;p&gt;O comando &amp;quot;bp&amp;quot; cria um breakpoint no endereço requisitado. O que está entre aspas são os comandos que você deseja executar quando o breakpoint for disparado. No caso, para todas as funções será impresso o seu nome (comando &amp;quot;.echo&amp;quot;) e a execução irá continuar (comando &amp;quot;g&amp;quot;). Ao rodar o programa, as chamadas das funções são mostradas na saída do depurador:&lt;/p&gt;
&lt;p&gt;Lindo, não? Porém ainda podem estar sendo chamadas as funções obtidas pela segunda técnica, a do GetProcAddress. Para esse caso devemos ir um pouquinho mais fundo e rodar o executável duas vezes. Na primeira, coletamos as funções que são obtidas por essa técnica através do seguinte comando:&lt;/p&gt;
&lt;p&gt;O comando &amp;quot;da&amp;quot; exibe o conteúdo de uma string em C (caracteres ANSI e terminada em zero) na memória. A memória no caso é o &amp;quot;apontado do valor contido no segundo parâmetro da pilha&amp;quot;. Complicado? Nem tanto: lembre-se que o ESP aponta sempre pro endereço de retorno da função chamadora e os parâmetros são sempre empilhados na ordem inversa da declaração em C. Logo, se o protótipo de GetProcAddress é:&lt;/p&gt;
&lt;p&gt;O último parâmetro empilhado (ESP+4) é o hModule, e o penúltimo (ESP+8) é o lpProcName, que é o lugar onde é passado o nome da função.&lt;/p&gt;
&lt;p&gt;Devemos lembrar de colocar esse breakpoint bem no início da execução e rodar o executável uma vez. Com isso coletamos o conjunto de nomes de funções usadas para chamar GetProcAddress:&lt;/p&gt;
&lt;p&gt;Daí é só organizar a lista obtida em ordem alfabética, acabar com duplicidades e criar o mesmo tipo de breakpoint que foi usado para as funções estáticas (pode ser sem o nome da DLL porque, embora não recomendado, o WinDbg se vira para encontrar os símbolos). Depois de criados os comandos, rodamos novamente o executável e, logo no início, já colocamos todos os breakpoints das funções coletadas.&lt;/p&gt;
&lt;p&gt;Essa é uma maneira rústica, porém eficaz e rápida de obter a lista de execução da API utilizada por um programa [2].&lt;/p&gt;
&lt;p&gt;[1] Uma variação do método GetProcAddress é a técnica de delay load usado pelo Visual C++. Porém, como o Dependency Walker nos mostra também as DLLs que estão linkadas usando essa técnica se torna dispensável um tratamento ad hoc.&lt;/p&gt;
&lt;p&gt;[2] Essa técnica nem sempre funciona com todas as chamadas API, pois o aplicativo ainda pode utilizar outras maneiras de obter o endereço de uma função e chamá-la. A solução definitiva seria escrever diretamente um assembly esperto no começo da função, o que pode gerar mais problemas que soluções. Do jeito que está, conseguimos resolver 90% dos nossos problemas com análise de chamadas API. O resto nós podemos resolver em futuros artigos.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.kakeeware.com&#34;&gt;http://www.kakeeware.com&lt;/a&gt;: sítio com monitor de chamadas de API e outras ferramentas interessantes. Detalhe notável: o cara faz tudo usando apenas &lt;em&gt;assembly&lt;/em&gt;, o que torna os programas realmente pequenos e rápidos.&lt;/li&gt;
&lt;li&gt;ComTrace: outro monitor de chamadas, mas de componentes COM. Intercepta todas as chamadas de métodos de um aplicativo.&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Antidebug: ocupando a DebugPort</title>
  <link>http://www.caloni.com.br/antidebug-ocupando-a-debugport/</link>
  <pubDate>2007-08-23</pubDate>
  
  <guid>http://www.caloni.com.br/antidebug-ocupando-a-debugport/</guid>
  <description>&lt;p&gt;Quando um depurador inicia um processo para ser depurado ou, o caso abordado por este artigo, se conecta em um processo já iniciado, as comunicações entre esses dois processos é feita através de um recurso interno do Windows chamado de LPC (Local Procedure Call). O sistema cria uma &amp;quot;porta mágica&amp;quot; de comunicação específica para a depuração e os eventos trafegam por meio dela.&lt;/p&gt;
&lt;p&gt;Entre esses eventos podemos citar os seguintes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Breakpoints&lt;/em&gt; disparados&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exceções lançadas&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Criação/saída de &lt;em&gt;threads&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Load&lt;/em&gt;/&lt;em&gt;unload&lt;/em&gt; de DLLs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Saída do processo&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;No caso de se conectar em um processo já existente, é chamada a função da API DebugActiveProcess. A partir dessa chamada, se retornado sucesso, o processo que depura agora está liberado para ficar chamando continuamente a função API WaitForDebugEvent. E o código se resume a isto:&lt;/p&gt;
&lt;p&gt;O detalhe interessante desse processo de comunicação depurador/depurado é que um processo só pode ser depurado por apenas UM depurador. Ou seja, enquanto houver um processo depurando outro, os outros processos só ficam na vontade.&lt;/p&gt;
&lt;p&gt;Partindo desse princípio, podemos imaginar uma proteção baseada nessa exclusividade, criando um processo protetor que conecta no processo protegido e o &amp;quot;depura&amp;quot;:&lt;/p&gt;
&lt;p&gt;Os passos para testar o código acima são:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compilar o código.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Executar o notepad (ou qualquer outra vítima).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Obter seu PID (Process ID).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Executar o protetor passando o PID como parâmetro.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tentar &amp;quot;atachar&amp;quot; no processo através do Visual C++.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Após o processo de attach, a porta de debug é ocupada, e a comunicação entre depurador e depurado é feita através do LPC. Abaixo uma pequena ilustração de como as coisas ocorrem:&lt;/p&gt;
&lt;p&gt;Basicamente o processo fica recebendo eventos de debug (através da fila de mensagens LPC) continuamente até o evento final, o de final de processo. Note que se alguém tentar derrubar o processo que depura o processo depurado cai junto.&lt;/p&gt;
&lt;p&gt;O ponto forte desse tipo de proteção é que não afeta a compreensão e a legibilidade do código. De fato o próprio código que &amp;quot;protege&amp;quot; está em outro processo. O fraco, eu diria, é a sua alta visibilidade. Todo mundo que tentar atacar verá dois processos serem criados; e isso já faz pensar...&lt;/p&gt;
&lt;p&gt;Por isso é necessário pensar bem na implementação. Particularmente uma coisa a ser bem arquitetada é a união entre depurador e depurado. Quanto melhor essas duas peças forem encaixadas, tão mais difícil será para o atacante separá-las. Uma idéia adicional é utilizar a mesma técnica na direção oposta, ou seja, o processo depurado se atachar no depurador.&lt;/p&gt;
&lt;p&gt;Dessa vez não vou afirmar que, uma vez entendido o problema, a solução torna-se óbvia. Isso porque ainda não pensei o suficiente para achar uma solução óbvia. Idéias?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Erro de compilação: funções muito novas na Win32 API</title>
  <link>http://www.caloni.com.br/erro-de-compilacao-funcoes-muito-novas-na-win32-api/</link>
  <pubDate>2007-08-21</pubDate>
  
  <guid>http://www.caloni.com.br/erro-de-compilacao-funcoes-muito-novas-na-win32-api/</guid>
  <description>&lt;p&gt;Quando fala-se em depuração geralmente o pensamento que vem é de um código que já foi compilado e está rodando em alguma outra máquina e gerando problemas não detectados nos testes de desenvolvedor. Mas nem sempre é assim. Depuração pode envolver problemas durante a própria compilação. Afinal de contas, se não está compilando, ou foi compilado errado, é porque já existem problemas antes mesmo da execução começar.&lt;/p&gt;
&lt;p&gt;O fonte abaixo, por exemplo, envolve um detalhe que costuma atormentar alguns programadores, ou por falta de observação ou documentação (ou ambos).&lt;/p&gt;
&lt;p&gt;Tirando o fato que o retorno void não é mais um protótipo padrão da função main e que a definição da enumeração COMPUTERNAMEFORMAT dentro da função main é no mínimo suspeita, podemos testar a compilação e verificar que existe exatamente um erro grave neste fonte:&lt;/p&gt;
&lt;p&gt;A função GetComputerNameEx parece não ter sido definida, apesar de estarmos incluindo o header windows.h, que é o pedido pela documentação do MSDN. Esse tipo de problema acontece na maioria das vezes por dois motivos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;o header responsável não foi incluído (não é o caso, como vimos),&lt;/li&gt;
&lt;li&gt;é necessário especificar a versão mínima do sistema operacional.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;De fato, se criarmos coragem e abrirmos o arquivo winbase.h, que é onde a função é definida de fato, e procurarmos pela função GetComputerNameEx encontramos a seguinte condição:&lt;/p&gt;
&lt;p&gt;Ou seja, para que essa função seja visível a quem inclui o windows.h, é necessário antes definir que a versão mínima do Windows será a 0x0500, ou seja, Windows 2000 (vulgo Windows 5.0). Aliás, é como aparece na documentação. Um pouco de observação nesse caso seria o suficiente para resolver o caso, já que tanto abrindo o header quanto olhando no exemplo do MSDN nos levaria a crer que é necessário definir essa macro:&lt;/p&gt;
&lt;p&gt;Outra observação que poderia ter ajudado na hora de codificar seria dar uma olhada no que os caras escrevem na seção de advertências (remarks) da documentação:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To compile an application that uses this function, define the WIN32WINNT macro as 0x0500 or later. For more information, see Using the Windows Headers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Podemos também notar pela definição do COMPUTERNAMEFORMAT dentro do main que o código estava no meio do caminho de cometer um sacrilégio: declarar funções e estruturas que já estão definidas nos headers da API. Portanto, se você já encontrou algum código parecido com esse, é hora de colocar em prática algumas teorias de refactoring.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Junctions</title>
  <link>http://www.caloni.com.br/junctions/</link>
  <pubDate>2007-08-17</pubDate>
  
  <guid>http://www.caloni.com.br/junctions/</guid>
  <description>&lt;p&gt;Semana passada baixei uma nova imagem para minha máquina de desenvolvimento. Esse esquema do pessoal da engenharia instalar as coisas para você facilita muito as coisas, mas existe o risco de algo ser instalado no lugar errado, que foram os casos do DDK e do SDK do Windows. Aqui no desenvolvimento, para efeito de padronização, utilizamos a seguinte estrutura de diretórios para esses dois aplicativos:&lt;/p&gt;
&lt;p&gt;Porém, por algum motivo desconhecido os instaladores da Microsoft não seguem o nosso padrão: o SDK é instalado em &amp;quot;%programfiles%\Microsoft Platform SDK&amp;quot; e o DDK em &amp;quot;C:\WINDDK\3790.1830&amp;quot;. Para corrigir este pequeno ato relapso eu até poderia reinstalar ambos os aplicativos no local correto, gastanto algumas horas do dia, mas existe uma outra solução mais rápida e simpática chamada de junction.&lt;/p&gt;
&lt;p&gt;Um junction é um link simbólico (symbolic link) de diretório. É praticamente um atalho, com a diferença que ele se comporta exatamente como se fosse o próprio objeto para o qual aponta: qualquer arquivo criado ou apagado usando o junction cria ou apaga um arquivo real no diretório real para o qual ele aponta. Essa característica pode ser tão útil quanto perigosa, por isso devem-se utilizar junctions com cuidado.&lt;/p&gt;
&lt;p&gt;Para criar um junction pode-se usar uma ferramenta disponível no Windows Resource Kit chamada linkd.exe. Porém, para evitar de ter que baixar todo o pacote para usar um único arquivo, existe uma outra ferramenta desenvolvida à parte por Russinovich chamada junction.exe. O comando para criar junctions é bem fácil e direto:&lt;/p&gt;
&lt;p&gt;E é isso aí. A partir de agora tanto as pastas originais quanto os junctions criados para elas respondem como se fossem a mesma coisa, porém com paths diferentes.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Neo, sooner or later, you&#39;re going to realize, just as I did, that there&#39;s a different between knowing the path... and walking the path...&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;No Vista os junctions também funcionam para arquivos e possuem seu próprio aplicativo nativo, o mklink.exe. Porém, ele chama os links para diretórios de junctions (em português, junções) e os links para arquivos de links mesmo. Você pode notar uma pequena gamb.. adaptação técnica ao mudarem o nome da pasta &amp;quot;Documents and Settings&amp;quot; para &amp;quot;Users&amp;quot; (ou &amp;quot;Usuários&amp;quot;, na versão em português).&lt;/p&gt;
&lt;p&gt;Esse link é extremamente necessário para a compatibilidade daqueles aplicativos feitos às pressas que não se importam em perguntar para o sistema onde está a pasta de documentos do usuário, fixando o path como se ele fosse estar sempre lá.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lista dos &lt;em&gt;junctions&lt;/em&gt; do Vista e explicações mais detalhadas e técnicas.&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>História da linguagem C - parte 2</title>
  <link>http://www.caloni.com.br/historia-da-linguagem-c-parte-2/</link>
  <pubDate>2007-08-15</pubDate>
  
  <guid>http://www.caloni.com.br/historia-da-linguagem-c-parte-2/</guid>
  <description>&lt;p&gt;No princípio... não, não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados Srs. dos Laboratórios Bell, K. Thompson e D. Ritchie, criaram uma linguagem chamada B. E B era bom.&lt;/p&gt;
&lt;p&gt;O bom de B era sua rica expressividade e sua simples gramática. Tão simples que o manual da linguagem consistia de apenas 30 páginas. Isso é menos do que as 32 palavras reservadas de C. As instruções eram definidas em termos de if&#39;s e goto&#39;s e as variáveis eram definidas em termos de um padrão de bits de tamanho fixo - geralmente a word da plataforma - que utilizada em expressões definiam seu tipo; esse padrão de bits era chamado rvalue. Imagine a linguagem C de hoje em dia com apenas um tipo: int.&lt;/p&gt;
&lt;p&gt;Como esse padrão de bits nunca muda de tamanho, todas as rotinas da biblioteca recebiam e retornavam sempre valores do mesmo tamanho na memória. Isso na linguagem C quer dizer que o char da época ocupava tanto quanto o int. Existia inclusive uma função que retornava o caractere de uma string na posição especificada:&lt;/p&gt;
&lt;p&gt;Sim! Char era uma função, um conversor de &amp;quot;tipos&amp;quot;. No entanto a própria variável que armazenava um char tinha o tamanho de qualquer objeto da linguagem. Esse é o motivo pelo qual, tradicionalmente, as seguintes funções recebem e retornam ints em C e C++:&lt;/p&gt;
&lt;p&gt;Segue o exemplo de uma função na linguagem B, hoje muito famosa:&lt;/p&gt;
&lt;p&gt;Como podemos ver, vários elementos (se não todos) da linguagem C já estão presentes na B.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>GINA x Credential Provider</title>
  <link>http://www.caloni.com.br/gina-x-credential-provider/</link>
  <pubDate>2007-08-13</pubDate>
  
  <guid>http://www.caloni.com.br/gina-x-credential-provider/</guid>
  <description>&lt;p&gt;Não fui convidado a participar do tema, mas como já faz algum tempo que o rascunho deste artigo está no molho, e aproveitando que meu amigo Ferdinando resolveu escrever sobre nossa amiga em comum, darei continuidade à minha empolgação sobre o tagging e largarei aqui este pequeno adendo.&lt;/p&gt;
&lt;p&gt;Com a chegada do Windows Vista, uma velha conhecida minha e dos meus colegas deixou de fazer parte do sistema de autenticação do sistema operacional: a velha GINA, Graphical Identification aNd Autentication.&lt;/p&gt;
&lt;p&gt;Basicamente se trata de uma DLL que é chamada pelo WinLogon, o componente responsável pelo famoso Secure Attention Sequence (SAS), mais conhecido por Ctrl + Alt + Del. Ele efetua o logon do usuário, mas quem mostra as telas de autenticação, troca de senha, bloqueio da estação é a GINA. Mexi com várias GINAs há um tempo atrás: GINAs invisíveis, GINAs que autenticam smart cards, GINAs que autenticam pela impressão digital, e por aí vai a valsa.&lt;/p&gt;
&lt;p&gt;O Windows já vem com uma GINA padrão, a MsGina.dll, que autentica o usuário baseada em usuário e senha e/ou smart card. Teoricamente o intuito original de uma GINA fornecida por terceiros era permitir outros meios de autenticação. Para isso o fornecedor deveria trocar todas as telas de autenticação pela equivalente de acordo com o novo tipo de autenticação (por exemplo, um campo com uma impressão digital para permitir o uso de biometria em vez de senha). Porém, um outro uso pode ser controlar o login dos usuários baseado em outras regras além das que o Windows já fornece.&lt;/p&gt;
&lt;p&gt;Apesar de útil, o sistema baseado em GINAs tinha um pequeno problema: permitia somente a troca exclusiva, ou seja, só uma GINA pode ser ativada. Se não for a da Microsoft, que seja a do fornecedor, e apenas a de um fornecedor. Isso começa a ficar limitado diante das novas e conflitantes maneiras que um usuário possui hoje em dia de fazer logon: nome e senha, íris dos olhos, impressão digital, formato do nariz e assim por diante. Todas essas autenticações deveriam estar disponíveis ao mesmo tempo para que o usuário escolha qual deles lhe convém.&lt;/p&gt;
&lt;p&gt;Foi por isso que surgiu seu substituto natural no Windows Vista: o Credential Provider.&lt;/p&gt;
&lt;p&gt;O sistema de Credential Provider permite que inúmeras DLLs sejam registradas no sistema para receberem eventos de logon, seja para criar uma nova sessão (tela de boas vindas) ou apenas para se autenticar já em uma sessão iniciada, como, por exemplo, nos casos em que o Controle da Conta do Usuário (UAC: User Account Control) entra em ação.&lt;/p&gt;
&lt;p&gt;O sistema de coleta foi simplificado e modernizado: agora a interface não se baseia em funções exportadas, como a GINA, mas em interfaces COM disponíveis. O desenvolvedor também consegue escolher os cenários em que ele pretende entrar em ação:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Efetuar logon&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Desbloquear estação&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mudar a senha&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Efetuar conexão de rede (antes do logon)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Baseado no número de CPs registrados no sistema, o LogonUI (processo responsável por exibir a tela de boas vindas) irá exibir as respectivas credenciais para cada um dos CPs envolvidos no logon.&lt;/p&gt;
&lt;p&gt;Já que fomos brindados com um exemplo de GINA stub do Ferdinando, também irei disponibilizar um outro exemplo, este um pouco mais perigoso, da época de laboratório da faculdade. Se trata igualmente de uma GINA que se aproveita da implementação da GINA original, porém na hora de autenticar um usuário ela captura os dados do logon (usuário e senha) e grava em uma parte do registro acessível apenas pelo sistema (lembre-se que a GINA, por fazer parte do WinLogon, roda na conta de sistema).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;É claro que para utilizar essa GINA, você deve possuir direitos de administração, ou conhecer alguma brecha de segurança. Eu optei pela segunda opção, já que não tinha a primeira. Podemos dizer apenas que o artigo sobre falhas de segurança relacionadas a usuários avançados do Russinovich pôde resolver meu problema.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Última referência técnica&lt;/li&gt;
&lt;li&gt;Documentação das interfaces&lt;/li&gt;
&lt;li&gt;Guia de migração GINA =&amp;gt; CP&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Antidebug: interpretação baseada em exceção (parte 2)</title>
  <link>http://www.caloni.com.br/antidebug-interpretacao-baseada-em-excecao-parte-2/</link>
  <pubDate>2007-08-09</pubDate>
  
  <guid>http://www.caloni.com.br/antidebug-interpretacao-baseada-em-excecao-parte-2/</guid>
  <description>&lt;p&gt;No primeiro artigo vimos como é possível &amp;quot;enganar&amp;quot; o depurador através de exceções e assim fazer o atacante perder um tempo considerável tentando se desvencilhar dos breakpoints de mentira. Porém, vimos também que essa é uma solução difícil de manter no código-fonte, além de possuir o ponto fraco de ser facilmente contornada se descoberta. Agora é a hora de tornar as coisas mais fáceis de manter e ao mesmo tempo garantir maior dificuldade mesmo que o atacante descubra o que está acontecendo debaixo do seu nariz.&lt;/p&gt;
&lt;p&gt;O upgrade apresentado aqui continua utilizando o lançamento de exceções intrinsecamente, mas agora não depende mais da divisão do código em minifunções e chamá-las aos poucos. Em invés disso, temos apenas que pegar traços de código e colocá-los em torno de uma macro milagrosa que fará tudo o que quisermos. Isso, claro, depois de algumas marteladas que serão explicadas aqui.&lt;/p&gt;
&lt;p&gt;A solução acima está apresentada em pseudo-código para tornar mais claro o conceito. Note que existe uma espécie de &amp;quot;retorno invisível&amp;quot;, não baseado em retorno de pilha, envolvido. Para implementá-lo, contudo, podemos nos ajeitar com o velho e bom padrão C ANSI, com as rotinas setjmp (passo 1) e longjmp (passo 3). Para entender a implementação dessa funções na plataforma 8086 precisamos ter primeiro uma visão básica da estrutura de chamada de funções baseada em pilha.&lt;/p&gt;
&lt;p&gt;Registradores são variáveis reservadas do processador que podem ser utilizadas pelo código assembly da plataforma envolvida. Stack frame (estrutura da pilha) nada mais é que a hierarquia de chamadas das funções, o &amp;quot;quem chamou quem&amp;quot; em uma execução qualquer. Call e ret são instruções em assembly para chamar uma função (call) e sair de uma função (ret), respectivamente. Ambas alteram o stack frame.&lt;/p&gt;
&lt;p&gt;Imagine que você tem uma função, CallFunc, e outra função, Func, e que uma chame a outra. Para analisarmos apenas a chamada de função, e apenas isso, vamos considerar que Func não recebe nenhum parâmetro e não retorna nenhum valor. O código em C fica, então, assim:&lt;/p&gt;
&lt;p&gt;void Func()
{
return;
}&lt;/p&gt;
&lt;p&gt;void CallFunc()
{
Func();
}&lt;/p&gt;
&lt;p&gt;Simples, não? Por esse mesmo motivo o disassembly terá que ser igualmente simples. Em CallFunc ele deverá conter a chamada da função (call) e em Func o retorno da chamada (ret). O resto que eventualmente aparecer está relacionado aos controles da versão Debug.&lt;/p&gt;
&lt;p&gt;Func:
00411F73 previnstruction ; ESP = 0012FD38 (four bytes stacked up)
00411F74 ret ; *ESP = 00411FA3 (return address)&lt;/p&gt;
&lt;p&gt;CallFunc:
00411F9C previnstruction
00411F9E call Func (411424h) ; ESP = 0012FD3C
00411FA3 nextinstruction&lt;/p&gt;
&lt;p&gt;A partir do assembly acima podemos concluir no mínimo duas coisas: 1. a pilha &amp;quot;cresce&amp;quot; para baixo, pois seu valor decrementou de quadro (0012FD3C para 0012FD38 são 4 byte a menos) e 2. o valor de retorno da função chamada é o endereço da próxima instrução após a chamada (call), no caso 00411FA3.&lt;/p&gt;
&lt;p&gt;Ora, da mesma forma que conseguimos acompanhar essa simples execução, o atacante também o fará. Por isso que no meio dessa chamada iremos colocar o lançamento de uma exceção e, no retorno, faremos não do modo convencional apresentado, mas por uma outra técnica que, ao invés de utilizar a instrução ret, seta &amp;quot;manualmente&amp;quot; o valor do registrador ESP (estado da pilha) e &amp;quot;pula&amp;quot; para a próxima instrução de CallFunc.&lt;/p&gt;
&lt;p&gt;Func:
00411F60 throwexception
00411F61 ...
00411F73 catchexception
00411F74 mov ESP, 0012FD3C ; ESP = 0012FD3C, como em CallFunc
00411F75 jmp 00411FA3 ; &amp;quot;pula&amp;quot; para CallFunc::nextinstruction&lt;/p&gt;
&lt;p&gt;Toda essa esculhambada em assembly não precisa ser necessariamente feita em linguagem de baixo nível. Foi apenas uma maneira que encontrei pra ilustrar as diferenças entre retorno baseado em pilha e alteração no fluxo do código. Como já foi dito, para a sorte e o bem-estar de todos, essa mesma técnica pode ser implementada com funções C da biblioteca ANSI:&lt;/p&gt;
&lt;p&gt;Essa foi a técnica adicionada à solução do lançamento de exceções. O código final ficou mais claro:&lt;/p&gt;
&lt;p&gt;À primeira vista parece um desperdício o if estar diretamente no código (lembre-se que vamos utilizar a mesma estrutura condicional em várias e várias partes do código. Para tornar mais claro seu uso, resumir a chamada protegida e permitir que a proteção seja desabilitada em debug, vamos criar uma macro:&lt;/p&gt;
&lt;p&gt;Veja que como agora permitimos a seleção do anti-debug por chamada, fica mais fácil escolher quais os pontos a serem protegidos e quais não devem/podem por conta de perfomance ou outro detalhe obscuro que sempre existe na vida de um programador C++.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 3.51</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-351/</link>
  <pubDate>2007-08-07</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-351/</guid>
  <description>&lt;p&gt;Nos anos 90, a relação IBM/Microsoft era muito próxima por causa do desenvolvimento do OS/2, o projeto de um novo sistema operacional. As empresas cooperavam entre si e tinham acesso uma ao código da outra. A Microsoft desejava avançar seu desenvolvimento no Windows, enquanto a IBM desejava que todo trabalho futuro fosse baseado em OS/2. Para resolver essa tensão, as duas combinaram que a IBM iria desenvolver o OS/2 versão 2.0 para substituir o OS/2 versão 1.3 e o Windows v3.0, enquanto a Microsoft iria desenvolver um novo sistema operacional, o OS/2 versão 3.0 para depois suceder ao OS/2 anterior. É lógico que esse acordo foi por água abaixo.&lt;/p&gt;
&lt;p&gt;A relação IBM/Microsoft foi terminada. A IBM continuou a desenvolver o OS/2 v2.0 enquanto a Microsoft mudou o nome de seu ainda não lançado OS/2 v3.0 para Windows NT. O Windows NT foi tão massivamente promovido que a maioria das pessoas nem se deu conta que ele era um OS/2 redesenhado. Ambas as empresas obtiveram os direitos de utilizarem as tecnologias do OS/2 e do Windows que foram desenvolvidas até a quebra do acordo.&lt;/p&gt;
&lt;p&gt;A IBM lançou a versão 2.0 do OS/2 no início dos anos 90. O sistema foi uma grande melhora sobre o antigo OS/2 v1.3. Apresentava um novo sistema de janelas orientado a objetos (o Workplace Shell) para substituir o Presentation Manager, um novo sistema de arquivos (o HPFS) para substituir o sistema FAT utilizado pelo DOS e Windows e aproveitou todas as vantagens das capacidades 32 bits do processador 386 da Intel. Ele também rodava programas DOS e Windows 3.0, uma vez que a IBM tinha acesso e direito a essas duas tecnologias.&lt;/p&gt;
&lt;p&gt;Para concorrer com a IBM, a Microsoft lançou o Windows 3.1, com pequenas melhorias à sua versão anterior, a 3.0.&lt;/p&gt;
&lt;p&gt;A Microsoft continuou a desenvolver o Windows NT. A empresa requeriu os serviços de Dave Cutler, um dos chefes arquitetos da VMS na Digital Equipment Corporation (hoje parte da Compaq) para desenvolver o NT dentro de um projeto de sistema operacional mais capaz. Cutler estava desenvolvendo um seguimento para o VMS na DEC chamado Mica, e quando a DEC desistiu do projeto ele acabou trazendo para a Microsoft sua especialidade nesse sistema e algum engenheiros do projeto com ele. A DEC acreditava que ele usara parte do código do Mica no Windows NT e acabou processando a Microsoft. A empresa de Gates teve que eventualmente pagar 150 milhões para a DEC, além de concordar em suportar o chip Alpha CPU da DEC na plataforma NT.&lt;/p&gt;
&lt;p&gt;Sendo um sistema operacional completamente novo, Windows NT sofreu com questões de compatibilidade com hardware e software geralmente usados na época. Ele era também concentrado em recursos, o que o deixava aceitável apenas para máquinas maiores e mais caras. Tanto que inicialmente foi dirigido a servidores de rede, workstations e máquinas de desenvolvimento de software. Por causa disso, a maioria dos usuário foi incapaz de migrar para a plataforma NT. E o Windows NT ainda estava projetado graficamente como o Windows 3.1, o que era inferior ao OS/2 Workplace Shell. Em resposta, a Microsoft começou a desenvolver um sucessor para o Windows 3.1, um projeto de codinome Chicago. Chicago tinha por objetivo apresentar uma nova GUI que competisse com o OS/2 Workplace Shell. Ele também foi projetado para ser de 32 bits e suportar execução multitarefa, como o OS/2 e o Windows NT. Só algumas partes do Chicago, entretanto, foram convertidas para 32 bits, e o resto permaneceu em 16. A Microsoft argumentou que a conversão total iria atrasar em muito o projeto, o que acabaria por encarecê-lo além do limite.&lt;/p&gt;
&lt;p&gt;Para Chicago, foi desenvolvida uma nova API para substituir a de 16 bits do Windows anterior. Essa API foi chamada de Win32, e a outra renomeada para Win16. Houveram 3 ramificações: uma para o Chicago, outra para o NT e uma terceira chamada Win32s, que foi um subconjunto para o Windows 3.1 garantir a compatibilidade retroativa das versões. Também foi pensado num mínimo de compatibilidade entre o Chicago e o Windows NT, mesmo que os dois possuissem duas arquiteturas radicalmente diferentes.&lt;/p&gt;
&lt;p&gt;Em setembro de 1994 é lançada o Windows NT 3.5. A versão Workstation substituiu o Windows NT 3.1 e a versão Server o Windows NT 3.1 Advanced Server.&lt;/p&gt;
&lt;p&gt;Como todo projeto de sucesso, a primeira coisa a ser feita é definir os objetivos principais. No caso do Windows NT não foi diferente. É importante para nós sabermos que objetivos eram esses e como eles foram mudando de acordo com o momento histórico de forma a analisarmos as conseqüências. Em outubro de 1988, os objetivos do novo sistema operacional eram os seguintes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;Compatibilidade com OS/2&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Segurança&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Suporte a POSIX&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Multiprocessamento&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rede integrada&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Confiabilidade&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Como o Windows 3.0 fez um sucesso enorme, a compatibilidade nativa passou a ser do próprio Windows caseiro, sendo o OS/2 sendo implementado como um mero subsistema. Subsistema no Windows basicamente quer dizer ambiente virtual de execução de processos feitos para rodar em outro sistema operacional. Essa maneira de suportar processos de outros sistemas operacionais foi usado tanto para o OS/2 quanto para o Windows 16 bits, o MS-DOS e aplicativos POSIX.&lt;/p&gt;
&lt;p&gt;O tempo do projeto foi inicialmente estimado em pouco mais de dois anos. Ao final, quatro anos e meio se passaram até a chegada do primeiro release, que era grande e lento para as máquinas da época. Assim foi iniciado o projeto Daytona, que teve como novos objetivos tornar a nova versão do NT mais rápida e confiável. Foi lançada então a versão 3.51.&lt;/p&gt;
&lt;p&gt;O Windows NT é um sistema operacional de 32 bits. Isso quer dizer, entre outras coisas, que ele suporta duas propriedades fundamentais dos sistemas operacionais modernos: modo protegido de execução e memória virtual. O modo protegido de execução permite a divisão entre a parte confiável do sistema operacional (kernel mode) e a parte não-confiável, que não possui acesso às instruções privilegiadas (user mode). A memória virtual abstrai a memória física e permite isolamento de memória entre aplicativos, evitando que um programa invada a memória do outro.&lt;/p&gt;
&lt;p&gt;Além disso, foi criada uma camada de abstração do hardware (HAL, Hardware Abstraction Layer) que livrou boa parte do código de ter sido escrito em assembly, fazendo assim que ele fosse facilmente portável. A figura abaixo demonstra a divisão básica entre os componentes do sistema, tanto do kernel mode quanto do user mode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inside Microsoft Windows NT, by David Solomon&lt;/li&gt;
&lt;li&gt;Inside Microsoft Windows 2000, by David Solomon&lt;/li&gt;
&lt;li&gt;Windows Internals, by Mark Russinovich&lt;/li&gt;
&lt;li&gt;Outros artigos sobre a história do windows&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 3.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-30/</link>
  <pubDate>2007-08-03</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-30/</guid>
  <description>&lt;p&gt;Em 22 de maio de 1990 a versão 3.0 do Windows foi lançada. Foi melhorado o gerenciador de programas e o sistema de ícones, além de um novo gerenciador de arquivos e suporte a 16 cores. Entre as mudanças internas podemos citar a velocidade e a confiabilidade. Como a partir dessa versão apareceram muitos desenvolvedores que passaram a suportar a plataforma, o número de programas disponíveis aumentou, o que conseqüentemente fez com que as vendas alavancassem. Três milhões de cópias foram vendidas apenas no primeiro ano, e assim o Windows se tornou padrão nos computadores domésticos. Quando a versão 3.1 foi lançada, em 6 de abril de 1992, mais três milhões de cópias foram vendidos em apenas dois meses.&lt;/p&gt;
&lt;p&gt;As fontes TrueType foram adicionadas, junto de novas capacidades multimídia. Outro grande avanço foi na área de comunicação entre aplicativos com a implementação da tecnologia OLE (Object Linking and Embedding), que permitiu documentos de diferentes fabricantes serem intercambiados.&lt;/p&gt;
&lt;p&gt;Em novembro de 1993 foi lançada a primeira versão que integrou o Windows e a rede de trabalho, o Windows for Workgroups 3.1. O suporte a compartilhamento de arquivos e impressoras apareceu a partir daí. Duas aplicações novas também surgiram: Microsoft Mail, cliente de mail para uso em redes, e Schedule+, uma agenda de trabalho.&lt;/p&gt;
&lt;p&gt;E, finalmente, agora já é hora de conversarmos sobre...&lt;/p&gt;
&lt;p&gt;Programar interfaces naquela época não era bem o &amp;quot;clicar e arrastar&amp;quot; de hoje em dia. Eram necessários profundos conhecimentos sobre como o sistema operacional se relacionava com o seu programa e vice-versa. Hoje em dia é possível ainda programar como antigamente, já que toda a estrutura continua a mesma. Porém, é algo extremamente contraprodutivo de se fazer com as IDEs modernas que existem e suas barras de controles pré-fabricados e código automático. Faremos da forma mais rústica para entender como as coisas funcionam por baixo dos panos, o que por si só será extremamente produtivo para o nosso conhecimento.&lt;/p&gt;
&lt;p&gt;Antes de ser criada uma janela, é necessário registrar uma classe de janela no sistema, cuja relação com uma janela é mais ou menos a mesma entre classe e objeto no paradigma de orientação a objetos. Você primeiro define uma classe para sua janela e posteriormente pode criar inúmeras janelas a partir da mesma classe.&lt;/p&gt;
&lt;p&gt;Quando você define uma classe e a registra está dizendo para o sistema qual será sua função de janela, i. e., qual será a função responsável por receber as mensagens das janelas criadas.&lt;/p&gt;
&lt;p&gt;Uma mensagem é um evento que ocorre relativo à sua janela ou o que está acontecendo ao redor dela no mundo Windows. Por exemplo, as janelas recebem eventos a respeito dos cliques do usuário, redesenho da janela, etc. Quem envia essas mensagens é o próprio Windows, e ele espera uma resposta da sua função de janela. Agora a parte esquisita: quem envia essas mensagens para o Windows é o seu próprio aplicativo!&lt;/p&gt;
&lt;p&gt;O aplicativo fica aguardando por eventos em um loop conhecido como loop de mensagens. A função do loop basicamente é chamar a função GetMessage e redirecionar as mensagens obtidas para as respectivas funções de janela.&lt;/p&gt;
&lt;p&gt;E aqui está o código completo:&lt;/p&gt;
&lt;p&gt;Esse exemplo é bem velho, mas compila e funciona até hoje, depois de passados 17 anos:&lt;/p&gt;
&lt;p&gt;O Windows 3.x tinha uma particularidade nefasta: qualquer aplicativo poderia travar o sistema como um todo. Se lembrarmos que o Windows antigamente era multitarefa e não-preemptivo, podemos deduzir que enquanto é executada a função de janela de um aplicativo o sistema aguarda por esse aplicativo indefinidamente. Se o aplicativo trava, ele nunca retorna. Se ele nunca retorna, o sistema fica eternamente esperando pelo retorno da função de janela. Alguns travamentos conseguiam ser resolvidos por interrupção, mas a maioria não. No próximo capítulo da série veremos como os sistemas de 32 bits resolveram esse pequeno problema.&lt;/p&gt;
&lt;p&gt;O que o resto do código do Petzold faz? Dê uma olhada na documentação do MSDN. Ela ainda está disponível, já que todos os aplicativos precisam utilizar essas funções, seja diretamente ou através de imensos frameworks de interface com o usuário. E existem pessoas que precisam suportar código-fonte legado.&lt;/p&gt;
&lt;p&gt;Já que agora você sabe o que são funções de janela, mensagens e afins, por que não ver tudo isso funcionando? O Microsoft Visual Studio possui uma ferramenta muito útil para isso chamada Spy++ (spyxx.exe). Existem também aplicativos equivalentes (com fonte). Outra ferramenta muito útil, principalmente na hora de desenvolver janelas com controles comuns do Windows, é o Control Spy.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Site de Charles Petzold&lt;/li&gt;
&lt;li&gt;Outros artigos sobre a história do windows&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>História da linguagem C - parte 1</title>
  <link>http://www.caloni.com.br/historia-da-linguagem-c-parte-1/</link>
  <pubDate>2007-08-01</pubDate>
  
  <guid>http://www.caloni.com.br/historia-da-linguagem-c-parte-1/</guid>
  <description>&lt;p&gt;Confesso que adoro estudar sobre a história da linguagem C. Essa verdadeira adoração pela linguagem me fez estudar suas precursoras, como as linguagens BCPL e B. Posso dizer que todo esse conhecimento, no final das contas, valeu a pena. Hoje entendo muito melhor as decisões tomadas na criação da linguagem e, principalmente, a origem de algumas idiossincrasias e boas idéias que permaneceram até hoje.&lt;/p&gt;
&lt;p&gt;Em 21 de julho de 1967 Martin Richards libera o manual da sua recém-criada linguagem BCLP. Na verdade, ela havia sido criada em 66 e implementada na primavera do ano seguinte no Instituto de Tecnologia de Massachusetts (vulgo MIT). Seus objetivos eram claros, como para todo criador de uma nova linguagem: melhorar uma linguagem anterior. Nesse caso, foi uma melhoria da Combined Programming Language (CPL), retirando, de acordo com Martin, &amp;quot;todas aquelas características da linguagem completa que tornavam a compilação difícil&amp;quot;.&lt;/p&gt;
&lt;p&gt;E BCPL era de fato bem simples. Não tinha tipos, era limpa e poderosa. Porém, mais importante que tudo isso, ela era portável. E essa portabilidade, aliada ao fato que escrever compiladores para ela era bem mais simples (alguns compiladores rodavam com apenas 16 KB), a tornaram especialmente popular na época.&lt;/p&gt;
&lt;p&gt;Essa portabilidade era obtida com o uso de um artifício mais ou menos conhecido da comunidade C/C++ hoje em dia: a divisão entre código objeto e código final. O compilador era dividido em duas partes: a primeira parte era responsável por criar um código em estado intermediário feito para rodar em uma máquina virtual. Esse código era chamado de O-code (O de object). A segunda parte do compilador era responsável por traduzir esse O-code no código da máquina-alvo (onde iria ser rodado o programa). Essa sacada genial de 40 anos atrás permitiu que fosse mais simples fazer um compilador para uma nova plataforma e portar todo o código que já tinha sido escrito para uma plataforma anterior, driblando o grande problema daquela época: a incompatibilidade entre plataformas.&lt;/p&gt;
&lt;p&gt;Perceba que é possível fazer toda a parte do compilador detrás do código-objeto uma única vez e, conforme a necessidade, criar novos interpretadores BCPL para máquinas diferentes.&lt;/p&gt;
&lt;p&gt;O código intermediário é gerado para uma máquina virtual. O interpretador, cerca de um quinto do compilador, tem a função de traduzir o código gerado para a máquina-alvo. Qualquer semelhança com Java ou .NET não é mera coincidência. Pois é. As boas idéias têm mais idade que seus criadores.&lt;/p&gt;
&lt;p&gt;É inevitável também não fazer a associação entre essa forma de funcionamento do compilador BCPL e a divisão feita em C/C++ entre o pré-processador, o compilador e o ligador (linker, em inglês).&lt;/p&gt;
&lt;p&gt;O uso do pré-processador na linguagem C facilitou a portabilidade por um bom tempo, quando não existiam typedefs. Diferente do BCPL, C já tinha tipagem, o que quer dizer que era necessário escolher o espaço de armazenamento que seria utilizado para as variáveis. Com o pré-processamento, essa escolha pode ser feita de maneira seletiva, documentada e generalizada.&lt;/p&gt;
&lt;p&gt;Como é natural, o código-fonte de uma aplicação tende a crescer em muitas linhas durante sua evolução, especialmente se estamos falando de sistemas operacionais. A compilação desse código vai tomar cada vez mais tempo no processo de desenvolvimento. Por isso, manter esse código-fonte em um mesmo arquivo eventualmente torna-se inviável, tornando a compilação de módulos separados uma solução pra lá de elegante. Compila-se apenas o módulo que foi modificado e liga-se esse módulo com módulos pré-compilados.&lt;/p&gt;
&lt;p&gt;Para saber mais:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bell Labs&lt;/li&gt;
&lt;li&gt;BCPL Reference Manual by Martin Richards&lt;/li&gt;
&lt;li&gt;Parte 2&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>C and C&#43;&#43; Operators Precedence Table</title>
  <link>http://www.caloni.com.br/c-and-c-operators-precedence-table/</link>
  <pubDate>2007-07-30</pubDate>
  
  <guid>http://www.caloni.com.br/c-and-c-operators-precedence-table/</guid>
  <description>&lt;blockquote&gt;
&lt;p&gt;Wanderley, your explanation about why a program compiles in C++ and not in C seems to me logic and correct, but gave me some doubts, because I always learned that the C and C++ operator precedence are the same thing. I checked out the Appendix A in the &amp;quot;C ++ - How To Program&amp;quot; (sixth edition) and the book table is equal to the C operators precedence table and it is different from the C++ precedence table presented by you in the article. I went to the internet and found out in two websites the table and both are equal to the book table.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/OperatorsinCandC&#34;&gt;http://en.wikipedia.org/wiki/OperatorsinCandC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://www.cppreference.com/operatorprecedence.html&#34;&gt;http://www.cppreference.com/operatorprecedence.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From where did you get the presented C++ table?&lt;/p&gt;
&lt;p&gt;[]s,&lt;/p&gt;
&lt;p&gt;Márcio Andrey Oliveira&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Dear Márcio,&lt;/p&gt;
&lt;p&gt;You have been my most productive reader ever. Besides having found the portability fail using static variables inside ifs, now you put in check the precedence table comparison between these two languages. In fact, some things were not so clear in that post. Let&#39;s clarify everything now (or at least try) using trustworthy sources, including the Wikipedia link sent to me.&lt;/p&gt;
&lt;p&gt;The first doubt it&#39;s about the most basic principle: what is a precedence table? Well, it is who defines, amount a set of concurrent operations in a language, which will be the evaluation order. In other words, who cames first, who cames next, etc. Through this table is possible to know all the language facts, as the fact that the multiplication operators are evaluated before the addition operators.&lt;/p&gt;
&lt;p&gt;This way, the table can resolve 99% of the evaluation order issues in a language, but it is not perfect.&lt;/p&gt;
&lt;p&gt;Let&#39;s see, by example, the conditional operator, most of the times known by ternary operator. Given its peculiar format, even having the precedence lower than the comma operator, the language doesn&#39;t allow a misinterpretation. If so,&lt;/p&gt;
&lt;p&gt;will be interpreted as&lt;/p&gt;
&lt;p&gt;and not as&lt;/p&gt;
&lt;p&gt;that would be the logic result if we followed the precedence table, since the comma operator has lower precedence than the ternary operator. But that doesn&#39;t make any sense in the language, and that&#39;s why the first form is understood by the compiler, even contradicting the precedence table. This is corroborated by the following quote from Wikipedia:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A precedence table, while mostly adequate, cannot resolve a few details. In particular, note that the ternary operator allows any arbitrary expression as its middle operand, despite being listed as having higher precedence than the assignment and comma operators.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That is one of the reasons why the precedence table is just a way to express the grammar rules of a language in a simple and resumed manner. It is not the grammar neither ought to be. Let&#39;s see one more quotation, this time from the Stroustrup himself, just after presented the C++ precedence table (by the way, that was the source used by me to get the table for my post):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A few grammar rules cannot be expressed in terms of precedence (also known as binding strength) and associativity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We can see from my example, the Wikipedia example and the Stroustrup example that the ternary operator is the main victim. Not for less. Talking about the grammar, the C ternary operator definition is different from the C++ ternary operator definition. While in C this operator is defined like this:&lt;/p&gt;
&lt;p&gt;In C++ language it is defined like this:&lt;/p&gt;
&lt;p&gt;This little difference can give us some (rare) situations where we can get a syntax error in C. As in a Wikipedia example , the following expression:&lt;/p&gt;
&lt;p&gt;is interpreted by the C language as:&lt;/p&gt;
&lt;p&gt;In the C++ language is interpreted as:&lt;/p&gt;
&lt;p&gt;In the C language case, we have a compilation error because the code is trying to assign a value to a lvalue (remember that lvalues can&#39;t be assigned to anything).&lt;/p&gt;
&lt;p&gt;But in C++ there&#39;s no invalid assignment, what makes a no error compilation performed.&lt;/p&gt;
&lt;p&gt;Now, one last question, that seems to be the most relevant in this precedence issue:&lt;/p&gt;
&lt;p&gt;Why is the Stroustrup book precedence table different from the C precedence table?  Well, I believe that, after all our analysis, the answer must be somewhat obvious: knowing that, in the ternary operator, the third operand is an assignment-expression, it is most likely the table is agree with the grammar if we put a extra weight for the assignment operators before the ternary operator. This way, if the third operand is an assignment operation (as the case above), the imaginary parentesis will be put first in the assignment operation, making the grammar definition valid (green is in C++; red is in C):&lt;/p&gt;
&lt;p&gt;I hope this second post about the precedence table have cleared a bit more about the subject. Is not easy to understand the C language, but once you start to try, one magic door opens. Some things to remember from this experience:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The precedence table is not in the Standard; it is deduced from the grammar rules.&lt;/li&gt;
&lt;li&gt;There are rare expressions where we can&#39;t use the precedence table (e.g. ternary operator).&lt;/li&gt;
&lt;li&gt;Nobody knows so well a language to the point to understand 100% from it; after all, nobody (and nothing) is perfect.&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Movendo o cursor do mouse com o teclado</title>
  <link>http://www.caloni.com.br/movendo-o-cursor-do-mouse-com-o-teclado/</link>
  <pubDate>2007-07-26</pubDate>
  
  <guid>http://www.caloni.com.br/movendo-o-cursor-do-mouse-com-o-teclado/</guid>
  <description>&lt;p&gt;Bom, vamos deixar de papo furado e &amp;quot;codar&amp;quot;. Para essa primeira tentativa iremos desenvolver um programa que move o cursor do mouse quando pressionada uma tecla de atalho e voltar à sua posição original quando pressionada outra tecla.&lt;/p&gt;
&lt;p&gt;Nota de desculpas: eu sei que estou sendo rabugento demais com o mouse. Já é o segundo artigo que escrevo falando como evitar o mouse e isso deve realmente irritar os fãs desse ponteirinho irritante.&lt;/p&gt;
&lt;p&gt;Como eu já havia dito anteriormente, uso o mouse quando necessário. Quando ele não é necessário ele fica clicando inconscientemente no Windows Explorer, já que utilizo a configuração de clique único, onde as pastas e arquivos ficam selecionáveis apenas pousando o cursor sobre eles. Eu gosto dessa configuração, exceto pelo comportamento desagradável que ocorre quando mudo para a janela do Windows Explorer e meu mouse ganha vida própria, selecionando alguma pasta ou arquivo e mudando meu foco de seleção.&lt;/p&gt;
&lt;p&gt;Portanto, o objetivo desse programa é simples e direto: mover o mouse para um canto enquanto eu uso meu teclado. Nada mais, nada menos. Para isso iremos registrar alguns atalhos globais no Windows. Para registrar atalhos globais no Windows utilizamos a função RegisterHotKey.&lt;/p&gt;
&lt;p&gt;O importante aqui é saber que iremos ser avisados do pressionamento das teclas que registrarmos por meio dessa função através do loop de mensagens da thread que chamar a função.&lt;/p&gt;
&lt;p&gt;Resumidamente, um loop de mensagens é a maneira definida pelo Windows para avisar as aplicações dos eventos que ocorrerem no sistema que são relevantes para as suas janelas. Teremos chance de observar isso mais vezes, mas por enquanto basta ter uma visão geral do fluxo de mensagens que ocorre quando digitarmos a nossa tecla de atalho:&lt;/p&gt;
&lt;p&gt;Como você pode ver o código não tem muitos segredos. Para registrar os atalhos, usamos a função RegisterHotKey. Para manipular os eventos usamos o tal loop de mensagens e manipulamos a mensagem WMHOTKEY de acordo com a tecla pressionada. Para mover o mouse usamos a função SetCursorPos (e para armazenar a posição atual GetCursorPos). Por fim, para ler configurações de um .ini usamos a função GetPrivateProfileInt. Abaixo um exemplo desse arquivo texto:&lt;/p&gt;
&lt;p&gt;Nota final: você acha que os atalhos &amp;quot;WinKey + Del&amp;quot;, &amp;quot;WinKey + Insert&amp;quot; e &amp;quot;WinKey + End&amp;quot; foram uma má escolha? Concordo. Fiz de propósito. Que tal customizar o programa para que as teclas sejam lidas do arquivo de configuração HideCursor.ini?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>C&#43;&#43;0x parcial no novo GCC 4.3</title>
  <link>http://www.caloni.com.br/c0x-parcial-no-novo-gcc-43/</link>
  <pubDate>2007-07-24</pubDate>
  
  <guid>http://www.caloni.com.br/c0x-parcial-no-novo-gcc-43/</guid>
  <description>&lt;p&gt;A nova versão do GCC implementa em caráter de teste algumas novas características da nova versão da linguagem C++, que será lançada ainda nesta década (provavelmente em 2009). As novas funcionalidades são empolgantes e já fazem parte do imaginário dos programadores C++ já há algum tempo.&lt;/p&gt;
&lt;p&gt;Atualmente temos duas maneiras de fazer asserções: usando a função assert (assert.h) ou utilizando a diretiva do pré-processador #error. Nenhum desses dois serve para templates. Para eles deverá ser definida a nova palavra-chave staticassert, que irá ser composta de dois parâmetros:&lt;/p&gt;
&lt;p&gt;Podemos usá-la tanto no lugar da função assert quanto da diretiva #error. Mas seu uso mais interessante é como limite para a instanciação de templates:&lt;/p&gt;
&lt;p&gt;Existem outros lugares onde esse novo comando pode ser usado. Para saber quando usá-lo, lembre-se que a verificação é feita durante a compilação, diferente do assert tradicional, que é chamada em tempo de execução.&lt;/p&gt;
&lt;p&gt;Quem diria: depois de todos esse anos o pré-processador sofrerá um upgrade. O objetivo é ser compatível com o novo padrão da linguagem C, o C99. A maior novidade fica por conta do número variável de parâmetros para macros. A linha abaixo resume tudo:&lt;/p&gt;
&lt;p&gt;Ou seja, não será mais necessário usar o truque dos &amp;quot;parênteses duplos&amp;quot; em macros de log que formatam parâmetros.&lt;/p&gt;
&lt;p&gt;Considero essa mudança a mais interessante. Com ela será possível usar um número variável de parâmetros em templates. Basicamente isso permite que um dado template aceite um número variável de parâmetros e esses parâmetros sejam &amp;quot;expandidos&amp;quot; em inúmeras construções dentro do escopo desse template. Nada melhor para explicar que um exemplo, como o caso da herança múltipla. Imagine um template que precisa herdar de seus parâmetros, mas não quer especificar a quantidade:&lt;/p&gt;
&lt;p&gt;Outras pequenas correções também serão feitas para tornar a linguagem mais robusta:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Referências para &lt;em&gt;lvalue.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Parâmetros &lt;em&gt;default&lt;/em&gt; em funções-&lt;em&gt;template.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Problema do fecha-&lt;em&gt;templates&lt;/em&gt; duplo (&amp;gt;&amp;gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Podemos esperar por outras grandes mudanças que irão ocorrer nesse novo padrão? Não exatamente. As principais estarão na biblioteca C++, com a inclusão de diversas classes e funções do projeto Boost. O resto são pequenas correções e melhorias de uma linguagem que, cá entre nós, já está bem poderosa e complexa.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Antidebug: interpretação baseada em exceção (parte 1)</title>
  <link>http://www.caloni.com.br/antidebug-interpretacao-baseada-em-excecao-parte-1/</link>
  <pubDate>2007-07-20</pubDate>
  
  <guid>http://www.caloni.com.br/antidebug-interpretacao-baseada-em-excecao-parte-1/</guid>
  <description>&lt;p&gt;Um depurador utiliza breakpoints para &amp;quot;paralisar&amp;quot; momentaneamente a execução do programa sendo depurado. Para isso ele se utiliza de uma bem conhecida instrução conhecida como int 3. Essa instrução gera uma exceção - exceção de breakpoint - que é capturada pelo sistema operacional e repassada para o código de tratamento dessa exceção. Em programas sendo depurados esse código está localizado no depurador. Em programas &amp;quot;livres&amp;quot; esse código normalmente não existe e ao acontecer essa exceção o aplicativo simplesmente &amp;quot;capota&amp;quot;.&lt;/p&gt;
&lt;p&gt;A idéia principal na proteção baseada em exceção é tomarmos conta dessas exceções durante a execução do aplicativo. Fazendo isso podemos nos aproveitar desse fato e, no código responsável por tratar a exceção, executar o código protegido. A solução discutida aqui é parecido com um interpretador de scripts. Consiste basicamente de duas threads. A primeira thread lê uma seqüência de instruções e manda a segunda thread executá-las passo a passo. Para fazer isso a segunda thread usa um conjunto de pequenas funções com blocos de código bem definidos. Em pseudocódigo isso ficaria assim:&lt;/p&gt;
&lt;p&gt;A proteção ainda não está aí. Mas fará parte intrínseca da thread de execução. Tudo que precisamos fazer é adicionar um tratamento de exceções e fazer chover ints 3. As exceções disparadas pela int 3 são capturadas por uma segunda função que antes de retornar o controle executa a próxima instrução enfileirada:&lt;/p&gt;
&lt;p&gt;O algoritmo da thread de execução continua o mesmo. Só que o ponto onde cada instrução é executada depende do lançamento de uma exceção. Note que essa exceção tem que ocorrer para que a chamada da próxima instrução ocorra. Isso é fundamental, pois dessa forma ninguém pode simplesmente retirar o int 3 do código para evitar o lançamento da exceção. Se fizer isso, então mais nenhuma instrução será executada.&lt;/p&gt;
&lt;p&gt;Na prática, se alguém tentar depurar um programa desse tipo vai ter que enfrentar dezenas ou centenas de lançamento de exceções até descobrir o que está acontecendo. Claro que, como em toda a proteção de software, ela não é definitiva; tem por função dificultar o trabalho de quem tenta entender o software. Isso não vai parar aqueles que são realmente bons no que fazem.&lt;/p&gt;
&lt;p&gt;O preço pago por essa proteção fica na visibilidade e compreensão do código-fonte comprometidos pelo uso da técnica. A programação fica baseada em uma máquina de estados e as funções ficam limitadas a algum tipo de padronização no comportamento. Quando mais granular for o pseudoscript, ou seja, quanto menores forem os blocos de código contido nas minifunções, mais difícil de entender o código será.&lt;/p&gt;
&lt;p&gt;O exemplo abaixo recebe entrada por um prompt de comandos e mapeia a primeira palavra digitada para o índice de uma função que deve ser chamada. O resto da linha digitada é passado como parâmetro para essa função. A thread de interpretação lê a entrada do usuário e escreve em uma variável-string global, ao mesmo tempo que a thread de execução espera essa string ser preenchida para executar a ação. Foi usado o pool dessa variável para o código ficar mais simples, mas o ideal seria algum tipo de sincronismo, como eventos, por exemplo.&lt;/p&gt;
&lt;p&gt;O ponto forte da proteção é que a pessoa precisa entender o que está acontecendo para tomar alguma atitude inteligente para solucionar o &amp;quot;problema&amp;quot;. O ponto fraco é que após entendido o problema a solução torna-se fácil de visualizar. Tão fácil que eu nem pretendo citar aqui.&lt;/p&gt;
&lt;p&gt;Futuramente veremos uma maneira de tornar as coisas mais legíveis e usáveis no dia-a-dia de um programador de software de segurança.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Como ser um melhor desenvolvedor nos próximos seis meses</title>
  <link>http://www.caloni.com.br/como-ser-um-melhor-desenvolvedor-nos-proximos-seis-meses/</link>
  <pubDate>2007-07-18</pubDate>
  
  <guid>http://www.caloni.com.br/como-ser-um-melhor-desenvolvedor-nos-proximos-seis-meses/</guid>
  <description>&lt;p&gt;Graças ao meu amigo Thiago estive acompanhando uma série de posts de gente renomada sobre o tema deste artigo. Eles fazem parte de uma nova modalidade entre os blogueiros (pelo menos para mim) chamada de tagging. Funciona assim: você escreve sobre algo (por exemplo, &amp;quot;como ser um melhor cozinheiro em 6 meses&amp;quot;) e manda uma tag para que outras pessoas também escrevam sobre o mesmo assunto, o que pode ser feito referenciando o sítio dessas pessoas.&lt;/p&gt;
&lt;p&gt;Ainda não tive tempo de ler todos os artigos (nem vou ter, pela velocidade com que isso se espalha), mas acho que dá tempo de escrever um pouco sobre isso.&lt;/p&gt;
&lt;p&gt;Acredito que nós, programadores/desenvolvedores/depuradores, tentamos aprimorar nossos conhecimentos e nossas técnicas com o objetivo de enxergar os problemas do dia-a-dia de todos os ângulos e de encará-los e resolvê-los da melhor maneira possível. Quer dizer, nós achamos que é a melhor maneira possível. E exatamente por acharmos que tentamos melhorar sempre, em busca da inalcançável perfeição.&lt;/p&gt;
&lt;p&gt;O problema existe quando nós, embriagados pela falsa crença de sabermos tudo (ou o suficiente), acreditamos realmente que estamos fazendo o melhor possível e que não há nem haverá maneira de melhorar. É lógico que sempre há. Melhor maneira de ver isso é pegar um código-fonte antigo e observar as mudanças de estilo. E nem precisa ser tão antigo assim. E nem precisa ser código. Pode ser uma idéia antiga de como implementar alguma coisa. A não ser que você seja um teimoso que quer fazer tudo em assembly verá que o que aprendemos ontem influencia nas decisões de amanhã.&lt;/p&gt;
&lt;p&gt;Minha lista não é muito diferente da dos outros. Basicamente se resume em: ler livros e blogs, programar mais e pensar mais ainda. O importante é que já estou ciente das coisas que devo melhorar, e é nelas que devo me focar nos próximos 180 dias:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fazer um curso de memorização. Confesso que não ligava muito para isso e agora isso faz um diferença e tanto. Eu sei que hoje temos &lt;em&gt;post-its&lt;/em&gt; e agendas, mas nada substitui a confiança que temos em nossa própria mente. E é frustrante ler um livro três meses atrás e não se lembrar de capítulos inteiros.&lt;/li&gt;
&lt;li&gt;Fazer um curso de leitura dinâmica. Minha velocidade na leitura é deplorável e eu sei disso. Minha vontade de ler sempre ultrapassa o ato (isso deve ter acontecido com alguns de vocês). Mas o objetivo não é apenas ler mais rápido. É ter foco. Ler e absorver. Não estou dizendo isso de livros de ficção, que para mim são um entretenimento prazeroso. São os livros técnicos que pertubam, e urgem pela minha atenção quando os estou lendo.&lt;/li&gt;
&lt;li&gt;Aprender o meu ritmo. Às vezes me impressiono com o meu descaso para comigo mesmo. Por exemplo, eu já sabia que &amp;quot;rendia&amp;quot; bem mais quando lia livros simultaneamente, e não em fila. Mas mesmo assim insistia em querer terminar um livro antes de começar o outro. O resultado? Aproveitamento 60%. Nada mau. Mas poderia ser bem melhor. Bastava seguir o método que melhor se adapte às minhas necessidades. E isso é o que eu chamo de aprender a si mesmo.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Agora que já passei pelo sofrimento de taguear nada como escolher minhas vítimas. Não conheço pessoalmente muitos blogueiros, mas pelo menos essa minha lista é fiel e sincera. Rodrigo Strauss, Fernando Roberto e Thiago Oliveira: o que vocês farão nos próximos seis meses para se tornarem melhores desenvolvedores (ainda)?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>What happens inside the sizeof operator</title>
  <link>http://www.caloni.com.br/what-happens-inside-the-sizeof-operator/</link>
  <pubDate>2007-07-16</pubDate>
  
  <guid>http://www.caloni.com.br/what-happens-inside-the-sizeof-operator/</guid>
  <description>&lt;p&gt;The question: how to get the size of a struct member without declaring it as a variable in memory? In pseudocode:&lt;/p&gt;
&lt;p&gt;In this first try (even being a nice one) we can clearly see by instinct that the construction is not supposed to work. The compiler error is not even clear. The member access operator (the point sign) needs to have as its left some variable or constant of the same type of the struct. Since the operand is the type itself, there is no deal.&lt;/p&gt;
&lt;p&gt;The second test is more feasible. Even the compiler can alert us. We have accessed the right member in the right struct but in the wrong way. As we&#39;re not using a static member or, in other words, a class variable, we can&#39;t access the member by scope. We need an object. But in order to have an object we are supposed to have to create one, and this is exactly what is not allowed in our solution.&lt;/p&gt;
&lt;p&gt;This kind of problem reminds me about a curious feature inside the sizeof operator: it doesn&#39;t evaluate the expressions used as operands. How&#39;s that? Well, as the sizeof main purpose is to provide us the memory size filled by the expression, it simply doesn&#39;t make sense to execute the expression. We just need to note that the language we&#39;re talking about defends eficiency and clarity as main principles. If you want to execute the expression, we do it without using sizeof operator.&lt;/p&gt;
&lt;p&gt;So, now we know that everything put inside a sizeof is not going to be executed in fact. It works somewhat like the c++ &amp;quot;dead zone&amp;quot;: is the place where - talking about executable code - nothing runs. That means we can build a object inside sizeof that nothing is going to happen, except for the expression size. Let&#39;s look the resulting assembly:&lt;/p&gt;
&lt;p&gt;Another way to do the same thing (for those who can&#39;t bear the use of operator new delete, seeing the code as a memory leak):&lt;/p&gt;
&lt;p&gt;Conclusion: the operator new is called and nothing happens. We got what we wanted. That shows us one more time that the little details built inside a language layout are only very important in the exact time we need them.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Desejo insano de programar no kernel</title>
  <link>http://www.caloni.com.br/desejo-insano-de-programar-no-kernel/</link>
  <pubDate>2007-07-12</pubDate>
  
  <guid>http://www.caloni.com.br/desejo-insano-de-programar-no-kernel/</guid>
  <description>&lt;p&gt;Muitas vezes meus amigos (um em particular) me perguntam por que não me interesso em programar em kernel mode, como se isso fosse um objetivo a ser alcançado por qualquer programador em user mode. Bom, não é.&lt;/p&gt;
&lt;p&gt;Claro que sempre me empenho em entender como o sistema funciona, nos menores detalhes e sempre que posso, o que nem sempre me leva para o kernel mode (entender como a CLR funciona, por exemplo). Posso até me considerar um ser privilegiado, já que trabalho com dois experts em kernel mode e .NET, respectivamente. Isso já faz algum tempo, e ambos possuem conhecimento e experiência necessários para sanar minhas dúvidas mais cruéis. Porém, uma coisa é o conhecimento da coisa. Outra coisa é a prática. E a teoria, como já dizia o Sr. Heldai, na prática é outra.&lt;/p&gt;
&lt;p&gt;Existem também aqueles programadores que, entorpecidos pela idéia de que seu software deve ser o mais baixo nível possível porque... bem, porque ele faz coisas muito profundas (?), ou é muito avançado (??), ou talvez até porque ele precisa ser otimizado ao máximo. Baseados nessas premissas (???), antes mesmo de conhecer o sistema operacional e pesquisar o que ele tem a oferecer que já está disponível em user mode partem direto para a programação nua e crua, pelo simples motivo de ser legal ou na ilusão de ser a melhor maneira de se fazer as coisas sob qualquer circunstância.&lt;/p&gt;
&lt;p&gt;Munidos de bons motivos para fazer drivers, o próximo passo seria então pedir ajuda desesperadamente (e urgentemente) em listas de discussões. Talvez esse seja o lugar menos apropriado para procurar por uma palavra amiga. Acompanhei por um tempo uma lista de kernel do Windows. Apenas para efeitos de descrição, o clima e a impressão com que fiquei de lá foi que os programadores em kernel não se dão muito ao trabalho de ajudar aqueles que estão perdidos no ring0. Então para que existe a lista? Aparentemente para aqueles que já sabem fazer o carro andar, já conhecem o motor e um pouco de mecânica dos fluidos.&lt;/p&gt;
&lt;p&gt;Digamos que é uma cultura bem diferente do que estamos acostumados a vivenciar em user mode. Eles estão muito mais ocupados com problemas relacionados especificamente com o desenvolvimento de drivers, e não dúvidas bestas do tipo &amp;quot;como eu faria isso&amp;quot;. Lá não se briga entre linguagens gerenciadas e não-gerenciadas (nem entre linguagens gerenciadas), mas entre linguagens C e C++. Lá não se ajuda a fazer aquelas &amp;quot;gambis&amp;quot; que tanto ajudam o programador na hora do sufoco, mas sim redirecionam os hereges para o desenvolvimento &amp;quot;politicamente correto&amp;quot; (siga a documentação e seja feliz).&lt;/p&gt;
&lt;p&gt;Isso não é uma crítica destrutiva, apenas uma descrição narrativa. Nada que falo aqui é exagero ou blasfêmia. Podem perguntar para o meu amigo de kernel mode. Aliás, use o blog dele para aprender um pouco sobre o kernel.&lt;/p&gt;
&lt;p&gt;O fato é que bons programadores são bons onde quer que eles estejam (e os ruins serão ruins em qualquer lugar). E ser um desenvolvedor de qualidade exige tempo, dedicação, paciência e estudo. Pode ser um designer usando Action Script ou um engenheiro da NASA projetando foguetes. Tanto faz. Fazer as coisas com qualidade sempre exigirá mais tempo do que gostaríamos de despender. Não é uma questão de ser mais difícil em kernel mode ou mais fácil em Javascript. É saber qual dos dois será necessário usar para atingir o nível de funcionalidade e qualidade que o projeto exige. O resto é preconceito.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Precedence difference</title>
  <link>http://www.caloni.com.br/precedence-difference/</link>
  <pubDate>2007-07-10</pubDate>
  
  <guid>http://www.caloni.com.br/precedence-difference/</guid>
  <description>&lt;p&gt;Once upon a time my old friend Kabloc wrote this little and &amp;quot;harmless&amp;quot; function in order to print the multiplication table:&lt;/p&gt;
&lt;p&gt;Despite the fact the result is a strong candidate to &amp;quot;The International Obfuscated C Code Contest&amp;quot;, the linux guys told him the code was not successful on GCC, and somewhere inside those four lines there was a non-standard piece of code.&lt;/p&gt;
&lt;p&gt;Asked to solve the problem, given my congenital inclination to random subjects involving C++, I decided to fix the things up in my old-n-good Visual Studio 2003. Nonetheless, it compiles C source code as well. We just need to rename the file from .cpp to .c. It was doing this that I found the following compiler error:&lt;/p&gt;
&lt;p&gt;That happens in the line 6, the first for line. In other words, a C source that compiles as C++ but gives us a lack of l-value error since compiled as pure C.&lt;/p&gt;
&lt;p&gt;Thinking about the problem rather intuitively than rationally I imagined that could be some little difference in the precedence table. Keeping that in mind, wrested the standard papers for both languages and took a look at the precedence tables.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Precedence&lt;/th&gt;
&lt;th&gt;Operator&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;th&gt;Associativity&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;++ --&lt;/td&gt;
&lt;td&gt;Suffix/postfix increment and decrement&lt;/td&gt;
&lt;td&gt;Left-to-right&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;()&lt;/td&gt;
&lt;td&gt;Function call&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[]&lt;/td&gt;
&lt;td&gt;Array subscripting&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;Structure and union member access&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&amp;gt;&lt;/td&gt;
&lt;td&gt;Structure and union member access through pointer&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(type){list}&lt;/td&gt;
&lt;td&gt;Compound literal(C99)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;++ --&lt;/td&gt;
&lt;td&gt;Prefix increment and decrement[note 1]&lt;/td&gt;
&lt;td&gt;Right-to-left&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+ -&lt;/td&gt;
&lt;td&gt;Unary plus and minus&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;! ~&lt;/td&gt;
&lt;td&gt;Logical NOT and bitwise NOT&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(type)&lt;/td&gt;
&lt;td&gt;Cast&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;Indirection (dereference)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;Address-of&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sizeof&lt;/td&gt;
&lt;td&gt;Size-of[note 2]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_Alignof&lt;/td&gt;
&lt;td&gt;Alignment requirement(C11)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;* / %&lt;/td&gt;
&lt;td&gt;Multiplication, division, and remainder&lt;/td&gt;
&lt;td&gt;Left-to-right&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;+ -&lt;/td&gt;
&lt;td&gt;Addition and subtraction&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&amp;lt;&amp;lt; &amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;Bitwise left shift and right shift&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&amp;lt; &amp;lt;=&lt;/td&gt;
&lt;td&gt;For relational operators &amp;lt; and ≤ respectively&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt; &amp;gt;=&lt;/td&gt;
&lt;td&gt;For relational operators &amp;gt; and ≥ respectively&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;== !=&lt;/td&gt;
&lt;td&gt;For relational = and ≠ respectively&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;Bitwise AND&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;Bitwise XOR (exclusive or)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Bitwise OR (inclusive or)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;Logical AND&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;?:&lt;/td&gt;
&lt;td&gt;Ternary conditional[note 3]&lt;/td&gt;
&lt;td&gt;Right-to-Left&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14[note 4]&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;Simple assignment&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;+= -=&lt;/td&gt;
&lt;td&gt;Assignment by sum and difference&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*= /= %=&lt;/td&gt;
&lt;td&gt;Assignment by product, quotient, and remainder&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;lt;= &amp;gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;Assignment by bitwise left shift and right shift&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;= ^=&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;Assignment by bitwise AND, XOR, and OR&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;,&lt;/td&gt;
&lt;td&gt;Comma&lt;/td&gt;
&lt;td&gt;Left-to-right&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Besides some now less important details, we can notice at the end of the table a inversion between the ternary operator and the attribution operator and, more importantly, the inversion of the evaluation order. In C, the ternary operator is evaluated from right to left, whilst in C++ from left to right, like the rest. This is going to shows us that, in line 6, the same expression has two different interpretations in each language.&lt;/p&gt;
&lt;p&gt;In order to understand bit by bit the problem, let&#39;s disassemble the second part of that for:&lt;/p&gt;
&lt;p&gt;We have two ternary operators nestled. In accordance with C++ standard, the ternary operators have less precedence than the attribution operators and are evaluated from left to right. In other words, in first place all the atributions inside the expression are made before any ternary operator. After that, the first ternary operator is executed, followed by the second:&lt;/p&gt;
&lt;p&gt;The parts in red are the first ones to run, followed by the green ones and, finally, by the blue ones. This color priority is completely arbitrary. Of course, the colors you see in your text editor doesn&#39;t have anything to do with this explanation.&lt;/p&gt;
&lt;p&gt;Now let&#39;t take a look in C. In this language, different from C++, the ternary operators have more precedence than the attribution operators, and are executed from right to left. That means the first and last ternary operators are executed, ignoring the right attribution, and after that the first ternary operator is executed. Only after these two events the right attribution is evaluated:&lt;/p&gt;
&lt;p&gt;All this make us to see the attribution to 12 will be done on the first ternary operator result, which possible values could be from the putchar return or f1. Remember about the comma operator purpose outside function calls: chain expressions, execute them and return the value from the rightmost expression:&lt;/p&gt;
&lt;p&gt;Well, the f1 variable is an integer. And putchar return as well. This is not going to break any type rule. However, breaks the attribution gold rule: &amp;quot;put an lvalue in the right side of an attribution&amp;quot;.&lt;/p&gt;
&lt;p&gt;This finishes the long explanation about why that little insignificant error at the beginning of this article happened only in the C language. This is a perfect example of the little differences between these two languages. Perhaps do you use parenthesis like a crazy, and are not going to find this kind of problems inside your source code. Perhaps not.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Google shortcuts</title>
  <link>http://www.caloni.com.br/google-shortcuts/</link>
  <pubDate>2007-07-06</pubDate>
  
  <guid>http://www.caloni.com.br/google-shortcuts/</guid>
  <description>&lt;p&gt;I do love shortcuts. Since my very first years using computers, shortcuts had become my obsession. I research them through the time, collecting them, using them. For a long time I avoid myself from touching the mouse, trainning to remember all keystroke sequences I know.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I have nothing against using the mouse neither the people that do it. I&#39;m just not very much enthusiastic in using mice. For sometime, I even believed that the cursor pointer was getting me annoyed, so I developed a program to get rid of it from the screen (using a shortcut, of course). But, one more time, I&#39;m not againt its use, and I use it myself sometimes (when I need to).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Until some time ago the web was not so good for shortcut users. So came out Google, plenty of web applications supporting shortcuts and giving me a true reason to use webmail and web RSS reader without pressing constantly the tab key. But there was a lack for its web search engine. Fortunately, there WAS.&lt;/p&gt;
&lt;p&gt;Even being in test, I began to use the new keyboard shortcuts in Google search, available in the Google Experimental Search website. Until now there is shortcuts for next result (J), previous result (K), opening the search (O or Enter) and putting the cursor in the search box (/). It is just like Gmail and Google Reader. I was so excited with the idea that I changed the Google search plugin inside Firefox by myself. And now I&#39;m going to tell how to do it (note: Windows only).&lt;/p&gt;
&lt;p&gt;Probably your search plugin will be in one of these two folder bellow. Try one of them:&lt;/p&gt;
&lt;p&gt;The search plugin file has the name google.xml and you can edit it using notepad or another simple text editor. Bellow is the point where you must insert the new line that will get the plugin able to show the shortcuts inside Google.&lt;/p&gt;
&lt;p&gt;That&#39;s all. Now you can get all the best: the best search engine with shortcuts. How can we be even more productive?&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 2.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-20/</link>
  <pubDate>2007-07-04</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-20/</guid>
  <description>&lt;blockquote&gt;
&lt;p&gt;Eu seu, eu sei. A maioria dos meus leitores odiou o tema história do Windows na era paleozóica. Porém, como eu disse na parte 1.0, estou apenas satisfazendo a outra parte de leitores que procurou no Google por esse tema e acabou caindo no meu antigo blog. Mas vejamos o lado bom: a partir da próxima versão iremos destrinchar a API do sistema, entendendo o porquê das coisas serem como elas são. No momento os deixo apenas com história, pois é desconhecido para mim como funcionavam os primeiros rabiscos do MS-DOS Shell, mais conhecido como Windows/386. Bom divertimento!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Assim, em 9 de dezembro de 1987, é lançado o aperfeiçoadíssimo Windows 2.0, que fez do PC um ambiente muito mais parecido com um computador Macintosh. O novo sistema possui ícones para representar programas e arquivos, fornece suporte para memória expandida e janelas que podem se sobrepor(!). Porém, ainda utilizava o modelo de memória do 8088 e portanto era limitado a 1 Megabyte, ainda que certas pessoas houvessem tido sucesso rodando o sistema em cima de outro multitarefa como DesqView.&lt;/p&gt;
&lt;p&gt;A Apple, vendo a extrema semelhança entre seu sistema e o Windows, abriu um processo em 1988 alegando ter a Microsoft quebrado o acordo feito em 1985. A Microsoft se defendeu tendo o argumento que a licença lhe dava o direito do uso dessas características. Uma guerra judicial se arrastou por quatro anos. A Microsoft ganhou. Ao final, a Apple declarou que a Microsoft havia infligido 170 de seus copyrights. A corte judicial disse que o acordo de licença dava direito de uso da Microsoft de todos menos nove. Então a Microsoft alegou que os copyrights restantes não poderiam ser reinvidicados pela lei do copyright, já que a Apple pegou suas idéias da interface gráfica desenvolvida pela Xerox em seus computadores Star. Assim, um impresso de 01/06/93, disponível no Microsoft Timeline, resumiu a solução final:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Microsoft announces that Judge Vaughn R. Walker of the U.S. District Court of Northern California ruled today in Microsoft&#39;s favor in the Apple vs. Microsoft and Hewlett-Packard copyright suit. The judge granted Microsoft&#39;s and Hewlett-Packard&#39;s motions to dismiss the last remaining copyright infringement claims against Microsoft Windows 2.03 and 3.0, as well as, the HP NewWave.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Uma outra frase resume o caminho trilhado pela empresa a partir de então:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Microsoft become the top software vendor in 1988 and never looked back...&amp;quot; - Microsoft&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Com o advento dos novos lançamentos da Intel, os processadores 80286 e 80386, o Windows acabou sendo atualizado duas vezes para aproveitar as novas características dos dois sistemas. E assim nasceram as versões 2.1.x do Windows, respectivamente conhecidas como Windows/286 e Windows/386.&lt;/p&gt;
&lt;p&gt;A próxima versão do Windows é que vai alavancar as vendas da Microsoft de uma vez por todas. Veremos que boa parte da API que usamos hoje em dia já existia no Windows 3.0, e boa parte das peculiaridades que nos perseguem até hoje.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows 1.0 to XP: Screenshots&lt;/li&gt;
&lt;li&gt;Um vídeo divertidíssimo do Windows/386&lt;/li&gt;
&lt;li&gt;Outros artigos sobre a história do windows&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Introdução ao SoftICE</title>
  <link>http://www.caloni.com.br/introducao-ao-softice/</link>
  <pubDate>2007-07-02</pubDate>
  
  <guid>http://www.caloni.com.br/introducao-ao-softice/</guid>
  <description>&lt;p&gt;O que acontece quando você precisa depurar um programa e não tem o Visual Studio instalado na máquina onde o problema está ocorrendo? Ora, para isso que existe o Remote Debugging.aspx). Eu uso direto. Você só precisa rodar um pequeno programa na máquina que vai ser depurada e abrir uma porta ou duas. O resto o Visual Studio da máquina que vai depurar faz.&lt;/p&gt;
&lt;p&gt;Tudo bem, mas e se estamos falando de depuração em kernel mode? Bem, nesse caso o mais indicado é o nosso já conhecido WinDbg. Só precisamos de um cabo serial, firewire ou USB conectando as duas máquinas.&lt;/p&gt;
&lt;p&gt;A vida pode ser complicada às vezes. O WinDbg em versões antigas até rodava em plataforma 9x (95/98/ME), mas agora já não roda mais. Felizmente eu mantenho uma versão das antigonas, só para garantir. Só que ele rodava apenas para depurar em user mode, o que de qualquer forma não seria útil nesse caso.&lt;/p&gt;
&lt;p&gt;Existe uma ferramenta de depuração no DDK do Windows 98 chamada WDEB386. Sua existência está documentada no próprio DKK. Funciona similarmente ao WinDbg, ou seja, o depurador em parte roda na máquina depurada e em parte na máquina que depura, e ambas são conectadas por um cabo serial. Teoricamente essa ferramenta serviria para depurar o kernel dos sistemas 9x, mas na maioria das vezes tive problemas com ela. Não que nunca tenha funcionado. Até já consegui essa proeza uma vez depois de muito ler a documentação e resolver uma série de problemas que não estavam documentados. Se você leitor quiser tentar a sorte, vá em frente.&lt;/p&gt;
&lt;p&gt;Para piorar as coisas, existe mais um último problema: a máquina não está ao alcance de um cabo serial. Para esse último caso talvez fosse a hora de chamar um produto não-Microsoft que dá conta do recado muito bem: o SoftICE.&lt;/p&gt;
&lt;p&gt;O SoftICE é um depurador de kernel e user mode que é instalado na própria máquina depurarada. Ou seja, ele não precisa de uma segunda máquina só para rodar o depurador ou parte dele. Funciona no MS-DOS (versão 16 bits), plataforma 9x e NT. Criado pela Numega, mais tarde foi comprado pela Compuware, que passou a vendê-lo como um pacote para desenvolvimento de drivers, o Driver Studio. No seu time de desenvolvimento passaram nomes consagrados como Matt Pietrek e Mark Russinovich.&lt;/p&gt;
&lt;p&gt;Essa ferramenta teve seus dias de glória quando a maioria dos crackers a utilizava para quebrar a proteção de programas e do sistema operacional. Tanto foi famosa que foram desenvolvidas diversas técnicas para detectar se o SoftICE estava ativo na máquina, mais ou menos o equivalente das diversas técnicas atuais para detectar se um programa está sendo executado dentro de uma máquina virtual.&lt;/p&gt;
&lt;p&gt;O SoftICE deve ser instalado na máquina do desenvolvedor para gerar os símbolos dos programas e na máquina que vai ser depurada para depurar. Isso quer dizer que ele não precisa ser ativado na máquina do desenvolvedor. Só precisamos usar uma ferramenta chamada Symbol Loader, responsável por gerar símbolos e empacotar os fontes para serem usados na máquina depurada.&lt;/p&gt;
&lt;p&gt;Na hora de instalar, você tem três opções:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Full installation&lt;/em&gt;: desenvolvimento e depuração; use se for desenvolver e depurar na mesma máquina.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Host machine&lt;/em&gt;: apenas desenvolvimento; não serve para depuração.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Target machine&lt;/em&gt;: depuração; instale essa opção na máquina de testes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Após esse processo e a compilação do seu driver favorito podemos gerar os símbolos.&lt;/p&gt;
&lt;p&gt;Obs. importante! Infelizmente, o Driver Studio só traduz os símbolos corretamente até a versão 6 do Visual C++, ou seja, não inclui nenhuma das versões .NET do Visual Studio (2002/2003/2005+). A Compuware se negou a oferecer suporte para os novos compiladores, talvez até prevendo que o produto iria ser descontinuado em breve.&lt;/p&gt;
&lt;p&gt;A geração de símbolos pode ser feita de modo gráfico pelo Symbol Loader ou pela linha de comando. Vamos usar aqui a linha de comando para demonstrar como automatizar esse processo durante o processo de build:&lt;/p&gt;
&lt;p&gt;As opções source e package são importantes para traduzir utilizando o código-fonte e empacotar esse código-fonte no arquivo gerado. Note que eu disse empacotar, o que significa que o fonte vai estar dentro do arquivo de símbolos. Portanto, se a licença do seu software é de código fechado, nunca se esqueça de apagar esse arquivo quando estiver na máquina de um cliente.&lt;/p&gt;
&lt;p&gt;Se tudo der certo no final teremos dois arquivos a serem copiados para a máquina depurada:&lt;/p&gt;
&lt;p&gt;Depois de copiados e o driver instalado, insira pelo Symbol Loader o arquivo NMS na lista de símbolos a serem carregados no reboot. Após configurar o depurador como lhe aprouver basta reiniciar a máquina. Feito o reboot, existe uma tecla mágica que irá nos levar para o mundo da tela preta, o ambiente padrão do SoftICE: Ctrl + D.&lt;/p&gt;
&lt;p&gt;A interface é divida em pseudojanelas que ficam organizadas em camadas. Para exibir/esconder as janelas ou especificar o tamanho de uma delas usa-se o comando w. Aliás, basta começar a digitar um comando e o programa irá listar os comandos possíveis.&lt;/p&gt;
&lt;p&gt;Com certeza existe um monte de coisas novas para aprender quando se troca de depurador. Mais uma vez, assim como o WinDbg, temos a opção de utilizar o sistema de janelas ou a linha de comando. Aqui vão algumas dicas importantes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Para mostrar a tela do SoftICE, Ctrl + D. Digite novamente e ela some e o sistema volta a rodar.&lt;/li&gt;
&lt;li&gt;Os nomes dos comandos se assemelham aos do WinDbg. Tente usá-los e sinta as diferenças.&lt;/li&gt;
&lt;li&gt;A ajuda do programa é muito boa e explica direitinho todos os detalhes do ambiente. Caso algo falhe, RTFM!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Essa parece ser uma introdução muito básica ao SoftICE. E na verdade é. Teremos outras oportunidades mais pra frente de usar esse poderoso depurador, principalmente naqueles casos onde um problema só acontece no Windows 95 Release A e sem rede. Isso não é tão incomum quanto parece.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>A inteligência do if - parte 2</title>
  <link>http://www.caloni.com.br/a-inteligencia-do-if-parte-2/</link>
  <pubDate>2007-06-29</pubDate>
  
  <guid>http://www.caloni.com.br/a-inteligencia-do-if-parte-2/</guid>
  <description>&lt;p&gt;Vimos na primeira parte desse artigo, &amp;quot;A inteligência do if - parte 1&amp;quot;, como o if revolucionou o mundo da computação ao trazer um salto que depende de condições anteriores e, portanto, depende do estado do programa. A ele chamamos de salto condicional. Também vimos como o resto das construções lógicas de uma linguagem são apenas derivações montadas a partir de saltos condicionais e incondicionais. Neste artigo veremos como implementar um saldo condicional baseando-se no fato de que o computador pode apenas realizar operações matemáticas. Afinal de contas, um computador não &amp;quot;pensa&amp;quot;.&lt;/p&gt;
&lt;p&gt;Uma condição, item necessário para o funcionamento do salto condicional, nada mais é do que o conjunto de um cálculo matemático e o seu resultado, sendo o salto dependente desse resultado. Geralmente o resultado usado é uma flag definida pela arquitetura como o armazenador de resultado para comparações de igualdade. Na plataforma 8086, por exemplo, as instruções que comparam memória definem uma flag chamada de Zero Flag (ZF) que é modificada sempre logo após de executada uma instrução dessa categoria.&lt;/p&gt;
&lt;p&gt;É comum nas arquitetura o resultado de uma comparação ser igual a zero se os elementos são iguais e diferente de zero se são diferentes. O resultado, então, denota a diferença entre as memórias comparadas, e se não há diferença o resultado é zero.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set memA, 1
set memB, 1
cmp memA, memB # ZF=0

set memA, 1
set memB, 0
cmp memA, memB # ZF=1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mas como de fato comparar? Aí é que reside a mágica das portas lógicas e operações booleanas. A comparação acima pode ser feita com uma porta lógica XOR, o OU-eXclusivo, por exemplo, e o resultado pode ser obtido e armazenado se a saída for conectada a um flip-flop (um flip-flop, ou multivibrador biestável, é um circuito de computador capaz de armazenar o valor de 1 bit, o necessário para o nosso salto). Vamos por partes.&lt;/p&gt;
&lt;p&gt;Uma porta lógica é uma série de circuitos que recebe uma ou mais entradas e que resulta em uma saída, sendo as entradas e a saída representadas pelo sinal 1 e 0. As portas lógicas costumam ser nomeadas pela sua função na lógica booleana. Dessa forma, uma porta AND, ou E, é uma porta em que a saída será 1 se todas as suas entradas forem 1, e 0 se pelo menos uma de suas entradas for 0.&lt;/p&gt;
&lt;p&gt;Um flip-flop é o circuito que é usado para armazenar os resultados das portas lógicas de forma que após ter sido alimentado o valor não se perde. É o bloco mais fundamental de memória de um computador. Ele não se esquece depois que as entradas foram zeradas e pode ser resetado quando novas entradas forem fornecidas. É a maneira de gravar dados temporários na memória RAM da placa-mãe ou na memória cache do processador.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     +---+
memA | _ |
     +---+
     +---+
memB | _ |
     +---+
     +---+
 XOR | _ |
     +---+
     +---+
 NOT | _ |
     +---+
 +-----------+
 | flip-flop |
 +-----------+
       | 0     
    +----+    
    | ZF |    
    +----+    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O flip-flop serve para que o valor do ZF permaneça após a instrução XOR entre os registradores que serão comparados. Eis como funciona: é feito um XOR em cada um dos bits dos valores comparados, fazendo com que qualquer bit diferente tenha uma saída 1. Se todos os bits dos valores comparados forem iguais a zero, significa que os valores são idênticos. Para agrupar todas essas saídas é usada uma porta lógica OR, fazendo com que um único bit diferente de zero (ou mais) reflita na saída. A saída da porta OR, por sua vez, é invertida através da porta NOT colocada antes do flip-flop. Ou seja, se os valores forem idênticos (saída zero da porta OR) a saída final será 1, do contrário será zero.&lt;/p&gt;
&lt;p&gt;No final das contas, esse valor será armazenado na flag ZF. Se houver alguma diferença entre os valores, como foi o caso no exemplo acima, o valor final será o um invertido, ou seja, zero. Esse valor armazenado pode ser usado nas próximas instruções para realizar o salto, que dependerá do que estiver nessa flag.&lt;/p&gt;
&lt;p&gt;Dessa forma temos o nosso resultado realizado automaticamente através de um cálculo matemático. Agora, para executar o salto condicional, precisamos de um array de dois elementos, cada elemento com um endereço de memória. Podemos definir o primeiro elemento (índice zero) como o armazenador do salto se a condição for falsa, o que quer dizer que seu endereço vai ser o da próxima instrução seqüencial.&lt;/p&gt;
&lt;p&gt;Já o segundo elemento irá conter o endereço do salto não-seqüencial, que será feito se a condição for verdadeira.&lt;/p&gt;
&lt;p&gt;Dessa forma, para executar o salto baseado em um resultado de 0 ou 1 (o Zero Flag), só temos que alterar o endereço da próxima instrução para o valor do nosso array na posição resultado (0 para falso, 1 para verdadeiro). Note que se o resultado for falso o valor da próxima instrução não muda.&lt;/p&gt;
&lt;p&gt;Lembre-se que essa é apenas uma demonstração de como pode funcionar um salto condicional através de cálculos matemáticos. De maneira alguma estou afirmando que é feito dessa forma. Aliás, existem inúmeras formas de realizar esse salto. Uma segunda solução seria adicionar a defasagem (offset) entre o endereço da próxima instrução e o endereço do salto. Nesse caso podemos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Usar o ZF para multiplicar a defasagem e somar ao valor de Próxima Instrução.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Continuar usando a técnica do array, sendo o primeiro elemento (&lt;code&gt;false&lt;/code&gt;) igual a 0.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Acredito ser a solução da multiplicação a pior das três citadas, e a solução da defasagem a mais intuitiva por analogia (se você já programou em assembly). Meu objetivo foi apenas ilustrar que, dado um problema, pode haver várias soluções. Talvez mais para a frente veremos como é implementado um if em assembly, subindo mais um nível de abstração.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 1.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-10/</link>
  <pubDate>2007-06-26</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-10/</guid>
  <description>&lt;p&gt;Devido à grande procura através de mecanismos de busca (vulgo Google), estarei republicando esse artigo dividido em partes (até porque existem partes não acabadas), cada parte descrevendo um conceito geral do que representou cada versão do sistema operacional.&lt;/p&gt;
&lt;p&gt;Tudo começou em 1981, quando chegou às lojas o primeiro IBM PC, uma poderosa máquina de 4.7mhz, 64(KB!) de RAM e um drive de disquete de 160KB. Já havia sido lançado em agosto o MS-DOS, sistema operacional encomendado pela IBM à empresa recém-criada por Paul Allen e Bill Gates, a Microsoft Corporation. O DOS foi baseado num sistema básico anterior produzido pela Seattle Computer Products.&lt;/p&gt;
&lt;p&gt;No mesmo ano uma empresa chamada Xerox pôs ao mundo uma estação de trabalho gráfica chamada Star. Do Star vieram os conceitos de janelas, ícones, e o uso de um hardware apontador de tela chamado de mouse. De lá foram tiradas, portanto, as principais idéias que moldaram a criação dos futuros sistemas operacionais que revolucionaram o conceito de interação computador/usuário, como o LISA, da Apple - que mais tarde também deu origem ao Macintosh - e o sistema gráfico da Microsoft chamado Windows.&lt;/p&gt;
&lt;p&gt;Em novembro de 1983 a Microsoft Corporation anuncia oficialmente, no Plaza Hotel em Nova York, o Microsoft Windows, a próxima geração de sistemas operacionais que irá ter uma interface gráfica para o usuário (GUI) e ambiente multitarefa. É possível que o nome original do sistema tivesse sido Interface Manager se um dos gênios do departamento de marketing da Microsoft, Rowland Hanson, não tivesse convencido o fundador da empresa, Bill Gates, que Windows seria um nome melhor por ser mais intuitivo. A promessa inicial dizia que o sistema iria ser lançado em abril do próximo ano.&lt;/p&gt;
&lt;p&gt;No início daquele ano, então, foi mostrada uma versão beta aos chefões da IBM, que não se mostraram muito entusiamados. Na verdade, a criadora do Personal Computer estava trabalhando num novo projeto que substituiria o sistema original da Microsoft, o MS-DOS.&lt;/p&gt;
&lt;p&gt;Surgiram concorrentes potenciais do Microsoft Windows. VisiOn, da VisiCorp, foi a primeira GUI oficial lançada para PC. GEM (Graphical Environment Manager), lançada pela Digital Research no começo de 1983. No entanto ambos careciam do suporte de desenvolvedores para a plataforma. Ora, se ninguém quer fazer programas para um sistema, quem vai querer comprá-lo?&lt;/p&gt;
&lt;p&gt;Um produto chamado Top View fora lançado pela IBM em fevereiro de 1985, baseado em DOS com um gerenciador multitarefa, mas sem uma GUI. Era lento e precisava de muita memória. Acabou sendo descontinuado dois anos depois e nunca chegou a ter uma interface gráfica.&lt;/p&gt;
&lt;p&gt;Antes do lançamento do Windows, advogados da Apple alertavam sobre a possibilidade do sistema infringir os direitos e patentes que a empresa tinha sobre as características da sua interface gráfica, a LISA (janelas com barra de título, menus drop-downs, suporte a mouse, etc). Daí o fundador da Microsoft, Bill Gates, teve a idéia brilhante de firmar um contrato de licença com a Apple, dando-lhe o direito de incluir em todas as futuras versões do Windows e programas os conceitos de GUI adquiridos pelo sistema gráfico da Apple (isso antes do Windows ser lançado).&lt;/p&gt;
&lt;p&gt;Finalmente, em 20 de novembro de 1985, a Microsoft lança o Windows 1.0, quase dois anos depois da promessa inicial. Foi vendido inicialmente por U$100. Continha em seu pacote: MS-DOS Executive, Calendar, Cardfile, Notepad, Terminal, Calculator, Clock, Reversi, Control Panel, PIF (Program Information File) Editor, Print Spooler, Clipboard, RAMDrive, Windows Write e Windows Paint.&lt;/p&gt;
&lt;p&gt;O novo sistema não fez muito sucesso de imediato. Pelo contrário, foi considerado lento e primitivo. Devido às limitações impostas pela Apple o sistema não pôde apresentar certas características como a sobreposição de janelas e a famosa lixeira (um conceito proprietário da Apple). Ficou cerca de dois anos boiando no mercado até que foi lançado um produto chamado Aldus PageMaker 1.0. PageMaker foi o primeiro programa WYSIWYG (What You Seee Is What You Get) para o PC. Tinha a grande novidade de juntar tipos e gráficos no mesmo documento. Depois de um ano, a Microsoft lança uma planilha de cálculos chamada Excel. Mais tarde outros produtos como Microsoft Word e Corel Draw ajudaram a aumentar a popularidade do Windows, embora esse ainda precisasse de muitas melhoras.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Disassembling the array operator</title>
  <link>http://www.caloni.com.br/disassembling-the-array-operator/</link>
  <pubDate>2007-06-22</pubDate>
  
  <guid>http://www.caloni.com.br/disassembling-the-array-operator/</guid>
  <description>&lt;p&gt;Arrays are fascinating in C language because they are so simple and so powerful at the same time. When we start to really understand them and realize all its power we are very close to understand another awesome feature of the language: pointers.&lt;/p&gt;
&lt;p&gt;When I was reading the K&amp;amp;R book (again) I was enjoying the language specification details in the Appendix A. It was specially odd the description as an array must be accessed:&lt;/p&gt;
&lt;p&gt;A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type &amp;quot;pointer to T&amp;quot; and the other shall have enumeration or integral type. The result is an lvalue of type &amp;quot;T&amp;quot;. (...) The expression E1 [ E2 ] is identical (by definition) to *( (E1) + (E2) ).&lt;/p&gt;
&lt;p&gt;Notice that the rules don&#39;t specify the order of expressions to access the array. In other words, it doesn&#39;t matter for the language if we use a pointer before the integer or an integer before the pointer.&lt;/p&gt;
&lt;p&gt;The quote[index] bellow shows that we can use both orders and the code will compile successfully.&lt;/p&gt;
&lt;p&gt;This code doesn&#39;t show how obscure we can be. If we use a constant integer replacing the index, by example, the code starts to be an IOCCC participant:&lt;/p&gt;
&lt;p&gt;Is this a valid code yet, right? The expression types are following the rule. It is easy to see if we always think about using the &amp;quot;universal match&amp;quot; *( (E1) + (E2) ). Even bizarre things like this are easy to realize:&lt;/p&gt;
&lt;p&gt;Obs.: this kind of &amp;quot;obscure rule&amp;quot; hardly will pass in a code review since it is a useless feature. Be wise and don&#39;t use it in production code. This is just an amusing detail in the language specification scope. It can help in analysis, never in programming.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>Introdução ao Debugging Tools for Windows</title>
  <link>http://www.caloni.com.br/introducao-ao-debugging-tools-for-windows/</link>
  <pubDate>2007-06-20</pubDate>
  
  <guid>http://www.caloni.com.br/introducao-ao-debugging-tools-for-windows/</guid>
  <description>&lt;p&gt;O WinDbg é uma ferramenta obrigatória em uma das minhas mais divertidas tarefas aqui na Open: engenharia reversa de cavalos de tróia. Não tenho o código-fonte desses programas, não posso executá-los em minha própria máquina e não consigo fazer tudo que preciso usando apenas o depurador integrado do Visual Studio (como remontar o assembly do programa, por exemplo). Tudo isso faz do WinDbg a alternativa perfeita (senão uma das únicas). É um depurador que permite ser usado tanto através de janelas quanto através de comandos, o que permite um aprendizado em doses homeopáticas: comece com as janelas e aos poucos ganhe o controle total. Conseqüentemente cada dia aprendo um comando novo ou um novo uso para um comando que já conheço.&lt;/p&gt;
&lt;p&gt;Abaixo um esboço de como o WinDbg se parece, com suas principais janelas. A de comandos é a da direita.&lt;/p&gt;
&lt;p&gt;Ele não está limitado apenas para engenharia reversa de código malévolo. Esse é o uso que eu faço dele. Meu amigo Thiago, por exemplo, resolve problemas em servidores que rodam código gerenciado com WinDbg. É a maneira ideal de depurar um problema em uma máquina onde o ambiente de desenvolvimento não está disponível nem pode ser instalado. Outro ponto relevante é que ele não depura apenas um programa em particular, mas pode ser usado para depurar um sistema inteiro. Chamado de kernel debugging, podemos usar esse modo de funcionamento para resolver os problemas que surgem logo depois de espetar algum periférico novo comprado na Santa Ifigênia.&lt;/p&gt;
&lt;p&gt;Mas esse artigo não é apenas sobre o WinDbg. Ele não vem sozinho. É uma interface amigável para alguns depuradores linha de comando e outras ferramentas disponíveis no Debugging Tools for Windows, pacote disponível gratuitamente no sítio da Microsoft e atualizado geralmente de seis em seis meses. Nele podemos encontrar:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CDB: depurador que roda em &lt;em&gt;user mode&lt;/em&gt; e é uma &amp;quot;linha de comando agradável&amp;quot; para um programador avançado.&lt;/li&gt;
&lt;li&gt;NTSD: depurador que roda em &lt;em&gt;user mode&lt;/em&gt;, da mesma forma que o CDB, mas também pode ser usado como um redirecionador de comandos para o depurador de &lt;em&gt;kernel&lt;/em&gt; (logo abaixo). Existem algumas diferenças sutis entre esses dois depuradores (como o fato do NTSD não criar janelas quando usado como redirecionador), mas são diferenças que se aprendem no dia-a-dia.&lt;/li&gt;
&lt;li&gt;KD: depurador que roda em &lt;em&gt;kernel mode&lt;/em&gt;, pode analisar dados do sistema local ou depurar um sistema remoto conectado através de um cabo serial ou por meio de um &lt;em&gt;pipe&lt;/em&gt; criado por uma máquina virtual. Existem outros métodos mais avançados ainda para conseguir depurar uma máquina tão tão distante, por exemplo.&lt;/li&gt;
&lt;li&gt;Logger: _tracer _de chamadas de funções da API. Pode ser usado para análise de performance ou para fazer o que eu faço com os &lt;em&gt;trojans&lt;/em&gt;, que é dar uma olhada nas funções que eles chamam constantemente.&lt;/li&gt;
&lt;li&gt;Logviewer: visualiza resultados do Logger. É o que abriremos depois de capturar as APIs chamadas por um programa através do &lt;em&gt;logger&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Existem ainda outras ferramentas, mas estas são as principais que costumo utilizar. Para saber como usá-las de acordo com suas necessidades recomendo a leitura de um pequeno tutorial para o WinDbg que vem junto da instalação, o kerneldebuggingtutorial.doc. Ele é apenas a introdução dos principais comandos e técnicas. Depois de ter dominado o básico, pode partir para o arquivo de ajuda, que detalha de forma completa todos os comandos, técnicas e ferramentas de todo o pacote: o debugger.chm. A maioria dos comandos que precisava encontrei usando essa ajuda ou em alguns blogs muito bons. Acredite: no WinDbg, você quase sempre vai encontrar o comando que precisa.&lt;/p&gt;
&lt;p&gt;Já baixei e instalei. E agora, o que eu faço? Para exemplificar um uso prático dessas ferramentas vamos usar o Loggerpara descobrir quais funções API estão sendo chamadas constantemente por um cavalo de tróia, uma coisa um tanto comum em ataques a bancos. Para tornar as coisas mais reais ainda vamos utilizar o código-fonte de um suposto cavalo de tróia usado em minhas apresentações:&lt;/p&gt;
&lt;p&gt;Para compilar esse programa, você só precisa digitar os seguintes comandos em um console do Visual Studio:&lt;/p&gt;
&lt;p&gt;O logger.exe possui uma extensão que pode ser usada pelo WinDbg para usar os mesmos comandos a partir do depurador. Mas para tornar as coisas mais fáceis nesse primeiro contato iremos iniciar o programa através do próprio executável:&lt;/p&gt;
&lt;p&gt;Irá aparecer uma janela onde selecionamos o conjunto de APIs que serão capturadas. Podemos manter todas as categorias selecionadas e mandar rodar usando o botão &amp;quot;Go&amp;quot;.&lt;/p&gt;
&lt;p&gt;Aguarde o programa executar por um tempo para termos um pouco de dados para analisar. Em minhas análises reais eu geralmente deixo ele atacar, seja no sítio real do banco ou em uma armadilha. Depois do ataque posso confirmar qual a API que ele utilizou. Se quiser fazer isso nesse teste basta criar uma janela que contenha o texto &amp;quot;Fict Bank&amp;quot; em seu título. Após isso, podemos finalizar o processo pelo Gerenciador de Tarefas:&lt;/p&gt;
&lt;p&gt;Mesmo após finalizá-lo ele continuará na lista de processos, como se tivesse travado. Na verdade, a parte injetada do Logger mantém o processo no ar, em um estado semi-morto (ou semi-vivo). Depois de finalizar o Logger fechando sua janela principal ambos os processos terminam e podemos ler o resultado da captura em uma pasta chamada LogExts criada por padrão no Desktop ouÁrea de Trabalho. Podemos dar uma olhada nos resultados através do visualizador de logs gerados, o Logviewer.&lt;/p&gt;
&lt;p&gt;Algumas colunas do Logviewersão tão úteis que vale a pena mencioná-las:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Module: determina quem chamou a API, o próprio executável ou alguma DLL.&lt;/li&gt;
&lt;li&gt;Call Duration: tempo em milissegundos que a chamada da função demorou.&lt;/li&gt;
&lt;li&gt;API Function: o nome da função API que foi chamada.&lt;/li&gt;
&lt;li&gt;Return Value: o retorno da chamada da função.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;De quebra ele exibe todos os parâmetros das funções de acordo com o tipo, identificando inclusive quando se trata de uma enumeração ou define reservado. Essa &amp;quot;mágica&amp;quot; é feita interpretando os headers que ficam na pasta &amp;quot;Debugging Tools for Windows\winext\manifest&amp;quot;, tarefa executada pelo Logger no início.&lt;/p&gt;
&lt;p&gt;É só isso? O Debugging Tools é um pacote extremamente poderoso de ferramentas para programadores avançados. De maneira alguma conseguirei cobrir tudo que é possível fazer com essas ferramentas em apenas um blog. Porém, espero que essa pequena introdução seja o começo de uma série de artigos bem interessantes sobre debugging e uma série de testes realizados pelos meus leitores.&lt;/p&gt;
&lt;p&gt;Seguem alguns blogs dedicados inteiramente ao assunto WinDbg e debugging:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Microsoft Advanced Windows Debugging and Troubleshooting - site mantido pelo time de resolução de problemas críticos da Microsoft.&lt;/li&gt;
&lt;li&gt;Debugging Toolbox - &lt;em&gt;blog&lt;/em&gt; mantido pelo Roberto Farah, contém muitos &lt;em&gt;scripts&lt;/em&gt; para ser utilizando no Windbg.&lt;/li&gt;
&lt;li&gt;Crash Dump Analysis - uma exploração profunda na análise de telas azuis e o motivo delas existirem.&lt;/li&gt;
&lt;li&gt;WinDbg by Volker von Einem - como o autor mesmo diz, &amp;quot;uma coleção de utilidades para lidar com windbg&amp;quot;.&lt;/li&gt;
&lt;li&gt;Nynaeve - além de falar sobre &lt;em&gt;debugging&lt;/em&gt; no Windows contém análises de engenharia reversa.&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>A inteligência do if - parte 1</title>
  <link>http://www.caloni.com.br/a-inteligencia-do-if-parte-1/</link>
  <pubDate>2007-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/a-inteligencia-do-if-parte-1/</guid>
  <description>&lt;p&gt;No nível mais baixo, podemos dizer que as instruções de um computador se baseiam simplesmente em cálculos matemáticos e manipulação de memória. E entre os tipos de manipulação existe aquela que muda o endereço da próxima instrução que será executada. A essa manipulação damos o nome de salto.&lt;/p&gt;
&lt;p&gt;O salto simples e direto permite a organização do código em subrotinas. Subrotinas permitem o reaproveitamento de código com parâmetros de entrada distintos, o que economiza memória, mas computacionalmente é &amp;quot;inútil&amp;quot;, já que pode ser implementado simplesmente pela repetição das mesmas subrotinas. O que eu quero dizer é que, do ponto de vista da execução, a mesma seqüência de instruções será executada. Pense no fluxo de execução de uma rotina que chama várias vezes a mesma subrotina:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sub:
  code
  ret

routine:
  code
  call sub
  code
  call sub
  code
  call sub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ela é, na prática, equivalente à uma rotina que contém várias cópias da subrotina na memória, uma seguida da outra.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;routine:
  code
  sub:
    code
  code
  sub:
    code
  code
  sub:
    code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A grande sacada computacional não são subrotinas. O real motivo pelo qual hoje os computadores são tão úteis para os seres humanos é a invenção de um conceito chamado salto condicional. Ou seja, não é um salto certo, mas um salto que será executado caso a condição sob a qual ele está subordinado for verdadeira:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code
if cond:
  call sub
code
if cond:
  call sub
code
if cond:
  call sub
code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Os saltos condicionais, vulgarmente conhecidos como if, permitiram às linguagens de programação possuírem construções de execução mais sofisticadas: laços, iterações e seleção de caso. Claro que no fundo todas essas construções não passam de um conjunto formado por saltos condicionais e incondicionais. Peguemos o while e seu bloco, por exemplo. A construção em uma linguagem de programação possui uma condicional seguido de um bloco de código que se repete enquanto a condicional for verdadeira:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while cond:
  code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enquanto para o programador dessa fictícia linguagem existe um controle de execução no início que determina quando o código deixará de ser executado repetidamente, para o compilador o while não passa de um salto no final do bloco para o começo de um if.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;label:
if cond:
  code
  jump label
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O for, por outro lado, possui tradicionalmente em seu início três operações: inicialização, condição e incremento. O código começa executando a inicialização e verifica a condição uma primeira vez. Após executado o bloco de código condicionado ao for, o incremento será executado, e mais uma vez a condição verificada. Caso a condição seja verdadeira novamente o bloco de código volta a executar, para no final executar o incremento e verificar a condição, e assim por diante.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for: i = 0; i &amp;lt; 10; i++
  code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do ponto de vista do compilador, que irá transformar esta lógica em código de máquina, o for não passa de um contador que é incrementado a cada iteração com um salto incondiconal no final do bloco de código executado.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i = 0
label:
  if i &amp;lt; 10:
    code
    i++
    jump label
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O switch-case, ou seleção, filtra um determinado valor em comparações de igualdade, a condição, em série. Quando é encontrada alguma igualdade verdadeira o código atrelado é executado e o código imediatamente seguinte ao switch é executado. Opcionalmente o bloco inteiro após uma seleção é ignorado.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch i:
  case 0:
    code
  case 1:
    code
  case 2:
    code
  default:
    code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Essa lógica embutida nas linguagens de programação são convertidas pelo compilador em vários ifs seguidos e unidos por um else, o que torna a comparação exclusiva. No final de cada bloco de código existe um salto incondicional para o final da construção.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if i = 0:
  code
  jump label
elif i = 1:
  code
  jump label
elif i = 2:
  code
  jump label
else:
  code
label:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Neste artigo vimos como todas as construções de uma linguagem de programação, independente do seu nível, podem ser convertidas em um conjunto de saltos, condicionais e incondicionais. Em um próximo artigo, que chamaremos de &amp;quot;A inteligência do if - parte 2&amp;quot;, veremos como o salto condicional verdadeiramente funciona, e como pode ser implementado usando apenas operações matemáticas. Afinal, matemática básica é o bloco lógico mais básico que temos em um computador; qualquer computador.&lt;/p&gt;
</description>
</item>

     
    
  </channel>
</rss>
