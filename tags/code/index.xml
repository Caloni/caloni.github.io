<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>code on Blogue do Caloni</title>
    <link>http://www.caloni.com.br/tags/code/</link>
    <description>Recent content in code on Blogue do Caloni</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Fri, 26 Feb 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.caloni.com.br/tags/code/" rel="self" type="application/rss+xml" />
    
     
        <item>
  <title>Lessons From Online Poker Exploit</title>
  <link>http://www.caloni.com.br/lessons-from-online-poker-exploit/</link>
  <pubDate>2021-02-26</pubDate>
  
  <guid>http://www.caloni.com.br/lessons-from-online-poker-exploit/</guid>
  <description>Em 2014 eu palestrei na trilha de segurança do TDC em São Paulo um tema que me deixou muito animado: um exploit baseado em falhas de programação em um código de 10 linhas. O código era tão simples que achei válido traduzir para C e demonstrar como atacar uma simulação de cassino online.
Esta palestra (e o código) se perdeu no tempo, mas eu anotei o nome da pesquisadora que escreveu o post pelo qual me baseei: Laura Diane Hamilton (que também estuda Machine Learning em seu blog). Seu post comenta sobre uma história de 1990 quando hackers se aproveitaram de falhas básicas no algoritmo de embaralhamento de cartas de pôquer.
O código original estava escrito em Pascal, mas é facilmente traduzido para C:
unsigned char Card[52];unsigned char CurrentCard = 0;unsigned char JustShuffled = 0;void DeckShuffle(){unsigned char ctr;unsigned char tmp;unsigned char random_number;/* Fill the deck with unique cards */for( ctr = 0; ctr &amp;lt; 52; ctr&#43;&#43; )Card[ctr] = ctr &#43; 1;/* Generate a new seed based on the system clock */srand(time(NULL));/* Randomly rearrange each card */for( ctr = 0; ctr &amp;lt; 52; ctr&#43;&#43; ){random_number = rand() % 51;tmp = card[random_number];card[random_number] = card[ctr];card[ctr] = tmp;}CurrentCard = 0;JustShuffled = 1;} Fiz um código para compilar e rodar o embaralhador de cartas que embaralha e imprime a saída em cada nova execução para podermos observar mais facilmente os bugs encontrados por Hamilton. A falha número 1, o &amp;quot;An Off-by-One Error&amp;quot;, pode ser feita em C também, se você usar a função rand() da maneira como está no código:
random_number = rand() % 51; É um erro simples de ser cometido por programadores incautos, que querem expressar na verdade a obtenção de um número aleatório entre 1 e 52 e ao mesmo tempo obter o índice correto 0-based de um array. No entanto, o resto de uma divisão por N sempre irá cair entre 0 e N-1, já obtendo o índice correto em C.
random_number = rand() % 52; Para observar o que Hamilton quer dizer com &amp;quot;a 52a. carta nunca irá cair na 52a. posição&amp;quot; é possível forçar um loop nesse estilo:
/* call only once in main */srand(time(NULL));do{DeckShuffle();}while( Card[51] != 52 ); Este loop nunca irá terminar. Faça o teste. Depois compare com a rapidez com que o loop encontra a carta 52 em qualquer outra posição.
A segunda falha, &amp;quot;The Shuffle Isn&#39;t Uniform&amp;quot;, diz respeito à distribuição não-uniforme da igual probabilidade de certas cartas estarem em qualquer posição da pilha. Da maneira com que é implementado o algoritmo essa distribuição é enviesada. Temos como provar isso atribuindo pesos a cada embaralhada e depois de um certo tempo exibir os totais:
int CardStats[52];int j, j2;for( j = 0; j &amp;lt; 1000; &#43;&#43;j ){for( j2 = 0; j2 &amp;lt; 1000; &#43;&#43;j2 ){DeckShuffle();for( i = 0; i &amp;lt; 52; &#43;&#43;i )if( Card[i] == i&#43;1 )CardStats[i]&#43;&#43;;}}printf(&amp;quot;cards stats: \n&amp;quot;);for( i = 0; i &amp;lt; 52; &#43;&#43;i ){printf(&amp;quot;%d &amp;quot;, CardStats[i]);} A versão original do algoritmo rodando um milhão de vezes demonstra o viés de forma descarada:
cards stats:19270 18869 18685 18442 18348 18024 18119 17647 17612 17388 17661 17360 17183 17018 17176 16621 16705 16522 16337 16599 16499 16238 16315 15970 16294 16388 16294 16418 16463 16313 16462 16491 16450 16384 16674 16736 16577 16879 16933 17159 17417 17344 17672 18025 17883 18053 18107 18691 19042 19152 19559 0 Com a correção desse viés (e do bug da 52a. carta) aplicada:
random_number = rand() % (ctr - 52) &#43; ctr; O resultado se torna muito mais uniforme:
cards stats:19116 19035 19371 19328 19293 19327 19308 19277 19412 19231 19314 19192 19200 19229 19461 19398 19299 19314 19452 19291 19329 19003 19354 19282 19319 19237 19255 19149 19321 19291 19123 19266 19237 19443 19355 19318 19321 19127 19147 19277 19250 19307 19353 19169 19047 19225 19310 19297 19298 19423 19370 19213 No entanto, o pior bug talvez seja a união entre a terceira e a quarta falhas apontadas pela pesquisadora: &amp;quot;Using a 32-bit Seed&amp;quot; &#43; &amp;quot;Using the System Clock as a Seed&amp;quot;. Com esses dois unidos o hackerismo fica à solta, pois além das possibilidades de embaralhamento ficarem restritas em 2^32 o uso do clock limita em 86,400,000 milissegundos por dia da função random do Pascal. Em C poderia ser feito algo semelhante.
Um range muito específico de geração da semente do gerador de números aleatórios pode criar uma tabela maleável de possibilidades. Com isso em mãos, de acordo com Hamilton, uma vez que o atacante saiba pelo menos cinco cartas é possível fazer uma busca rápida em um range pequeno possibilidades. Em um jogo de pôquer isso é possível apenas com duas cartas em sua mão e as três cartas na mesa (flop).
Com base nesse comportamento vamos criar um exploit que recebe as três cartas do flop fornecidas pelo atacante que está no jogo e que inicia uma busca a partir do horário atual para trás. Conforme o programa encontra matches dessas três cartas juntas ele exibe o deck completo de cartas, a partir do qual o atacante pode verificar se suas cartas constam na distribuição.
time(&amp;amp;curr_time);printf(&amp;quot;how is the flop? &amp;quot;);scanf(&amp;quot;%d %d %d&amp;quot;, &amp;amp;flop1, &amp;amp;flop2, &amp;amp;flop3);while( 1 ){DeckShuffle(curr_time);if( Card[0] == flop1 &amp;amp;&amp;amp; Card[1] == flop2 &amp;amp;&amp;amp; Card[2] == flop3 ){printf(&amp;quot;%d: &amp;quot;, (int) curr_time);for( i = 0; i &amp;lt; 52; &#43;&#43;i ){printf(&amp;quot;%d &amp;quot;, Card[i]);}printf(&amp;quot;\n&amp;quot;);}curr_time--;} Por sua vez o cassino rodará o algoritmo bugado que já vimos. Para simplificar ele já pergunta para o jogador #2 se ele sabe quais são as cartas do jogador #1. Se ele não souber o programa diz ser ainda seguro, mas se acertar isso é revelado.
DeckShuffle();printf(&amp;quot;(for you) your cards, player#%d: %d %d\n&amp;quot;, player, Card[3 &#43; (player-1) * 2], Card[3 &#43; (player-1) * 2 &#43; 1]);printf(&amp;quot;(for all) flop: %d %d %d\n&amp;quot;, Card[0], Card[1], Card[2]);player1_card1 = Card[3];player1_card2 = Card[4];printf(&amp;quot;do you know which cards have player #1? &amp;quot;);scanf(&amp;quot;%d %d&amp;quot;, &amp;amp;player1_guess1, &amp;amp;player1_guess2);if( player1_guess1 == player1_card1 &amp;amp;&amp;amp; player1_guess2 == player1_card2 ){printf(&amp;quot;acerto, miseravi!\n&amp;quot;);}else{printf(&amp;quot;no no no, I am still secure!\n&amp;quot;);} Para rodar os programas basta iniciar o cassino e copiar as cartas do flop. Em seguida rodar o exploit e colar o flop. A partir daí ele começa a calcular e quando houver um deck em que aparecem as suas cartas copiar e colar as cartas do adversário, ou seja, o jogador #1, que são as cartas logo depois do flop.
&amp;gt;cassino.exe(for you) your cards, player#2: 1 21(for all) flop: 9 22 15do you know which cards have player #1?&amp;gt;cassino_exploit.exehow is the flop? 9 22 151614385852: 9 22 15 6 12 1 21 14 ...1614222117: 9 22 15 4 36 16 25 5 ...1613983918: 9 22 15 32 31 14 16 ...^C(for you) your cards, player#2: 1 21(for all) flop: 9 22 15do you know which cards have player #1? 6 12acerto, miseravi! </description>
</item>

     
        <item>
  <title>Awk</title>
  <link>http://www.caloni.com.br/awk/</link>
  <pubDate>2020-06-07</pubDate>
  
  <guid>http://www.caloni.com.br/awk/</guid>
  <description>Meu amigo sugeriu que aprender awk poderia ser útil de várias maneiras. Uma delas para organizar finanças pessoais. Dei uma lida em alguns tutoriais, sendo que o melhor custo benefício foi o Awk in 20 Minutes, de Fred Hebert (ele é o mesmo autor de um livro sobre erlang). Gostei. É sobre tratamento de texto como sed, mas em uma versão estendida e criada na época com a mesma sintaxe de C.
# commentPattern1 { ACTIONS; }# commentPattern2 { ACTIONS; }# commentPattern3 { ACTIONS; }# commentPattern4 { ACTIONS; } Por ela ser uma ferramenta antiga usa conceitos antigos, como field e record. Ela foi criada para formatar texto em formato de planilha, ou banco de dados. Um field, ou campo, é uma coluna na planilha, e um record, ou registro, é uma linha dessa planilha. Imagine que você pode usar awk para manipular e extrair dados de qualquer texto que contenha esse padrão, sendo que os detalhes como o separador de campos e registros, por padrão espaço e nova-linha, podem ser alterados no começo do programa.
# can be modified by the userBEGIN {# Field# SeparatorFS = &amp;quot;,&amp;quot;;# Record# Separator (lines)RS = &amp;quot;\n&amp;quot;;# Output# Field# SeparatorOFS = &amp;quot; &amp;quot;;# Output# Record# Separator# (aka lines)ORS = &amp;quot;\n&amp;quot;;}# can&#39;t be modified by the user{# Number of Fields# in the current RecordNF# Number of Records# seen so farNR# Script ArgumentsARGV / ARGC} Como toda linguagem usada como ferramenta do dia-a-dia existem os comandos mais úteis:
# prints $0 # (just print will do it){ print $0; } # ends the program{ exit; } # skips to the # next line of input{ next; } # variable assignment{ a=$1; b=$0 } # array assignment{ c[$1] = $2 }  Existem tópicos mais avançados como funções, seja embutidas ou criadas pelo usuário (inclusive em C), e versões mais novas como nawk e gawk. Assim como existe o vim e existem plugins, sendo que passo muito bem sem usar plugins no meu vim. Acho difícil que um dia precise estender awk, exceto por curiosidade e para aguçar minha criatividade. E como o próprio guia GNU da ferramenta sugere, se seu programa awk atingir algumas centenas de linhas é melhor você refazer em outra linguagem. Python, por exemplo (brincadeira).
{ if (BOOLEAN) { ACTION }else if (BOOLEAN) { ACTION }else { ACTION }}{ for (i=1; i&amp;lt;x; i&#43;&#43;) { ACTION } }{ for (item in c) { ACTION } } </description>
</item>

     
        <item>
  <title>Golang e C</title>
  <link>http://www.caloni.com.br/golang-e-c/</link>
  <pubDate>2020-04-05</pubDate>
  
  <guid>http://www.caloni.com.br/golang-e-c/</guid>
  <description>É muito difícil configurar a linguagem Go no ambiente Windows para compilar código C. O único ambiente de compilação que o projeto leva a sério são os ports do GCC, e não o Visual Studio, que seria a ferramenta nativa. Dessa forma, realizei boa parte das travessuras desse artigo em Linux, usando o WSL com a distro Ubuntu ou CentOS. Deve funcionar em qualquer Unix da vida.
A linguagem Go na versão mais nova precisa que seja definida através da cgo, o backend C do ambiente de build da linguagem, uma função trampolim, que é uma função escrita em C que irá chamar uma função escrita em Go. Essa função pode ser passada como parâmetro de callback para uma biblioteca C que quando a biblioteca C chamar esse ponteiro de função ele irá atingir a função trampolim, que por sua vez, chama a função Go, que é onde queremos chegar depois de todo esse malabarismo.
main|C.set_callback|C.call_callback|g_callback*|GoCallback_cgo|GoCallback Em resumo: o main em Go chama C.set_callback (função C exportada) passando o endereço do seu callback (em cgo) e em uma segunda chamada ou nessa mesma pede para chamar esse callback. O módulo em C pode ou não chamar essa função nessa thread ou mais tarde, através do ponteiro de função que estocou (g_callback). Ao chamá-la, ativará a função GoCallback_cgo, que por sua vez chamará GoCallback, essa sim, já no módulo Go (embora ambas estejam no mesmo executável, já que C e Go podem ser linkados juntos de maneira transparente.
Criei um repositório com os fontes deste artigo. Bom proveito =)
</description>
</item>

     
        <item>
  <title>Como Funciona o MPTunnel</title>
  <link>http://www.caloni.com.br/como-funciona-o-mptunnel/</link>
  <pubDate>2019-12-11</pubDate>
  
  <guid>http://www.caloni.com.br/como-funciona-o-mptunnel/</guid>
  <description>A ideia por trás de um sistema multipath de rede é fornecer mais de um caminho para o tráfego de pacotes. O objetivo pode ser diminuir a perda de pacotes por causa da instabilidade da infra, mas também fazer com que a velocidade da comunicação seja maior pela diminuição da razão da perda de pacotes, além da melhor rota acabar sendo por onde os pacotes irão chegar primeiro, em uma espécie de seleção natural da arquitetura.
O projeto MPTunnel é uma implementação em user space de UDP multipath. Assim como a contraparte em sua versão TCP, você pode estabilizar várias conexões entre o servidor local e o remoto.
MPTCP (MultiPath TCP) é uma boa ideia para tornar a conexão de rede mais robusta, mas apenas funciona em TCP, e em um ambiente multiplataforma não há soluções em kernel mode exceto o ECMP desenvolvido no último Linux, cujos artigos de Jakub Sitnicki explicam os detalhes. E foi através da minha busca por uma implementação de MPUDP que encontrei essa ferramenta feita por greensea, um usuário do GitHub.
Concepção Existem dois servidores: Server A e Server B. A conexão de rede entre Server A e Server B é instável (com uma razão alta de perda de pacotes). Dessa forma, nós gostaríamos de estabilizar um túnel multipath entre Server A e Server B, esperando que a conexão entre ambos se torne mais confiável, diminuindo a razão entre perda e envio de pacotes. Com o broadcast dos pacotes por vários caminhos o resultado a longo prazo é uma comunicação cuja performance é prioridade.
Server A|- mpclient|- bridge 1|- mpserver|- Server B|- bridge 2|- mpserver|- Server B|- bridge 3|- mpserver|- Server B Mpclient é a parte cliente do mptunnel que roda no Server A. Você deve dizer a ele a informação dos servidores bridge. Uma vez que é iniciado, o mpclient abre uma porta local UDP para escutar e redirecionar qualquer pacote de e para os servidores bridge.
Mpserver é a parte servidora do mptunnel que roda em qualquer lugar que acessa o Server B. Você deve dizer a ele a informação desse Server. Uma vez que é iniciado, o mpserver irá redirecionar qualquer pacote para o Server B.
Os servidores bridge são simples, eles apenas redirecionam os pacotes do mpclient para mpserver, ou pacotes do mpserver para mpclient. Você pode usar as ferramentas nc ou socat para entregar um servidor bridge.
Compilação Para a solução ser rodável em Linux, Windows e Mac OS os fontes compilam em um ambiente POSIX mínimo, já disponível nos três SOs, sendo que para Windows este ambiente é o Cygwin. O resumo para compilar em Linux é instalar o gcc, o make, o git, as dependências, baixar o projeto e compilar. Esses passos devem funcionar em qualquer Linux e foi testado em Ubuntu.
Windows Para Windows o primeiro passo é baixar e instalar o cygwin com os seguintes pacotes adicionais ao padrão: gcc-core, socat, git, make, libev, libev-devel, libintl-devel. Em seguida deve-se baixar o repositório do mtunnel e de dentro de um terminal Cygwin executar o build.
Exemplo usando udpserver e udpclient Dentro do repositório deste post há como exemplo de um modelo cliente e servidor em UDP, udpclient.c e udpserver.c. Eles se comunicam de um lado para outro enviando mensagens de hello com um número na frente que é incrementado pelo servidor.
udpclient udpserver| ||--- 1 hello cli -----&amp;gt;|| ||&amp;lt;-- 2 hello srv ------|| ||--- 2 hello cli -----&amp;gt;|| ||&amp;lt;-- 3 hello srv ------|| ||--- 3 hello cli -----&amp;gt;|| ||&amp;lt;-- 4 hello srv ------|| ||......................|| | Agora eu quero conectar em meu udpserver, mas a conexão é instável e a razão de perda de pacotes é alta, gerando um throughput muito pequeno. Para aumentar o throughput, ou seja, diminuir a perda de pacote, eu posso rodar um MPUDP para o servidor e estabilizar uma &amp;quot;conexão&amp;quot; UDP através da redundância das bridges.
O udpserver está em listen na porta 6666 UDP e eu executo o mpserver no servidor da seguinte forma: &amp;quot;mpserver 2000 localhost 6666&amp;quot;. Localmente executo o mpclient da seguinte forma: &amp;quot;mpclient 4000 client.mpclient.conf&amp;quot;. Abaixo está o conteúdo do arquivo client.mpclient.conf:
# mptunnellocalhost 4001localhost 4002localhost 4003 Em cada &amp;quot;servidor bridge&amp;quot; (no exemplo está tudo local, mas não precisaria) use socat para redirecionar os pacotes: &amp;quot;socat udp-listen:4001 udp4:localhost:2000&amp;quot;, &amp;quot;socat udp-listen:4002 udp4:localhost:2000&amp;quot;, &amp;quot;socat udp-listen:4003 udp4:localhost:2000&amp;quot;.
Os servidores bridge irão ficar em listen nas portas 4001, 4002 e 4003 e redirecionar qualquer pacote recebido para localhost:2000, e vice-versa. Agora eu faço o cliente conectar em localhost:4000 que o mpclient está em listen ele irá estabiizar uma conexão sobre o MultiPath UDP tunnel.
Dois scripts estão disponíveis para iniciar e parar a arquitetura de exemplo acima chamados respectivamente sample.start.sh e sample.stop.sh.
Para observar a performance da solução os exemplos de client e server servirão para medir a eficiência de uma comunicação onde as bridges se tornam instáveis, e para isso eles precisarão de uma rota remota entre as bridges. Este teste requer ao menos uma máquina a mais que esteja acessível na rede pelas portas a serem usadas (pode ser uma máquina virtual). Altere a execução das bridges da seguinte forma, trocando o endereço remoto pelo correto:
main computer  socat udp-listen:4001 udp4:remote_address:5001&amp;amp; socat udp-listen:4002 udp4:remote_address:5002&amp;amp; socat udp-listen:4003 udp4:remote_address:5003&amp;amp;  failback  socat udp-listen:4004 udp4:localhost:2000&amp;amp;  remote computer  socat udp-listen:5001 udp4:local_address:2000&amp;amp; socat udp-listen:5002 udp4:local_address:2000&amp;amp; socat udp-listen:5003 udp4:local_address:2000&amp;amp;  Isso fará com que três dos quatros bridges sejam remotos, enquanto o último estará funcionando totalmente local. Ao iniciar o mptunnel nesta configuração a comunicação entre udpclient e udpserver continuará funcionando na mesma velocidade mesmo que a comunicação na rede seja interrompida, graças ao quarto caminho totalmente local.
Outros cenários podem ser desenhados, levando em conta a velocidade de uma rede ou sua instabilidade.
Bugs e observações Mptunnel adiciona alguma informação de controle dentro dos pacotes, incluindo informação síncrona. O mpserver e o mpclient devem ser iniciados ao mesmo tempo. Se o mpclient ou o mpserver terminar, você terá que reiniciar ambos para restabelecer o túnel.
Atualmente você pode especificar apenas um único host alvo. Alguém sabe se existe uma biblioteca C de proxy SOCKS5? Penso que ao tornar o mpclient como um servidor proxy SOCKS irá torná-lo mais fácil de usar.
Mptunnel não encripta os pacotes por padrão, apesar de ter essa opção, pois isso irá diminuir o throughput. Em alguns testes o throughput atual é 3Mbps enquanto usando três túneis com criptografia, e após desabilitar a criptografia o throughput sobe para 300Mbps. Se você ainda quiser que o mptunnel encripte os pacotes, defina a variável de ambiente MPTUNNELENCRYPT=1.
Para compilar o mptunnel, a biblioteca libev é um requisito. Para uma uma solução similar para multipath UDP em TCP dê uma olhada no projeto mlvpn.
</description>
</item>

     
        <item>
  <title>Vcpkg: Bootstrap</title>
  <link>http://www.caloni.com.br/vcpkg-bootstrap/</link>
  <pubDate>2019-11-29</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg-bootstrap/</guid>
  <description>A versatilidade do vcpkg, gerenciador de pacotes multiplataforma da Microsoft, é permitir modificar tudo no projeto, desde código-fonte, pacotes instaláveis e a própria origem do repositório. Através do controle de fonte um vcpkg pode ser alimentado por diversas fontes, e por cada pacote existir em uma pasta separada permite a coexistência de várias versões e origens. Além disso, a forma de compilar os projetos e o código-base pode ser alterado exatamente da forma com que o projeto precisa.
Sabendo de tudo isso, a única coisa que você precisa em um projeto isolado é um script de bootstrap que baixe um repositório vcpkg customizado para o projeto, compile, instale os pacotes necessários e integre com o Visual Studio antes de iniciar a compilação do próprio projeto. Dessa forma é possível montar o ambiente de maneira automática e sanitizada para qualquer membro da equipe ou máquina de build.
Vejamos como seria um bootstrap.bat:
@echo offif not exist vcpkg (git clone https://vcpkg.git) else (echo vcpkg detected)if not exist vcpkg\vcpkg.exe (pushd vcpkgcall bootstrap-vcpkg.batpopd) else (echo vcpkg detected)if exist vcpkg\vcpkg.exe (pushd vcpkgvcpkg updatevcpkg install pkg1vcpkg install pkg2vcpkg install pkgNvcpkg integrate installpopd) Com esse script na pasta raiz do seu projeto ele irá criar uma subpasta chamada vcpkg e após realizar as operações descritas acima integrar ao Visual Studio. Dessa forma quando for compilar o projeto os includes e libs já estarão disponíveis para que ele funcione, mesmo diretamente de uma máquina limpa.
Esse script pode ser integrado à lib principal do projeto ou o projeto da solution que primeiro deve compilar (porque todos dependem dele). Para isso existe o Pre-Build Event nas configurações de um projeto do Visual Studio. Os comandos que estiverem lá serão executados sempre antes da compilação.
&amp;lt;PreBuildEvent&amp;gt;&amp;lt;Command&amp;gt;pushd $(SolutionDir)call bootstrap.batpopd&amp;lt;/Command&amp;gt;&amp;lt;/PreBuildEvent&amp;gt; O único passo não-descrito neste artigo é baixar o projeto e iniciar o build, tarefas triviais de integração.
</description>
</item>

     
        <item>
  <title>DTLS Simples... simples?</title>
  <link>http://www.caloni.com.br/dtls-simples/</link>
  <pubDate>2019-11-13</pubDate>
  
  <guid>http://www.caloni.com.br/dtls-simples/</guid>
  <description>O protocolo DTLS, grosso modo, é um addon do TLS, que é a versão mais nova e segura do SSL. Só que em vez de usar por baixo o TCP, que garante entrega na ordem certa dos pacotes, além de outras garantias, o UDP é permitido. Ou seja, datagramas. Em teoria essa forma de usar TLS é uma versão mais light, com menos overhead e menos tráfico de banda. E a pergunta que tento responder aqui é: será que isso é verdade?
A primeira tarefa é conseguir compilar e rodar um sample DTLS. Estou usando Windows como sistema operacional alvo (requisitos de projeto). Para criar um sample client/server de DTLS usando a biblioteca OpenSSL (no momento na versão 1.1.1d) precisei de alguns passos de setup, conforme especificados no tutorial do próprio OpenSSL. O repositório DTLS-Examples, disponível no GitHub, possui alguns starts para começarmos a compilar e rodar um pouco de código, mas nem tudo são flores na hora de rodar para Windows.
O exemplo que peguei, dtlsudpecho.c, como diz o nome, usa DTLS em cima de UDP. As funções de setup e de definição de callbacks e settings do OpenSSL são configuradas de acordo com o esperado, mas por algum motivo quando a conexão entre um server e um client é estabelecida o server dispara vários listenings e a conexão estabelecida pelo client permanece sem escrita e leitura.
Após compilar o OpenSSL e antes de iniciar os testes gerei os certificados, e analisando a troca de pacotes pelo Wire Shark descobri um erro no handshake envolvendo fragmentação. Tentando descobrir o motivo encontrei alguns issues no GitHub a respeito de problemas no OpenSSL, e a solução era definir um MTU (Maximum Transmission Unit) em vez de deixar o OpenSSL usar o default, que é pequeno demais para poder enviar as mensagens do handshake de uma só vez, requisito do protocolo.
Isso corrigiu o envio do ClientHello, mas após isso o handshake entrou em loop no envio do resto das mensagens até retornar com erro. Do roteiro descrito pela RFC faltam as mensagens Finished após ChangeCipherSpec, o que terminaria o fluxo, mas por algum motivo o Finished nunca chega em nenhum dos lados, e as mensagens a partir de ServerHello se repetem até o retorno de erro de conexão (SSLERRORSSL). O Sequence Number do server e client indicam que apesar da troca de mensagens estar ocorrendo existe um loop.
Encontrei um gist que acompanha passo a passo o setup necessário da biblioteca. Ao pesquisar mais a respeito encontrei um artigo de Christopher A. Wood, que também está explorando esse protocolo usando OpenSSL e que é o autor do primeiro repositório de exemplo de DTLS, que falha não por não funcionar, mas por estar usando TCP em vez de UDP ao usar a flag SOCKSTREAM em vez de SOCKDGRAM na criação do socket.
Depois de muito analisar o protocolo desenhando cada pacote na janela do escritório resolvi abandonar essa miríade de detalhes e dar um passo atrás, usando o próprio openssl.exe compilado com os parâmetros abaixo. E, surpreso, mas nem tanto (afinal de contas, a compilação do OpenSSL passou pelos testes pós-build) eu consigo executar o protocolo DTLS em UDP IPV4 sem nenhuma falha.
O passo seguinte foi entender o código e as diferenças com os samples que havia tentado fazer funcionar da única maneira que penso ser possível: depurando. Sem conseguir navegar em todos os detalhes do fonte do OpenSSL recompilei o projeto com full debug alterando as flags de compilação no Makefile gerado para Windows (/Od e /Zi ajudam) e iniciei os dois modos acima depurando em duas instâncias do Visual Studio. Encontrei uma ou outra chamada à biblioteca OpenSSL que não havia notado ainda, mas nada que parece fazer a diferença.
Mas nenhuma dessas mudanças fez efeito no projeto de teste. O próximo passo seria copiar cada chamada feita à lib OpenSSL pelo openssl.exe e colar no projeto de teste para descobrir onde está o pulo do gato que nenhum dos samples na internet parece ter encontrado (ao menos para Windows), mas há uma solução preguiçosa que é muito mais efetiva e testada: usar os fontes da própria pasta apps do projeto OpenSSL.
O próximo e último passo é customizar o código-fonte base no qual a OpenSSL valida o protocolo DTLS para o uso que pretendo fazer para ele: um executador de processos remoto.
</description>
</item>

     
        <item>
  <title>Vcpkg: Boost para Windows XP</title>
  <link>http://www.caloni.com.br/vcpkg-boost-windows-xp/</link>
  <pubDate>2019-09-16</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg-boost-windows-xp/</guid>
  <description>Quem programa em C&#43;&#43; no Brasil geralmente precisa estar preparado para manter velharias. Boa parte do parque de máquinas das empresas usam Windows, e não estou falando de Windows 10, mas muitas vezes XP. Apesar da Microsoft ter largado uma das melhores versões do seu SO para trás, milhares de máquinas ainda rodam esse bichinho, e muitos programadores precisam manter e desenvolver em nome da compatibilidade.
Porém, o desenvolvimento de libs C&#43;&#43; foram aos poucos largando o suporte ao XP (em C isso não existe muito, pois é mais fácil ser portável em C), pois muitos mecanismos de SOs modernos surgiram depois, como um mutex light ou mutex apenas de read. E como eles olham para o mercado global, o Brasil acaba ficando para trás.
E isso inclui a Boost, o famoso conjunto de bibliotecas usado pelos engenheiros que gostam de complicar seu código. O suporte oficial a XP da Boost acabou na 1.60, mas é possível compilar, se você quiser, versões mais novas, como a 1.68, que usaremos neste artigo. Com ela é possível gerar uma versão compatível com Windows XP usando o builder da Boost e alguns parâmetros mágicos, como toolset e define.
O parâmetro toolset usa no caso a versão compatível para XP do conjunto de compilação do Visual Studio 2015, e o define BOOSTUSEWINAPIVERSION é colocado para suportar pelo menos Windows XP. Já o stagedir seria apenas para separar a compilação padrão para a que suporta XP e é opcional para manter duas compilações distintas. Importante lembrar que, apesar da Microsoft ter extinto o suporte a XP, até o Visual Studio mais novo possui um toolset, compilador e libs para Windows, que suporte o sistema operacional.
Esses mesmos parâmetros usados no build da Boost podem ser usados dentro do vcpkg, o compilador de pacotes multiplataforma da Microsoft. Como esperado, as libs do vcpkg compilam usando tudo do último em sua máquina: Boost, Visual Studio e o suporte ao último Windows (no caso do pacote da Boost, não, se usa o Windows Vista em diante). Mas você pode e deve modificar os ports padrões sempre que necessário. Este artigo explica como fazer partindo do zero sem receita de bolo. Vamos escanear o problema e resolvê-lo. Para isso vamos usar um exemplo bem simples da Boost.Log, que possui dependências mais novas que o Windows XP.
O status inicial e inocente de um projeto que deseja rodar para XP em Visual Studio 2015 (nosso caso de uso, poderia ser o VS mais novo) é criar um projeto que usa Boost.Log pelo wizard, instalar, se ainda não estiver instalado, o Boost.Log no vcpkg, e acabou. Só que não.
Existem erros no meio do caminho que geralmente acontecem por dois motivos. O primeiro é quando rodamos um executável de 64 bits em um ambiente 32, mas este não é o caso. O segundo é quando rodamos um executável que possui alguma DLL faltando ou funções específicas de alguma DLL, que é o caso. Para descobrir as dependências de um executável basta rodar o comando dumpbin de dentro de um terminal com as ferramentas do Visual Studio disponíveis.
Dependências de APIs relacionadas com o SRWLock dizem respeito ao Slim Read/Write Lock do Windows, implementado a partir do Windows Vista. A primeira coisa a ser descoberta pelo programador é: quem está usando essas funções? Se não está no seu próprio código, provavelmente está em uma das libs linkadas. E uma dessas libs com certeza é o Boost.Log, pelo include no código.
Note as linhas onde ::InitializeSRWLock é chamado. O escopo global indica que há uma dependência estática entre essa função API e o executável se essa parte do código for compilada, o que pode ser descoberto através da IDE do Visual Studio abrindo os arquivos e verificando se a parte onde há essas chamadas fica &amp;quot;cinza&amp;quot; (há defines que impedem essa parte de compilar), ou depurando e inserindo breakpoints nessa parte, que deverá ser chamada. O dumpbin poderia ser usado de novo caso houvesse símbolos para explorar o uso dessas funções de dentro do executável, mas por padrão a compilação do Boost não gera símbolos, tornando a tarefa ingrata, pois estará tudo em assembly sem tradução para o fonte.
Se analisarmos onde BOOSTUSEWINAPIVERSION é definido descobriremos que ele é um reflexo do famigerado WIN32WINNT, que é o define que o Windows usa para determinar qual a versão mínima que o executável deve rodar. Windows Vista é 0x0600, Windows XP é 0x0501 (com SP 2 em diante 0x0502). Isso quer dizer que devemos compilar nosso projeto indicando que pretendemos rodar em Windows XP.
E aí começam os problemas de linker.
Aparentemente a própria lib Boost.Log estará entrando em contradição com ela mesma, pois há usos dos métodos new e delete, por exemplo, entre vários. A análise da lib compilada irá nos revelar que esses nomes realmente não existem. Não há nenhum símbolo com esse namespace. Precisamos agora averiguar de onde ele vem através de algumas ferramentas como dumpbin ou direto no código-fonte do Boost. O Boost precisa ser compilado com certo define para Windows XP. Do contrário ele deve conter o namespace v2smtnt6 em sua lib. Mudando o define no nosso projeto ele irá apenas mudar a definição nos headers, mas não na lib já compilada.
Mas para isso precisamos descobrir como o Boost é compilado no vcpkg. Sabemos que ele utiliza arquivos cmake dentro de cada subpasta em port, que junto de uma série de scripts já disponíveis pela ferramenta irá executar ações de compilação, instalação, etc. De dentro do Boost.Log encontramos alguns arquivos para analisar.
Não há nada que indique a versão do Windows, mas há um include de boost-modular-build.cmake que parece útil.
Há muito mais coisa nesse cmake, incluindo definição de toolset e os define de WIN32WINNT, que está como 0x602, ou seja, acima do Windows XP. No entanto, esses flags são da compilação do Visual Studio, e não do b2.exe, o compilador do Boost. Como vimos no início do artigo, são os parâmetros para o b2.exe que precisam ser modificados. Ao analisar sua execução de dentro do próprio cmake podemos verificar que há uma variável com essas opções, o bmOPTIONS. O que faz muito sentido.
Me parece que o segredo é inserir ou modificar os argumentos dessa variável e as libs da Boost estarão automagicamente modificadas. Me parece isso hoje, horas e horas depois de analisar o build do vcpkg. Mas vou lhe economizar essas horas. Podemos realizar essa mudança pontualmente no boost-modular-build-helper, mas também devemos recompilá-lo, o que inclui suas dependências e toda a bagaça.
Eu sei, é triste, mas mais uma caneca de café, uma partidinha de xadrez, e está pronta a recompilação. Fun fact: antigamente a compilação do Boost te dava essa dica de ir fazer café.
Depois de muito trabalho voilà! Não há mais dependências das APIs muito novas e conseguimos executar nosso programa em Windows XP. Mas, mais importante que isso, o que aprendi nessa brincadeira:
 A verificar os símbolos importados por um executável usando dumpbin, se certificando de que ele poderá rodar em SOs mais antigos. A buscar pelo uso de funções novas pelos fontes compilados pelo vcpkg. A analisar o build do vcpkg para poder modificá-lo e ser compatível com o ambiente que precisamos.  </description>
</item>

     
        <item>
  <title>Vcpkg: Atualizando Lib Asio</title>
  <link>http://www.caloni.com.br/vcpkg-atualizando-lib-asio/</link>
  <pubDate>2019-09-07</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg-atualizando-lib-asio/</guid>
  <description>Hoje tive que compilar a versão 1.13.0 do Asio para Windows, mas o vcpkg não suporta essa versão ainda, apesar de suportar uma versão (1.12.2.2). Daí entra os problemas que todo programador Windows tem para manter bibliotecas de terceiro compilando em seu ambiente, mas agora com o vcpkg isso nem é tão difícil assim. Vamos lá.
Primeiro de tudo, os pacotes disponíveis no vcpkg podem não ser os disponíveis no branch oficial, que é apenas uma base, que está sendo atualizado e mantido por uma equipe grande que responde os issues, é verdade, mas nem sempre possui as versões que precisamos no dia-a-dia. Para adicionar ou modificar os pacotes deve-se mexer na pasta port do projeto. Dentro dela há uma pasta para cada pacote disponível.
É lá que fica a pasta asio, com seus quatro arquivos: asio-config.cmake, CMakeLists.txt, CONTROL e portfile.cmake. No CONTROL temos o sumário do pacote (nome, descrição, versão), no asio-config.cmake a receita CMake para fazer o build e em CMakeLists.txt como instalar. Isso varia de pacote para pacote, mas no caso de libs como a asio ela fica no GitHub, então em algum lugar nas instruções de instalação (aqui no caso em portfile.cmake) você irá encontrar o uso da função vcpkgfromgithub.
Essa função irá obter os fontes baixando pela referência master do git, mas poderia ser outro branch ou tag. Para trocar a versão para a 1.13-0, por exemplo, existe uma tag para isso. Tudo que você precisa é mudar em HEADREF, mas para ficar mais bonito mude em REF também (além de atualizar o CONTROL, que contém informações sobre o pacote que o vcpkg irá exibir para o usuário). De início o SHA512 do download irá falhar, mas assim que você rodar o vcpkg install asio ele irá cuspir qual o hash correto. Daí é só atualizar no arquivo e rodar novamente. Feito isso o pacote é baixado, compilado e instalado exatamente como a versão 1.12.
</description>
</item>

     
        <item>
  <title>Do Bit para o Código</title>
  <link>http://www.caloni.com.br/do-bit-para-o-codigo/</link>
  <pubDate>2019-09-03</pubDate>
  
  <guid>http://www.caloni.com.br/do-bit-para-o-codigo/</guid>
  <description>Olá. Esta é uma viagem para dentro do computador. Como funciona um computador? Você sabe? Pois é, nem eu. Mas vamos explorar alguns pontos onde nossa vã metafísica mal encosta na singularidade que é uma arquitetura Von Neumann.
Em primeiro lugar, um bit. O que é um bit? Um bit nada mais é que um dado que se traduz em uma informação com dois, e apenas dois, valores possíveis: ligado ou desligado. Em eletrônica um bit precisa ser extraído de nosso mundo analógico, e quando eu digo analógico eu digo físico, onde existem átomos, prótons e elétrons, mas não existem bits, ou se existem, eles são muito complicados no momento.
Por enquanto, a esmagadora maioria dos computadores utiliza a frequência de uma onda para representar um bit, e dizer se ele está ligado ou desligado. Um filtro de onda consegue detectar se a frequência está alta ou baixa, sendo que alta e baixa também é uma interpretação arbitrária. É estipulado uma determinada frequência e através dela o filtro sensibiliza para o mundo digital se no momento o fio condutor desta frequência está acima ou abaixo dessa frequência, o que para nós, humanos, irá significar se o bit está ligado ou desligado.
Note que tanto faz a maneira com que você traduz a frequência, desde que haja apenas dois valor possíveis, condição sine qua non para definir um bit. Você pode interpretar uma frequência acima do nível estabelecido como ligado ou desligado, mas a partir dessa definição a frequência oposta, abaixo desse nível, deve ser o oposto do que foi definido, para assim termos o ligado/desligado (ou desligado/ligado).
(a) limite entre frequência alta (1) e frequência baixa (0)1/--\------------ /-- --\ ------- (a)/-- --\/-- --\ 0/-- --\---- ---(b) limite entre frequência alta (0) e frequência baixa (1)0/--\------------ /-- --\ ------ (b)/-- --\/-- --\ 1/-- --\---- --- A onda (mais uma intepretação da realidade) gerada pela frequência do sinal elétrico, então, é dividida em dois espaços, delimitados pelo filtro, que funciona como um filtro de linha: apenas a partir de um certo valor da onda ele deixa passar os elétrons, que irão definir do outro lado se o bit está ligado ou desligado.
Isso não quer dizer que o bit desligado (ou ligado, depende de como você definir) não contém eletricidade correndo antes do filtro, apenas que seu valor está abaixo do estabelecido para contar como ligado (ou desligado).
A partir deste ponto podemos trabalhar com o mundo digital. Limpamos as &amp;quot;imperfeições&amp;quot; do mundo físico e transformamos elétrons esquivos em apenas dois valores possíveis: 0 e 1.
Conseguindo usar e armazenar bits, a matemática fica muito mais simples e intuitiva para seres humanos, que só precisam trabalhar com uma base numérica de 2 valores em vez de 10. As mãos dos computadores possuem apenas um dedo cada, somando dois no total.
Como a base é dois convencionamos a dar nomes para as potências de 2 para conseguirmos trabalhar com valores maiores que 0 e 1. 2 elevado a 8, por exemplo, chamamos de byte, embora não no mundo todo, isso também pode mudar de interpretação, dependendo da arquitetura. Porém, na grande maioria do mundo, um byte serão 8 bits, cada um pondendo valer 0 ou 1, e juntando todos, podemos representar os valores de 0 a 255, pois 2 elevado a 8 são 256 combinações (e devemos incluir o zero).
---------------1 1 0 0 1 0 1 0---------------| | | | | | | |--- bit #0 (até 1)| | | | | | |----- bit #1 (até 3)| | | | | |------- bit #2 (até 7)| | | | |--------- bit #3 (até 15)| | | |----------- bit #4 (até 31)| | |------------- bit #5 (até 63)| |--------------- bit #6 (até 127)|----------------- bit #7 (até 255) A partir daí não existe muita mágica, pois juntando bytes podemos ter kilobytes (1024 bytes), dos kilobytes podemos ter megabytes, assim por diante até chegarmos no seu &amp;quot;HD de 2 Tera&amp;quot;, o que quer dizer 2 terabytes de informação, ou 35184372088832 bits, todos organizados para serem acessados, ou um a um ou em blocos. O que for mais conveniente para a arquitetura.
Como acessamos esses bits? Bom, informação gera informação na tecnologia da informação. Precisamos dizer, usando bits, quais bits queremos obter do seu &amp;quot;HD de 2 Tera&amp;quot;. O primeiro? O segundo? O vigésimo-quinto? O de número 35184372088832?
Para conseguir acessar precisamos de acesso, e esse acesso precisa conseguir deixar eu falar qual bit/byte que eu quero, ou seja, permitir que eu consiga passar esse valor (primeiro, segundo, etc). Onde está esse bit/byte nós chamamos de endereço, e para passar o endereço de um bit/byte para um HD usamos algo chamado barramento, que é como uma rodovia pode onde passam no máximo X bits (cada ----- é uma rodovia diferente).
 1 -&amp;gt; ----- -&amp;gt; 10 -&amp;gt; ----- -&amp;gt; 010101 -&amp;gt; 1 -&amp;gt; ----- -&amp;gt; 1 -&amp;gt; 101010 -&amp;gt; ----- -&amp;gt; 01 -&amp;gt; ----- -&amp;gt; 1 Porém, como vimos, dependendo do número de bits há um limite da quantidade de valores que podemos representar, e isso irá limitar o nosso acesso aos bits que queremos do &amp;quot;HD de 2 Tera&amp;quot;.
 8 bits --&amp;gt; byte 0 ao 25516 bits --&amp;gt; byte 0 ao 6553632 bits --&amp;gt; byte 0 ao 429496729664 bits --&amp;gt; byte 0 ao 1844674407...... 3709551616 ufa Bom, já deu pra ver que 64 bits é suficiente para pegar muitos e muitos bits. O problema é que endereçar toda essa gente custa tempo, pois cada bit precisa ser interpretado para daí o HD conseguir chegar no bit que ele precisa para daí devolver o seu bit. Imagine que para acessar 1 bit você precisa enviar 64?
Como esse modelo é impraticável criamos uma contraparte: em vez de apenas retornar 1 bit vamos diminuir a resolução e entregar já o bloco mais próximo de bits. Você manda 32 bits, por exemplo, e eu te mando uns 16 bytes, o que dá 65536 bits pela tabelinha acima. É um ótimo negócio, pois enviar bits e bytes para lá e para cá é muito mais barato, computacionalmente falando, do que ter que fazer uma busca de 1 bit em uma imensidão de bits. Essa quantidade de bits que o computador trabalha sempre que pedimos chamamos de palavra (word), o que faz muito sentido: estamos conversando com o computador, e ele responde com palavras geralmente, não com letras. Quem diabos responde um &amp;quot;olá&amp;quot; com &amp;quot;b&amp;quot;?
Já aprendemos muita coisa. Sabemos que os elétrons de um fio condutor pode ser dividido em frequências alta e baixa da onda e que essa divisão transforma o mundo analógico/físico em mundo digital, com bits valendo apenas 0 e 1. Sabemos que 1 bit sozinho não faz muita coisa, então começamos a ajuntá-los com nomes como byte, kilobyte e &amp;quot;HD de 2 Tera&amp;quot;. Sabemos que para conseguir pegar os nossos bits de volta o computador pede bits que dizem onde eles estão, o que chamamos de endereço. E como mandar 32 bits para obter apenas 1 é muito trabalho de busca à toa, sabemos que o computador nos entrega de volta uma palavra, que é um naco de 8, 16, 32 bits ou valores maiores. É assim que nos comunicamos com os computadores: com palavras (words).
Então, agora, o código abaixo não deve ser o menor mistério para nós:
#include &amp;lt;stdio.h&amp;gt;int main(int argc, char* argv[]){if (argc == 2){const char* file_name = argv[1];FILE* file = fopen(file_name, &amp;quot;r&amp;quot;);if (file){char line[1000];if (fgets(line, 1000, file))puts(line);elseputs(&amp;quot;Error reading line\n&amp;quot;);fclose(file);}else puts(&amp;quot;Error opening file\n&amp;quot;);}else puts(&amp;quot;How to use: program file_name\n&amp;quot;);} O programa acima verifica se a variável argc contém o valor 2. Argc é um int, o que quer dizer que na minha arquitetura são 4 bytes, ou 32 bits. Se esses 32 bits estão configurados com 0s e 1s de tal maneira que a soma de todos totalizam o valor 2, então meu código entrará dentro do primeiro if. Se não, então o código cairá no else e enviará os caracteres &amp;quot;How to use...&amp;quot; blá blá blá para a saída padrão através da chamada da função da libc puts. Esses caracteres também são formados por bits. Cada caractere possui 8 bits. E estão configurados de tal forma que darão um valor de 0 a 255 que será interpretado de tal maneira: o nth elemento da entrada de uma tabela de caracteres. Essa tabela se chama tabela ascii, e contém os números 0 a 9, as letras de a até z (e maiúculas, A até Z), alguns sinais, etc. Essa é uma nova forma de interpretar os números que conseguimos somando os bits, e só funciona dessa forma porque a linguagem C está especificada dessa maneira.
01001000 ---&amp;gt; 72 ---&amp;gt; &#39;H&#39;01101111 ---&amp;gt; 111 ---&amp;gt; &#39;o&#39;01110111 ---&amp;gt; 119 ---&amp;gt; &#39;w&#39;00100000 ---&amp;gt; 32 ---&amp;gt; &#39; &#39; (space)01110100 ---&amp;gt; 116 ---&amp;gt; &#39;t&#39;01101111 ---&amp;gt; 111 ---&amp;gt; &#39;o&#39;00100000 ---&amp;gt; 32 ---&amp;gt; &#39; &#39; (space)01110101 ---&amp;gt; 117 ---&amp;gt; &#39;u&#39;01110011 ---&amp;gt; 115 ---&amp;gt; &#39;s&#39;01100101 ---&amp;gt; 101 ---&amp;gt; &#39;e&#39;xxxxxxxx ---&amp;gt; ddd ---&amp;gt; letter... ---&amp;gt; ... ---&amp;gt; ... Essas letras representam o alfabeto romano, usado por boa parte do Ocidente, mas para o computador isso é apenas um comando que depois de passar por várias camadas de interpretação, incluindo o sistema operacional (que controla bits e bytes acima do computador), irá acender determinados leds em seu monitor para que o ser humano que estiver olhando para ele irá entender que aquilo é a letra H, por exemplo. No caso de H, imagine que ele está acendendo uma série de leds da cor da letra que está vendo exatamente na posição que você está olhando, enquanto em volta está acendendo a cor do fundo onde essa letra está sendo &amp;quot;impressa&amp;quot;. Se pudéssemos enxergar com um zoom, poderíamos ver cada um desses leds acesos, mas perderíamos a noção de qual letra no final está sendo desenhada. Na época de monitores de tubo e preto e branco era até possível ver os dois, mas hoje em dia o celular mais vagabundo exibe milhões e milhões de leds em sua cara.
HHHHHHHHH HHHHHHHHHH:::::::H H:::::::HH:::::::H H:::::::HHH::::::H H::::::HHH:::::H H:::::H H:::::H H:::::H H::::::HHHHH::::::H H:::::::::::::::::H H:::::::::::::::::H H::::::HHHHH::::::H H:::::H H:::::H H:::::H H:::::H HH::::::H H::::::HHH:::::::H H:::::::HH:::::::H H:::::::HHHHHHHHHH HHHHHHHHH Poderíamos continuar explicando o que é esse FILE e como ele se relaciona com o seu &amp;quot;HD de 2 Tera&amp;quot; para abrir apenas os bits que dizem respeito ao nome do arquivo, que é uma entrada em outra tabela de nomes de arquivos que ele encontra perguntando para o sistema operacional e assim lendo a posição correta dos bits que você precisa e assim por diante até que sua mente estrale e você entenda a miríade de abstrações e interpretações da realidade com que estamos lidando. Daí você veria que eu sou que nem você, dos bits e bytes, dos bauds e sockets, e que me surpreendo a cada dia em como mais e mais interpretações são possíveis de serem criadas a partir de um mundo digital inteiro construído a partir de nosso mundo físico. Bem-vindo ao meu mundo, ao nosso mundo, programador =)
</description>
</item>

     
        <item>
  <title>Some things I learned in a Hacker Rank exercise</title>
  <link>http://www.caloni.com.br/hacker-rank/</link>
  <pubDate>2019-08-08</pubDate>
  
  <guid>http://www.caloni.com.br/hacker-rank/</guid>
  <description>A couple of days ago I subscribed to Hacker Hank, a website specialized in provide interview exercises. The site is as a better version of Code Jam, with the possibility to Compile &amp;amp; Run the code, as well as running several test cases.
Talking with friends about one of them proposed a interesting puzzle called Find the Running Median. This is a good problem because it is easy to understand and tricky to implement.
My first attempt was naive, but worked for test cases where there were no duplicated numbers, a detail I overlooked in the description and happenned the very first test (lucky me it is possible to download the test cases, input and output, giving in return some of the points accumulated solving other problems).
/** Complete the runningMedian function below.*/vector&amp;lt;double&amp;gt; runningMedian(ofstream&amp;amp; fout, vector&amp;lt;int&amp;gt; a) {vector&amp;lt;double&amp;gt; ret;set&amp;lt;int&amp;gt; oa;for( int n: a ) {oa.insert(n);auto oaMidIt = oa.size() == 1 ? oa.begin(): next(oa.begin(), oa.size() / 2 - (oa.size() % 2 == 0 ? 1 : 0) );auto oaMidIt2 = next(oaMidIt);double median;if( oa.size() % 2 == 1 ) {median = *oaMidIt;}else {median = ( *oaMidIt &#43; *oaMidIt2 ) / 2.0;}fout &amp;lt;&amp;lt; median &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;ret.push_back(median);}return ret;} So I started to draw in my window a new solution, based on inplace sort algorithm, using the same vector proposed skeleton by the site. The idea was to just move elements inside the vector, ordering them as calculating the median to evey new number.
BEGIN --&amp;gt; 12, 4, 5, 3, 8, 7 &amp;lt;-- END^ ^| |-- SORTED_ENDMEDIAN ^|-- NEWBOOL ODD = TRUE;{DOUBLE MEDIAN = ODD ? MEDIAN : (MEDIAN &#43; MEDIAN&#43;1) / 2NEW = SORTED_ENDRECURSIVE/ITERATIVE_INSERT(BEGIN, SORTED_END, MEDIAN, NEW)ODD = ! ODDSORTED_END&#43;&#43;} WHILE( SORTED_END != END )INSERT(BEG, END, NEW, MED, ODD) {MED = SZ/2 - (SZ_ODD ? 0 : 1)1, 2, 3, 5, 6 (4)-&amp;lt; ?RIGHT OR LEFT/*my playgroundvector&amp;lt;int&amp;gt; test = { 12, 4, 5, 3, 8, 7, 5, 5 };for (size_t new_element = 1; new_element &amp;lt; test.size(); &#43;&#43;new_element)insert_new_element(test, new_element);return 0;*/ I still wasn&#39;t thinking about the sort algorithm until I began to try and fail several times, but this try/error bitch always taught me how to make things faster then embryological bullshit to born from scribbed windows. It only requested a debugger to make the edit, compile, debug triple step.
I was still trying in the window, thought, until in one of these iteractions with the compiler/debugger I achieved a simples, clearer solution, using only offsets from the vector instead of iterators.
void insert_new_element(vector&amp;lt;int&amp;gt;&amp;amp; a, size_t new_element){size_t begin = 0;size_t end = new_element;size_t sz = end - begin;size_t median= begin &#43; sz / 2 - (sz % 2 ? 0 : 1);while( sz &amp;gt; 1 ) {if( a[new_element] &amp;lt; a[median] ) end = median;elsebegin = median &#43; 1;sz = end - begin;median = median == begin? begin : begin &#43; sz / 2 - (sz % 2 ? 0 : 1);}size_t insert_offset = a[new_element] &amp;lt; a[median] ? median : median &#43; 1;int element = a[new_element];a.erase(a.begin() &#43; new_element);a.insert(a.begin() &#43; insert_offset, element);} This version almost done it, except for timeout error. Hacker Hank has a timeout of 2 seconds to C&#43;&#43; solutions and I was exceding it. After some thought (more try/error) I thought about change the container, but before I made a simples test: instead of using erase/insert methods make the things manually as in good old C.
void insert_new_element(vector&amp;lt;int&amp;gt;&amp;amp; a, size_t new_element){//...size_t insert_offset = a[new_element] &amp;lt; a[median] ? median : median &#43; 1;int element = a[new_element];//a.erase(a.begin() &#43; new_element);//a.insert(a.begin() &#43; insert_offset, element);memmove(&amp;amp;a[insert_offset &#43; 1], &amp;amp;a[insert_offset], (new_element - insert_offset) * sizeof(int));a[insert_offset] = element;} And it worked. Now what I learned looking the other solutions.
There are incredible tools in C&#43;&#43;, even since 98 or 11, that are frequently overlooked, but it is important to notice that the language has a framework for processing: containers, algorithms and so on. By example, looking for other solutions I learned about the characteristics of multiset and priorityqueue (spoiler: both have a ordering predicate and are logarithmic). There are smart functions in algorithm, too, as lowerbound.
A lot of solutions simply ignored the skeleton provided by the site and began its own code from scratch, eliminating the &amp;quot;request&amp;quot; that the numbers must be stored first in a vector. Sometimes, when there as skeleton in our life, we use them as guidelines, forgetting that &amp;quot;there is no spoon&amp;quot;.
I hope you learned something, too. You can see my Hacker Rank attempts in the site (nickname caloni) or my GitHub repository.
</description>
</item>

     
        <item>
  <title>SLQLocalDB</title>
  <link>http://www.caloni.com.br/sqllocaldb/</link>
  <pubDate>2019-07-21</pubDate>
  
  <guid>http://www.caloni.com.br/sqllocaldb/</guid>
  <description>Hoje foi o dia de redescobrir meu velho ranço com a solução Microsoft para banco de dados. Já perdi horas, dias e semanas com problemas de conexão com algum servidor SQL Server porque a instalação possuía configurações de segurança específicas, a string de conexão não estava exatamente de acordo com a versão instalada ou uma combinação macabra desses e de mais alguns problemas.
Após degladiar novamente com problemas com o SQL Server Express 17 minha esperança para este projeto que requer este banco de dados foi uma versão mínima chamada de LocalDB [1]. Essa versão tem objetivo de servir para desenvolvedores, pois é tão mínima que apenas roda quando você usa, além de permitir isolamento por contas e compartilhamento entre contas e até remoto via named pipe. Parece bom, não?
O marketing da Microsoft sempre será melhor do que as reais soluções entregues. Depois de ver tudo isso funcionar em um banco criado com o LocalDB em pequenos e simples passos, as dores de cabeça começaram na hora de compartilhar ou de criar do zero este mesmo banco em uma conta de sistema, que é como rodam geralmente os serviços do projeto:
C:\WINDOWS\system32&amp;gt;psexec -s cmd.exePsExec v2.11 - Execute processes remotelyCopyright (C) 2001-2014 Mark RussinovichSysinternals - www.sysinternals.comMicrosoft Windows [Version 10.0.17763.615](c) 2018 Microsoft Corporation. All rights reserved.C:\WINDOWS\system32&amp;gt;sqllocaldb iMSSQLLocalDBC:\WINDOWS\system32&amp;gt;sqllocaldb create &amp;quot;test&amp;quot;LocalDB instance &amp;quot;test&amp;quot; created with version 13.1.4001.0.C:\WINDOWS\system32&amp;gt;sqllocaldb start &amp;quot;test&amp;quot;LocalDB instance &amp;quot;test&amp;quot; started.C:\WINDOWS\system32&amp;gt;sqlcmd -S (localdb)\test...... hangs forever... O fun fact até aqui é que a primeira versão que tentei, a Express 2017, sequer chegava nesse ponto, dando erros de conexão com named pipe ou timeout no login. Não estou certo de como funcionaria um login em um acesso local em um arquivo, mas essa era uma mensagem extremamente longa e potencialmente inútil. Encontrei uma outra alma sofredora na internet neste mesmo dia de hoje que recomendou fazer o rollback para o Server 2016 [2] (por isso a versão 13.1 no prompt acima), mas os erros apenas mudam de figura ou se repetem indefinidamente.
Aliás, outro fato curioso e revoltante é que a Microsoft sequer mantém a versão anterior dos seus produtos para download. A versão 2016 achei no site de alguém que se dispôs a mantê-los. Do contrário, a solução seria sentar e chorar olhar o código-fonte.
Rá, brincadeira. Não tem o código-fonte.
Um erro frequente e algumas vezes reportado pelas internet é o do login, mesmo. Pesquisando mais a fundo encontrei um artigo no Code Project [3] (quem diria, velhos tempos em que postava nele) de 2014 onde a pessoa explicava que depois de ler muito e testar muito ele descobriu praticamente depurando a instância do SQL Server e descobrindo que o problema estava em um crash que nunca voltava, sendo necessário dropar todas as conexões (ou o conhecido restart que várias pessoas também recomendaram).
Esse não é o meu problema. Meu problema é conseguir rodar a solução na conta de sistema, e desconfio que o modo em que o psexec executa o cmd.exe na conta de sistema pode estar relacionado, pois contas interativas em sistema são fontes clássicas de configuration mismatch (talvez falte ou sobre variáveis de ambiente, alguns handles perdidos, essas coisas).
 [1] https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb [2] https://feedback.azure.com/forums/908035-sql-server/suggestions/36481279-sql-server-2017-express-localdb-shared-instance-co [3] https://www.codeproject.com/Tips/775607/How-to-fix-LocalDB-Requested-Login-failed  </description>
</item>

     
        <item>
  <title>C Resolve Tudo: goto</title>
  <link>http://www.caloni.com.br/goto/</link>
  <pubDate>2019-05-28</pubDate>
  
  <guid>http://www.caloni.com.br/goto/</guid>
  <description>Para quem decide usar a linguagem C para resolver tudo, a gota da água é o goto. Ele é flexível, cabe em (quase) qualquer ponto do código e tem 1001 utilidades. O goto é o bombril da engenharia de software.
O uso mais simples dessa importante construção da linguagem é pular de um ponto para outro do código em que esses pontos não estão diretamente relacionados, como geralmente ocorre, como sair de um laço, não entrar em um if ou selecionar um case do switch (lembrando que no caso do case do switch ele é no fundo um goto disfarçado).
if( argc != 5 )goto usage;/*do something do something elsemore to doand moreand moreand moreand moretoo much lines...finished*/return 0;usage:printf(&amp;quot;How to use: ...&amp;quot;);return 1; Claro que esse uso é trivial demais para valer a pena uma troca de fluxo tão desestruturada. Há formas mais úteis de desviar o fluxo padrão. No exemplo acima bastaria colocar todo o código que se segue dentro do grupo pertencente ao if e o goto seria desnecessário.
Mas, por exemplo, imagine que precisamos nos desfazer de recursos na ordem inversa ao qual vão sendo adquiridos. Pode-se aninhar indefinidamente ifs ou usar um bloco de código de unwinding que vai fechando os recursos na ordem inversa e inicia sua chamada dependendo de onde ocorreu o erro. Código é melhor para ilustrar:
FILE *f1, *f2, *f3, *f4, *f5;if( ! (f1 = fopen()) )goto end;if( ! (f2 = fopen()) )goto end_f1;if( ! (f3 = fopen()) )goto end_f2;if( ! (f4 = fopen()) )goto end_f3;if( ! (f5 = fopen()) )goto end_f4;/*code...code*/printf(&amp;quot;closing f5\n&amp;quot;);fclose(f5);end_f4: fclose(f4);end_f3: fclose(f3);end_f2: fclose(f2);end_f1: fclose(f1);end: ; Esse ponto-e-virgula final se deve ao fato que os labels do goto rotulam um comando; logo, se ha um label, deve haver um comando logo depois (mesmo que seja nulo, no caso de ponto-e-virgula). Esse estilo de liberação de recursos é muito usado em códigos de kernel e software mais básico, pois simplifica a visualização e aumenta a flexibilidade. Compare com a versão estruturada:
if( f1 = fopen() ){if( f2 = fopen() ){if( f3 = fopen() ){if( f4 = fopen() ){if( f5 = fopen() ){/*code...code*/fclose(f5);}fclose(f4);}fclose(f3);}fclose(f2);}fclose(f1);} Aliás, esse uso do goto é a maneira de aplicar RAII em C (Resource acquisition is initialization). Implícito em linguagens como C&#43;&#43; e seus destrutores de objetos, em C é você que precisa fazer a faxina. E se a bagunça foi feita da direita pra esquerda a faxina deve ser feita da esquerda pra direita.
Esse uso super-aninhado do código me lembra do exemplo clássico de sair de muitos loops aninhados. Apenas por didática, vamos citá-lo:
for( ; ; ){for( ; ; ){for( ; ; ){if( condition )goto outer_world;}}}outer_world: ; Comentei no começo do texto que os cases do switch são labels de goto disfarçados. E são mesmo. Um dos algoritmos mais famosos de transformação de loop chamado Duff&#39;s device junta um do-while com switch e realiza uma cópia de buffer com um número de bytes variável:
send(to, from, count)register short *to, *from;register count;{register n = (count &#43; 7) / 8;switch (count % 8) {case 0: do { *to = *from&#43;&#43;;case 7: *to = *from&#43;&#43;;case 6: *to = *from&#43;&#43;;case 5: *to = *from&#43;&#43;;case 4: *to = *from&#43;&#43;;case 3: *to = *from&#43;&#43;;case 2: *to = *from&#43;&#43;;case 1: *to = *from&#43;&#43;;} while (--n &amp;gt; 0);}} O que está acontecendo no código acima: é possível inserir qualquer tipo de mudança de fluxo dentro do switch. Duff aproveitou essa particularidade da linguagem para produzir jumps que poderiam ser feitos em assembly. Dependendo do resto da divisão por oito o salto é realizado para um case diferente, que executará parte do laço até o while comparador final. A vantagem desse tipo de abordagem é que evita-se sair da programação estruturada, e muito menos precisa-se apelar para o assembly.
Esse código também seria possível de ser feito com o goto clássico, mas note que nesse caso ele fica mais verboso, pois é necessário fazer um if diferente para cada condição.
register n = (count &#43; 7) / 8;if (count % 8 == 0 ) goto case_0;if (count % 8 == 7 ) goto case_7;if (count % 8 == 6 ) goto case_6;if (count % 8 == 5 ) goto case_5;if (count % 8 == 4 ) goto case_4;if (count % 8 == 3 ) goto case_3;if (count % 8 == 2 ) goto case_2;if (count % 8 == 1 ) goto case_1;case_0: do { *to&#43;&#43; = *from&#43;&#43;;case_7: *to&#43;&#43; = *from&#43;&#43;;case_6: *to&#43;&#43; = *from&#43;&#43;;case_5: *to&#43;&#43; = *from&#43;&#43;;case_4: *to&#43;&#43; = *from&#43;&#43;;case_3: *to&#43;&#43; = *from&#43;&#43;;case_2: *to&#43;&#43; = *from&#43;&#43;;case_1: *to&#43;&#43; = *from&#43;&#43;;} while (--n &amp;gt; 0); Caso você tenha estranhada a definição inicial da função, ela é como se definia os argumentos em linguagem C antes do padrão ANSI, com os nomes e logo em seguida a declaração das variáveis como se fossem locais (porque de fato elas são, embora sua inicialização seja feita antes da chamada). Como este código data dos anos 80 e como o padrão só foi finalizado em 89, percebe-se que ainda se usava o formato antigo no código.
Passemos para o próximo uso: código infinito. Esse é um uso clássico, e diferente do uso degenerado de laços em que a condição é sempre verdadeira (while(true), for(;;)) usando o goto fica bem-documentado que o objetivo é ficar eternamente nesse loop. Um laço infinito que eu me lembro é quando dá tela azul no Windows. O código-fonte do kernel era algo mais ou menos assim:
gerarDump();mudarParaVga();while( true ); /* that&#39;s all, folks */ Os programadores usaram o apelo clássico do while. Sem motivo, pois goto é usado direto como RAII (já explicado acima). A maneira procedural de fazer seria assim:
infinite:goto infinite; Isso lembra outra utilidade do goto que você pode anotar no seu caderninho: ele pode voltar o fluxo, de baixo para cima. Esse último exemplo é um dos programas C mais lindos do universo. Sua única instrução é o comando rotulado por infinite e referencia ele mesmo. É quase o salto incondicional do assembly, materializado na linguagem mais elegante jamais criada em nossa realidade.
</description>
</item>

     
        <item>
  <title>C Resolve Tudo Clos</title>
  <link>http://www.caloni.com.br/c-resolve-tudo-clos/</link>
  <pubDate>2019-05-17</pubDate>
  
  <guid>http://www.caloni.com.br/c-resolve-tudo-clos/</guid>
  <description>Continuando nossa série, conforme sugerido pelo @colemaker do grupo C/C&#43;&#43;/42/Império do Brasil, a próxima ideia a ser implementada em C é o sistema polimórfico de chamadas do Lisp orientado a objetos. Esse sistema permite realizar a seguinte manobra:
O aspecto-chave aqui, conforme eu descobri, é implementar a estratégia de prioridades entre as sobrecargas dos métodos de acordo com os tipos passados. Analisando bem por cima devemos sempre priorizar os métodos com os tipos mais específicos e ir realizando underpromotion até chegarmos no menos específico (se houver).
A implementação está no GitHub.
Sistema de tipos Para o sistema de tipos em C nada como fazer do zero:
/* defclass(foo, cclass_instance); */typedef struct foo_instance { cclass_instance type; } foo_instance;static foo_instance foo = { &amp;#34;foo&amp;#34; };/* defclass(bar, foo); */typedef struct bar_instance { cclass_instance type; } bar_instance; static bar_instance bar = { &amp;#34;bar&amp;#34; };Estruturas de dados As estruturas estão usando STL. O quê? Mas não era C? Sim, você tem toda razão. Porém, estou usando uma lib mais conhecida. Há milhares de libs containers em C para você escolher para trocar a implementação. Lembre-se que o mais importante não é ser purista, mas atingir os objetivos. Como eventualmente veremos nessa série de artigos, o próprio C&#43;&#43; e toda a sua biblioteca pode ser implementada em C. Este é apenas um atalho para fins didáticos e de produtividade (como eu já falei, produtividade não é o foco aqui, mas enxergar por debaixo dos panos).
Inicialmente feito em STL pela produtividade, a solução atual no GitHub é feita inteiramente em C usando a glib (lib comum em Linux com estrutura de dados, etc). O legal dessa biblioteca é que ela tem 20 anos (desde 1998) e já foi muito usada e testada, além de possuir estruturas e algoritmos simples que fazem parte do pacote básico de qualquer programador, como arrays, strings, hash tables.
#include &amp;#34;cclos.h&amp;#34;#include &amp;lt;stdarg.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;gmodule.h&amp;gt;typedef GPtrArray Argv;typedef struct _Method{void* fun;Argv* argv;} Method;typedef void (*FP_Argv0)();typedef void (*FP_Argv1)(cclass_instance*);typedef void (*FP_Argv2)(cclass_instance*, cclass_instance*);typedef void (*FP_Argv3)(cclass_instance*, cclass_instance*, cclass_instance*);typedef GHashTable ClassMap;typedef GPtrArray Methods;typedef GHashTable MethodMap;static ClassMap* g_classes;static MethodMap* g_methods;static Methods* g_calledMethods;void cdefgeneric_initialize(){g_classes = g_hash_table_new(g_str_hash, g_str_equal);g_methods = g_hash_table_new(g_str_hash, g_str_equal);}Method* method_new(void* fun, Argv* argv){Method* ret = (Method*)malloc(sizeof(Method));if (ret){ret-&amp;gt;fun = fun;ret-&amp;gt;argv = argv ? argv : g_ptr_array_new();}return ret;}Argv* method_free(Method* method, gboolean free_seg){Argv* ret = free_seg ? g_ptr_array_free(method-&amp;gt;argv, TRUE), NULL : method-&amp;gt;argv;free(method);return ret;}const char* defclass(const char* name, const char* deriv){gboolean insertOk = g_hash_table_insert(g_classes, (gpointer*)name, (gpointer*)deriv);return name;}#define extractargv(argv, argc) \	va_list vl; \va_start(vl, argc); \for (int i = 0; i &amp;lt; argc; &#43;&#43;i) \{ \cclass_instance* arg = va_arg(vl, cclass_instance*); \g_ptr_array_add(argv, arg); \}void defmethod(const char* name, void* fun, int argc, ...){Method* method = method_new(fun, NULL);Methods* methods = (Methods*)g_hash_table_lookup(g_methods, name);extractargv(method-&amp;gt;argv, argc);if (!methods){methods = g_ptr_array_new();g_hash_table_insert(g_methods, (gpointer) name, (gpointer) methods);}g_ptr_array_add(methods, method);}void callmethod(const char* name, Method* method){g_ptr_array_add(g_calledMethods, (gpointer) method-&amp;gt;fun);cclass_instance** argv = (cclass_instance * *)method-&amp;gt;argv-&amp;gt;pdata;if (method-&amp;gt;argv-&amp;gt;len == 0){FP_Argv0 fun = (FP_Argv0)method-&amp;gt;fun;fun();}else if (method-&amp;gt;argv-&amp;gt;len == 1){FP_Argv1 fun = (FP_Argv1)method-&amp;gt;fun;fun(argv[0]);}else if (method-&amp;gt;argv-&amp;gt;len == 2){FP_Argv2 fun = (FP_Argv2)method-&amp;gt;fun;fun(argv[0], argv[1]);}else if (method-&amp;gt;argv-&amp;gt;len == 3){FP_Argv3 fun = (FP_Argv3)method-&amp;gt;fun;fun(argv[0], argv[1], argv[2]);}}Method* find_method_by_fun(const char* name, void* fun){Method* method = NULL;Methods* methods = (Methods*) g_hash_table_lookup(g_methods, name);if (methods){Method** meths = (Method**)methods-&amp;gt;pdata;guint i = 0;while (i &amp;lt; methods-&amp;gt;len){Method* m = meths[i];if (m-&amp;gt;fun == fun){method = m;break;}&#43;&#43;i;}}return method;}int calcdistance_arg(cclass_instance* arg, cclass_instance* underpromo){int ret = 0;char* promo = (char*)arg-&amp;gt;type;while (strcmp(promo, underpromo-&amp;gt;type) != 0){promo = (char*)g_hash_table_lookup(g_classes, (gpointer*)promo);if (!promo || strlen(promo) == 0){ret = -1;break;}&#43;&#43;ret;}return ret;}int calcdistance(cclass_instance** args, cclass_instance** underpromo, int len){int ret = 0;for (int i = 0; i &amp;lt; len; &#43;&#43;i){int dist = calcdistance_arg(args[i], underpromo[i]);if (dist == -1) return -1;ret &#43;= dist;}return ret;}void call_next_method(const char* name, int argc, ...){Method* method = method_new(NULL, NULL);extractargv(method-&amp;gt;argv, argc);int nextdist = 666;Methods* methods = (Methods*)g_hash_table_lookup(g_methods, name);if (methods){guint i = 0;while( i &amp;lt; methods-&amp;gt;len ){Method* m = ((Method * *)methods-&amp;gt;pdata)[i];gboolean alreadyCalled = FALSE;guint cms = 0;while (cms &amp;lt; g_calledMethods-&amp;gt;len){void* fun = ((void **)g_calledMethods-&amp;gt;pdata)[cms];if (fun == m-&amp;gt;fun){alreadyCalled = TRUE;break;}&#43;&#43;cms;}if ( ! alreadyCalled){int dist = -1;if (method-&amp;gt;argv-&amp;gt;len == m-&amp;gt;argv-&amp;gt;len)dist = calcdistance((cclass_instance * *)method-&amp;gt;argv-&amp;gt;pdata, (cclass_instance * *)m-&amp;gt;argv-&amp;gt;pdata, method-&amp;gt;argv-&amp;gt;len);if (dist &amp;gt;= 0 &amp;amp;&amp;amp; dist &amp;lt; nextdist){if (dist &amp;lt; nextdist){method-&amp;gt;fun = m-&amp;gt;fun;nextdist = dist;}}}&#43;&#43;i;}if (method-&amp;gt;fun)callmethod(name, method);}}void call(const char* name, int argc, ...){g_calledMethods = g_ptr_array_new();Method* method = method_new(NULL, NULL);extractargv(method-&amp;gt;argv, argc);int nextdist = 666;Methods* methods = g_hash_table_lookup(g_methods, name);if (methods){guint i = 0;while( i &amp;lt; methods-&amp;gt;len ){Method* m = ((Method * *)methods-&amp;gt;pdata)[i];int dist = -1;if (method-&amp;gt;argv-&amp;gt;len == m-&amp;gt;argv-&amp;gt;len)dist = calcdistance((cclass_instance * *)method-&amp;gt;argv-&amp;gt;pdata, (cclass_instance * *)m-&amp;gt;argv-&amp;gt;pdata, method-&amp;gt;argv-&amp;gt;len);if (dist &amp;gt;= 0 &amp;amp;&amp;amp; dist &amp;lt; nextdist){if (dist &amp;lt; nextdist){method-&amp;gt;fun = m-&amp;gt;fun;nextdist = dist;}}&#43;&#43;i;}if (method-&amp;gt;fun)callmethod(name, method);}method_free(method, TRUE);}O código é bem simples. Mapas e listas com strings e ponteiros para organizar as estruturas por detrás do sistema de tipos que estamos implementando e seus métodos sobrecarregados. Cada método possui um nome, um endereço de ponteiro e o número dos seus argumentos. Todos os argumentos são do tipo polimórfico, seguindo o que provavelmente existe por detrás da própria implementação do Lisp.
Main O código que utiliza a clos.c é bem direto e enxuto. Como no Lisp.
#include &amp;#34;cclos.h&amp;#34;#include &amp;lt;stdio.h&amp;gt;/* defclass(foo, cclass_instance); */typedef struct foo_instance { cclass_instance type; } foo_instance;static foo_instance foo = { &amp;#34;foo&amp;#34; };/* defclass(bar, foo); */typedef struct bar_instance { cclass_instance type; } bar_instance; static bar_instance bar = { &amp;#34;bar&amp;#34; };void test_dispatch(){bar_instance x = bar;bar_instance y = bar;call(&amp;#34;thing&amp;#34;, 2, &amp;amp;x, &amp;amp;y);}void thing_foo_foo(cclass_instance* x, cclass_instance* y){printf(&amp;#34;Both are of type FOO\n&amp;#34;);}void thing_bar_foo(cclass_instance* x, cclass_instance* y){printf(&amp;#34;X is BAR, Y is FOO. Next...\n&amp;#34;);call_next_method(&amp;#34;thing&amp;#34;, 2, x, y);}void thing_foo_bar(cclass_instance* x, cclass_instance* y){printf(&amp;#34;X is FOO, Y is BAR. Next...\n&amp;#34;);call_next_method(&amp;#34;thing&amp;#34;, 2, x, y);}int main(){cdefgeneric_initialize();defclass(&amp;#34;foo&amp;#34;, &amp;#34;cclass&amp;#34;);defclass(&amp;#34;bar&amp;#34;, &amp;#34;foo&amp;#34;);defmethod(&amp;#34;thing&amp;#34;, &amp;amp;thing_foo_foo, 2, &amp;amp;foo, &amp;amp;foo);defmethod(&amp;#34;thing&amp;#34;, &amp;amp;thing_bar_foo, 2, &amp;amp;bar, &amp;amp;foo);defmethod(&amp;#34;thing&amp;#34;, &amp;amp;thing_foo_bar, 2, &amp;amp;foo, &amp;amp;bar);test_dispatch();}Futuros posts sobre C Resolve Tudo poderão utilizar a glib ou qualquer outra. Uma outra vantagem da linguagem C é que sua biblioteca padrão é muito enxuta, sendo fácil de ter disponível em seu ambiente um compilador C com a clib, e em cima dela você pode utilizar qualquer biblioteca de sua escolha para estruturas e algoritmos mais complexos. Ou fazer a sua própria.
</description>
</item>

     
        <item>
  <title>C Resolve Tudo: Orientação a Objetos (com Polimorfismo)</title>
  <link>http://www.caloni.com.br/c-resolve-tudo/</link>
  <pubDate>2019-05-17</pubDate>
  
  <guid>http://www.caloni.com.br/c-resolve-tudo/</guid>
  <description>Como programadores há um vício em nossas cabeças que é estar constantemente buscando a bala de prata, ou seja, a solução final e única para todos os nossos problemas de implementação. Com o tempo e alguma experiência descobrimos que tal coisa não existe, mas até lá nos encantamos com esse ou aquele framework, e claro, com essa ou aquela linguagem.
As linguagens que são criadas depois da revolução dos computadores pessoais querem facilitar a vida do programador médio embutindo soluções já testadas por programadores de verdade e evitando a todo custo que o código incorra em erros comuns. Além disso, há movimentos nas comunidades e no mercado que geram tendências que influenciam essas linguagens, o que explica design patterns, orientação a objetos, programação funcional, xp, scrum, devops e qualquer outra bala de prata que vá se solidificando.
Expliquei tudo isso para chegar no tema deste artigo: você pode fazer tudo isso usando linguagem C.
Mas aí você deve estar se perguntando: &amp;quot;supor que uma linguagem resolve tudo não é estar defendendo também uma bala de prata?&amp;quot;. A resposta é sim e não. Sim, é uma bala de prata se você pensar que pode fazer do zero sites e interfaces gráficas modernas em C puro. Mas a resposta também é não porque eu estou trabalhando em uma outra camada, aquela em que as soluções que ficam pra sempre são implementadas. Estou falando de pensar sempre na linguagem C quando estiver interessado no funcionamento das outras soluções.
Esse mindset propost tem como objetivo impedir que você pense que as outras soluções são mágicas porque se você consegue pensar em C ela é real. Se tem algo que a linguagem C não é esse algo é mágica. C é uma simples abstração de uma máquina virtual que se relaciona de maneira muito íntima com as implementações em assembly de várias arquiteturas. Mágica é algo que te impede de enxergar em que momento uma solução se encontra com o hardware. C nunca irá te impedir de fazer isso.
Dito isto, vamos analisar algumas balas de prata e entender como em C isso é implementado para revelar a mágica.
Orientação a Objetos A Orientação a Objetos se divide em algumas features. Algumas não vale a pena falar aqui, como tratar tudo como objeto. C já faz isso através de structs. Você pode montar uma struct que possua métodos, inclusive, através de ponteiros para função. E esses métodos já são sobrecarregáveis e virtuais.
struct MyClass{int x, y;void (*method)(int);};void method(int x){}struct MyClass NewMyClass(){struct MyClass ret = { 0, 0 };ret.method = &amp;amp;method;return ret;}int main(){struct MyClass obj = NewMyClass();obj.method(10);}A sobrecarga se torna algo trivial, bem documentada através dos nomes das funções que você está chamando. Tudo fica às claras, nada implícito, nada disse que me disse. Se eu chamo um método NewMyClass2 é óbvio que estou construindo uma segunda versão baseada na primeira, e posso inclusive comparar para ver se os métodos são originais ou sobrescritos com obj.method == &amp;amp;method, por exemplo. Além disso, é possível realizar composições de tipos onde alguns métodos são sobrescritos enquanto outros são compostos por chamadas duplas, triplas. Não há qualquer limitação ao polimorfismo exceto o que você define.
struct MyClass{int x, y;void (*method)(int);};void method(int x){}struct MyClass NewMyClass(){struct MyClass ret = { 0, 0 };ret.method = &amp;amp;method;return ret;}void method2(int x){}struct MyClass NewMyClass2(){struct MyClass ret = NewMyClass();ret.method = &amp;amp;method2;return ret;}int main(){struct MyClass obj = NewMyClass2();obj.method(10);}Os métodos são &amp;quot;estáticos&amp;quot; por default (não há contexto), o que aliás facilita programação funcional, mas você pode buscar contexto onde te interessa, passando como parâmetro toda a &amp;quot;classe&amp;quot;, seja por valor ou referência, ou passando até uma versão parcial dela. Há inúmeras maneiras de construir um objeto em C, pois ele não está restrito às regras de sintaxe da definição da linguagem, uma vez que é você que define. Além disso, como você deve ter percebido, para declarar tipos de structs é necessário o uso dessa palavra-chave, mas a linguagem C já possui um sistema de typedef para trocar convenientemente qualquer definição de tipo como um nome único.
#include &amp;lt;stdio.h&amp;gt;typedef struct SCalc{int (*sum)(int, int);int (*mult)(struct SCalc*, int, int);} Calc;int calc_sum(int x, int y){return x &#43; y;}int calc_mult(Calc* calc, int x, int y){int ret = 0;int i;for( i = 0; i &amp;lt; x; &#43;&#43;i )ret = calc-&amp;gt;sum(ret, y);return ret;}Calc CalcNew(){Calc calc;calc.sum = &amp;amp;calc_sum;calc.mult = &amp;amp;calc_mult;return calc;}int main(){Calc calc = CalcNew();int x = 10, y = 32;int z = calc.sum(x, y);int k = calc.mult(&amp;amp;calc, z, y);printf(&amp;#34;%d &#43; %d = %d, %d * %d = %d\n&amp;#34;, x, y, z, z, y, k);}10 &#43; 32 = 42, 42 * 32 = 1344Note que podemos ao redefinir a função de soma a de multiplicação também é alterada, mesmo não alterando seu funcionamento (mas alterando uma função que ela usa).
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;typedef struct SCalc{int (*sum)(int, int);int (*mult)(struct SCalc*, int, int);} Calc;int calc_sum(int x, int y){return x &#43; y;}int calc_mult(Calc* calc, int x, int y){int ret = 0;int i;for( i = 0; i &amp;lt; x; &#43;&#43;i )ret = calc-&amp;gt;sum(ret, y);return ret;}Calc CalcNew(){Calc calc;calc.sum = &amp;amp;calc_sum;calc.mult = &amp;amp;calc_mult;return calc;}int calc_cat(int x, int y){char buf[100];int ret;sprintf(buf, &amp;#34;%d%d&amp;#34;, x, y);ret = atoi(buf);return ret;}Calc BizarreCalcNew(){Calc calc = CalcNew();calc.sum = &amp;amp;calc_cat;return calc;}int main(){Calc calc = BizarreCalcNew();int x = 1, y = 1;int z = calc.sum(x, y);int k = calc.mult(&amp;amp;calc, z, y);printf(&amp;#34;%d &#43; %d = %d, %d * %d = %d\n&amp;#34;, x, y, z, z, y, k);}10 &#43; 32 = 1032, 1032 * 32 = 2147483647Este é apenas um exemplo besta de polimorfismo, além de um exemplo trivial de como OO em C é infinitamente mais rico e mais complexo. Está nas mãos do programador definir até onde vai a solução proposta. E é bom saber que não existe bala de prata.
</description>
</item>

     
        <item>
  <title>Const Int Pointer Var</title>
  <link>http://www.caloni.com.br/const-int-pointer-var/</link>
  <pubDate>2019-04-29</pubDate>
  
  <guid>http://www.caloni.com.br/const-int-pointer-var/</guid>
  <description>A melhor forma de declarar variáveis ponteiros (constante ou não, mas segue o exemplo) é const int * var. Explicação:
Quem diz o asterisco fazer parte do tipo e não da variável tem razão. Pensando dessa forma ele tem que ficar próximo do tipo.
const int* varPorém, outra forma de interpretar a variável é que ela equivale a um inteiro quando usado com asterisco, o que também é verdade. Ou seja, int *var significa que *var equivale a um int (constante ou não, mas preciso dessa variável não-const para o exemplo). É por isso que *var = 10 possui o mesmo valor de atribuição do que int var; var = 10, ou seja, *var é sinônimo do l-value var (se var fosse um inteiro e não um ponteiro).
Além disso, outro argumento pró-proximidade da variável é que declarações de múltiplas variáveis na mesma linha precisam de múltiplos asteriscos: const int *var1, *var2, *var3.
Portanto, como ambos os lados estão certos, separar o asterisco de ambos não dá prioridade a nenhuma forma que o programador poderá interpretar essa decisão, seja como parte do tipo ou da variável. Cada programador com seu próprio estilo irá enxergar em const int * var a proximidade com int ou com var de acordo com seu próprio bias (e estará certo em sua análise).
Ergo:
qualifier type * name;</description>
</item>

     
        <item>
  <title>Free Pascal e VS Code</title>
  <link>http://www.caloni.com.br/free-pascal-e-vs-code/</link>
  <pubDate>2019-03-09</pubDate>
  
  <guid>http://www.caloni.com.br/free-pascal-e-vs-code/</guid>
  <description>Agora que o VS Code é a ferramenta universal para todas as plataformas e linguagens imagináveis, acreditem ou não, há até plugin para Pascal. Ao instalar a extensão mantida por Alessandro Fragnani você recebe o intelisense e algumas dicas durante erros de programação.
A própria integração com o Free Pascal Compiler, o compilador open source de Pascal multiplataforma, já é mostrada na Home desse plugin. É só seguir os modelos e alterar de acordo com o que pede o VS Code (que está sendo atualizado constantemente).
Após isso o Terminal, Run Build Task exibe a opção de rodar o fpc.exe para seu programa e a compilação sai perfeita ou ele aponta os erros direto no fonte. O programa resultante pode ser executado por fora ou dentro do VS Code e tudo OK.
PS: Se quiser depurar é possível gerar informação de debug para o gdb via a flag -g, ou apenas usar o velho writeln(&#39;passou por aqui&#39;). Alguns dizem que o segundo uso algumas vezes é conveniente. Faz sentido se é um programa de faculdade.
Bons programas verdadeiramente estruturados! (Pascal, diferente de C, permite procedures aninhadas, passando o self durante as chamadas internas; isso, sim, é linguagem bem desenhada).
</description>
</item>

     
        <item>
  <title>Debug Remoto no Visual Studio 2010 ou Superior</title>
  <link>http://www.caloni.com.br/debug-remoto-visual-studio-2010-superior/</link>
  <pubDate>2019-03-06</pubDate>
  
  <guid>http://www.caloni.com.br/debug-remoto-visual-studio-2010-superior/</guid>
  <description>Já escrevi sobre debug remoto no finado C&#43;&#43; Builder, sobre como usar o msvcmon.exe no VS 2003 e o msvsmon.exe no 2010&#43;. Sobre como depurar um serviço quando a máquina está para desligar, e até sobre depurar através de um servidor de símbolos. Está na hora de tornar a depuração mais simples para programadores de serviços Win32.
Resumo dos comandos:
Busca do pacote de debug:c:\&amp;gt;dir /s /b &amp;quot;Remote Debugger&amp;quot;Executável:C:\Tools\Remote Debugger\x64\msvsmon.exeArgumentos:/noauth /anyuser /timeout 99999999 /silentServiço:C:\Tools\nssm.exe install MsvcmonHoje em dia, às vésperas do Visual Studio 2019, espero que todo mundo use pelo menos o Visual Studio 2010 porque a partir dessa versão tornou-se muito fácil depurar remotamente, pois um pacote feito para isso já é instalado junto do Visual Studo. É uma pasta que basta copiar e colar na máquina-alvo. Para encontrá-la basta digitar &amp;quot;Remote Debugger&amp;quot; dentro do Program Files.
Copie essa pasta para a máquina onde estará os processos que deseja depurar e escolha sua arquitetura (x86, x64, i64), pois cada uma possui uma sub-pasta com os mesmos arquivos. Executa uma vez o msvsmon.exe dentro de uma delas e ele irá configurar para você o firewall do Windows. Feito isso e configurando através da janela que aparece o resto dos parâmetros basta atachar o processo ou iniciá-lo remotamente pela configuração do seu projeto no Visual Studio.
Mas este artigo não é sobre isso, é um pouco mais fundo: depurar serviços. Eles rodam na conta de sistema e muitas vezes é preciso depurá-los antes ou depois do logon na máquina. Às vezes é um teste sob as condições de sistema, o que é igualmente importante. Seja como for a maneira de fazer isso com o msvsmon.exe é transformá-lo também em um serviço. Para isso usaremos o NSSM: o Non-Sucking Service Manager. Copie ele para a mesma máquina e o executa com o comando install &amp;lt;nome-do-serviço&amp;gt;. Os campos principais são os mais importantes.
Se você digitar msvsmon.exe /h ou algo do gênero irá encontrar os parâmetros que precisa:
Obs.: Eu costumo executar sem segurança alguma, pois minhas máquinas de teste são VMs locais e o perigo de vulnerabilidade não é menor do que minha própria máquina real.
</description>
</item>

     
        <item>
  <title>Bug no Boost Asio usando função AcceptEx do Winsock</title>
  <link>http://www.caloni.com.br/bug-boost-asio-acceptex-winsock/</link>
  <pubDate>2019-01-06</pubDate>
  
  <guid>http://www.caloni.com.br/bug-boost-asio-acceptex-winsock/</guid>
  <description>Depois de um mês de correção e mais um ou dois meses preparando um compilado do que ocorreu no software que estamos mantendo, foi descoberta uma situação muito peculiar que ocorre tanto em Windows XP quanto no Windows 10, mas que no 10 tem uma correção bem-educada e no XP... bom, nem tanto.
O problema ocorreu em um uso padrão do Boost.Asio de modo assíncrono. Sem querer entrar muito em código nesse momento -- que teve como base nosso projeto de servidor de requisições mais rápido do universo, o motherforker -- se trata apenas de um listening que usa spawn de um lambda para tratar os accepts e dentro dele cria processos, redirecionando sua entrada e saída.
// pseudocodevoid Acceptor::doAccept(){while(!isStopping()){async_accept();spawn(Acceptor::createProcessGetOutputAndSendBack);}}Nas entranhas do Boost.Asio na implementação para Windows o accept utiliza a API AcceptEx, que já cria o socket cliente antes mesmo da conexão ser fechada. Se trata de uma operação de IO assíncrono como os que tem no Windows: faz tudo que é necessário fazer e é responsabilidade do programa verificar se houve IO (de maneira síncrona ou assíncrona). No caso do Asio a maneira de verificar é via checagem do handle de completion durante os momentos de idle do io_service.
BOOL AcceptEx(SOCKET sListenSocket,SOCKET sAcceptSocket, // &amp;lt;--- socket cliente já criado PVOID lpOutputBuffer,DWORD dwReceiveDataLength,DWORD dwLocalAddressLength,DWORD dwRemoteAddressLength,LPDWORD lpdwBytesReceived,LPOVERLAPPED lpOverlapped);Quando há uma nova conexão o método createProcessGetOutputAndSendBack lê dados do socket cliente como um comando a ser executado e utiliza a API CreateProcess passando esse comando. A saída desse processo criado é capturada via saída-padrão. Para isso é usada a flag de herança de handles e handles de arquivos (poderiam ser pipes) são usados para enviar entrada, capturar saída, etc.
BOOL CreateProcessA(LPCSTR lpApplicationName,LPSTR lpCommandLine,LPSECURITY_ATTRIBUTES lpProcessAttributes,LPSECURITY_ATTRIBUTES lpThreadAttributes,BOOL bInheritHandles, // &amp;lt;--- flag de herança de handles DWORD dwCreationFlags,LPVOID lpEnvironment,LPCSTR lpCurrentDirectory,LPSTARTUPINFOA lpStartupInfo,LPPROCESS_INFORMATION lpProcessInformation);// usando flags de uso de entrada/saída padrãoSTARTUPINFO si = { sizeof(si) };si.dwFlags = STARTF_USESTDHANDLES;si.hStdInput = CreateFileA(inputTempFilePath, GENERIC_READ, 0, &amp;amp;sa, OPEN_EXISTING, 0, NULL);si.hStdOutput = CreateFileA(outputTempFilePath, GENERIC_WRITE, FILE_SHARE_READ, &amp;amp;sa, CREATE_ALWAYS, 0, NULL);si.hStdError = si.hStdOutput;Após o término do processo a saída estará no arquivo aberto em si.hStdOutput. Basta abri-lo para leitura e enviar seu conteúdo via socket para o cliente. O trabalho dessa conexão termina por aí.
O Bug O que não estava previsto é que junto da herança dos handles vai também handles indesejados. Como o de &amp;quot;\Device\Afd&amp;quot;, que é um recurso usado na comunicação do winsock. Ao usar as funções síncronas e tradicionais do winsock, que constitui em criar o socket server, dar listen e no accept o socket cliente ter sido criado, o AcceptEx exige já um socket cliente criado, o que é feito no sample da Microsoft com a função socket e no Boost.Asio com a duplicação do socket existente (que também foi criado via socket function).
ClientSocket = socket(result-&amp;gt;ai_family, result-&amp;gt;ai_socktype, result-&amp;gt;ai_protocol);Esses dois sockets são herdáveis por default (implementação da função socket) e são representados pelos handles listados no Process Explorer como já visto, pelo nome &amp;quot;\Device\Afd&amp;quot;. O contador de handles é aumentado a partir da criação do processo-filho e esses dois handles aparecem em ambos os processos.
Até aí tudo bem. O problema na verdade ocorre no segundo request enviado quando o primeiro request não terminou (e.g. o primeiro request é um notepad.exe que irá demorar e o segundo request um &amp;quot;cmd /c dir&amp;quot;, que executa e já volta com a saída). Nessa situação todos os sockets criados até aqui -- incluindo o cliente do primeiro request -- são herdados para o segundo processo-filho, e por questões que estão além do escopo desse estudo, mas que poderão ser verificados ao se analistar os drivers das camadas de TDI do Windows (kernel mode), o send da saída do segundo request para o socket cliente fica travado até a saída do primeiro processo-filho, onde ocorre dos handles serem fechados.
É uma situação complexa, que depende de várias variáveis, mas ela ocorre, se todas as variáveis ocorrerem ao mesmo tempo. Um resumo:
 Criação do socket cliente com a função socket. Uso do AcceptEx para aceitar conexões. Criação de process-filho com flag de herança de handles habilitada. Processo-filho do primeiro request ainda em execução. Recebimento do segundo request e criação do segundo processo-filho. Escrita no socket cliente do segundo request enquanto o primeiro request ainda não foi finalizado. BUG: Cliente do segundo request não recebe sua resposta. RESULTADO ESPERADO: Que o cliente do primeiro request não interferisse no segundo. Detalhe: Cliente do segundo requeste recebe eventualmente sua resposta após o primeiro request terminar.  Solução #1 (Windows Vista ou superior): InitializeProcThreadAttributeList e UpdateProcThreadAttribute A solução para evitar handles herdáveis que não são desejáveis é proposta pelo Raymond Chen em seu blog: usar as API InitializeProcThreadAttributeList e UpdateProcThreadAttribute. Com isso é possível especificar quais handles podem ser herdados pelo processo-filho, e obviamente iremos colocar na lista apenas os arquivos de entrada e saída padrão (obs: não duplicar saída-padrão com erro-padrão quando ambos são o mesmo arquivo/handle).
Solução #2 (Windows XP): Ad Hoc As API InitializeProcThreadAttributeList e UpdateProcThreadAttribute não existem no Windows XP, o que quer dizer que isso exige uma segunda solução, que eu considerei antes de achar a terceira solução que teria que ser ad hoc: criar um processo-neto, sendo que o filho não receberá os handles herdados, mas irá criar o neto herdando os arquivos de entrada e saída padrão, enviando a saída de volta por um método à parte (ex: usando o nome de um arquivo em comum).
Solução #3 (todos Windows): WSASocketW com WSA_FLAG_NO_HANDLE_INHERIT (leia update abaixo) A terceira solução encontrada durante a compilação deste artigo é usar em vez da função socket, que não dá o controle sobre herança de handle, a função WSASocketW, onde existe um argumento dwFlags em que é possível passar o valor WSA_FLAG_NO_HANDLE_INHERIT (0x80), onde o handle do socket não será criado com a flag de herdável. Dessa forma apenas o socket cliente não se torna herdável e com isso o primeiro request não trava o segundo. A vantagem dessa correção é que ela é pontual no código e é de uma API já antiga, portanto compatível com todos os Windows.
Update (2019-01-07): Na verdade a flag de não-herança do socket só passou a existir no Windows 7 com SP1, o que inviabiliza essa solução para Windows Vista e XP, como previamente foi dito.
Solução #4: Boost.Asio Essas correções dizem respeito ao sample de uso do winsock como modelo server/client da própria Microsoft. Ele foi modificado em um repositório que criei para meus testes e poderá ser usado como correção de todos que tiverem o mesmo problema utilizando a API do Windows diretamente.
Já para o Boost.Asio será necessário um estudo de impacto e o envio de uma proposta de correção (ou uso de um patch em que a criação do socket cliente deve ser feita sem herança). Isso pode potencialmente quebrar o funcionamento de outros tipos de programas que dependem direta ou indiretamente da herança de todos os sockets, ou talvez o Boost.Asio tenha uma maneira educada de entregar o controle da criação de sockets dependente de implementação. Eu não sei. Este é um próximo passo da pesquisa.
Update (2019-01-07): Embora use a função WSASocketW o Boost.Asio não suporta a parametrização das flags, e sua implementação não é sobrecarregável, fazendo parte do namespace socket_opt. Foi criado um issue no GitHub do projeto Boost.Asio para ver os comentários e colocações da equipe. No aguardo.
</description>
</item>

     
        <item>
  <title>Coroutine Internals</title>
  <link>http://www.caloni.com.br/coroutine-internals/</link>
  <pubDate>2018-09-18</pubDate>
  
  <guid>http://www.caloni.com.br/coroutine-internals/</guid>
  <description>Uma corrotinas é um mecanismo de troca de contexto onde apenas uma thread está envolvida. Ela me faz lembrar do Windows 3.0, não exatamente por não existirem threads (e não existiam mesmo), mas pelo caráter cooperativo dos diferentes códigos.
Só que no caso do Windows se a rotina de impressão travasse todo o sistema congelava.
A volta das corrotinas via C&#43;&#43; moderno ocorre, para variar, no Boost. E a arquitetura é simples: mantenha um histórico das stacks das diferentes tasks da thread. Vamos pegar o caso mais simples da Boost.Coroutine para analisar:
#define BOOST_COROUTINES_NO_DEPRECATION_WARNING // Já existe uma nova versão de Coroutine, a 2, e a 1 está sendo abandonada.#include &amp;lt;boost/coroutine/all.hpp&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace boost::coroutines;void cooperative(coroutine&amp;lt;void&amp;gt;::push_type &amp;amp;sink){std::cout &amp;lt;&amp;lt; &amp;#34;Hello&amp;#34;;sink();std::cout &amp;lt;&amp;lt; &amp;#34;world&amp;#34;;}int main(){coroutine&amp;lt;void&amp;gt;::pull_type source{ cooperative };std::cout &amp;lt;&amp;lt; &amp;#34;, &amp;#34;;source();std::cout &amp;lt;&amp;lt; &amp;#34;!\n&amp;#34;;}Se você já é um programador esperto já deve ter percebido que na saída do prompt será impresso &amp;quot;Hello, world!&amp;quot;, com a vírgula no meio sendo impressa pela função main e as duas palavras da ponta pela função cooperative, ainda que ela seja chamada apenas uma vez.
Note que falei chamada porque se a stack não retornou da função ela não terminou ainda seu trabalho. Não houve o &amp;quot;return&amp;quot;. Outra forma de entender isso é que ela é chamada aos poucos. Enfim, deixo para você a discussão semântica. O fato é que a saída é &amp;quot;Hello, world&amp;quot;:
Vamos depurar.
Oh, oh! A stack de cooperative nos indica que ela não partiu do main, apesar de ter sido chamada através da construção de coroutine::pull_type. O método sink chamado logo após imprimir &amp;quot;Hello&amp;quot; deve colocar essa rotina para dormir, voltando o controle para main. Vamos ver como isso é feito.
Oh, não. O depurador do Visual Studio está fazendo caquinha, pois rodando passo-a-passo voltei para a mesma função cooperative sem passar pelo main. No entanto, a vírgula &amp;quot;, &amp;quot; foi impressa.
Para conseguirmos depurar diferentes rotinas dentro da mesma thread é imperativo entendermos como o mecanismo de troca de contexto funciona por baixo dos panos. Para isso nada como depurar as próprias trocas de contexto.
typedef void ( * coroutine_fn)( push_coroutine&amp;lt; void &amp;gt; &amp;amp;);explicit pull_coroutine( coroutine_fn fn, attributes const&amp;amp; attrs = attributes() ){// create a stack-context stack_context stack_ctx;stack_allocator stack_alloc;// allocate the coroutine-stack stack_alloc.allocate( stack_ctx, attrs.size);BOOST_ASSERT( 0 != stack_ctx.sp);// typedef of internal coroutine-type typedef detail::pull_coroutine_object&amp;lt;push_coroutine&amp;lt; void &amp;gt;, void, coroutine_fn, stack_allocator&amp;gt; object_t;// reserve space on top of coroutine-stack for internal coroutine-type std::size_t size = stack_ctx.size - sizeof( object_t);BOOST_ASSERT( 0 != size);void * sp = static_cast&amp;lt; char * &amp;gt;( stack_ctx.sp) - sizeof( object_t);BOOST_ASSERT( 0 != sp);// placement new for internal coroutine impl_ = new ( sp) object_t(boost::forward&amp;lt; coroutine_fn &amp;gt;( fn), attrs, detail::preallocated( sp, size, stack_ctx), stack_alloc); BOOST_ASSERT( impl_);impl_-&amp;gt;pull();}O tamanho total da stack reservada no Windows é de 1 MB, mas a granuralidade padrão é de 64 KB (&amp;quot;que é suficiente para qualquer um&amp;quot; - Gates, Bill). Então é por isso que quando o Boost aloca uma stack com atributos padrões esse é o tamanho que vemos (65536).
 The default size for the reserved and initially committed stack memory is specified in the executable file header. Thread or fiber creation fails if there is not enough memory to reserve or commit the number of bytes requested. The default stack reservation size used by the linker is 1 MB. To specify a different default stack reservation size for all threads and fibers, use the STACKSIZE statement in the module definition (.def) file. The operating system rounds up the specified size to the nearest multiple of the system&#39;s allocation granularity (typically 64 KB). To retrieve the allocation granularity of the current system, use the GetSystemInfo function.
 Detalhe curioso de arquitetura x86 (32 bits): na hora de alocar, o sp (stack pointer) aponta para o final da pilha. Isso porque no x86 a pilha cresce &amp;quot;para baixo&amp;quot;.
ctx.sp = static_cast&amp;lt; char * &amp;gt;( limit) &#43; ctx.size;Logo em seguida, no topo da pilha, é empilhado o objeto da corrotina:
typedef pull_coroutine_object&amp;lt;push_coroutine, coroutine_fn, stack_allocator&amp;gt; object_t;void * sp = static_cast&amp;lt;char*&amp;gt;(stack_ctx.sp) - sizeof( object_t);impl_ = new (sp) object_t(boost::forward&amp;lt;coroutine_fn&amp;gt;(fn), attrs, detail::preallocated(sp, size, stack_ctx), stack_alloc); Bom, entrando mais a fundo na implementação de corrotinas do Boost, temos o objeto pull_coroutine_impl, que possui flags, ponteiro para exceção e o contexto do chamador e do chamado para se localizar.
template&amp;lt;&amp;gt;class pull_coroutine_impl&amp;lt; void &amp;gt; : private noncopyable{protected:int flags_;exception_ptr except_;coroutine_context * caller_;coroutine_context * callee_;O coroutine_context possui elementos já conhecidos de quem faz hook de função: trampolins. Ou seja, funções usadas para realizar saltos incondicionais de um ponto a outro do código independente de contexto. Na minha época de hooks isso se fazia alocando memória na heap e escrevendo o código assembly necessário para realizar o pulo, geralmente de uma colinha de uma função naked (funções naked não possuem prólogo e epílogo, que são partes do código que montam e desmontam contextos dentro da pilha, responsável pela montagem dos frames com ponto de retorno, variáveis locais, argumentos).
// class hold stack-context and coroutines execution-contextclass BOOST_COROUTINES_DECL coroutine_context{private:template&amp;lt; typename Coro &amp;gt;friend void trampoline( context::detail::transfer_t);template&amp;lt; typename Coro &amp;gt;friend void trampoline_void( context::detail::transfer_t);template&amp;lt; typename Coro &amp;gt;friend void trampoline_pull( context::detail::transfer_t);template&amp;lt; typename Coro &amp;gt;friend void trampoline_push( context::detail::transfer_t);template&amp;lt; typename Coro &amp;gt;friend void trampoline_push_void( context::detail::transfer_t);preallocated palloc_;context::detail::fcontext_t ctx_;A função que faz a mágica do pulo do gato é a pull, que muda o estado da rotina para running e realiza o salto de contexto. Vamos analisar essa parte com muita calma.
inline void pull(){BOOST_ASSERT( ! is_running() );BOOST_ASSERT( ! is_complete() );flags_ |= flag_running;param_type to( this);param_type * from(static_cast&amp;lt; param_type * &amp;gt;(caller_-&amp;gt;jump(* callee_,&amp;amp; to) ) );flags_ &amp;amp;= ~flag_running;if ( from-&amp;gt;do_unwind) throw forced_unwind();if ( except_) rethrow_exception( except_);}Quem desfaz a mágica, &amp;quot;desempilhando&amp;quot; o contexto para voltar ao chamador da corrotina (através do contexto apenas, não da pilha) é a função push.
inline void push(){BOOST_ASSERT( ! is_running() );BOOST_ASSERT( ! is_complete() );flags_ |= flag_running;param_type to( this);param_type * from(static_cast&amp;lt; param_type * &amp;gt;(caller_-&amp;gt;jump(* callee_,&amp;amp; to) ) );flags_ &amp;amp;= ~flag_running;if ( from-&amp;gt;do_unwind) throw forced_unwind();if ( except_) rethrow_exception( except_);}Com os dados disponíveis nos objetos de contexto (no exemplo do main, a variável source) é possível pelo Windbg analisar qualquer tipo de stack com o comando k.
A variável de uma coroutine contém o contexto do chamador e do chamado. Quando houver a necessidade de explorar uma pilha não-ativa é preciso obter o valor de sp através dessa variável. Ela fica um pouco escondida, mas está lá. Acredite.
Usando o comando k = BasePtr StackPtr InstructionPtr passando o conteúdo de sp como o stack pointer o Windbg deve mostrar a pilha de todas as formas possíveis (especificar se terá FPO, mostrar código-fonte, argumentos, etc). Para a demonstração live fica bom ter um loop &amp;quot;eterno&amp;quot; para poder repetir a análise quantas vezes forem necessárias:
void cooperative(coroutine&amp;lt;void&amp;gt;::push_type &amp;amp;sink){while( g_stopAll == false ){boost::this_thread::sleep_for(boost::chrono::milliseconds(1000));sink();std::cout &amp;lt;&amp;lt; &amp;#34;Hello&amp;#34;;boost::this_thread::sleep_for(boost::chrono::milliseconds(1000));sink();std::cout &amp;lt;&amp;lt; &amp;#34;world&amp;#34;;}}int main(){coroutine&amp;lt;void&amp;gt;::pull_type source{ cooperative };while( g_stopAll == false ){source();std::cout &amp;lt;&amp;lt; &amp;#34;, &amp;#34;;source();std::cout &amp;lt;&amp;lt; &amp;#34;!\n&amp;#34;;}}0:000&amp;gt; ~kvn# ChildEBP RetAddr Args to Child 00 00b707c4 00f39668 00b708c8 075d31e5 00b70a08 coroutines_cooperative!cooperative&#43;0xa0 (FPO: [Non-Fpo]) (CONV: cdecl) [c:\projects\caloni\static\samples\coroutines_cooperative\coroutines_cooperative.cpp @ 19] 01 00b70910 00f18b5b cdcdcdcd cdcdcdcd 00f01fd2 coroutines_cooperative!boost::coroutines::detail::pull_coroutine_object&amp;lt;boost::coroutines::push_coroutine&amp;lt;void&amp;gt;,void,void (__cdecl*)(boost::coroutines::push_coroutine&amp;lt;void&amp;gt; &amp;amp;),boost::coroutines::basic_standard_stack_allocator&amp;lt;boost::coroutines::stack_traits&amp;gt; &amp;gt;::run&#43;0xf8 (FPO: [Non-Fpo]) (CONV: thiscall) [c:\libs\vcpkg\installed\x86-windows\include\boost\coroutine\detail\pull_coroutine_object.hpp @ 281] *** ERROR: Symbol file could not be found. Defaulted to export symbols for C:\Projects\caloni\static\samples\coroutines_cooperative\Debug\boost_context-vc141-mt-gd-x32-1_67.dll - 02 00b70a08 54261075 0075f4f0 0075f528 ffffffff coroutines_cooperative!boost::coroutines::detail::trampoline_pull&amp;lt;boost::coroutines::detail::pull_coroutine_object&amp;lt;boost::coroutines::push_coroutine&amp;lt;void&amp;gt;,void,void (__cdecl*)(boost::coroutines::push_coroutine&amp;lt;void&amp;gt; &amp;amp;),boost::coroutines::basic_standard_stack_allocator&amp;lt;boost::coroutines::stack_traits&amp;gt; &amp;gt; &amp;gt;&#43;0x9b (FPO: [Non-Fpo]) (CONV: cdecl) [c:\libs\vcpkg\installed\x86-windows\include\boost\coroutine\detail\trampoline_pull.hpp @ 42] WARNING: Stack unwind information not available. Following frames may be wrong.03 00b70a14 ffffffff 77c49ec1 cdcdcdcd cdcdcdcd boost_context_vc141_mt_gd_x32_1_67!make_fcontext&#43;0x75...0a 00b70a30 00000000 00000000 00000000 00b70a48 coroutines_cooperative!boost::coroutines::detail::pull_coroutine_object&amp;lt;boost::coroutines::push_coroutine&amp;lt;void&amp;gt;,void,void (__cdecl*)(boost::coroutines::push_coroutine&amp;lt;void&amp;gt; &amp;amp;),boost::coroutines::basic_standard_stack_allocator&amp;lt;boost::coroutines::stack_traits&amp;gt; &amp;gt;::`vftable&#39;.detachDica: É importante detachar do processo, mesmo que estejamos analisando em modo não-invasivo, porque a porta de Debug pode ser ocupada e o Visual Studio vai ficar pra sempre esperando receber eventos de debug que ele não vai mais receber.
Após rodarmos novamente o programa ele pára no main. Podemos atachar com o WinDbg quantas vezes precisarmos:
0:000&amp;gt; ~*kvn. 0 Id: 1b50.a58 Suspend: 1 Teb: 00b8c000 Unfrozen# ChildEBP RetAddr Args to Child 00 00cff9cc 00f3cc8e 00000001 030b6998 030b84d8 coroutines_cooperative!main&#43;0x9a (FPO: [Non-Fpo]) (CONV: cdecl) [c:\projects\caloni\static\samples\coroutines_cooperative\coroutines_cooperative.cpp @ 32] 01 00cff9e0 00f3cb27 3c5cdfac 00f02a9a 00f02a9a coroutines_cooperative!invoke_main&#43;0x1e (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl @ 78] 02 00cffa3c 00f3c9bd 00cffa4c 00f3cd08 00cffa60 coroutines_cooperative!__scrt_common_main_seh&#43;0x157 (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl @ 288] 03 00cffa44 00f3cd08 00cffa60 760f8654 00b89000 coroutines_cooperative!__scrt_common_main&#43;0xd (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl @ 331] 04 00cffa4c 760f8654 00b89000 760f8630 af8d0600 coroutines_cooperative!mainCRTStartup&#43;0x8 (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\vcstartup\src\startup\exe_main.cpp @ 17] 05 00cffa60 77c24a47 00b89000 7348514c 00000000 KERNEL32!BaseThreadInitThunk&#43;0x24 (FPO: [Non-Fpo])06 00cffaa8 77c24a17 ffffffff 77c49ee4 00000000 ntdll!__RtlUserThreadStart&#43;0x2f (FPO: [SEH])07 00cffab8 00000000 00f02a9a 00b89000 00000000 ntdll!_RtlUserThreadStart&#43;0x1b (FPO: [Non-Fpo])</description>
</item>

     
        <item>
  <title>Vcpkg Internals: como o gerenciador de pacotes da M$ funciona por dentro (e como fazer seu próprio pacote!)</title>
  <link>http://www.caloni.com.br/vcpkg-internals/</link>
  <pubDate>2018-09-12</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg-internals/</guid>
  <description>Depois de entender mais ou menos como funciona o vcpkg é hora de realmente entrar no código e entender qual a grande sacada dessa ferramenta da Microsoft.
Depurando o projeto Uma das formas mais divertidas de entender o funcionamento de um fonte é compilar e sair depurando. E foi o que eu fiz. Através dos step ins e step outs foi possível ter as primeiras impressões de em qual pé está o projeto, além de pegar boas ideias para meu próprio código.
Por exemplo, no começo do programa encontrei uma saída simples e eficaz de como tratar entrada e saída (ou só saída) de dentro de um terminal:
SetConsoleCP(CP_UTF8);SetConsoleOutputCP(CP_UTF8);Com tudo UTF-8 a vida fica mais fácil.
Outro ponto interessante é que o fonte é muito C&#43;&#43; moderno, com direito a inclusive usar headers ainda experimentais, como o (C&#43;&#43; 17). Ele usa também um conjunto de paths sobre onde estão as coisas (instalação, pacotes, etc). Há muito código no vcpkg que são módulos independentes que soam como retrabalho de coisas comuns, como parseamento de argumentos (e a já citada transformação em UTF-8), mas o objetivo do projeto é ser independente de tudo. Do contrário ele não seria um bom gerenciador de pacotes.
O arquivo vcpkg\installed\vcpkg\status contém em formato texto simples o status de todos os pacotes instalados (se foi instalado com sucesso ou não, etc). A pasta vcpkg\ports contém todos os pacotes, instalados ou não. O início de tudo é o executável na pasta-raiz após compilado, vcpkg.exe, feito em C&#43;&#43; e que realiza todas as bruxarias para montar a hierarquia de pastas e arquivos em texto. Tudo é tão simples e baseado em arquivos de texto que vejo que a M$ finalmente se rendeu ao jeito unix de fazer as coisas (mais conhecido como o jeito certo).
Triplets No gerenciador de pacotes há um conceito chamado de triplet, que não é uma novidade; é uma forma de especificar um conjunto de elementos do ambiente para cross compiling utilizando um simples nome.
c:\Libs\vcpkg&amp;gt;vcpkg help tripletAvailable architecture triplets:arm-uwparm-windowsarm64-uwparm64-windowsx64-linuxx64-osxx64-uwpx64-windowsx64-windows-staticx86-uwpx86-windowsx86-windows-staticx86-windows-static-v140xp &amp;lt;--- essa eu crieiO vcpkg já vem com alguns triplets de fábrica, mas você pode criar os seus próprios na pasta triplets, alterando várias variáveis de controle de compilação:
 VCPKG_TARGET_ARCHITECTURE. A arquitetura alvo (x86, x64, arm, arm64). VCPKG_CRT_LINKAGE. A linkagem do CRT (que é mais conhecida pelo pessoal do Zwindows; valores: dynamic, static). VCPKG_LIBRARY_LINKAGE. O mesmo do CRT, mas para libs (as bibliotecas podem ignorar se elas não suportam isso). VCPKG_CMAKE_SYSTEM_NAME. A plataforma alvo, que pode ser vazio (o Windows desktop padrão), WindowsStore, Darwin (Mac OSX) ou Linux. VCPKG_PLATFORM_TOOLSET. O toolset do Visual Studio (mais uma coisa do Zwindows); v141, v140 são valores válidos (vazio também). VCPKG_VISUAL_STUDIO_PATH. Onde está a instalação do Visual Studio (é, o vcpkg tem uma certa tendência pro Zwindows). VCPKG_CHAINLOAD_TOOLCHAIN_FILE. Esse não é do Zwindows, mas do CMake; a possibilidade de escolher outro toolchain (diferente de scripts/toolchains) para o CMake.  VCPKG_CXX_FLAGS Há diversas flags de compilação que podem ser especificadas direto no triplet:
 VCPKG_CXX_FLAGS_DEBUG VCPKG_CXX_FLAGS_RELEASE VCPKG_C_FLAGS VCPKG_C_FLAGS_DEBUG VCPKG_C_FLAGS_RELEASE  Customização per-port A macro do CMake PORT será interpretada pelo triplet. Isso é uma garantia de mudanças nos settings para portabilidade. Por exemplo:
set(VCPKG_LIBRARY_LINKAGE static)if(PORT MATCHES &amp;quot;qt5-&amp;quot;)set(VCPKG_LIBRARY_LINKAGE dynamic)endif()Que compila qualquer coisa que entre no match &amp;quot;qt5-*&amp;quot; como dinâmico (DLLs), embora todo o resto possa ser estático.
Integração com Visual Studio A integração com o Visual Studio ocorre com o uso daqueles pedaços de configuração de projetos que são as abas de propriedades. Você mesmo pode criar abas de propriedade como arquivos separados do seu vcxproj para configurações comuns a mais projetos.
Para realizar a integração o comando é **vcpkg integrate install&amp;quot;:
c:\Libs\vcpkg&amp;gt;vcpkg.exe integrate installApplied user-wide integration for this vcpkg root.All MSBuild C&#43;&#43; projects can now #include any installed libraries.Linking will be handled automatically.Installing new libraries will make them instantly available.CMake projects should use: &amp;quot;-DCMAKE_TOOLCHAIN_FILE=c:/Libs/vcpkg/scripts/buildsystems/vcpkg.cmake&amp;quot;Note que as coisas para quem usa CMake são automáticas e fáceis de usar. Basta acrescentar o toolchain especificado. Já para Visual Studio...
Behind the scene O mecanismo envolve uma pasta do msbuild:
C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V140\ImportBefore\Default
Dentro dessa pasta é colocado um desses pedaços de configuração (propriedades) chamado vcpkg.system.props.
&amp;lt;Project ToolsVersion=&amp;quot;4.0&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;&amp;lt;!-- version 1 --&amp;gt;&amp;lt;PropertyGroup&amp;gt;&amp;lt;VCLibPackagePath Condition=&amp;quot;&#39;$(VCLibPackagePath)&#39; == &#39;&#39;&amp;quot;&amp;gt;$(LOCALAPPDATA)\vcpkg\vcpkg.user&amp;lt;/VCLibPackagePath&amp;gt;&amp;lt;/PropertyGroup&amp;gt;&amp;lt;Import Condition=&amp;quot;&#39;$(VCLibPackagePath)&#39; != &#39;&#39; and Exists(&#39;$(VCLibPackagePath).targets&#39;)&amp;quot; Project=&amp;quot;$(VCLibPackagePath).targets&amp;quot; /&amp;gt;&amp;lt;/Project&amp;gt;Essa diretiva usa a pasta definida pela variável de ambiente LOCALAPPDATA (geralmente C:\Users&amp;lt;seu-usuario&amp;gt;\AppData\Local) para localizar um outro arquivo, o vcpkg.user.targets.
&amp;lt;Project ToolsVersion=&amp;quot;4.0&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;&amp;lt;Import Condition=&amp;quot;Exists(&#39;C:\Libs\vcpkg\scripts\buildsystems\msbuild\vcpkg.targets&#39;) and &#39;$(VCPkgLocalAppDataDisabled)&#39; == &#39;&#39;&amp;quot; Project=&amp;quot;C:\Libs\vcpkg\scripts\buildsystems\msbuild\vcpkg.targets&amp;quot; /&amp;gt;&amp;lt;/Project&amp;gt;No exemplo estou usando um vcpkg disponível na pasta c:\libs (que é basicamente um clone do repositório GitHub do vcpkg). Note que ele inclui automaticamente nos projetos do Visual Studio um target dentro dele, o vcpkg\scripts\buildsystems\msbuild\vcpkg.targets. Vejamos o que tem nele:
&amp;lt;Project ToolsVersion=&amp;quot;4.0&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;&amp;lt;!-- ... --&amp;gt;&amp;lt;ItemDefinitionGroup Condition=&amp;quot;&#39;$(VcpkgEnabled)&#39; == &#39;true&#39;&amp;quot;&amp;gt;&amp;lt;Link&amp;gt;&amp;lt;AdditionalDependencies Condition=&amp;quot;&#39;$(VcpkgNormalizedConfiguration)&#39; == &#39;Debug&#39; and &#39;$(VcpkgAutoLink)&#39; != &#39;false&#39;&amp;quot;&amp;gt;%(AdditionalDependencies);$(VcpkgRoot)debug\lib\*.lib&amp;lt;/AdditionalDependencies&amp;gt;&amp;lt;AdditionalDependencies Condition=&amp;quot;&#39;$(VcpkgNormalizedConfiguration)&#39; == &#39;Release&#39; and &#39;$(VcpkgAutoLink)&#39; != &#39;false&#39;&amp;quot;&amp;gt;%(AdditionalDependencies);$(VcpkgRoot)lib\*.lib&amp;lt;/AdditionalDependencies&amp;gt;&amp;lt;AdditionalLibraryDirectories Condition=&amp;quot;&#39;$(VcpkgNormalizedConfiguration)&#39; == &#39;Release&#39;&amp;quot;&amp;gt;%(AdditionalLibraryDirectories);$(VcpkgRoot)lib;$(VcpkgRoot)lib\manual-link&amp;lt;/AdditionalLibraryDirectories&amp;gt;&amp;lt;AdditionalLibraryDirectories Condition=&amp;quot;&#39;$(VcpkgNormalizedConfiguration)&#39; == &#39;Debug&#39;&amp;quot;&amp;gt;%(AdditionalLibraryDirectories);$(VcpkgRoot)debug\lib;$(VcpkgRoot)debug\lib\manual-link&amp;lt;/AdditionalLibraryDirectories&amp;gt;&amp;lt;/Link&amp;gt;&amp;lt;ClCompile&amp;gt;&amp;lt;AdditionalIncludeDirectories&amp;gt;%(AdditionalIncludeDirectories);$(VcpkgRoot)include&amp;lt;/AdditionalIncludeDirectories&amp;gt;&amp;lt;/ClCompile&amp;gt;&amp;lt;ResourceCompile&amp;gt;&amp;lt;AdditionalIncludeDirectories&amp;gt;%(AdditionalIncludeDirectories);$(VcpkgRoot)include&amp;lt;/AdditionalIncludeDirectories&amp;gt;&amp;lt;/ResourceCompile&amp;gt;&amp;lt;/ItemDefinitionGroup&amp;gt;&amp;lt;!-- ... --&amp;gt;&amp;lt;/Target&amp;gt;&amp;lt;/Project&amp;gt;Note como as pastas de instalação dos pacotes do triplet selecionado são incluídas na configuração de um projeto do Visual Studio. As libs ficam na subpasta installed//lib, os binários em installed//bin, os includes em installed//include e assim por diante. A ramificação dos pacotes está de acordo com o basename de cada um deles.
A mágica ocorre já na hora de dar include. E é mágica desde o autocomplete até o link. Por exemplo, digamos que vamos fazer um embedded de Python usando o exemplo do help:
int main(int argc, char* argv[]){wchar_t *program = Py_DecodeLocale(argv[0], NULL);if (program == NULL) {fprintf(stderr, &amp;quot;Fatal error: cannot decode argv[0]\n&amp;quot;);exit(1);}Py_SetProgramName(program); /* optional but recommended */Py_Initialize();PyRun_SimpleString(&amp;quot;from time import time,ctime\n&amp;quot;&amp;quot;print(&#39;Today is&#39;, ctime(time()))\n&amp;quot;);if (Py_FinalizeEx() &amp;lt; 0) {exit(120);}PyMem_RawFree(program);return 0;}O programa compila e linka. Para provar que ele usa a lib instalada (versão debug):
c:\Libs\vcpkg&amp;gt;dir /s /b installed\x86-windows\*python*.libc:\Libs\vcpkg\installed\x86-windows\debug\lib\boost_python36-vc140-mt-gd.libc:\Libs\vcpkg\installed\x86-windows\debug\lib\python36_d.libc:\Libs\vcpkg\installed\x86-windows\lib\boost_python36-vc140-mt.libc:\Libs\vcpkg\installed\x86-windows\lib\python36.libc:\Libs\vcpkg&amp;gt;mv c:\Libs\vcpkg\installed\x86-windows\debug\lib\python36_d.lib \Temp1&amp;gt;------ Rebuild All started: Project: ConsoleApplication1, Configuration: Debug Win32 ------1&amp;gt;pch.cpp1&amp;gt;ConsoleApplication1.cpp1&amp;gt;LINK : fatal error LNK1104: cannot open file &#39;python36_d.lib&#39;1&amp;gt;Done building project &amp;quot;ConsoleApplication1.vcxproj&amp;quot; -- FAILED.========== Rebuild All: 0 succeeded, 1 failed, 0 skipped ==========Se você prestou atenção ao conteúdo de msbuild\vcpkg.targets lá em cima vai ter visto que há uma condição que adiciona toda e qualquer lib como dependência adicional ao projeto compilando:
&amp;lt;AdditionalDependencies Condition=&amp;quot;&#39;$(VcpkgNormalizedConfiguration)&#39; == &#39;Debug&#39; and &#39;$(VcpkgAutoLink)&#39; != &#39;false&#39;&amp;quot;&amp;gt;%(AdditionalDependencies);$(VcpkgRoot)debug\lib\*.lib&amp;lt;/AdditionalDependencies&amp;gt;&amp;lt;AdditionalDependencies Condition=&amp;quot;&#39;$(VcpkgNormalizedConfiguration)&#39; == &#39;Release&#39; and &#39;$(VcpkgAutoLink)&#39; != &#39;false&#39;&amp;quot;&amp;gt;%(AdditionalDependencies);$(VcpkgRoot)lib\*.lib&amp;lt;/AdditionalDependencies&amp;gt;É isso que resolve o problema de saber qual o nome da lib resultante de um pacote instalado. Porém, isso não é o ideal, principalmente por dois motivos:
 Os nomes de configuração do projeto tem que ser Debug ou Release (maneiras de melhorar já está sendo discutido no GitHub). O usuário final não tem qualquer controle do que adicionar como dependência; simplesmente vai todos os pacotes instalados (mais uma discussão no GitHub).  Porém, no momento é assim que funciona. Para o problema #1 a solução paliativa é o próprio usuário adicionar em seu msbuild as condições de sua configuração. A sugestão da thread é boa:
&amp;lt;AdditionalDependencies Condition=&amp;quot;$(VcpkgConfiguration.StartsWith(&#39;Debug&#39;)) and &#39;$(VcpkgAutoLink)&#39; != &#39;false&#39;&amp;quot;&amp;gt;%(AdditionalDependencies);$(VcpkgRoot)debug\lib\*.lib&amp;lt;/AdditionalDependencies&amp;gt;Pelo menos tudo que começar com Debug (ou Release) já entraria no filtro.
Update: Essa sugestão já foi adicionada à última versão do vcpkg. É feita uma normalização do nome:
 &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(VcpkgEnabled)&#39; == &#39;true&#39;&amp;quot;&amp;gt;&amp;lt;VcpkgConfiguration Condition=&amp;quot;&#39;$(VcpkgConfiguration)&#39; == &#39;&#39;&amp;quot;&amp;gt;$(Configuration)&amp;lt;/VcpkgConfiguration&amp;gt;&amp;lt;VcpkgNormalizedConfiguration Condition=&amp;quot;$(VcpkgConfiguration.StartsWith(&#39;Debug&#39;))&amp;quot;&amp;gt;Debug&amp;lt;/VcpkgNormalizedConfiguration&amp;gt;&amp;lt;VcpkgNormalizedConfiguration Condition=&amp;quot;$(VcpkgConfiguration.StartsWith(&#39;Release&#39;)) or &#39;$(VcpkgConfiguration)&#39; == &#39;RelWithDebInfo&#39; or &#39;$(VcpkgConfiguration)&#39; == &#39;MinSizeRel&#39;&amp;quot;&amp;gt;Release&amp;lt;/VcpkgNormalizedConfiguration&amp;gt;&amp;lt;VcpkgRoot Condition=&amp;quot;&#39;$(VcpkgRoot)&#39; == &#39;&#39;&amp;quot;&amp;gt;$([MSBuild]::GetDirectoryNameOfFileAbove($(MSBuildThisFileDirectory), .vcpkg-root))\installed\$(VcpkgTriplet)\&amp;lt;/VcpkgRoot&amp;gt;&amp;lt;VcpkgApplocalDeps Condition=&amp;quot;&#39;$(VcpkgApplocalDeps)&#39; == &#39;&#39;&amp;quot;&amp;gt;true&amp;lt;/VcpkgApplocalDeps&amp;gt;&amp;lt;/PropertyGroup&amp;gt;Assim o que seguir é Debug ou Release =).
F5 que funciona Um outro potencial problema dos usuários de Visual Studio para compilar e rodar projetos C&#43;&#43; são as dependências de binários (DLLs). É possível que um pacote seja compilado de maneira dinâmica, ou seja, com DLLs de dependência. Essas DLLs na instalação do pacote devem constar na pasta bin, mas por conta dessa pasta não fazer parte dos diretórios de sistema o depurador do Visual Studio irá carregar um executável em sua pasta de geração em que não encontrará as eventuais DLLs que ele precisa para rodar.
Para &amp;quot;corrigir&amp;quot; isso, ou melhor dizendo, contornar a experiência, também foi adicionado um comando Post Build no vcpkg.targets com um comando Power Shell que copia esses binários para a pasta de geração do projeto atual. Dessa forma o projeto pode rodar sem problemas, o usuário fica feliz e consegue terminar sua programação antes de passar para o deploy (e facilita deploys de testes, pois basta copiar a pasta de geração do executável que todas suas dependências estarão lá).
 &amp;lt;Target Name=&amp;quot;AppLocalFromInstalled&amp;quot; AfterTargets=&amp;quot;CopyFilesToOutputDirectory&amp;quot; BeforeTargets=&amp;quot;CopyLocalFilesOutputGroup;RegisterOutput&amp;quot; Condition=&amp;quot;&#39;$(VcpkgEnabled)&#39; == &#39;true&#39; and &#39;$(VcpkgApplocalDeps)&#39; == &#39;true&#39;&amp;quot;&amp;gt;&amp;lt;WriteLinesToFileFile=&amp;quot;$(TLogLocation)$(ProjectName).write.1u.tlog&amp;quot;Lines=&amp;quot;^$(TargetPath);$([System.IO.Path]::Combine($(ProjectDir),$(IntDir)))vcpkg.applocal.log&amp;quot; Encoding=&amp;quot;Unicode&amp;quot;/&amp;gt;&amp;lt;Exec Condition=&amp;quot;$(VcpkgConfiguration.StartsWith(&#39;Debug&#39;))&amp;quot;Command=&amp;quot;$(SystemRoot)\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass -noprofile -File %22$(MSBuildThisFileDirectory)applocal.ps1%22 %22$(TargetPath)%22 %22$(VcpkgRoot)debug\bin%22 %22$(TLogLocation)$(ProjectName).write.1u.tlog%22 %22$(IntDir)vcpkg.applocal.log%22&amp;quot;StandardOutputImportance=&amp;quot;Normal&amp;quot;&amp;gt;&amp;lt;/Exec&amp;gt;&amp;lt;Exec Condition=&amp;quot;$(VcpkgConfiguration.StartsWith(&#39;Release&#39;))&amp;quot;Command=&amp;quot;$(SystemRoot)\System32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass -noprofile -File %22$(MSBuildThisFileDirectory)applocal.ps1%22 %22$(TargetPath)%22 %22$(VcpkgRoot)bin%22 %22$(TLogLocation)$(ProjectName).write.1u.tlog%22 %22$(IntDir)vcpkg.applocal.log%22&amp;quot;StandardOutputImportance=&amp;quot;Normal&amp;quot;&amp;gt;&amp;lt;/Exec&amp;gt;&amp;lt;ReadLinesFromFile File=&amp;quot;$(IntDir)vcpkg.applocal.log&amp;quot;&amp;gt;&amp;lt;Output TaskParameter=&amp;quot;Lines&amp;quot; ItemName=&amp;quot;VcpkgAppLocalDLLs&amp;quot; /&amp;gt;&amp;lt;/ReadLinesFromFile&amp;gt;&amp;lt;Message Text=&amp;quot;@(VcpkgAppLocalDLLs,&#39;%0A&#39;)&amp;quot; Importance=&amp;quot;Normal&amp;quot; /&amp;gt;&amp;lt;ItemGroup&amp;gt;&amp;lt;ReferenceCopyLocalPaths Include=&amp;quot;@(VcpkgAppLocalDLLs)&amp;quot; /&amp;gt;&amp;lt;/ItemGroup&amp;gt;&amp;lt;/Target&amp;gt;O script executado pelo PowerShell fica em vcpkg\scripts\buildsystems\msbuild e recebe o TargetPath (o binário-alvo) como parâmetro e onde estão os binários instalados pelo vcpkg, e com base na saída da ferramenta dumpbin extrai as dependências do executável e as busca no diretório bin:
$a = $(dumpbin /DEPENDENTS $targetBinary | ? { $_ -match &amp;quot;^ [^ ].*\.dll&amp;quot; } | % { $_ -replace &amp;quot;^ &amp;quot;,&amp;quot;&amp;quot; })Isso é o equivalente ao uso padrão de dumpbin com grep e sed:
c:\Libs\vcpkg&amp;gt;dumpbin /DEPENDENTS c:\...\Debug\ConsoleApplication1.exe | grep &amp;quot;^ .*.dll&amp;quot; | sed &amp;quot;s/^ \(.*.dll\)/\1/&amp;quot;python36_d.dllVCRUNTIME140D.dllucrtbased.dllKERNEL32.dllA cópia dos binários é feito com um teste simples de &amp;quot;path existe&amp;quot; com deploy:
if (Test-Path &amp;quot;$installedDir\$_&amp;quot;) {deployBinary $baseTargetBinaryDir $installedDir &amp;quot;$_&amp;quot;Fato curioso: no script do PowerShell existem alguns hacks para alguns pacotes, incluindo Qt.
CMake for the win! O uso do CMake permite aos usuários do vcpkg ter boas ideias apenas lendo os scripts do projeto. Se você abrir o solution vcpkg.sln dentro de toolsrc vai descobrir todos os scripts listados por lá. Há funções espertinhas como o download e extração de pacotes 7zip do Source Forge.
Essa parte fica em vcpkg/scripts/cmake. Olhe, por exemplo, como retornar a versão do Windows SDK (vcpkg_get_windows_sdk.cmake):
# Returns Windows SDK number via out variable &amp;quot;ret&amp;quot;function(vcpkg_get_windows_sdk ret)set(WINDOWS_SDK $ENV{WindowsSDKVersion})string(REPLACE &amp;quot;\\&amp;quot; &amp;quot;&amp;quot; WINDOWS_SDK &amp;quot;${WINDOWS_SDK}&amp;quot;)set(${ret} ${WINDOWS_SDK} PARENT_SCOPE)endfunction()Assim como o esquema de triplets, tudo pode ser atualizado conforme o gosto do freguês, adicionando funções e configurações úteis em seu clone do repositório, e feitas atualizações com a versão oficial.
Exportando instalações O vcpkg não é apenas um ecossistema de libs compiladas e instaladas em uma pasta para serem usadas localmente. Pode ser um caminho simples e rápido para você conseguir compilar libs conhecidas e entregar para um terceiro um zip com todos os includes, libs e dependências do seu projeto.
c:\Libs\vcpkg&amp;gt;vcpkg.exe export python3 --7zipThe following packages are already built and will be exported:python3:x86-windowsExporting package python3:x86-windows...Exporting package python3:x86-windows... doneCreating 7zip archive...Creating 7zip archive... done7zip archive exported at: c:/Libs/vcpkg/vcpkg-export-20180912-172712.7zTo use the exported libraries in CMake projects use:&amp;quot;-DCMAKE_TOOLCHAIN_FILE=[...]/scripts/buildsystems/vcpkg.cmake&amp;quot;Montando seu próprio pacote Para trabalhar em equipe é vital que todos falem a mesma língua. Uma das formas disso acontecer é usar um gerenciamento de pacotes que inclua todos os ambientes que a equipe usa. Como geralmente esses ambiente não são os mesmos, o uso de pacotes próprios do vcpkg é um plus da ferramenta que vem para somar em padronização de fontes e compilação.
Primeiro de tudo é interessante existir um local público de download dos fontes (caso o projeto seja opensource; se bem que é possível que o endereço seja apenas visível para usuários logados ou outro mecanismo de proteção).
Uma estrutura simples de lib que compila com CMake, por exemplo, deverá conter alguns arquivos mínimos:
c:\Libs\vcpkg&amp;gt;dir /s /b \Libs\bitforgec:\Libs\bitforge\bitforge.cppc:\Libs\bitforge\bitforge.hc:\Libs\bitforge\CMakeLists.txtc:\Libs\bitforge\LICENSEUm .cpp com a implementação, um .h público para o usuário acessar, uma licença de uso (LICENSE) e um arquivo CMakeLists.txt são o suficiente para demonstar o uso. Dentro do CMakeLists.txt temos as seguintes diretivas:
cmake_minimum_required (VERSION 3.11.2)project(bitforge VERSION 18.9.12 LANGUAGES CXX)add_library(bitforge STATIC bitforge.cpp)install(TARGETS bitforge DESTINATION lib)install(FILES bitforge.h DESTINATION include)A partir de um zip na internet da pasta bitforge já é possível começar a montar seu próprio pacote:
c:\Libs\vcpkg&amp;gt;vcpkg.exe create bitforge http://caloni.com.br/release/bitforge-18.9.12.zip bitforge-18.9.12.zip-- Downloading http://caloni.com.br/release/bitforge-18.9.12.zip...-- Generated portfile: C:\Libs\vcpkg\ports\bitforge\portfile.cmake-- Generated CONTROL: C:\Libs\vcpkg\ports\bitforge\CONTROL-- To launch an editor for these new files, run-- .\vcpkg edit bitforgeDica: você pode também testar ou implantar isso localmente usando Python:
python3 -m http.serverpython -m SimpleHTTPServerO arquivo portfile.cmake já possui teoricamente tudo o que precisa para falhar. Há alguns caveats que podem te dar bastante dor de cabeça no começo. Por isso mesmo eu vou economizar algum tempo para você.
Em primeiro lugar, preste atenção no diretório onde estarão os fontes. É costume do template usar o mesmo nome do zip, o que nem sempre é verdade (aqui não é, não existe versão no nome da pasta zipada):
Então em vez de:
set(SOURCE_PATH ${CURRENT_BUILDTREES_DIR}/src/bitforge-18.9.12)Isso:
set(SOURCE_PATH ${CURRENT_BUILDTREES_DIR}/src/bitforge)O erro que deve acontecer na falta dessa mudança é o seguinte:
c:\Libs\vcpkg&amp;gt;vcpkg.exe build bitforge-- Using cached C:/Libs/vcpkg/downloads/bitforge-18.9.12.zip-- Configuring x86-windowsCMake Error at scripts/cmake/vcpkg_execute_required_process.cmake:56 (message):Command failed: ninja;-vWorking Directory: C:/Libs/vcpkg/buildtrees/bitforge/x86-windows-rel/vcpkg-parallel-configureSee logs for more information:C:\Libs\vcpkg\buildtrees\bitforge\config-x86-windows-out.logCall Stack (most recent call first):scripts/cmake/vcpkg_configure_cmake.cmake:246 (vcpkg_execute_required_process)ports/bitforge/portfile.cmake:22 (vcpkg_configure_cmake)scripts/ports.cmake:71 (include)Elapsed time for package bitforge:x86-windows: 983.4 msError: Building package bitforge:x86-windows failed with: BUILD_FAILEDPlease ensure you&#39;re using the latest portfiles with `.\vcpkg update`, thensubmit an issue at https://github.com/Microsoft/vcpkg/issues including:Package: bitforge:x86-windowsVcpkg version: 0.0.113-nohashAdditionally, attach any relevant sections from the log files above.c:\Libs\vcpkg&amp;gt;cat C:\Libs\vcpkg\buildtrees\bitforge\config-x86-windows-out.log[1/2] cmd /c &amp;quot;cd .. &amp;amp;&amp;amp; &amp;quot;C:/Libs/vcpkg/downloads/tools/cmake-3.11.4-windows/cmake-3.11.4-win32-x86/bin/cmake.exe&amp;quot; &amp;quot;C:/Libs/vcpkg/buildtrees/bitforge/src/bitforge-18.9.12&amp;quot; &amp;quot;-DCMAKE_MAKE_PROGRAM=C:/Program Files (x86)/Microsoft Visual Studio/Preview/Enterprise/Common7/IDE/CommonExtensions/Microsoft/CMake/Ninja/ninja.exe&amp;quot; &amp;quot;-DBUILD_SHARED_LIBS=ON&amp;quot; &amp;quot;-DVCPKG_CHAINLOAD_TOOLCHAIN_FILE=C:/Libs/vcpkg/scripts/toolchains/windows.cmake&amp;quot; &amp;quot;-DVCPKG_TARGET_TRIPLET=x86-windows&amp;quot; &amp;quot;-DVCPKG_PLATFORM_TOOLSET=v141&amp;quot; &amp;quot;-DCMAKE_EXPORT_NO_PACKAGE_REGISTRY=ON&amp;quot; &amp;quot;-DCMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY=ON&amp;quot; &amp;quot;-DCMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY=ON&amp;quot; &amp;quot;-DCMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_SKIP=TRUE&amp;quot; &amp;quot;-DCMAKE_VERBOSE_MAKEFILE=ON&amp;quot; &amp;quot;-DVCPKG_APPLOCAL_DEPS=OFF&amp;quot; &amp;quot;-DCMAKE_TOOLCHAIN_FILE=C:/Libs/vcpkg/scripts/buildsystems/vcpkg.cmake&amp;quot; &amp;quot;-DCMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION=ON&amp;quot; &amp;quot;-DVCPKG_CXX_FLAGS=&amp;quot; &amp;quot;-DVCPKG_CXX_FLAGS_RELEASE=&amp;quot; &amp;quot;-DVCPKG_CXX_FLAGS_DEBUG=&amp;quot; &amp;quot;-DVCPKG_C_FLAGS=&amp;quot; &amp;quot;-DVCPKG_C_FLAGS_RELEASE=&amp;quot; &amp;quot;-DVCPKG_C_FLAGS_DEBUG=&amp;quot; &amp;quot;-DVCPKG_CRT_LINKAGE=dynamic&amp;quot; &amp;quot;-DVCPKG_LINKER_FLAGS=&amp;quot; &amp;quot;-DCMAKE_INSTALL_LIBDIR:STRING=lib&amp;quot; &amp;quot;-DCMAKE_INSTALL_BINDIR:STRING=bin&amp;quot; &amp;quot;-G&amp;quot; &amp;quot;Ninja&amp;quot; &amp;quot;-DCMAKE_BUILD_TYPE=Release&amp;quot; &amp;quot;-DCMAKE_INSTALL_PREFIX=C:/Libs/vcpkg/packages/bitforge_x86-windows&amp;quot;&amp;quot;FAILED: ../CMakeCache.txtcmd /c &amp;quot;cd .. &amp;amp;&amp;amp; &amp;quot;C:/Libs/vcpkg/downloads/tools/cmake-3.11.4-windows/cmake-3.11.4-win32-x86/bin/cmake.exe&amp;quot; &amp;quot;C:/Libs/vcpkg/buildtrees/bitforge/src/bitforge-18.9.12&amp;quot; &amp;quot;-DCMAKE_MAKE_PROGRAM=C:/Program Files (x86)/Microsoft Visual Studio/Preview/Enterprise/Common7/IDE/CommonExtensions/Microsoft/CMake/Ninja/ninja.exe&amp;quot; &amp;quot;-DBUILD_SHARED_LIBS=ON&amp;quot; &amp;quot;-DVCPKG_CHAINLOAD_TOOLCHAIN_FILE=C:/Libs/vcpkg/scripts/toolchains/windows.cmake&amp;quot; &amp;quot;-DVCPKG_TARGET_TRIPLET=x86-windows&amp;quot; &amp;quot;-DVCPKG_PLATFORM_TOOLSET=v141&amp;quot; &amp;quot;-DCMAKE_EXPORT_NO_PACKAGE_REGISTRY=ON&amp;quot; &amp;quot;-DCMAKE_FIND_PACKAGE_NO_PACKAGE_REGISTRY=ON&amp;quot; &amp;quot;-DCMAKE_FIND_PACKAGE_NO_SYSTEM_PACKAGE_REGISTRY=ON&amp;quot; &amp;quot;-DCMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_SKIP=TRUE&amp;quot; &amp;quot;-DCMAKE_VERBOSE_MAKEFILE=ON&amp;quot; &amp;quot;-DVCPKG_APPLOCAL_DEPS=OFF&amp;quot; &amp;quot;-DCMAKE_TOOLCHAIN_FILE=C:/Libs/vcpkg/scripts/buildsystems/vcpkg.cmake&amp;quot; &amp;quot;-DCMAKE_ERROR_ON_ABSOLUTE_INSTALL_DESTINATION=ON&amp;quot; &amp;quot;-DVCPKG_CXX_FLAGS=&amp;quot; &amp;quot;-DVCPKG_CXX_FLAGS_RELEASE=&amp;quot; &amp;quot;-DVCPKG_CXX_FLAGS_DEBUG=&amp;quot; &amp;quot;-DVCPKG_C_FLAGS=&amp;quot; &amp;quot;-DVCPKG_C_FLAGS_RELEASE=&amp;quot; &amp;quot;-DVCPKG_C_FLAGS_DEBUG=&amp;quot; &amp;quot;-DVCPKG_CRT_LINKAGE=dynamic&amp;quot; &amp;quot;-DVCPKG_LINKER_FLAGS=&amp;quot; &amp;quot;-DCMAKE_INSTALL_LIBDIR:STRING=lib&amp;quot; &amp;quot;-DCMAKE_INSTALL_BINDIR:STRING=bin&amp;quot; &amp;quot;-G&amp;quot; &amp;quot;Ninja&amp;quot; &amp;quot;-DCMAKE_BUILD_TYPE=Release&amp;quot; &amp;quot;-DCMAKE_INSTALL_PREFIX=C:/Libs/vcpkg/packages/bitforge_x86-windows&amp;quot;&amp;quot;--- IMPORTANTE ---CMake Error: The source directory &amp;quot;C:/Libs/vcpkg/buildtrees/bitforge/src/bitforge-18.9.12&amp;quot; does not exist.--- IMPORTANTE ---Em segundo lugar, a cópia do header é feita tanto em release quanto em debug. A compilação via vcpkg irá te avisar que tem alguma coisa errada pois está duplicado, mas já há uma linha mágica que pode ser adicionada:
# Fix duplicated includefile(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/include)O erro que deve acontecer na falta dessa mudança é o seguinte:
c:\Libs\vcpkg&amp;gt;vcpkg.exe build bitforge-- Using cached C:/Libs/vcpkg/downloads/bitforge-18.9.12.zip-- Configuring x86-windows-- Building x86-windows-dbg-- Building x86-windows-rel-- Performing post-build validation--- IMPORTANTE ---Include files should not be duplicated into the /debug/include directory. If this cannot be disabled in the project cmake, usefile(REMOVE_RECURSE ${CURRENT_PACKAGES_DIR}/debug/include)--- IMPORTANTE ---The software license must be available at ${CURRENT_PACKAGES_DIR}/share/bitforge/copyrightfile(COPY ${CURRENT_BUILDTREES_DIR}/src/bitforge/LICENSE DESTINATION ${CURRENT_PACKAGES_DIR}/share/bitforge)file(RENAME ${CURRENT_PACKAGES_DIR}/share/bitforge/LICENSE ${CURRENT_PACKAGES_DIR}/share/bitforge/copyright)Found 2 error(s). Please correct the portfile:c:\Libs\vcpkg\ports\bitforge\portfile.cmake-- Performing post-build validation doneElapsed time for package bitforge:x86-windows: 4.139 sError: Building package bitforge:x86-windows failed with: POST_BUILD_CHECKS_FAILEDPlease ensure you&#39;re using the latest portfiles with `.\vcpkg update`, thensubmit an issue at https://github.com/Microsoft/vcpkg/issues including:Package: bitforge:x86-windowsVcpkg version: 0.0.113-nohashAdditionally, attach any relevant sections from the log files above.E por último, é obrigatório ter um arquivo de copyright, no caso o nosso LICENSE do projeto. O portfile.cmake já tem o comando, mas está comentado:
# Handle copyrightfile(INSTALL ${SOURCE_PATH}/LICENSE DESTINATION ${CURRENT_PACKAGES_DIR}/share/bitforge RENAME copyright)O erro que deve acontecer na falta dessa mudança é o seguinte:
c:\Libs\vcpkg&amp;gt;vcpkg.exe build bitforgeYour feedback is important to improve Vcpkg! Please take 3 minutes to complete our survey by running: vcpkg contact --survey-- Using cached C:/Libs/vcpkg/downloads/bitforge-18.9.12.zip-- Configuring x86-windows-- Building x86-windows-dbg-- Building x86-windows-rel-- Performing post-build validation--- IMPORTANTE ---The software license must be available at ${CURRENT_PACKAGES_DIR}/share/bitforge/copyright--- IMPORTANTE ---file(COPY ${CURRENT_BUILDTREES_DIR}/src/bitforge/LICENSE DESTINATION ${CURRENT_PACKAGES_DIR}/share/bitforge)file(RENAME ${CURRENT_PACKAGES_DIR}/share/bitforge/LICENSE ${CURRENT_PACKAGES_DIR}/share/bitforge/copyright)Found 1 error(s). Please correct the portfile:c:\Libs\vcpkg\ports\bitforge\portfile.cmake-- Performing post-build validation doneElapsed time for package bitforge:x86-windows: 4.188 sError: Building package bitforge:x86-windows failed with: POST_BUILD_CHECKS_FAILEDPlease ensure you&#39;re using the latest portfiles with `.\vcpkg update`, thensubmit an issue at https://github.com/Microsoft/vcpkg/issues including:Package: bitforge:x86-windowsVcpkg version: 0.0.113-nohashAdditionally, attach any relevant sections from the log files above.Basicamente isso é o que você precisa para começar a construir seu pacote:
c:\Libs\vcpkg&amp;gt;vcpkg.exe build bitforge-- Using cached C:/Libs/vcpkg/downloads/bitforge-18.9.12.zip-- Configuring x86-windows-- Building x86-windows-dbg-- Building x86-windows-rel-- Installing: C:/Libs/vcpkg/packages/bitforge_x86-windows/share/bitforge/copyright-- Performing post-build validation-- Performing post-build validation doneElapsed time for package bitforge:x86-windows: 4.224 sO próximo passo é instalar:
c:\Libs\vcpkg&amp;gt;vcpkg.exe install bitforgeThe following packages will be built and installed:bitforge[core]:x86-windowsStarting package 1/1: bitforge:x86-windowsBuilding package bitforge[core]:x86-windows...-- Using cached C:/Libs/vcpkg/downloads/bitforge-18.9.12.zip-- Configuring x86-windows-- Building x86-windows-dbg-- Building x86-windows-rel-- Installing: C:/Libs/vcpkg/packages/bitforge_x86-windows/share/bitforge/copyright-- Performing post-build validation-- Performing post-build validation doneBuilding package bitforge[core]:x86-windows... doneInstalling package bitforge[core]:x86-windows...Installing package bitforge[core]:x86-windows... doneElapsed time for package bitforge:x86-windows: 4.239 sTotal elapsed time: 4.239 sc:\Libs\vcpkg&amp;gt;dir /s /b installed\x86-windows\bitforge.*c:\Libs\vcpkg\installed\x86-windows\debug\lib\bitforge.libc:\Libs\vcpkg\installed\x86-windows\include\bitforge.hc:\Libs\vcpkg\installed\x86-windows\lib\bitforge.libc:\Libs\vcpkg\installed\x86-windows\share\bitforgeE voilá! Agora o include está disponível, as funções estão disponíveis, o link está funcionando e seu pacote pode ser compartilhado com toda a empresa. Basta copiar a pasta ports/bitforge ou adicioná-la no repositório por um commit.
</description>
</item>

     
        <item>
  <title>GetArg: the ultimate badass argv/argc parser</title>
  <link>http://www.caloni.com.br/getarg/</link>
  <pubDate>2018-08-30</pubDate>
  
  <guid>http://www.caloni.com.br/getarg/</guid>
  <description>Sim, eu acho que já resumi o suficiente meu parseador de argv/argc no meu último artigo sobre o tema. Sim, eu também acho que a versão com STL bonitinha (mas ordinária). A questão agora não são as dependências, mas o uso no dia-a-dia: precisa ter o argc nessa equação?
A resposta é não. Pois, como sabemos, o padrão C/C&#43;&#43; nos informa que o argv é um array de ponteiros de strings C que termina em nulo. Sabemos que ele termina, então o argc é apenas um helper para sabermos de antemão onde ele termina. Mas quando precisamos, por exemplo, passar o argv/argc para uma thread Windows, que aceita apenas um argumento mágico, talvez minha versão antiga não seja tão eficaz, pois isso vai exibir que eu aloque memória de um struct que contenha ambas as variáveis, etc. Por que não simplesmente utilizar apenas o argv?
#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;/** Interpreta argumentos da linha de comando (versão raiz truzona).@author Wanderley Caloni &amp;lt;wanderley.caloni@bitforge.com.br&amp;gt;@date 2018-08*/const char* GetArg(char* argv[], const char* arg){while( *&#43;&#43;argv ){if( strcmp(*argv, arg) == 0 ){if( *(argv&#43;1) )return *(argv&#43;1);elsereturn &amp;quot;&amp;quot;;}}return NULL;}int main(int argc, char* argv[]){printf(&amp;quot;Type enter to start...&amp;quot;);getchar();if( GetArg(argv, &amp;quot;--debug&amp;quot;) )printf(&amp;quot;Waiting for debugger...\n&amp;quot;);if( const char* command = GetArg(argv, &amp;quot;--command&amp;quot;) )printf(&amp;quot;Command %s received\n&amp;quot;, command);}Nessa versão elminamos a necessidade do argc e de brinde ganhamos a possibilidade de usar um único ponteiro como start de um parseamento de argumentos.
</description>
</item>

     
        <item>
  <title>Meu Novo Parseador de Argc Argv</title>
  <link>http://www.caloni.com.br/meu-novo-parseador-de-argc-argv/</link>
  <pubDate>2018-08-21</pubDate>
  
  <guid>http://www.caloni.com.br/meu-novo-parseador-de-argc-argv/</guid>
  <description>Eis que me deparo com um projeto onde não posso usar STL. Ou seja, nada de map nem string. Isso quer dizer que minha função bonita e completa de parseamento de argumentos argc/argv não pode ser usado. Essa é uma má notícia. A boa notícia é que achei uma forma muito mais simples e à prova de falhas de fazer isso. Ele basicamente percorre o array argv em busca do nome do parâmetro enviado para a função. Uma vez que ele encontre ele retorna o próximo elemento. Na falta de próximo elemento ele simplesmente retorna uma string vazia que não é nulo, mas já indica que há o parâmetro na lista de argumento.
Essa função é tão simples, e tem tão poucas dependências (strcmp) que você pode usá-la em praticamente qualquer programa que use argc/argv e que use os parâmetros dos mais complexos. Ao chamar essa função se passa o argc e o argv recebido no main e o terceiro argumento é apenas o nome de um argumento válido que pode ser recebido via linha de comando. O resultado é um ponteiro (obtido no próprio argv) da próxima string ou uma string C vazia constante (não precisa de alocação) se for o último argv. E caso ele não ache o retorno é NULL. Seu uso comum é uma linha apenas, ou uma linha para cada argumento buscado. Sua complexidade é linear, mas, ei, quem está querendo performance no início do programa?
Uma última observação: dependendo do uso você pode ou não usar o retorno, e ele possui semântica booleana, pois caso o argumento não exista o retorno é NULL e por isso não cai dentro do if (pois NULL traduzido em booleano é false). Eis uma função para copiar e colar abusivamente.
</description>
</item>

     
        <item>
  <title>Vídeo: Visual Studio e seu depurador (comentado)</title>
  <link>http://www.caloni.com.br/video-depuracao-visualstudio-101-comentado/</link>
  <pubDate>2018-07-27</pubDate>
  
  <guid>http://www.caloni.com.br/video-depuracao-visualstudio-101-comentado/</guid>
  <description>Segue meu segundo vídeo curto onde estou apenas demonstrando como é o depurador do Visual Studio. Mas dessa vez com comentários =)
</description>
</item>

     
        <item>
  <title>Vídeo: Depuração Visual Studio 101</title>
  <link>http://www.caloni.com.br/video-depuracao-visualstudio-101/</link>
  <pubDate>2018-07-24</pubDate>
  
  <guid>http://www.caloni.com.br/video-depuracao-visualstudio-101/</guid>
  <description>Redescobrindo meu canal no YouTube me empolguei em publicar mais alguma coisa. Os meu primeiros vídeos, no meu canal pessoal, são longos e possuem narração um pouco confusa, mas explicam bem alguns detalhes do Visual Studio. Agora com meu primeiro vídeo curto estou apenas demonstrando sem voz como é o depurador do Visual Studio. Enjoy =)
</description>
</item>

     
        <item>
  <title>Vcpkg: gerenciador de libs c&#43;&#43; para Linux, Mac OS... e Windows!</title>
  <link>http://www.caloni.com.br/vcpkg/</link>
  <pubDate>2018-07-14</pubDate>
  
  <guid>http://www.caloni.com.br/vcpkg/</guid>
  <description>O ambiente padronizado de bibliotecas C/C&#43;&#43; dos sistemas UNIX é motivo de inveja dos programadores Windows por séculos. Mas, finalmente, a Microsoft tem acordado diante da ressurreição do C&#43;&#43;, com seus novos bug fixes e new deprecated features.
E com isso uma série de atividades têm permeada a evolução da ferramenta de desenvolvimento da Microsoft, o Visual Studio:
 Updates frequentes Projetos internos lançados como open source no GitHub Compra do GitHub Suporte a mais de um compilador (como clang) Depuração Linux (Ubuntu) dentro do Windows Ambiente Linux (Ubuntu) dentro do Windows Pesado suporte ao CMake Ambiente padronizado de bibliotecas para Windows, Linux e Mac OS (vcpkg) Suporte à compilação de bibliotecas clássicas dos ambientes UNIX via vcpkg Deploy de suas próprias bibliotecas padronizadas via vcpkg  Usar o vcpkg no Windows é tão simples que parece mágica. Ou Linux.
Para instalar você só precisa seguir o passo-a-passo do GitHub deles e usar PowerShell. O prompt PS faz tudo automático. O vcpkg é basicamente um conjunto de CMakes que fazem o serviço direito e conseguem compilar quase 1000 libs, a maioria nascidas no Linux, e integrar diretamente com projetos do VS2017.
Para provar todo o seu poder vamos usar a pior lib de todas: GTK.
O GTK não é apenas uma biblioteca, mas um conjunto de infinitas dependências. Há um tutorial gigantesco para compilar para Windows (defasado) e novos problemas surgem cada vez que alguém tenta utilizá-lo. Eu gastei mais de 40 horas para entender esses problemas compilando todas as dependências (estava em 95%) quando surgiu o vcpkg e jogou todos meus esforços no lixo (ainda bem).
Com o vcpkg tudo que é necessário fazer é rodar o comando de install com o nome da lib e toda a compilação é feita automaticamente. Depois disso, se não houver paths de include nos seus projetos do Visual Studio ele próprio irá levar em conta o path de instalação dessas libs (compilação e link). Parece mágica mesmo para quem passou décadas se matando para compilar alguma coisa que preste no Windows e que veio do Linux.
Vantagens do vcpkg:
 Economia de tempo (de pesquisa, de compilação, de tudo) Uniformidade no uso das libs Flexibilidade para colocar suas próprias libs  Desvantagens do vcpkg:
 Apenas as libs mais novas estão sendo suportadas (e não há suporte para Visual Studio mais antigo, nem SOs mais antigos como XP). Usuário Linux nenhum no mundo vai querer usar (motivo: Microsoft e este já é um problema resolvido neste mundo) Depende de um gerenciador proprietário (se bem que é tudo open source e não há restrições como o Java; qualquer um pode montar seu repositório).  </description>
</item>

     
        <item>
  <title>Manipulando Mouse e Teclado no Windows</title>
  <link>http://www.caloni.com.br/manipulando-mouse-e-teclado-no-windows/</link>
  <pubDate>2018-07-04</pubDate>
  
  <guid>http://www.caloni.com.br/manipulando-mouse-e-teclado-no-windows/</guid>
  <description>Uma forma extremamente bem comportada que o Windows tem para manipular entrada de mouse e teclado são as funções API BlockInput/SendInput [1][2]. Enquanto uma bloqueia todos os eventos de input vindo de todos os lugares do sistema, o outro consegue enviar inputs apenas por software. Imagine a peça que você pode pregar em seus amigos.
No entanto, estas funções não são para amadores. É preciso entender o que são threads, por exemplo, pois apenas a thread que chamou BlockInput pode depois chamar SendInput com sucesso. Além disso, apenas essa thread pode desbloquear novamente os inputs chamando BlockInput novamente, mas dessa vez passando FALSE em seu único parâmetro. E de qualquer forma, uma vez que o programa que chamou BlockInput com TRUE morreu o sistema detecta e tudo volta ao normal.
Essas funções API podem ser úteis para interação remota, por exemplo, quando um usuário não consegue realizar uma operação e ele pode mais atrapalhar do que ajudar você pode bloquear os inputs dele e emular seus próprios cliques de mouse e teclado pela rede.
Nota: usar essas APIs na própria máquina pode ser bem frustrante. Tenha sempre em mãos uma VM de teste.
Funções citadas neste texto:
 [1] https://msdn.microsoft.com/en-us/library/windows/desktop/ms646290(v=vs.85).aspx [2] https://msdn.microsoft.com/en-us/library/windows/desktop/ms646310(v=vs.85).aspx  </description>
</item>

     
        <item>
  <title>Lista Ligada; tá Ligado?</title>
  <link>http://www.caloni.com.br/lista-ligada/</link>
  <pubDate>2018-04-24</pubDate>
  
  <guid>http://www.caloni.com.br/lista-ligada/</guid>
  <description>Uma lista ligada é uma lista de alguma coisa onde os elementos se ligam um no outro, ou seja, um elemento tem a referência do próximo. O tipo dos elementos de uma lista ligada pode ser inteiros, strings ou estruturas inteiras. Independente do que for, você vai precisar de uma estrutura. Sabe por quê? Porque existe além dos dados em si mais uma informação que você precisará guardar em cada elemento de sua lista: o próximo elemento. E é daí que surge a ligação da lista ligada.
struct Node{int number;struct Node* next;}; Sua estrutura pode ser simples e direta. Digamos uma lista ligada de números vai ter o número que esse elemento armazena e o endereço para o próximo elemento. Em C guardamos o endereço de uma variável usando um ponteiro para o mesmo tipo de elemento (no caso um struct Node).
O elemento mais importante de sua lista ligada é o primeiro elemento, pois sem ele você não consegue mais voltar ao início. Isso pode ser uma variável especial que não é usada para nada exceto indicar qual o primeiro elemento da sua lista. Essa variável não pode mudar, pois precisamos sempre ter uma referência para o início da lista, a não ser que o primeiro elemento seja removido (veremos adiante). Ele pode ser simplesmente um ponteiro para o &amp;quot;próximo&amp;quot; elemento,que no caso o primeiro elemento.
struct Node* head = NULL;
Este ponteiro começa em NULL porque a lista está vazia. Mas assim que inserirmos um item ele deixará de ser nulo.
struct Node* node = (struct Node*) malloc(sizeof(struct Node));node-&amp;gt;number = 10;node-&amp;gt;next = NULL;head = node; Pronto, agora a lista não está mais vazia e a cabeça da lista aponta para o primeiro elemento. Note que você precisa sempre inicializar o membro next com NULL, uma vez que ele é o último elemento da lista e não possui próximo.
Para inserir um novo elemento você pode inseri-lo no começo, no fim ou no meio de sua lista. No começo é o mais fácil, pois já temos o endereço do primeiro elemento.
struct Node* node = (struct Node*) malloc(sizeof(struct Node));node-&amp;gt;number = 10;node-&amp;gt;next = next;head = node; Para inserir um novo elemento no final da lista você terá que percorrê-la até achar o próximo elemento cujo membro next é igual a NULL, o que quer dizer que não há mais próximo. Nesse caso é importante saber se a lista está vazia. Se estiver basta atualizar a cabeça da lista e está pronto (como já visto).
struct Node* lnode = head;if( ! lnode ){head = node;}else{while( lnode-&amp;gt;next )lnode = lnode-&amp;gt;next;lnode-&amp;gt;next = node;} Se formos sempre inserir um novo elemento no final também é interessante termos um ponteiro para o último elemento (o tail), que também pode ser um ponteiro e começa com NULL. Quando for inserido o primeiro elemento ele também será o último, então devem ser atualizados os ponteiros head e tail com o mesmo valor.
struct Node* tail = NULL; É preciso prestar atenção quando temos muitas variáveis com o estado de sua lista sobrando no código. Cada atualização na lista envolve atualizar todos os endereços envolvidos. Preste atenção sempre na hora que estiver escrevendo e depurando seu código ou se arrependerá por horas a fio em um fim-de-semana perdido.
Acho que remover elementos da lista ligada é a parte mais complicada, pois temos que atualizar o elemento anterior, se houver, para que o próximo dele seja o próximo do próximo.
void del(struct Node* node){struct Node* pnode = NULL;struct Node* cnode = head;while( cnode ){if( cnode == element )break;pnode = cnode;cnode = cnode-&amp;gt;next;}if( cnode == element ){if( pnode ){pnode-&amp;gt;next = cnode-&amp;gt;next;}else{head = cnode-&amp;gt;next;}}} Para simplificar programação, depuração e análise de problemas a lista duplamente ligada, apesar de ser uma estrutura mais complexa, acaba nos dando mais controle sobre os elementos de uma lista. Mas este é assunto para próximo post.
</description>
</item>

     
        <item>
  <title>Projeto Aluno</title>
  <link>http://www.caloni.com.br/projetoaluno/</link>
  <pubDate>2018-03-21</pubDate>
  
  <guid>http://www.caloni.com.br/projetoaluno/</guid>
  <description>Observar um estudante de computação (qualquer curso) lutando nos primeiros meses para conseguir fazer seus programas compilarem em C é um misto de emoções. É uma mistura entre risos, risadas e gargalhadas. Há vários motivos para isso, mas o principal, o que vem à minha mente sempre que isso acontece, é a eterna questão: por que a pessoa encontra fórum de programação para perguntar sobre variável mas não consegue ler duas páginas de um livro?
Essa questão está intrinsicamente ligada ao fracasso completo do sistema de ensino (qualquer nível), que no caso de programadores, se proliferou em diversas faculdades caça-níqueis porque &amp;quot;este é o mercado onde se ganha bem&amp;quot;. Ninguém questiona por que se ganha bem neste mercado. É só fazer uma faculdade e o dinheiro começa a fluir. Negócio certo.
Mas quando a primeira variável começa a dar problema, o desespero bate na bunda. &amp;quot;Por que esse programa não está funcionando?&amp;quot;, &amp;quot;Eu só queria resolver isso e voltar pra internet&amp;quot;, &amp;quot;Que droga, chegou a data limite e não sei de quem posso copiar&amp;quot;, &amp;quot;Por que esse exemplo que peguei sei-lá-de-onde está dando esse erro que nunca vi na vida?&amp;quot;.
&amp;quot;O que é UB? Universidade do Brasil?&amp;quot;, &amp;quot;Tá ficando mais complicado ainda; vou pesquisar pra ver se acho o email desse tal de Goku.&amp;quot;, &amp;quot;Já sei, vou mudar de IDE! Isso, sim, vai resolver meu problema.&amp;quot;
&amp;quot;Ah, não. Textão ninguém aguenta!&amp;quot;, &amp;quot;TL;DR&amp;quot;.
</description>
</item>

     
        <item>
  <title>Contra o &#39;Array de 100 bytes é suficiente&#39;</title>
  <link>http://www.caloni.com.br/contra-o-array-de-100-bytes-eh-suficiente/</link>
  <pubDate>2018-03-11</pubDate>
  
  <guid>http://www.caloni.com.br/contra-o-array-de-100-bytes-eh-suficiente/</guid>
  <description>Desde o C&#43;&#43; moderno (pós-03) o uso de arrays de tamanho fixo estão se tornando depreciados. E por um bom motivo: você nunca sabe realmente qual o tamanho que você precisa para um array de bytes até você saber. Daí a próxima grande questão é: &amp;quot;como gerenciar essa memória dinâmica de forma efetiva?&amp;quot;. E a resposta moderna sempre é: &amp;quot;não faça isso você mesmo&amp;quot;. Eis o porquê:
#include &amp;lt;string.h&amp;gt;#include &amp;lt;iostream&amp;gt;char* LegacyFunction(){ char* ret = (char*) malloc(100);strcpy(ret, &amp;quot;old old string&amp;quot;);return ret;}void WideStringFunction(wchar_t* mbString){std::wcout &amp;lt;&amp;lt; mbString &amp;lt;&amp;lt; L&#39;\n&#39;;}int main(){char* legacyString = LegacyFunction();size_t legacyLen = strlen(legacyString);wchar_t* convertedString = new wchar_t[legacyLen&#43;1]; // espalhando a merda de alocar dinamicamentembstowcs(convertedString, legacyString, legacyLen&#43;1);WideStringFunction(convertedString);free(legacyString);free(convertedString); // espalhando a merda de desalocar manualmente}Quando lidamos com funções legadas elas se misturam de tal maneira com código novo que a merda da alocação/desalocação dinâmica manual vai se espalhando também. A não ser que a gente comece a usar o novo modelo RAII e deixe a memória ser gerenciada automaticamente:
#include &amp;lt;string.h&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;char* LegacyFunction(){ char* ret = (char*) malloc(100);strcpy(ret, &amp;quot;old old string&amp;quot;);return ret;}void WideStringFunction(wchar_t* mbString){std::wcout &amp;lt;&amp;lt; mbString &amp;lt;&amp;lt; L&#39;\n&#39;;}int main(){char* legacyString = LegacyFunction();size_t legacyLen = strlen(legacyString);std::vector&amp;lt;wchar_t&amp;gt; convertedString(legacyLen&#43;1); // a STL que se vira pra alocarmbstowcs(&amp;amp;convertedString[0], legacyString, legacyLen&#43;1);WideStringFunction(&amp;amp;convertedString[0]);free(legacyString);// a STL que se vira pra desalocar convertedString}Note que estamos obtendo o endereço do primeiro elemento do nosso vector STL porque, desde o padrão C&#43;&#43;0x03, vetores são garantidos que serão contínuos. Essa garantia de leiaute de memória pode facilitar muitos usos de vector que estavam dependentes da implementação. O exemplo acima é apenas o mais simples deles, mas imagine que qualquer tipo de memória contígua cujo tamanho é desconhecido em tempo de compilação pode ser deixado seu gerenciamento para a STL cuidar.
Ah, e a partir do C&#43;&#43;11 podemos usar vector::data() para obter os dados sem deferenciar o primeiro elemento. Particularmente acho mais expressiva a sintaxe dos arrays, mas fica a gosto do freguês.
</description>
</item>

     
        <item>
  <title>Variáveis static local Nunca São Inicializadas Se Você Não Chama Sua Função</title>
  <link>http://www.caloni.com.br/variaveis-static-local-nunca-sao-inicializadas-se-voce-nao-chama-sua-funcao/</link>
  <pubDate>2018-02-20</pubDate>
  
  <guid>http://www.caloni.com.br/variaveis-static-local-nunca-sao-inicializadas-se-voce-nao-chama-sua-funcao/</guid>
  <description>Uma dúvida muito comum dos programadores iniciantes em C/C&#43;&#43; diz respeito às variáveis static que são declaradas dentro de um escopo, como uma função. Sabemos que se ela fosse declarada global, fora de qualquer escopo, ela seria inicializada antes do main ser chamado, como diz este trecho de alguém que pesquisou a respeito:
 &amp;quot;C&#43;&#43; Primer says. Each local static variable is initialized before the first time execution passes through the object&#39;s definition. Local statics are not destroyed when a function ends; they are destroyed when program terminates.&amp;quot; - Someone that google it for but did not get it
 Mas no caso de variáveis static declaradas dentro de uma função isso não acontece, e ela pode ser inicializada a qualquer momento. Basta alguém chamar a função onde ela foi definida.
#include &amp;lt;iostream&amp;gt;int func2(){std::cout &amp;lt;&amp;lt; &amp;quot;Func2 called\n&amp;quot;;return 21;}int func(){static int st_x = func2();return st_x * 2;}int main(){std::cout &amp;lt;&amp;lt; &amp;quot;Passing by...\n&amp;quot;;std::cout &amp;lt;&amp;lt; &amp;quot;Func returns &amp;quot; &amp;lt;&amp;lt; func() &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &amp;quot;Exiting...\n&amp;quot;;}c:\Projects\caloni\projects&amp;gt;cl /EHsc static_local_sample.cppMicrosoft (R) C/C&#43;&#43; Optimizing Compiler Version 19.12.25827 for x86Copyright (C) Microsoft Corporation. All rights reserved.static_local_sample.cppMicrosoft (R) Incremental Linker Version 14.12.25827.0Copyright (C) Microsoft Corporation. All rights reserved./out:static_local_sample.exestatic_local_sample.objc:\Projects\caloni\projects&amp;gt;c:\Projects\caloni\projects&amp;gt;static_local_sample.exePassing by...Func2 calledFunc returns 42Exiting...c:\Projects\caloni\projects&amp;gt;Note que mesmo trocando static int para static const int a mesma coisa acontece. Apenas conseguimos forçar a inicialização antes do main quando há alguma variável global (static ou não) que chame a função.
#include &amp;lt;iostream&amp;gt;int func2(){std::cout &amp;lt;&amp;lt; &amp;quot;Func2 called\n&amp;quot;;return 21;}int func(){static int st_x = func2();return st_x * 2;}static const int g_x = func();int main(){std::cout &amp;lt;&amp;lt; &amp;quot;Passing by...\n&amp;quot;;std::cout &amp;lt;&amp;lt; &amp;quot;Func returns &amp;quot; &amp;lt;&amp;lt; func() &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &amp;quot;Exiting...\n&amp;quot;;}c:\Projects\caloni\projects&amp;gt;cl /EHsc static_local_sample.cppMicrosoft (R) C/C&#43;&#43; Optimizing Compiler Version 19.12.25827 for x86Copyright (C) Microsoft Corporation. All rights reserved.static_local_sample.cppMicrosoft (R) Incremental Linker Version 14.12.25827.0Copyright (C) Microsoft Corporation. All rights reserved./out:static_local_sample.exestatic_local_sample.objc:\Projects\caloni\projects&amp;gt;static_local_sample.exeFunc2 calledPassing by...Func returns 42Exiting...c:\Projects\caloni\projects&amp;gt;O problema disso é que é possível que duas threads chamem func() &amp;quot;ao mesmo tempo&amp;quot;, gerando uma dupla inicialização caso a implementação da libc não seja thread-safe. E a menos que o padrão especifique que essa inicialização deva ser thread safe, melhor fazer as coisas direito.
Mas, a título de curiosidade, é bom saber que o Visual Studio 2017 essa parte da libc já possui um mecanismo de proteção, como o sugestivo nome _tls_index já indica:
c:\Projects\caloni\projects&amp;gt;cl /EHsc /Zi static_local_sample.cppMicrosoft (R) C/C&#43;&#43; Optimizing Compiler Version 19.12.25827 for x86Copyright (C) Microsoft Corporation. All rights reserved.static_local_sample.cppMicrosoft (R) Incremental Linker Version 14.12.25827.0Copyright (C) Microsoft Corporation. All rights reserved./out:static_local_sample.exe/debugstatic_local_sample.objc:\Projects\caloni\projects&amp;gt;windbg static_local_sample.exestatic_local_sample!func [c:\projects\caloni\projects\static_local_sample.cpp @ 10]:10 000fe410 55 push ebp10 000fe411 8bec mov ebp,esp10 000fe413 6aff push 0FFFFFFFFh10 000fe415 686c801800 push offset static_local_sample!wcschr&#43;0x1cc7 (0018806c)10 000fe41a 64a100000000 mov eax,dword ptr fs:[00000000h]10 000fe420 50 push eax10 000fe421 a180901a00 mov eax,dword ptr [static_local_sample!__security_cookie (001a9080)]10 000fe426 33c5 xor eax,ebp10 000fe428 50 push eax10 000fe429 8d45f4 lea eax,[ebp-0Ch]10 000fe42c 64a300000000 mov dword ptr fs:[00000000h],eax11 000fe432 a11cb51a00 mov eax,dword ptr [static_local_sample!_tls_index (001ab51c)] ((( Thread Local Storage? )))11 000fe437 648b0d2c000000 mov ecx,dword ptr fs:[2Ch]11 000fe43e 8b1481 mov edx,dword ptr [ecx&#43;eax*4]11 000fe441 a128b01a00 mov eax,dword ptr [static_local_sample!st_x&#43;0x4 (001ab028)]11 000fe446 3b8204010000 cmp eax,dword ptr [edx&#43;104h]11 000fe44c 7e3b jle static_local_sample!func&#43;0x79 (000fe489) ((( compara para ver se chama inicialização ou não )))static_local_sample!func&#43;0x3e [c:\projects\caloni\projects\static_local_sample.cpp @ 11]:11 000fe44e 6828b01a00 push offset static_local_sample!st_x&#43;0x4 (001ab028)11 000fe453 e8a736ffff call static_local_sample!ILT&#43;2810(__Init_thread_header) (000f1aff)11 000fe458 83c404 add esp,411 000fe45b 833d28b01a00ff cmp dword ptr [static_local_sample!st_x&#43;0x4 (001ab028)],0FFFFFFFFh11 000fe462 7525 jne static_local_sample!func&#43;0x79 (000fe489)static_local_sample!func&#43;0x54 [c:\projects\caloni\projects\static_local_sample.cpp @ 11]:11 000fe464 c745fc00000000 mov dword ptr [ebp-4],011 000fe46b e8bb37ffff call static_local_sample!ILT&#43;3110(?func2YAHXZ) (000f1c2b) ((( note a chamada a func2 )))11 000fe470 a324b01a00 mov dword ptr [static_local_sample!st_x (001ab024)],eax11 000fe475 c745fcffffffff mov dword ptr [ebp-4],0FFFFFFFFh11 000fe47c 6828b01a00 push offset static_local_sample!st_x&#43;0x4 (001ab028)11 000fe481 e89443ffff call static_local_sample!ILT&#43;6165(__Init_thread_footer) (000f281a)11 000fe486 83c404 add esp,4static_local_sample!func&#43;0x79 [c:\projects\caloni\projects\static_local_sample.cpp @ 12]:12 000fe489 a124b01a00 mov eax,dword ptr [static_local_sample!st_x (001ab024)] ((( a partir da segunda chamada tudo começa aqui )))12 000fe48e d1e0 shl eax,113 000fe490 8b4df4 mov ecx,dword ptr [ebp-0Ch]13 000fe493 64890d00000000 mov dword ptr fs:[0],ecx13 000fe49a 59 pop ecx13 000fe49b 8be5 mov esp,ebp13 000fe49d 5d pop ebp13 000fe49e c3 ret</description>
</item>

     
        <item>
  <title>Como Parsear Argc Argv para um map STL</title>
  <link>http://www.caloni.com.br/como-parsear-argc-argv-para-um-map-stl/</link>
  <pubDate>2018-01-26</pubDate>
  
  <guid>http://www.caloni.com.br/como-parsear-argc-argv-para-um-map-stl/</guid>
  <description>Os clássicos argv/argc são úteis quando os parâmetros de um programa são conhecidos e geralmente obrigatórios (até a ordem pode ser obrigatória). Isso funciona muito bem para C. Porém, há a possibilidade de STLzar esses argumentos de forma simples, usando a lógica *nix de fazer as coisas e transformando tudo em um map de string para string. E tudo isso cabe em uma função pequena que você pode copiar e levar com você em seu cinto de utilidades:
/** Interpreta argumentos da linha de comando.@author Wanderley Caloni &amp;lt;caloni@intelitrader.com.br&amp;gt;@date 2015-06@version 1.0.0*/#pragma once#include &amp;lt;map&amp;gt;#include &amp;lt;string&amp;gt;typedef std::map&amp;lt;std::string, std::string&amp;gt; Args;inline void ParseCommandLine(int argc, char* argv[], Args&amp;amp; args){for (int i = 1; i &amp;lt; argc; &#43;&#43;i){std::string cmd = argv[i];std::string arg;if (i &amp;lt; argc - 1 &amp;amp;&amp;amp; argv[i &#43; 1][0] != &#39;-&#39;){arg = argv[i &#43; 1];&#43;&#43;i;}args[cmd] = arg;}}Com a função ParseCommandLine disponível assim que você adicionar este header (eu chamo de args.h) basta no início do seu main chamá-lo passando o argv e o argc recebidos:
int main(int argc, char* argv[]){Args args;ParseCommandLine(argc, argv, args);// ...O resultado é que a variável args irá conter um mapa entre parâmetros e valores. Se seu programa for chamado com, por exemplo, a seguinte linha de comando:
&amp;gt;program.exe --name Agatha --surname Christie --enable-logA variável args irá conter três elementos: &amp;quot;--name&amp;quot;, &amp;quot;--surname&amp;quot; e &amp;quot;--enable-log&amp;quot;. Nos dois primeiros ele irá entregar os valores respectivos &amp;quot;Agatha&amp;quot; e &amp;quot;Christie&amp;quot; se indexado (args[&amp;quot;--name&amp;quot;], por exemplo). No terceiro elemento o valor é uma string vazia. Apenas a existência dele é o flag. Costumo usar isso para conseguir depurar por parâmetro:
if( args.find(&amp;quot;--debug&amp;quot;) != args.end() ){while( ! IsDebuggerPresent() )Sleep(1000);}De maneira geral argv/argc já estão divididos quando o programa começa. O que o ParseCommandLine faz é apenas entregar os parâmetros formatados da maneira usual para tratarmos rapidamente as opções passadas dinamicamente para o programa.
</description>
</item>

     
        <item>
  <title>Como Achar Erros no Printf via Dump</title>
  <link>http://www.caloni.com.br/como-achar-erros-no-printf-via-dump/</link>
  <pubDate>2018-01-25</pubDate>
  
  <guid>http://www.caloni.com.br/como-achar-erros-no-printf-via-dump/</guid>
  <description>Às vezes, e apenas às vezes, é útil ter um dump do processo que acabou de capotar e ter um singelo backup do pdb (arquivo de símbolos) dos binários envolvidos nessa tragédia. Com alguns cliques pontuais e uma análise simples da stack, da variável e do código envolvido é possível chegar em um veredito sem muitas controversas se foi isso mesmo que gerou o crash. No caso peguei hoje um caso assim.
Stack Abrir um dump (dmp) pode ser feito pelo Visual Studio, Windbg ou sua ferramenta de análise favorita. Mais importante que isso é carregar seus símbolos adequadamente.
Com o dump e símbolos abertos é possível analisar a stack de chamadas, o que nos revela que há um problema em uma função de Log. Como se trata de uma versão release não há muita informação da pilha, que pode fazer parte de uma stack modificada (otimização de código). Portanto, tudo que vier é lucro. Como variáveis.
Variable Demos sorte e é possível ver o que tem na variável de format, a mais importante de uma função de log estilo printf, pois geralmente é ela a responsável pelas dores de cabeça infernais.
Através dessa string é possível buscar no código usando grep, vim ou até o Visual Studio. Com isso reduzimos nosso escopo de busca ao mínimo.
Code E voilà! Temos uma chamada de log que teoricamente teria que passar uma string C, mas não passa nada. Isso quer dizer que a função de printf irá procurar na pilha pelo endereço de uma string, mas irá encontrar um endereço aleatório. Lendo esse endereço, que tem ótimas chances de ser inválido, ele irá capotar. Para dores de cabeças mais intensas, ele irá capotar aleatoriamente (ou na máquina do chefe, o mais provável).
E assim terminamos mais uma sessão simples e rápida de debug. Quer dizer, simples e rápida para quem tem 20 anos de experiência nessas coisas. Os estagiários devem ter ficado de cabelos em pé.
</description>
</item>

     
        <item>
  <title>Forma Mais Simples De Depurar Processos Antes Do Logon</title>
  <link>http://www.caloni.com.br/forma-mais-simples-de-depurar-processos-antes-do-logon/</link>
  <pubDate>2017-07-27</pubDate>
  
  <guid>http://www.caloni.com.br/forma-mais-simples-de-depurar-processos-antes-do-logon/</guid>
  <description>No post anterior sobre debug eu havia me focado mais na depuração de processos remotos no Visual Studio 2003 de maneira convencional. Aqui eu vou abordar o assunto de uma maneira menos convencional: usando o Visual Studio 2017 mais novo e depurando uma DLL (C&#43;&#43;) que é carregada por um serviço antes do logon no Windows 7.
Em primeiro lugar, como vimos anteriormente, a ponta server do depurador é um programa que você executa com alguns parâmetros e ele fica escutando em uma porta. Simples assim. Para que isso funcione antes do logon é necessário instalar esse programa como um serviço. Tanto no caso de depuradores mais antigos (msvCmon) quando nos mais novos (msvSmon) há sempre um executável com alguns parâmetros passados via linha de comando.
O depurador do Visual Studio mais novo fica em sua pasta de instalação Program Files, etc, Microsoft Visual Studio, 2017, Enterprise, Common7, IDE, Remote Debugger ou derivados. Dentro dessa pasta há subpastas para cada arquitetura, x64 ou x86. É essa pasta que deve ser copiada para a máquina que será depurada. Se você estiver depurando um processo 32 bits, use o x86; do contrário, vá de x64.
No caso do msvsmon, se executado com /? (padrão entre programas Windows) ele abre um pequeno help com a ajuda necessária para executar os parâmetros corretos:
No caso o comando maroto é o seguinte:
msvsmon.exe /timeout 999999 /anyuser /silent /noauthE para transformar em um serviço podemos usar o NSSM, já visto em outros artigos.
nssm.exe install Msvsmon msvsmon.exe /timeout 999999 /anyuser /silent /noauthIsso cria um serviço de start automático que irá iniciar o debugger na ponta server quietinho, sem janelas, só escutando e esperando o Visual Studio atachar.
Nosso serviço e DLL Para este exemplo vamos usar um programa console que será convertido, assim como o msvsmon, em serviço, e uma DLL que ele carrega, chamando dois métodos; um de start, outro de stop. Nosso objetivo aqui é começar a depurar a DLL logo em seu início, na chamada do start.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;windows.h&amp;gt;int main(){if( HMODULE dll = LoadLibraryA(&amp;#34;DLL&amp;#34;) ){void (*start)(), (*stop)();*((FARPROC*)&amp;amp;start) = GetProcAddress(dll, &amp;#34;DLL_Start&amp;#34;);*((FARPROC*)&amp;amp;stop) = GetProcAddress(dll, &amp;#34;DLL_Stop&amp;#34;);if( start )start();std::cout &amp;lt;&amp;lt; &amp;#34;Type &amp;lt;enter&amp;gt; to exit\n&amp;#34;;std::cin.get();if( stop )stop();FreeLibrary(dll);}else std::cout &amp;lt;&amp;lt; &amp;#34;DLL not found\n&amp;#34;;}As funções de start e stop não fazem nada, apenas imprimem um passou-por-aqui:
#include &amp;#34;DLL.h&amp;#34;#include &amp;lt;iostream&amp;gt;void DLL_Start(){std::cout &amp;lt;&amp;lt; &amp;#34;DLL started\n&amp;#34;;}void DLL_Stop(){std::cout &amp;lt;&amp;lt; &amp;#34;DLL stopped\n&amp;#34;;}Todo o projeto está no GitHub para baixar e compilar você mesmo.
Depois de copiar Service.exe e DLL.dll para a máquina-alvo (e não se esquecer de instalar as dependências) instalar da mesma forma com que foi instalado o msvsmon:
nssm.exe install Service service.exeAgora ache o IP da máquina-alvo e vá em Debug, Attach to Process (Ctrl&#43;Alt&#43;P) no Visual Studio, modo remoto e digite o IP.
cmd /k ipconfig | find &amp;quot;192&amp;quot;Lembre-se de iniciar o serviço.
Após esse teste podemos modificar a DLL para aguardar por um depurador:
#include &amp;lt;windows.h&amp;gt;void DLL_Start(){while( ! IsDebuggerPresent() )Sleep(1000);std::cout &amp;lt;&amp;lt; &amp;#34;DLL started\n&amp;#34;;}Depois que houver o attach você irá continuar a execução. Portanto, coloque um breakpoint logo depois.
Depois que isso funcionar já é possível iniciar sua depuração antes da tela de login. Os serviços executarão, e sua DLL estará aguardando um debugger ser atachado. Se houver necessidade é possível deixar esse modo de espera configurável, por timeout, etc.
</description>
</item>

     
        <item>
  <title>Debugger remoto do Visual Studio</title>
  <link>http://www.caloni.com.br/debugger-remoto-do-visual-studio/</link>
  <pubDate>2017-06-13</pubDate>
  
  <guid>http://www.caloni.com.br/debugger-remoto-do-visual-studio/</guid>
  <description>Então você está quebrando a cabeça para descobrir por que seu código não faz o que deveria fazer? Então você é desses que acha que é melhor ficar imaginando com um bloquinho de papel na mão do que colocar logo a mão na massa e ver exatamente o código passando pelo processador? Talvez você mude de ideia ao ver como é ridiculamente fácil depurar código em uma máquina remota, seja uma VM ou a máquina do cliente. Neste post vou ensinar a maneira mais antiga e a mais nova que conheço de usar o depurador do Visual Studio. Vamos usar a versão 2003 e a versão 2017 RC.
Há muito tempo atrás eu falei sobre o depurador remoto do C&#43;&#43; Builder, na época a ferramenta que eu mais utilizava para programar. Hoje disparado é o Visual Studio, já faz mais de uma década. Desde o VS2003 tem sido muito simples depurar remotamente. Tão simples que eu realmente esqueci que talvez algumas pessoas não saibam o quanto é útil essa ferramenta no dia-a-dia.
É possível depurar qualquer executável, tendo seu código-fonte ou não. A diferença é que sem código você terá que olhar o assembly e se for compilado como release você pode olhar o código mas ele não fará muito sentido em alguns momentos (onde estão minhas variáveis locais?). O melhor dos mundos, é claro, é depurar um executável que você tenha os símbolos, o código e esteja compilado em debug. Daí o código irá falar com você da maneira mais fácil.
É simples de achar essa opção no projeto em qualquer Visual Studio. Vá nas opções do projeto, Linker e irá encontrar em algum lugar sobre a geração do PDB. Não tenha medo de explorar as opções do projeto. Elas refletem como o XML do projeto muda (sim, é um XML). Se estiver querendo saber exatamente como ele muda, use um controle de fonte e vá experimentando.
Para depurar pelo Visual Studio 2003 há um programa chamado msvcmon.exe que deve ser copiado e executado na máquina-alvo. Ele é um executável que pode ser copiado para qualquer lugar. Junto dele devem estar duas DLLs: a natdbgdm.dll e a natdbgtlnet.dll. Se você tiver o VS2003 instalado deve achar esses arquivos em algum lugar, ou no pior dos casos no CD de instalação. Por via das dúvidas sempre há um link amigo na internet para ajudar alguém a achar o que precisa.
Copiados esses arquivos na máquina-alvo é necessário copiar também o executável. Afinal de contas, ele irá executar remotamente! O arquivo PDB, no entanto, você só precisa guardar com você. Lembre-se que toda recompilação em Debug altera de maneira significativa o PDB, então não recompile seu projeto enquanto estiver depurando. Se for fazê-lo, troque o executável na máquina-alvo.
A primeira execução de toda ferramenta, seu help, irá nos mostrar o seguinte no msvcmon:
C:\Tools\msvcmon-vs2003&amp;gt;msvcmon /?Microsoft (R) Visual C&#43;&#43; Remote Debug Monitor(x86) Version 7.10.3077Copyright (C) Microsoft Corporation 1987-2002. All rights reserved.Usage: msvcmon.exe [options]Options:-?Display options-anyuser (tcp/ip only)Allow any user to debug through msvcmon-maxsessions number (tcp/ip only)Change the number of concurrent debug sessions allowed-nowowwarnDo not warn when running under WOW64-s pipe_suffix_name (pipe only)Create main pipe with suffix pipe_suffix_name appended to pipe name-tcpipOperate in tcp-ip mode-timeout seconds (tcp/ip only)Termination timeout - reset on every connection request(use -1 for no timeout)-u xyz\abc (pipe only)Allow &amp;quot;abc&amp;quot; user/group in domain &amp;quot;xyz&amp;quot; to connectC:\Tools\msvcmon-vs2003&amp;gt;Minhas opções favoritas são -tcpip -anyuser -timeout -1, o que libera o acesso a qualquer usuário direto por TCP/IP e o timeout da execução é infinito. All access no limits =)
C:\Tools\msvcmon-vs2003&amp;gt;msvcmon -tcpip -anyuser -timeout -1Microsoft (R) Visual C&#43;&#43; Remote Debug Monitor(x86) Version 7.10.3077Copyright (C) Microsoft Corporation 1987-2002. All rights reserved.Maximum number of concurrent sessions:20**TCP-IP Mode**WARNING: TCP-IP mode is not a secure way to debug your application. For bettersecurity use msvcmon in pipe mode or the default port in the processesdialog to debug your application.To use the default port you will need to install the full set of remotedebugging components. For further information see &#39;Remote Debug Setup&#39; in Help.*WARNING- infinite timeout value set. Msvcmon will not timeout and exit*Waiting for Connections - everyone is allowed accessAgora no Visual Studio 2003 vá em Debug, Processes (ou Ctrl&#43;Alt&#43;P para os íntimos) e escolha a opção de Transport como TCP/IP, digite o IP... explore sua ferramenta, poxa!
Depois de conectar remotamente por essa janela o console do msvcmon irá mostrar que usuário se logou:
*WARNING- infinite timeout value set. Msvcmon will not timeout and exit*Waiting for Connections - everyone is allowed accessA Debug session has been started for user: CaloniPara configurar o início da depuração remota pelo próprio projeto você terá que ir nas opções de debug dele:
E para começar os problemas é sempre bom lembrar que projetos compilados como debug precisam das DLLs de runtime do Visual Studio que sejam debug. Mas você já sabe disso.
Depois que tudo isso estiver OK é só iniciar seus processos remotamente em modo de depuração ou atachar pela primeira janela que vimos.
Agora você deve estar se perguntando: &amp;quot;mas esse VS é muito velho! e os mais novos?&amp;quot;
Bom, desde o VS 2010 e até o VS2017 RC essa ferramenta está disponível na pasta de instalação, mudou um pouco de cara e você pode encontrar procurando por &amp;quot;remote&amp;quot;. No Caso do VS mais novo que tenho em mãos aqui, o 2017 RC, existe já uma pasta pronta para copiar e colar na máquina-alvo, em Common7, IDE, Remote Debugger. Há duas pastas disponíveis: x86 e x64. Dependendo do tipo de compilação que deseja realizar (e de qual o seu executável) copie uma das duas, rode o executável da pasta e apenas configure.
Você até já sabe qual o caminho do sucesso: All access to everyoooone!!! ;)

</description>
</item>

     
        <item>
  <title>qt5.natvis</title>
  <link>http://www.caloni.com.br/qt5-natvis/</link>
  <pubDate>2017-03-15</pubDate>
  
  <guid>http://www.caloni.com.br/qt5-natvis/</guid>
  <description>A estratégia que utilizei em meu último artigo sobre Qt para expandir o tipo QString no depurador não existe mais no VS2017 RC. O arquivo autoexp.dat foi extirpado e em seu lugar foi deixado os já ativos arquivos natvis, que podem ser usados de forma global ou por usuário.
Existe um arquivo pronto circulando pela net chamado qt5.natvis. Alguns funcionam, outros não. As strings estão funcionando no meu depois que eu adaptei este arquivo com as dicas do help do qt.
Se você é admin de sua máquina, basta copiar este arquivo em %programfiles(x86)%, Microsoft Visual Studio, 2017, Enterprise, Common7, Packages, Debugger, Visualizers. Se for um usuário mané, em %USERPROFILE%, Documents, Visual Studio 2017, Visualizers.
</description>
</item>

     
        <item>
  <title>Atalhos no terminal do Linux/Unix</title>
  <link>http://www.caloni.com.br/atalhos-no-terminal-do-linux-unix-cygwin/</link>
  <pubDate>2017-02-27</pubDate>
  
  <guid>http://www.caloni.com.br/atalhos-no-terminal-do-linux-unix-cygwin/</guid>
  <description>Há pouca coisa que você pode fazer para manipular a linha de comando que está digitando em um terminal do Windows. Isso faz sentido. O terminal da Microsoft é apenas um resquício do MS-DOS, que foi herdado pelas inúmeras versões do Windows para que desenvolvedores e suporte pudessem executar alguns comandos não disponíveis pelo clique de um mouse. Já no Unix a história é inversa. Durante tantas décadas sendo usado, o sistema Unix, hoje, em sua mais nova reencarnação, Linux, foi acumulando diferentes teclas de atalho para conseguirmos refazer, desfazer e fazer melhor a montagem dos comandos digitados na linha de comando. Um sistema bash padrão já deve ter implementado o mínimo que você precisa para sobreviver na linha de comando. Aparentemente esse é um conhecimento tão bem divulgado pela comunidade que ninguém se dá ao trabalho de escrever um artigo sobre isso. Eu fiz algumas pesquisas uns tempos atrás e cheguei na seguinte lista, que tem muito mais do que eu preciso, e que seria bom aprender, nem que fosse aos poucos.
 Ctrl &#43; r - navigate previous commands Ctrl &#43; a - go to the start of the command line Ctrl &#43; e - go to the end of the command line Ctrl &#43; k - delete from cursor to the end of the command line Ctrl &#43; u - delete from cursor to the start of the command line Ctrl &#43; w - delete from cursor to start of word (i.e. delete backwards one word) Ctrl &#43; y - paste word or text that was cut using one of the deletion shortcuts (such as the one above) after the cursor Ctrl &#43; xx - move between start of command line and current cursor position (and back again) Alt &#43; b - move backward one word (or go to start of word the cursor is currently on) Alt &#43; f - move forward one word (or go to end of word the cursor is currently on) Alt &#43; d - delete to end of word starting at cursor (whole word if cursor is at the beginning of word) Alt &#43; c - capitalize to end of word starting at cursor (whole word if cursor is at the beginning of word) Alt &#43; u - make uppercase from cursor to end of word Alt &#43; l - make lowercase from cursor to end of word Alt &#43; t - swap current word with previous Ctrl &#43; f - move forward one character Ctrl &#43; b - move backward one character Ctrl &#43; d - delete character under the cursor Ctrl &#43; h - delete character before the cursor Ctrl &#43; t - swap character under cursor with the previous one Ctrl &#43; l - clean the screen (history back) Ctrl &#43; z - put in background (fg restores it) Ctrl &#43; c - cancel current command Ctrl &#43; d - exit the current shell  </description>
</item>

     
        <item>
  <title>Convertendo Windows de UEFI para MBR</title>
  <link>http://www.caloni.com.br/convertendo-windows-de-uefi-para-mbr/</link>
  <pubDate>2017-02-13</pubDate>
  
  <guid>http://www.caloni.com.br/convertendo-windows-de-uefi-para-mbr/</guid>
  <description>Quando você pesquisa sobre isso no Google o que mais encontra é ferramentas &amp;quot;gratuitas&amp;quot; que prometem fazer a conversão ou algo do gênero. No entanto, há um procedimento simples em que o próprio Windows pode corrigir os problemas oriundos da conversão do boot UEFI/GPT. Depois, é claro, que você usar uma outra ferramenta esperta open-source =)
Entre as diferentes distros do Linux há uma chamada SystemRescueCD que é cheia dos paranauê para manutenção de micros. Entre eles há uma ferramenta chamada testdisk que tem a &amp;quot;proeza&amp;quot; de sair buscando partições perdidas e reescrever o MBR (seja o código ou a tabela de partições). É uma ferramenta simples, interativa e ágil. É ela que deve ser usada para resgatar as partições da máquina após configurar a BIOS para voltar a bootar no modo legacy.
Depois de feita essa manipulação é a vez do CD do Windows, que deverá estar em mãos porque o Windows simplesmente não irá mais bootar. A instalação feita através do modo UEFI não instala o BOOTMGR, o gerenciador de boots do Windows. Isso porque ele não é usado, já que é a partição UEFI que se torna responsável por gerenciar o boot dos SOs presentes.
Mas isso não significa que essa instalação do Windows está perdida. Através de dois boots com o CD, ambos escolhendo o modo de restauração (Repair e Repair at Startup) é possível fazer com que o Windows ache o problema (o bootmgr faltando) e &amp;quot;conserte&amp;quot; a instalação.
No primeiro boot o Windows irá achar um problema inicial na própria instalação, no segundo boot ele já encontra a instalação. E, acreditem só, ele descobre que o BOOTMGR está faltando!
E a partir daí a partição UEFI se torna inútil, embora ainda exista no início do HD, já que o boot legacy usa o velho esquema de usar o código da MBR e a partir daí chamar a partição ativa, que agora será a Windows.
Essa manipulação do boot pode dar algum trabalho, mas é gratuita e com todos os passos devidamente documentados. E não há mágica: reconstrução da MBR seguido de restauração de um SO pré-existente (Windows, no caso).
</description>
</item>

     
        <item>
  <title>UEFI: dê adeus à MBR</title>
  <link>http://www.caloni.com.br/uefi-de-adeus-a-mbr/</link>
  <pubDate>2017-02-09</pubDate>
  
  <guid>http://www.caloni.com.br/uefi-de-adeus-a-mbr/</guid>
  <description>Após depurar a BIOS e a MBR, eis que surge a UEFI: os GUIDs para SOs instalados no seu HD. Quantas siglas, não é mesmo?
A BIOS (Basic Input/Output System, Sistema Básico de Entrada e Saída) é o sistema-base que se comunica com o hardware diretamente e faz a ponte entre várias interrupções e o sistema operacional (se houver um). Uma das funções iniciais da BIOS era encontrar qual a MBR (Master Boot Record, Registro do Boot Mestre) válida para entregar o controle de um pedaço de código de 512 bytes (um pouco menos) cuja função clássica era procurar em uma tabela de quatro entradas dentro dela mesma qual o SO que está ativo. A partir daí o código da MBR passava o controle para a MBR da partição ativa, que deveria conter o bootstrap do sistema operacional (naquela época bootstrap significava outra coisa).
Isso gerava várias confusões em um sistema multi-SO, algo que começou a se tornar constante depois que o Linux e o Windows de verdade (NT) veio à tona, com gerenciadores de boot no próprio SO que possibilitava que o Windows 98 conseguisse pular seu controle para um Windows NT ou 2000 e também para um Conectiva Linux. Quando as coisas davam errado era só pegar o CD de instalação de um desses e começar tudo de novo.
Ou usar o Disk Editor, a famigerada ferramenta do Norton que já salvou a vida de muitos computadores aí afora. Eu me incluo na lista de salvadores durante o tempo que fiz a manutenção de um sistema de criptografia de HD. Usar o Disk Editor era basicamente navegar pelos bytes iniciais do HD principal para encontrar qual lógica do boot estava errada. Poderia ser um erro na tabela de partições ou um modo de endereçamento que não suportava partições muito longe do início (a tabela de partições era bem limitada; abaixo ela está selecionada).
Com a UEFI (Unified Extensible Firmware Interface, Inteface de Firmware Extendido Unificado) a MBR e seus 500 bytes perdem sua vez e no lugar surge uma partição inteira, onde os SOs são organizados não por tipos de entrada, mas por GUIDs únicos (números muito grandes que em teoria não são repetidos nunca). Não há mais a chance de modificar os bytes iniciais do boot para poder realizar alguma manipulação mágica, como gerenciar os diferentes SOs. A UEFI foi feita para isso, e não apenas para SOs locais, mas qualquer tipo de extensão de firmware (o código que reside direto no hardware e manipula correntes e leds). Note como a tabela de partições em um ambiente EFI não possui entradas válidas, e o setor logo em seguida é o início de sua partição.
A UEFI diz que há suporte ao modo antigo MBR. Isso é feito mantendo o primeiro setor disponível para escrita. Uma conversão possível seria editar a tabela de partições inserindo onde está a partição de um SO e inserindo um código padrão do MBR no lugar. A mudança do tipo de boot pode ser feito na BIOS (é o modo legado), mas se for trocada ela usará a MBR para bootar, então é necessário que ela esteja funcionando.
</description>
</item>

     
        <item>
  <title>Android Protobuf, Mock Configurável</title>
  <link>http://www.caloni.com.br/android-protobuf-mock-configuravel/</link>
  <pubDate>2017-02-06</pubDate>
  
  <guid>http://www.caloni.com.br/android-protobuf-mock-configuravel/</guid>
  <description>A comunicação oferecida pelo Protocol Buffers, uma maneira otimizada de codificar mensagens em alto nível, é uma das formas mais ideais de realizar a ponte entre cliente e servidor quando se fala de aplicativos mobile. A solução já suporta inúmeras linguagens, desde C&#43;&#43; (a linguagem oficial) até Java, passando por Python e .NET. Um mesmo arquivo de definição pode ser usado entre diferentes tipos de tecnologia. Este artigo mostra o caminho das pedras para compilar o protobuf para Android e de quebra mostra como é fácil fazer um mock de servidor local em uma configuração local com o gerenciador de builds do Android.
Antes de tudo é preciso saber que estou usando Windows. Provavelmente as coisas são mais simples no Linux, mas fazer o quê. De qualquer forma, a estrutura mantida pelo projeto do Protobuf para Visual Studio é boa, e compilei sem problemas a solução.
Mas, você deve estar se perguntando: se é para Android, por que C&#43;&#43;? Bom, uma vez que você baixou os fontes do protobuf é necessário gerar o compilador. Você poderia baixar um binário compilado, mas usar direto dos fontes garante que os unit tests estão todos alinhados e que não haverão problemas de versão.
Os guias contidos nos READMEs espalhados pelo fonte, começando pelo primeiro exigido na página do GitHub, são muito bem explicados. Não deve ser nenhum problema segui-los, desde que se atente em colocar os caminhos necessários no path, como a localização do JDK (que pode ser o que vem no Android Studio, mesmo) e abrir um prompt com as variáveis de ambiente para a compilação via Visual Studio. Eu recomendo baixar uma versão estável entre as releases, e pode já baixar a 3 em diante, que contém um monte de features novas e legais.
Depois de compilar o protoc e colocá-lo no devido lugar, há uma questão importante: a versão em Java usa um gerenciador de build do Apache que funciona muito naquelas para Windows, dando erro nos testes e na instalação. Minha solução foi simplesmente usar a segunda opção descrita no README: compilar o Descriptor.proto e com ele gerar todos os .java necessários para sua compilação. Com isso fica até mais simples montar no projeto Android uma solução mais enxuta, apenas com as classes necessárias (no meu caso, pelo menos o JsonFormat e dependências).
A grande vantagem do Android Studio é que ele já escaneia os diretórios do projeto, sendo apenas necessário copiar os fontes e ele já integra no projeto. A partir daí os imports funcionam e ele compila tudo junto. Para a parte do mock eu recomendo usar o sistema de variáveis do Gradle. Ele mantém uma lista de variáveis no arquivo app/build.gradle. Você pode jogar direto o valor que deseja, mas há uma solução ainda mais elegante que usa um arquivo apartado chamado local.properties, onde é ideal não jogar no controle de fonte, e de onde todo desenvolvedor pode customizar.
No caso de ServerMockData, ele pode ser um json com sua mensagem protobuf já certinha para uso, como se esses fossem os dados do server. É possível jogar um json nesse arquivo e depois o Android e o Gradle irão jogá-lo diretament em uma classe estática, a BuildConfig. A partir dessa string é possível obter rapidamente a mensagem equivalente.
O Android Studio tem um botão esperto em sua interface onde, depois de alterado o local.properties, é possível refazer o BuildConfig. E com isso podemos ter o protocol buffers e um sistema de mock simples e prático para a depuração e testes locais com o próximo app que vai revolucionar o mundo =).
</description>
</item>

     
        <item>
  <title>ReadFile assíncrono pode ser síncrono quando você menos espera</title>
  <link>http://www.caloni.com.br/readfile-assincrono-pode-ser-sincrono-quando-voce-menos-espera/</link>
  <pubDate>2017-01-16</pubDate>
  
  <guid>http://www.caloni.com.br/readfile-assincrono-pode-ser-sincrono-quando-voce-menos-espera/</guid>
  <description>Ano passado tive alguns problemas em um projeto que se comunicava com um dispositivo em firmware pela USB. Estávamos utilizando uma biblioteca open source do GitHub que parecia estar bem testada e mantida. Porém, não exatamente para nossos objetivos.
O problema da lib hidapi era que a comunicação usb era feita de forma assíncrona. Isso no Windows é feito com a mesma função de I/O (ReadFile/WriteFile) só que passando um argumento opcional chamado de overlapped. Esse argumento é um ponteiro para uma estrutura que irá ser preenchida assim que o I/O for concluído. E quando é isso? Deve-se esperar pelo handle ser sinalizado (em outras palavras, dando um Sleep ou WaitForSingleObject neste handle).
O funcionamento padrão via overlapped é bem simples: faça a operação de I/O (passando a estrutura) e verifique o retorno. Ele deve ser FALSE e o retorno do próximo GetLastError deve ser ERROR_IO_PENDING. Bom, descrevendo a operação ela não parece ser tão intuitiva. Mas funciona:
if (!ReadFile(hFile,pDataBuf,dwSizeOfBuffer,&amp;amp;NumberOfBytesRead,&amp;amp;osReadOperation ){if (GetLastError() != ERROR_IO_PENDING){// Some other error occurred while reading the file. ErrorReadingFile();ExitProcess(0);}else// Operation has been queued and // will complete in the future. fOverlapped = TRUE;}A questão que nós encontramos nesse projeto apenas aconteceu porque após a operação de I/O assíncrona a thread responsável por retornar o resultado ficava em wait eterno ou dava timeout. Ambas as situações são normais e esperadas. Ficar aguardando para sempre um device acontece quando este simplesmente não responde com nenhum dado. E dar timeout acontece quando não queremos aguardar o device para sempre (WaitForSingleObject(handle, 1000), por exemplo, daria timeout depois de 1 segundo, ou 1000 milissegundos).
O motivo da thread nunca retornar (ou dar timeout), porém, não estava em nenhuma dessas situações. Ao monitorar o tráfego usb se verificou que o device respondia em tempo hábil. O problema estava mais embaixo (ou mais em cima): a hidapi não se comportava conforme o MSDN mandava. Há uma situação não-mapeada nessa lib.
Erros ao chamar a API do Win32 são comuns exatamente porque esta é uma lib arcaica, pouco intuitiva com diferentes tipos de exceções. No caso de uma operação assíncrona com overlapped, se você ler as tantas páginas da função ReadFile, por exemplo, vai acabar encontrando um adendo escondido no meio da documentação:
Este adendo possui a informação que ninguém ainda sabia porque... porque a Microsoft é uma p***, oras =)
 If, on the other hand, an operation is completed immediately, then &amp;amp;NumberOfBytesRead passed into ReadFile is valid for the number of bytes read. In this case, ignore the OVERLAPPED structure passed into ReadFile; do not use it with GetOverlappedResult or WaitForSingleObject.
 Ou seja, em caso da função ReadFile (ou WriteFile) retornar TRUE em uma operação assíncrona/overlapped, isso quer dizer que a operação foi concluída com sucesso de forma síncrona, não sendo necessário aguardar o I/O ser concluído. Na verdade, é um pouco mais específico: o WaitForSingleObject não deve ser chamado. No nosso caso, ao chamá-lo, criávamos uma espera eterna, já que o I/O não seria mais sinalizado (porque deveria? a operação já foi concluída!).
Uma colinha da M$ de como deve ser feito o tratamento:
if (!ReadFile(hFile,pDataBuf,dwSizeOfBuffer,&amp;amp;NumberOfBytesRead,&amp;amp;osReadOperation ){if (GetLastError() != ERROR_IO_PENDING){// Some other error occurred while reading the file. ErrorReadingFile();ExitProcess(0);}else// Operation has been queued and // will complete in the future. fOverlapped = TRUE;}else// Operation has completed immediately. fOverlapped = FALSE;if (fOverlapped){// Wait for the operation to complete before continuing. // You could do some background work if you wanted to. if (GetOverlappedResult( hFile,&amp;amp;osReadOperation,&amp;amp;NumberOfBytesTransferred,TRUE))ReadHasCompleted(NumberOfBytesTransferred);else// Operation has completed, but it failed. ErrorReadingFile();}elseReadHasCompleted(NumberOfBytesRead);Após essa correção no projeto as coisas começaram a funcionar normalmente.
A BitForge fez a alteração em um fork próprio da hidapi e enviou o pull request para os mantenedores oficiais da hidapi, a signal11. Esta é mais uma lição de que, em se tratando de I/O, as coisas difíceis que o kernel às vezes faz lá embaixo acabam refletindo aqui em cima. Às vezes até na própria API!
</description>
</item>

     
        <item>
  <title>Vídeo: Usando clang no Visual Studio</title>
  <link>http://www.caloni.com.br/video-usando-clang-no-visual-studio/</link>
  <pubDate>2016-12-27</pubDate>
  
  <guid>http://www.caloni.com.br/video-usando-clang-no-visual-studio/</guid>
  <description>Com o surgimento da infraestrutura LLVM, que possibilita a união entre diferentes ferramentas que suportam diferentes plataformas para o desenvolvimento de software, e o clang, um font-end para C/C&#43;&#43; que roda não só em UNIXes da vida, como também no Windows, como também no Visual Studio, tem sido uma vantagem para projetos que usam as novas features do C&#43;&#43; moderno, muitas ainda não implementadas no compilador da Microsoft, unir o útil (Visual Studio) ao agradável (C&#43;&#43; modernos via clang). Este vídeo tem como objetivo demonstrar como essa união é simples e fácil de ser realizada dentro do próprio Visual Studio. De quebra, vamos descobrir alguns problemas que podem ocorrer nessa união de toolsets e como corrigir.
Este é um guia bem básico, mas atende os requisitos de quem quer começar a mexer com essas duas tecnologias (além de aficionados pelo novo C&#43;&#43; que está em desenvolvimento, mas não abre mão de uma IDE tão poderosa quanto o Visual Studio):
 Criar um novo projeto clang no Visual Studio. Utilizar o projeto com um Console Win32 padrão e toolset Visual Studio. Implementar uma feature ainda não suportada pelo Visual Studio. Utilizar essa feature no Console Win32. Corrigir e entender problemas no meio do caminho.  https://www.youtube.com/embed/dMY91ojS0tw
 CLang LLVM C&#43;&#43; compiler support Fold expression  </description>
</item>

     
        <item>
  <title>Vídeo: Resolvendo problemas em projetos desleixados</title>
  <link>http://www.caloni.com.br/video-resolvendo-problemas-em-projetos-desleixados/</link>
  <pubDate>2016-09-01</pubDate>
  
  <guid>http://www.caloni.com.br/video-resolvendo-problemas-em-projetos-desleixados/</guid>
  <description>Quem nunca teve que mexer em um projeto cheio de bugs de compilação, péssima organização, documentação e nomes de funções, classes e argumentos? Que você acaba de baixar em sua máquina e ele não compila (e você não tem a mínima noção por quê). Que a equipe que trabalha com você ouviu falar do projeto, mas nunca arregaçou as mangas e organizou. Que tal fazer isso agora?
Nesse vídeo eu exploro alguns dos erros mais comuns de projetos desleixados. Esses projetos em que o programador só se preocupa em entregar as coisas, e deixa os problemas de manutenção para o próximo trouxa que irá mexer com ele. Esse rapaz ou moça não usa a metologia PMF, que eu expliquei no artigo anterior. PMF quer dizer entregar as coisas com qualidade. Eles usam uma outra metodologia que também é simples, mas que traz gravíssimos problemas a médio e longo prazo (a despeito de ser divertida):
Pra começar, projetos que não compilam ou cheio de warnings são um sinal de que há algo de pobre no reino do GitHub. Ou é algo feito nas coxas ou é um projeto mal mantido ou é fruto de programação instintiva, que não pensa nas consequências de seus atos.
Depois, o sujeito usa headers com nomes complicados, inclui 2.653 headers diferentes (e duplicados) quando usa apenas dois, inclui headers do boost com nomes estranhos sem dar dica alguma de onde vieram. Cria funções que recebem s1 e s2 (e se chamam func2). Enfim, o pacote completo de desleixadas.
E por último, mas não menos importante: INCLUI BINÁRIOS NO GIT! TEMPORÁRIOS!
Pensando bem, meu exemplo fictício está bonito demais perto do que existe por aí. Bom, ele tem poucas linhas. É tudo questão de tempo e (des)empenho.
</description>
</item>

     
        <item>
  <title>DBAccess</title>
  <link>http://www.caloni.com.br/dbaccess/</link>
  <pubDate>2016-08-16</pubDate>
  
  <guid>http://www.caloni.com.br/dbaccess/</guid>
  <description>Bancos de dados são uma dor de cabeça para o desenvolvedor acessar. Quase tão motivation killer que as configurações do .NET. Se for um programador em C&#43;&#43; para Windows, então, desista.
O DBAccess é mais um dos códigos-fonte desenterrados dos meus backups. Esse eu usei já em vários projetos, porque é simples e rápido de usar.
class DBAccess{public:/// Factory para base de dados específica./// @param database Pode ser &amp;quot;sqlite&amp;quot; ou &amp;quot;oledb&amp;quot;.static DBAccess* CreateDBAccess(const std::string&amp;amp; database);typedef std::string ColumnName;typedef std::vector&amp;lt;std::string&amp;gt; Rows;typedef std::map&amp;lt;ColumnName, Rows&amp;gt; RowSet;virtual ~DBAccess() { }virtual bool Connect(const std::string&amp;amp; connectionString) = 0;virtual bool Disconnect() = 0;/// Executa uma instrução SQL e retorna opcionalmente os resultados (se for uma query).virtual bool Execute(const std::string&amp;amp; command, RowSet* response = 0) = 0;};Sua função é abstrair a abertura de um banco de dados, sua execução e sua saída. Para isso ele cria uma interface simples que usa STL. Por debaixo dos panos, usa OLEDB, que abstrai qualquer coisa, só precisando de instalar o driver e aprender qual das 500 mil combinações é a string de conexão correta. Para não ter que usar outras funções para coisas simples como sqlite, foi incluído seu suporte (que é mais uma tradução entre interfaces), necessitando para seu uso daquele projeto do sqlite que contém um header e um .c (pelo jeito o pessoal desse projeto também gosta de simplificar as coisas).
O código que trata o OLEDB é um pouco grande (umas 300 linhas) por conta da manipulação dos componentes COM. Porém, feito decentemente, faça uma vez e use um milhão (ainda falta fazer alguns unit tests, aliás).
IDataInitialize* pIDataInitialize;IDBInitialize* pIDBInitialize;IDBCreateSession* pIDBCreateSession;IDBCreateCommand* pIDBCreateCommand;É um bom projeto para entender o uso da minha batidíssima biblioteca de parsear argumentos argv/argc (Args.cpp/h) e a mais batidíssima ainda biblioteca de Log, que utiliza variadic templates para se livrar da maldição dos crashs causados pela falta de tipagem do printf e derivados (em Log.cpp/h).
Além disso, observe como o uso de interface permite que os headers específicos do que tem que ser feito (e.g. oledb.h, atlbase.h, msdasc.h, sqlite.h e até windows.h) não precisa necessariamente estar presente no header da interface (oledb.h), e como o uso de um factory em um método estático da interface permite que a junção das tecnologias envolvidas fique apenas no oledb.cpp. Dessa forma, para retirar ou acrescentar novas formas de comunicação com um banco de dados é muito simples.
PS: A publicação do DBAccess foi inspirada na thread iniciada por Spagiari no nosso grupo C/C&#43;&#43;.
</description>
</item>

     
        <item>
  <title>Vídeo: Depurando código C&#43;&#43; no Visual Studio</title>
  <link>http://www.caloni.com.br/depurando-codigo-c-no-visual-studio/</link>
  <pubDate>2016-08-12</pubDate>
  
  <guid>http://www.caloni.com.br/depurando-codigo-c-no-visual-studio/</guid>
  <description>Olá de novo. Este é o segundo vídeo da série &amp;quot;o que que eu tô fazendo no YouTube?&amp;quot;. Dessa vez abri o Visual Studio para depurar um código de 10 linhas com um bug absurdamente absurdo, mas que pode enganar muita gente. Há quem acredite que esse bug foi proposital, mas não foi. O importante é que ficou muito legal. Vamos ver?
https://www.youtube.com/embed/TpTNMj7ngc
Pra começo de conversa, é importante ressaltar que este é um vídeo introdutório, para quem deseja começar a programar em C&#43;&#43;, ou até para quem quer alguma dica de uso da IDE do Visual Studio. Já trabalhei algumas décadas (uma e meia) com a ferramenta, quando ainda se chamada Visual C&#43;&#43; e foi horrorosamente renomeada para Visual Studio .NET (arght!!!). Com o tempo fui me acostumando com a lerdeza cada vez mais crescente da ferramenta, acreditando piamente que um dia iriam transformar tudo em Java para ficar mais rápido.
Acho que não foi o caso. De qualquer forma, o vídeo acima tem o potencial de funcionar em quase qualquer versão do Visual Studio. Portanto, não se acanhe se ainda está mexendo em projetinhos jurássicos com o .NET 2003 (eu estou, mas só abro em emergência). Tudo deve funcionar exatamente como está no vídeo.
Ou não. Nesse caso, RTFM ou comente aqui =)
</description>
</item>

     
        <item>
  <title>Vídeo: Criando Projeto C&#43;&#43; Console no Visual Studio 2015</title>
  <link>http://www.caloni.com.br/video-criando-projeto-c-console-no-visual-studio-2015/</link>
  <pubDate>2016-08-04</pubDate>
  
  <guid>http://www.caloni.com.br/video-criando-projeto-c-console-no-visual-studio-2015/</guid>
  <description>Esse vídeo é um experimento que estou fazendo para tentar começar a compartilhar conhecimento em vídeo. Para começar, acho que nada mais apropriado que criar um projeto novo no Visual Studio, não? Dúvidas, sugestões, críticas, todas bem-vindas. Compartilhem com aquele amigo que pensa em começar a programar (ainda mais se for em C&#43;&#43;).
Essa primeira tentativa saiu um pouco longa -- 10 minutos -- mas era para ser mais sucinto. Me perdi em alguns detalhes da estrutura do projeto, mas o objetivo era entrar um pouco mais a fundo, mesmo, abrindo os arquivos do Visual Studio &amp;quot;na mão&amp;quot; para ver o que tem dentro, e já dando dicas de como a depuração pode começar já na compilação.
Espero que gostem. Se quiserem vídeos mais específicos, é só comentar logo abaixo. Dependendo do retorno -- ou não -- talvez em breve continuemos o projeto fazendo um básico de depuração.
</description>
</item>

     
        <item>
  <title>Palestra: Stack Overflow</title>
  <link>http://www.caloni.com.br/palestra-stack-overflow/</link>
  <pubDate>2016-06-04</pubDate>
  
  <guid>http://www.caloni.com.br/palestra-stack-overflow/</guid>
  <description>Há umas semanas (sim, estava enrolado para falar sobre isso) ministrei uma nova palestra lá em Sorocaba. Cheguei no meio de uma greve de ônibus, o que atrasou o evento em uma hora e me deu tempo de sobre para pensar nas desgraças que serão cidades próximas da capital crescendo desordenadamente graças às regulações estatais.
Mas divago.
A ideia da palestra foi do meu amigo Alan Silva (a.k.a. jumpi), e era para a SEMANA DA COMPUTAÇÃO E TECNOLOGIA -- mas nada tem a ver com computação, nem tecnologia, mas com oportunidade de emprego de estagiários para empresas corporativistas da área. O foco era sair da mesmisse que os representantes de R.H. fazem em falar de cultura, visão, valores e outras besteiras e falar um pouco mais de bits e bytes, algo que falta a essa geração.
Meu público era muito, muito jovem, e foquei erroneamente em conceitos muito, muito antigos para eles, então não tenho muita certeza se fui útil. De qualquer forma, foi um prazer falar sobre engenharia da computação atrelado a ataque na pilha de execução (sim, um salto enorme para baixo, do R.H. para a placa de memória RAM).
O conteúdo e a palestra está no GitHub e a palestra em si pode ser vista logo abaixo; a apresentação do conteúdo está mais abaixo, e peço desculpas por não ter tido tempo de apresentar todo ele (mesmo com quase duas horas):
http://www.slideshare.net/slideshow/embedcode/key/qRb4TSKjnf8Wx
PS: Ah, esqueci. Também fiz um vídeo para complementar o conteúdo da palestra. Segue:
https://www.youtube.com/embed/kSKQQDTBRXQ?list=PLa0QVTprDkHBz6fjuzy4kU1iTLUnRWkeW
Um StackOverflow é definido pela escrita em uma região não autorizada de memória. Stack overflow, overrun, etc, não interessando a nomenclatura &amp;quot;oficial&amp;quot;, o importante aqui é como um bug de acesso à memória pode permitir acesso exclusivo a regiões de memória que não estariam disponíveis para um atacante se não fosse por esse bug.
No exemplo do código deste projeto, um usuário fictício utiliza um código que possui controle de acesso, mas também possui um bug: ele escreve em uma região da memória inadvertidamente. Dessa forma, é possível explorar essa falha no código para escrever um novo endereço de retorno na pilha (stack), ganhando acesso, dessa forma, a código que não estaria disponível em situações normais de temperatura e pressão.
Para explorar esse tipo de falha, primeiro devemos entender a execução do código na arquitetura que se pretende atacar, além de alguns conceitos específicos do sistema operacional alvo.
  UML: Mundo real aplicado a engenharia.
  Programação: Codificação do mundo real.
  Assembly: Ponte entre ser humano e máquina.
  1&#39;s e 0&#39;s: Codificação lógica do computador.
  Impulsos elétricos: Voltamos para o mundo real.
  Qubit: Voltamos para a Matrix.
  (&amp;quot;IBM disponibiliza computador quântico para público&amp;quot;)
  Mais abstrações: Memória Virtual, Threads, I/O.
  Movimentação de memória (mov, lea)
  Cálculos matemáticos (add, div)
  Meta-comandos (push, pop, ret, jmp)
  Registradores (e[abcd]x, [bs]sp, eip)
  Endereço Virtual ([Kernel|User] Space)
  Endereço Físico (RAM, ROM, Storage, placas)
  Qual o sentido de apontar para a próxima instrução?
  R: Saber onde continuar a execução.
  Demo: Chamada de função.
  Demo: Retorno de função.
  Qual o sentido de existir uma stack?
  R: Conseguir chamar funções.
  Demo: Chamada de função.
  Demo: Passagem de argumentos.
  Demo: Retorno de função.
  Escalonamento de threads
  Virtualização da memória
  Controle de acesso
  Paginação
  Plug and Play
  Windows NT
  Dave Cutler
  xBox One
  Hypervisor
  Thread: Uma ilusão satisfatória.
  Fibers, Co-Routines, Cores, Pipe Line, Branch Prediction.
  Computação Quântica: Hackeando o Universo.
  Python, F#, Lambdas C&#43;&#43;11, Métodos, Função Virtual.
  Bloco de memória chama... Outro bloco de memória
  [[[C]]]]decl e Std(?)call (M$).
  Demo: Função em C sendo chamada.
  Demo: Função da Microsoft sendo chamada.
  Ou: Porque o printf precisa ser cdecl.
  Page Tables, PTEntries, Page Fault, Memory Map.
  Demo: Process Explorer.
  2 bits: Quatro possibilidades.
  Read-Only Memory, Execute Memory.
  Ah, vamos para o BAR: Base Address Randomization.
  Demo: Ver se isso funciona, mesmo.
  ESP Verification.
  Buffer overrun.
  0xCCCCCCCCCCCCCCCCCCCCC
  </description>
</item>

     
        <item>
  <title>Crash no Windows Explorer</title>
  <link>http://www.caloni.com.br/crash-no-windows-explorer/</link>
  <pubDate>2016-03-01</pubDate>
  
  <guid>http://www.caloni.com.br/crash-no-windows-explorer/</guid>
  <description>Quem nunca se deparou com um sistema Windows em que o Explorer travasse ou crashasse de vez em quando? O problema com esse tipo de problema (recursividade...) é que ele pode ocorrer por infinitos motivos. Tão infinitos quanto os shell extensions, aquelas DLLs irritantes que são carregadas automaticamente por todo processo explorer.exe, e que portanto podem gerar infinitas maneiras de travar seu shell.
Um que estava me incomodando já há algum tempo era um deadlock que acabava em restart do Explorer (isso é automático no Windows 10). Para verificar o que era, antes configurei a geração de dumps automática para que qualquer novo crash gerasse um arquivo de dump para eu analisá-lo. Só passou algumas horas para ter algo que pudesse trabalhar: um dump pode ser analisado pelo Visual Studio (qualquer versão) ou depuradores como WinDbg (do pacote Debugging Tools for Windows). Como análise exploratório, apenas o Visual Studio é suficiente, pois ele pode exibir coisas como os módulos carregados pelo processo e a pilha de chamadas da thread faltosa.
No caso do dump que eu estava analisando, verifiquei que a thread que gerou o travamento continha uma DLL da NVidia. Essa DLL, de acordo com o AutoRuns, estava cadastrada no registro como um Context Menu Handler para o shell. Depois de desativá-la e iniciar uma nova instância do Explorer foi possível verificar que a DLL não estava mais sendo carregada pelo processo.
E &amp;quot;magicamente&amp;quot; o travamento não aconteceu nos próximos dias =).
</description>
</item>

     
        <item>
  <title>Templates em C no lugar de macros</title>
  <link>http://www.caloni.com.br/templates-em-c-no-lugar-de-macros/</link>
  <pubDate>2016-01-14</pubDate>
  
  <guid>http://www.caloni.com.br/templates-em-c-no-lugar-de-macros/</guid>
  <description>A grande vantagem dos templates é manter o tipo de seus argumentos. Infelizmente, eles não existem na linguagem C, mas podem ser usados em construções C feitas com a linguagem C&#43;&#43;, como ocorre com quem desenvolve device drivers para Windows.
Imagine, por exemplo, a estrutura LIST_ENTRY, que é uma tentativa de generalizar não só o tipo de uma lista ligada, como seu posicionamento:
typedef struct _LIST_ENTRY {struct _LIST_ENTRY *Flink;struct _LIST_ENTRY *Blink;} LIST_ENTRY, *PLIST_ENTRY;A lógica por trás de LIST_ENTRY é que esse membro pode ser inserido em qualquer lugar da estrutura que representará um elemento:
Ele pode estar realmente no meio do elemento, pois isso não importa, desde que você saiba voltar para o começo da estrutura. Isso é útil quando um elemento pode fazer parte de diferentes listas.
typedef struct _LIST_ENTRY {struct _LIST_ENTRY *Flink;struct _LIST_ENTRY *Blink;} LIST_ENTRY, *PLIST_ENTRY;struct MeuElemento{int x;int y;LIST_ENTRY entry;double d;float f;};LIST_ENTRY g_head;int main(){InitializeListHead(&amp;amp;g_head);}OK, temos uma lista ligada cujo head está inicializado. Para inserir um novo item, podemos usar as rotinas InsertHeadList, AppendTailList, RemoveEntryList, PushEntryList, PopEntryList, etc. Enfim, uma infinidade de rotinas já cuidam disso para a gente.
O que não temos é como acessar o elemento. Para isso usamos um truque bem peculiar na linguagem C, já disponível também em kernel:
#define CONTAINING_RECORD(address, type, field) \ ((type *)( \(PCHAR)(address) - \(ULONG_PTR)(&amp;amp;((type *)0)-&amp;gt;field)))Basicamente a macro obtém a partir do endereço zero o offset do membro que é a entrada da lista ligada e subtrai esse ofsset do endereço do próprio campo, ganhando de brinde o tipo de sua estrutura. Usando a macro com nossa estrutura:
void DoSomething(PLINK_LIST pEntry){MeuElemento* pElem = CONTAINING_RECORD(pEntry, MeuElemento, entry);}Usando template Note que entry é o nome, literal, do membro na estrutura, e não há maneira possível com templates de obter isso. A solução? Usar um nome padronizado. O resultado final pode ser parecido com este:
template&amp;lt;typename T&amp;gt;T* ContainingRecord(PLIST_ENTRY pEntry){return ( reinterpret_cast&amp;lt;T*&amp;gt;( (char*)(pEntry) - (size_t)(&amp;amp;((T*)0)-&amp;gt;entry)) );}Em ação:
#include &amp;lt;iostream&amp;gt;using namespace std;typedef struct _LIST_ENTRY {struct _LIST_ENTRY *Flink;struct _LIST_ENTRY *Blink;} LIST_ENTRY, *PLIST_ENTRY;struct MeuElemento{int x;int y;LIST_ENTRY entry;double d;float f;};LIST_ENTRY g_head;template&amp;lt;typename T&amp;gt;T* ContainingRecord(PLIST_ENTRY pEntry){return ( reinterpret_cast&amp;lt;T*&amp;gt;( (char*)(pEntry) - (size_t)(&amp;amp;((T*)0)-&amp;gt;entry)) );}int main(){auto newElem = new MeuElemento();newElem-&amp;gt;x = 42;g_head.Flink = &amp;amp;newElem-&amp;gt;entry; // inserindo um elemento auto elem = ContainingRecord&amp;lt;MeuElemento&amp;gt;(g_head.Flink);cout &amp;lt;&amp;lt; &amp;#34;X is &amp;#34; &amp;lt;&amp;lt; elem-&amp;gt;x &amp;lt;&amp;lt; endl;}&amp;quot;Nossa, tudo isso para substituir uma macro já consagrada no WDK??&amp;quot; Sim, nesse post o objetivo não ficou muito útil. É apenas uma ideia de substituição possível de ser feita em macros em geral. Pode ser bem documentada, usada há 30 anos, mas ainda é uma macro. Meu conselho: se funciona bem, use. Se vai fazer algo novo, tente sempre templates.
</description>
</item>

     
        <item>
  <title>Gabaritos</title>
  <link>http://www.caloni.com.br/gabaritos/</link>
  <pubDate>2016-01-13</pubDate>
  
  <guid>http://www.caloni.com.br/gabaritos/</guid>
  <description>Um template -- ou, como é na tradução da primeira edição de The C&#43;&#43; Programming Language, de Bjarne Stroustrup, aqui no Brasil: gabarito -- é um molde que pode ser usado por diferentes tipos para traduzir o mesmo algoritmo, ou pelo menos a mesma intenção de algoritmo (por pela sobrecarga de operadores é possível que o comportamento de tipos diferentes pode ser diferente).
Em C&#43;&#43;, fazer uma função template é muito simples:
#include &amp;lt;iostream&amp;gt;using namespace std;template&amp;lt;typename T&amp;gt;bool Compare(T&amp;amp; var1, T&amp;amp; var2){return var1 &amp;lt; var2;}int main(){int x = 24, y = 42;double dx = 100.0, dy = 10.0;cout &amp;lt;&amp;lt; &amp;#34;x is &amp;#34; &amp;lt;&amp;lt; ( Compare(x, y) ? &amp;#34;lesser&amp;#34; : &amp;#34;bigger&amp;#34; ) &amp;lt;&amp;lt; &amp;#34; than y\n&amp;#34;;cout &amp;lt;&amp;lt; &amp;#34;dx is &amp;#34; &amp;lt;&amp;lt; ( Compare(dx, dy) ? &amp;#34;lesser&amp;#34; : &amp;#34;bigger&amp;#34; ) &amp;lt;&amp;lt; &amp;#34; than dy\n&amp;#34;;}Continuando nosso tema de fazer as mesmas coisas em C, templates não é tão simples, pois não existe de fato na linguagem. Templates são interpretados pelo compilador, que gera um esqueleto de algoritmo que é usado para preencher código de todos os tipos utilizados. Em C isso era feito usando macros. Porém, macros não fazem parte da linguagem C. É apenas uma ferramenta chamada pré-processador que substitui texto antes do programa ser compilado. É através do pré-processador que, por exemplo, os headers são incluídos em um código-fonte. Isso já foi explicado em um artigo bem velhinho, e mais recentemente em uma palestra.
// qual o tipo de x e y? qualquer um que faça comparação#define MACRO(x, y) x &amp;lt; yEu não recomendaria usar macros em C&#43;&#43;, assim como não recomendo em C. Porém, em C é a única opção para reciclar algoritmos de maneira estática. Exceto se você usar ponteiros de função, o que adiciona pouco overhead, mas se perde, assim como a técnica de macro, a informação dos tipos. A própria libc contém uma função, qsort, que é &amp;quot;genérica&amp;quot; através do uso de ponteiros sem tipo (void*) e ponteiro de função. A função ordena elementos de uma lista, mas para isso depende da função de comparação que é passada por parâmetro. Essa função recebe dois void* que deve comparar. Além disso, o leiaute na memória tem que ser fixo, contínuo, pois é assim que a função consegue mover os elementos. Ou seja, bem limitado.
Dessa forma, não pretendo ensinar a usar &amp;quot;templates&amp;quot; em C, mas a usá-los em C&#43;&#43; com foco em C. Um amigo conhecido de vocês, o Fernando/DriverEntry, utilizou essa técnica com maestria em alguns códigos kernel-mode que ele desenvolveu, e é uma maneira válida de se aproveitar de uma linguagem mais &amp;quot;alto nível&amp;quot; como C&#43;&#43; em ambientes limitados como o código que trabalha com o S.O.. Como a API do kernel lida com abstrações em C, seus objetos necessariamente não são objetos no sentido C&#43;&#43;, mas os famigerados &amp;quot;ponteiros opacos&amp;quot;.
Mais sobre isso em um próximo post.
</description>
</item>

     
        <item>
  <title>Classe, objeto, contexto, método, polimorfismo</title>
  <link>http://www.caloni.com.br/classe-objeto-contexto-metodo-polimorfismo/</link>
  <pubDate>2016-01-12</pubDate>
  
  <guid>http://www.caloni.com.br/classe-objeto-contexto-metodo-polimorfismo/</guid>
  <description>No post anterior implementamos &amp;quot;métodos&amp;quot; em C usando ponteiros de função dentro de structs que eram passadas como parâmetro. Tudo isso embutido por um compilador que gera o que chamamos de instância de uma classe, ou objeto, em C&#43;&#43;. Isso é possível graças ao contexto que é passado para uma função (que no caso de C&#43;&#43; é o operador implícito this, que sempre existe dentro de um método não-estático).
ClasseCpp obj;obj.Metodo(); // passando this implicitamenteClasseC obj;obj.Metodo = ClasseC_Metodo;obj.Metodo(&amp;amp;obj); // passando this explicitamentePara objetos não-polimórficos, o C&#43;&#43; não precisa mudar essa tabela de funções que os objetos de uma classe contém. No entanto, quando há pelo menos um método virtual, surge a necessidade de se criar a famigerada vtable, ou seja, justamente uma tabela de ponteiros de função, que dependem da classe instanciada (base ou algumas das derivadas). Se uma classe derivada sobrescreve um método de alguma classe base, é o endereço desse método que irá existir na vtable. Já vimos isso há muito tempo atrás escovando os bits da vtable direto no assembly e na pilha.
#include &amp;lt;iostream&amp;gt;class MinhaClasse{public:void MeuMetodo(){MeuOutroMetodo();}virtual void MeuOutroMetodo(){MinhaPropriedade = 42;}int MinhaPropriedade;};class MinhaClasseVersao75 : public MinhaClasse{public:virtual void MeuOutroMetodo(){MinhaPropriedade = 75;}};int main(){MinhaClasse obj;MinhaClasseVersao75 obj2;obj.MeuMetodo();obj2.MeuMetodo();std::cout &amp;lt;&amp;lt; &amp;#34;MinhaPropriedade (obj) = &amp;#34; &amp;lt;&amp;lt; obj.MinhaPropriedade &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &amp;#34;MinhaPropriedade (obj2) = &amp;#34; &amp;lt;&amp;lt; obj2.MinhaPropriedade &amp;lt;&amp;lt; std::endl;}Como você deve imaginar, é possível também fazer isso em C. Basta mudar os endereços das variáveis do tipo ponteiro de função que estão na struct usada como contexto. Para ficar o mais próximo possível do &amp;quot;modo C&#43;&#43;&amp;quot; de fazer polimorfirmo, podemos escrever hardcoded a tal vtable para os diferentes tipos de &amp;quot;classe&amp;quot;:
#include &amp;lt;stdio.h&amp;gt;struct MinhaVTable;struct MinhaClasse{const MinhaVTable* VTable;int MinhaPropriedade;};struct MinhaVTable{void (*MeuMetodo)(MinhaClasse*);void (*MeuOutroMetodo)(MinhaClasse*);};void MinhaClasse_MeuMetodo(MinhaClasse* pThis){pThis-&amp;gt;VTable-&amp;gt;MeuOutroMetodo(pThis);}void MinhaClasse_MeuOutroMetodo(MinhaClasse* pThis){pThis-&amp;gt;MinhaPropriedade = 42;}void MinhaClasse_MeuOutroMetodoVersao75(MinhaClasse* pThis){pThis-&amp;gt;MinhaPropriedade = 75;}static const MinhaVTable g_minhaVTableOriginal = { MinhaClasse_MeuMetodo, MinhaClasse_MeuOutroMetodo };static const MinhaVTable g_minhaVTableVersao75 = { MinhaClasse_MeuMetodo, MinhaClasse_MeuOutroMetodoVersao75 };int main(){MinhaClasse obj = { &amp;amp;g_minhaVTableOriginal };MinhaClasse obj2 = { &amp;amp;g_minhaVTableVersao75 };obj.VTable-&amp;gt;MeuMetodo(&amp;amp;obj);obj2.VTable-&amp;gt;MeuMetodo(&amp;amp;obj2);printf(&amp;#34;MinhaPropriedade (obj) = %d\n&amp;#34;, obj.MinhaPropriedade);printf(&amp;#34;MinhaPropriedade (obj2) = %d\n&amp;#34;, obj2.MinhaPropriedade);}A versão C ainda tem a vantagem de não precisar de uma vtable const (embora seja adequado em situações normais de temperatura e pressão). Os &amp;quot;métodos&amp;quot; poderiam mudar caso algum estado mudasse, alguma exceção fosse disparada, mantendo o mesmo contexto, mas um comportamento (vtable) diferente. Quem utiliza muito essa estratégia é o kernel do Windows, que mexe com estruturas que contém não apenas listas ligadas genéricas, mas funções de callback que não apenas o código da Microsoft precisa chamar, mas os próprios drivers de terceiros que se preocupam com bom comportamento e guidelines que tornam o SO rodando perfeitamente.
O importante deste artigo é demonstrar como conceitos aparentemente complicados ou escondidos de uma linguagem como C&#43;&#43; podem ser compreendidos completamente utilizando apenas linguagem de alto nível no bom e velho C. Essa estratégia de descer camadas de abstração, como verá, funciona para linguagens de mais alto nível, como C# ou Java, pois ambas são implementadas em linguagens como C&#43;&#43;. No fundo, engenharia de software é um universo multi-camadas transitando pela última camada que conhecemos -- a física. Pelo menos a última camada que ainda conhecemos.
</description>
</item>

     
        <item>
  <title>Classe, objeto, contexto, método</title>
  <link>http://www.caloni.com.br/classe-objeto-contexto-metodo/</link>
  <pubDate>2016-01-11</pubDate>
  
  <guid>http://www.caloni.com.br/classe-objeto-contexto-metodo/</guid>
  <description>No post anterior falamos como a passagem de um endereço de uma struct consegue nos passar o contexto de um &amp;quot;objeto&amp;quot;, seja em C (manualmente) ou em C&#43;&#43; (automagicamente pelo operador implícito this). Trocamos uma propriedade desse &amp;quot;objeto&amp;quot; em C, mas ainda não chamamos um método.
Hoje faremos isso.
Isso é relativamente simples quando se conhece ponteiros de função, existentes tanto em C quanto em C&#43;&#43;. Ponteiros de função são tipos que contém endereço de uma função com assinatura específica (tipo de retorno e de argumentos). Através de um ponteiro de função é possível chamar uma função e passar alguns argumentos. Como o contexto nada mais é que um argumento, será só passá-lo como parâmetro.
bool MinhaFuncao(int x, int y){return x == y;}int main(){bool (*PMinhaFuncao)(int, int) = MinhaFuncao;PMinhaFuncao(2, 3);}No exemplo anterior não sabíamos como chamar um método de nosso &amp;quot;objeto&amp;quot; em C:
struct MinhaClasse{int MinhaPropriedade;};void MinhaClasse_MeuMetodo(MinhaClasse* pThis){pThis-&amp;gt;MinhaPropriedade = 42;///@todo Chamar pThis-&amp;gt;MeuOutroMetodo();}Isso se torna fácil se tivermos uma nova &amp;quot;propriedade&amp;quot; na nossa struct que é um ponteiro para a função que queremos chamar.
#include &amp;lt;stdio.h&amp;gt;struct MinhaClasse{int MinhaPropriedade;void (*MeuMetodo)(MinhaClasse*);void (*MeuOutroMetodo)(MinhaClasse*);};void MinhaClasse_MeuMetodo(MinhaClasse* pThis){pThis-&amp;gt;MeuOutroMetodo(pThis);}void MinhaClasse_MeuOutroMetodo(MinhaClasse* pThis){pThis-&amp;gt;MinhaPropriedade = 42;}int main(){MinhaClasse obj;obj.MinhaPropriedade = 0;// precisamos iniciar os &amp;#34;métodos&amp;#34; em C; em C&#43;&#43; é automágico	obj.MeuMetodo = MinhaClasse_MeuMetodo; obj.MeuOutroMetodo = MinhaClasse_MeuOutroMetodo;obj.MeuMetodo(&amp;amp;obj);printf(&amp;#34;MinhaPropriedade = %d&amp;#34;, obj.MinhaPropriedade);}Parece muito trabalho para algo que é feito &amp;quot;automagicamente&amp;quot; em C&#43;&#43;, certo? Certo. Porém, agora sabemos o que acontece por baixo dos panos em C&#43;&#43; e que pode ser feito em C (ainda que &amp;quot;na mão&amp;quot;). Você provavelmente nunca fará esse tipo de código em C para emular C&#43;&#43;, mas o objetivo desse código é entender como funciona, por exemplo, a vtable do C&#43;&#43;, que permite polimorfismo.
Mas esse é assunto para outro post.
</description>
</item>

     
        <item>
  <title>Classe, objeto, contexto</title>
  <link>http://www.caloni.com.br/classe-objeto-contexto/</link>
  <pubDate>2016-01-10</pubDate>
  
  <guid>http://www.caloni.com.br/classe-objeto-contexto/</guid>
  <description>Para entender conceitos simples em C&#43;&#43;, como métodos de uma classe, ajuda muito seguir o raciocínio dos programadores C e como eles lidavam com o tipo de problema que C&#43;&#43; resolve elegantemente implementando um novo compilador com uma nova linguagem. Tomemos, por exemplo, métodos. Um método é uma função chamada dentro de um contexto. Qual o contexto? O objeto. Ou seja, uma instância específica de uma classe, que é um molde para se fazer alguma coisa.
int main(){MinhaClasse obj;obj.MeuMetodo(); // o contexto é obj, uma instância de MinhaClasse}Para obter esse contexto, existe uma palavra-chave reservada dentro dos métodos que é o this, que está tão incrustado na linguagem que não precisa ser usado explicitamente: quando referenciamos alguma propriedade (ou um outro método) da classe, só pelo fato de estarmos dentro de um método o compilador já entende que se trata do mesmo objeto, ou mesmo contexto.
class MinhaClasse{public:void MeuMetodo();void MeuOutroMetodo();int MinhaPropriedade;};void MinhaClasse::MeuMetodo(){MinhaPropriedade = 42; // ou seja: this-&amp;gt;MinhaPropriedade = 42; MeuOutroMetodo(); // ou seja: this-&amp;gt;MeuOutroMetodo();}E contexto nesse sentido nada mais é que um endereço na memória para alguma coisa que nos interessa. Tal qual uma função API do Windows -- tal qual FindFirstFile -- que recebe ou retorna uma struct com o que precisamos, esse geralmente é o contexto procurado.
WIN32_FIND_DATA findData;HANDLE findH = FindFirstFile(&amp;#34;*.txt&amp;#34;, &amp;amp;findData);if( findH != INVALID_HANDLE_VALUE ){if( findData.dwFileAttributes &amp;amp; FILE_ATTRIBUTE_ENCRYPTED ){//...No caso de nós, que escrevemos uma &amp;quot;classe&amp;quot;, o contexto é recebido &amp;quot;de fora&amp;quot;:
HANDLE MyFindFirstFile(const char* pattern, LPWIN32_FIND_DATA findData){//... findData-&amp;gt;dwFileAttributes = FILE_ATTRIBUTE_ENCRYPTED;//...Tal como uma struct que definimos, ela vira o contexto. Da mesma forma, um objeto de uma classe em C&#43;&#43; é esse contexto. Podemos fazer a mesma coisa em C, com o trabalho adicional de especificar o &amp;quot;this&amp;quot; (isto é, o ponteiro para o contexto/struct):
struct MinhaClasse{int MinhaPropriedade;};void MinhaClasse_MeuMetodo(MinhaClasse* pThis){pThis-&amp;gt;MinhaPropriedade = 42;///@todo Chamar pThis-&amp;gt;MeuOutroMetodo();}Em um próximo post vamos ver como fazer para chamar MeuOutroMetodo a partir de uma estrutura em C.
</description>
</item>

     
        <item>
  <title>Como ser um hacker</title>
  <link>http://www.caloni.com.br/como-ser-um-hacker/</link>
  <pubDate>2015-11-18</pubDate>
  
  <guid>http://www.caloni.com.br/como-ser-um-hacker/</guid>
  <description>Talvez as pessoas estejam com preguiça de ler. Talvez estejam apenas inundadas por tanta informação que temos hoje. Talvez seja apenas falta de foco pelas interrupções consecutivas de novos &amp;quot;espertofones&amp;quot; ou nossas redes sociais viciantes, pois oferecem muito a troco de nada.
O fato é: se você precisa perguntar para alguém (no caso, eu) o que é preciso fazer para se tornar um hacker, algo como um guia passo-a-passo, eu vou encarar o desafio numa boa, pensar por alguns dias, semanas e talvez meses, e chegar à conclusão que a pessoa que precisa que alguém lhe ensine está percorrendo o caminho errado. Ela nunca vai aprender o suficiente para se tornar algo que possa ser chamado de hacker.
E o que é hacker, que mal lhe pergunte? Há uma definição curta e simplista, há a definição do botão (que eu nunca mais vou me esquecer) e há o Jargon. O que é o Jargon? É um guia dos primórdios da web que contém tudo que você precisa saber sobre o jargão hacker. Duvida? Leia ele primeiro.
Falar em jargão me faz lembrar do nostálgico e muito curioso (e que já falei em outros artigos) Barata Elétrica, o fanzine jurássico de Derneval Ribeiro que consistia em copy&amp;amp;paste de partes interessantes da rede, em inglês e português, e um pouco da cultura hacker na América do Sul (sobretudo Buenos Aires) e sobre a vivência de seu editor no ambiente uspiano. Derneval pode até não ser um &amp;quot;hacker de verdade&amp;quot; (só pra citar a falácia do escocês), mas ler o Barata Elétrica me deu não conhecimentos técnicos, mas muito sobre a nossa era da informação, como informação é vital hoje em dia, além de outros conceitos interessantes que nos fazem ficar atentos para privacidade, governos, política, economia, filosofia, etc. Acho que foi lá a primeira vez que tive contato com 1984, PGP, Mitnick. Enfim, curiosidade, piadas e um pouco do clima social que a web tinha (para mais disso, nada como saudoso mIRC...).
Para quem pretende se tornar um hacker, já deve ficar claro que não existe receita de bolo, nem lista de conhecimentos desejáveis. Isso não e uma vaga para preenchimento de currículo. Isso é a vida real. Se existe uma receita, ela é vaga e de auto-ajuda:
 Primeiro você aprende a gostar de viver de acordo com a definição abaixo. Viver é a busca incessante de conhecimento em todas as suas formas, uma autodescoberta e a busca da felicidade pessoal e instransferível, subjetiva e inalienável. Com base nisso, comece a aprender profundamente sobre tudo o que deseja, em todas as áreas, sobre qualquer assunto, pessoa, lugar. Repita o passo anterior até que a inescapável morte aconteça; o resto é mistério.  Parece meio poético e filosófico, mas não é. Se eu te disser que para ser hacker precisa aprende a crackear programas no Windows, fuçar no WinDbg e esmiuçar a API Win32, disassemblar códigos em binário com o IDA e usar no percurso todas as ferramentas, sistemas operacionais, linguagens de programação e conhecimentos periférios necessários, vai ser apenas uma descrição pessoal que não te levará à satisfação que talvez você deseja nessa jornada. Se sua única satisfação será poder dizer que é um hacker, sinto muito, isso é inútil. Você não está procurando viver por si mesmo, mas se auto-promover sem conhecimento de causa do que realmente a palavra significa. Esqueça o assunto e vá ler um livro. Ou melhor dizendo, vá navegar em sua rede social favorita...
</description>
</item>

     
        <item>
  <title>É o fonte, idiota!</title>
  <link>http://www.caloni.com.br/e-o-fonte-idiota/</link>
  <pubDate>2015-09-12</pubDate>
  
  <guid>http://www.caloni.com.br/e-o-fonte-idiota/</guid>
  <description>Saiu um artigo recente no The Old New Thing (thanks Strauss pelo tuíte) que fala sobre não misturar runtimes do C de diferentes versões do compilador (especialmente se essas versões estão separadas pelo tempo em nada mais nada menos que dezenove anos!). Concordo. Aliás, a cultura Microsoftiana do uso de binários carece em C/C&#43;&#43; de um fundamento que facilite o reúso e compartilhamento de código exatamente por essa incompatibilidade inerente de uma biblioteca, se não em constante evolução, em constante aprimoramento pontual (como a STL). Como compartilhar código cujo fonte esteja indisponível e cujas bibliotecas sejam incompatíveis porque o projeto não é atualizado há dois pares de anos? Fiz uma vez um artigo explicando como usar a LIBC nativa do sistema operacional (nem sei se isso funciona ainda, provavelmente não). No entanto, essa é uma solução sub-ótima para um problema latente.
É por isso que nesse caso a cultura Linux de compartilhamento do código-fonte acaba por ser a mais flexível e melhor adaptável à mudança dos tempos. Se você encontrou uma LIB que pode te ajudar, baixe e compile usando o último compilador. Se o compilador não consegue mais gerar binário sem gerar erros antes, configure os parâmetros de compilação como eram na época que a LIB foi gerada. A runtime do C (e de qualquer outro framework) que será usado é o da sua máquina. Afinal de contas, é o que faz mais sentido, não? Por que hoje existem diferentes conjuntos de DLLs de runtime de diferentes versões do Visual Studio instalados em sua máquina? Por que os instaladores precisam se preocupar em compartilhar essas DLLs corretamente?
Questões de um passado remoto que voltam a bater à porta sempre que a Microsoft resolve lançar um novo Visual Studio. E isso irá se tornar cada vez mais constante, já que versões com começo e fim bem-definidos são um conceito também antigo, quando comprávamos pela licença de uma versão específica do programa. E hoje, no modelo de assinaturas, como fica?
</description>
</item>

     
        <item>
  <title>O Estranho Caso do PDB Mal-Aformado</title>
  <link>http://www.caloni.com.br/o-estranho-caso-do-pdb-mal-formado/</link>
  <pubDate>2015-08-19</pubDate>
  
  <guid>http://www.caloni.com.br/o-estranho-caso-do-pdb-mal-formado/</guid>
  <description>Era uma vez, há 13 anos atrás, um tal de Visual Studio .NET, que iria trazer a felicidade para nós, meros mortais usuários de programinhas em C com ponteiro pra lá e ponteiro pra cá. Agora a Microsoft traria para o pessoal do &amp;quot;baixo nível&amp;quot; a mais nova novidade do verão: uma IDE lenta, bugada e... bonita?
Bem, para os que estavam acostumados com o Visual C&#43;&#43; 6.0, nada foi mais incômodo do que esperar carregar o programa de manhã para conseguir finalmente compilar. Ajustadas as expectativas, os projetos foram aos poucos migrados para aquela nova forma de configurar EXEs, DLLs, LIBs e OCXs.
E eis que alguém, muito provavelmente eu mesmo, naquele momento de inspiração, criei a seguinte configuração para a geração dos PDBs, os símbolos para depurar programas no Windows:
Faz sentido, não? Afinal de contas, o PDB costuma ter o nome do projeto, e ele já está setado até em outro lugar para gerar com o mesmo nome. Nada de novo no front.
Até aí tudo bem. Aliás, tudo ficou muito bem por estranhos 13 anos.
Até que alguém decidiu migrar para o já não tão novo Visual Studio 2013!
E tudo correu muito bem por algumas horas... talvez 13.
Até que a depuração de repente parou de funcionar.
Será o benedito? Ou o co-piloto?
Pesquisando nos fóruns da vida, antro dos desesperados, achei/lembrei de um comando muito útil no WinDbg que não apenas diz se os símbolos estão &amp;quot;mismatch&amp;quot;, ou seja, os símbolos ou o PDB não está combinando com o EXE, mas também por quê.
Bom, para saber se está mismatch é aquela fórmula de bolo:
ntdll!LdrpDoDebuggerBreak&#43;0x2b:77e13bad cc int 30:000&amp;gt; .symfixNo downstream store given, using C:\Tools\DbgTools(x86)\sym0:000&amp;gt; !sym noisynoisy mode - symbol prompts on0:000&amp;gt; .reload /f Module.exeSYMSRV: C:\Tools\DbgTools(x86)\sym\Module.pdb\7CD3DD6A80254CE29E8A2E8D7C26BF1B2\Module.pdb not foundSYMSRV: http://msdl.microsoft.com/download/symbols/Module.pdb/7CD3DD6A80254CE29E8A2E8D7C26BF1B2/Module.pdb not foundDBGHELP: C:\Users\Caloni\Projects\Project\Source\_Output\bin\Debug\Module.pdb - mismatched pdbDBGHELP: Couldn&#39;t load mismatched pdb for C:\Users\Caloni\Projects\Project\Source\_Output\bin\Debug\Module.exe*** WARNING: Unable to verify checksum for Module.exe*** ERROR: Module load completed but symbols could not be loaded for Module.exeDBGHELP: Module - no symbols loadedPara saber o que está errado, o famigerado !IToldYouSo
Mano, como assim?!?!? Eu acabei de compilar esse binário, eu já apaguei 15 vezes as pastas de Debug e Release, eu já rebootei mais do que o Windows me obriga a rebootar por causa das falhas de segurança.
Pois, então, desesperançado, crio um projeto novo para comparar as configurações, e voltamos 13 anos atrás, naquele fatídico dia, e entendo por que o nome do PDB temporário não é igual. Bom, na verdade não entendo, mas intuo que tenha alguma relação:
E, de fato. Solução? Copie as configurações usuais do &amp;quot;novo&amp;quot; Visual Studio comparando com o velho.
Abaixo a chamada do suporte em inglês, se alguém achar o mesmo problema em algum fórum e quiser &amp;quot;espalhar a palavra&amp;quot;.
Just got stuck in the same problem, but in a C&#43;&#43; source that has 13 years, where its first solution was in VS 2003. Comparing the Project Properties in C/C&#43;&#43;, Output Files, Program Database File Name, I found out that the project was pointing to the same file path that Linker, Debugging, Generate Program Database File, when the normal situation is to generate a vc120.pdb. Comparing with a new project, the &amp;quot;right&amp;quot; value can&#39;t be $(OutDir)$(TargetName).pdb (ou ProjectName), but $(IntDir)vc$(PlatformToolsetVersion).pdb. That solved the problem. I hope solve another one&#39;s problem as well =)[]sMinha próxima tarefa, aparentemente, é ver como sendo sócio da BitForge e da Intelitrader, e mesmo tendo já atualizado meu perfil MVP há anos, continuo sendo funcionário da UOL Diveo/Broker =/
</description>
</item>

     
        <item>
  <title>Logs em serviços (e outras coisas)</title>
  <link>http://www.caloni.com.br/logs-em-servicos-e-outras-coisas/</link>
  <pubDate>2015-06-05</pubDate>
  
  <guid>http://www.caloni.com.br/logs-em-servicos-e-outras-coisas/</guid>
  <description>Já uso logs há muito tempo. Me lembro muito bem que quando programava em BASIC o &amp;quot;passou por aqui&amp;quot; já era útil. Depois de fazer muitas bibliotecas super-flexíveis de escrita em saídas diferentes, níveis configuráveis e uso do mais complexo ao mais banal, cheguei à seguinte conclusão:
Log(&amp;#34;Quero um log mais simples possível (de preferência &amp;#34;, 15, &amp;#34; vezes mais simples)&amp;#34;);Vou tentar defender meu ponto de vista.
Esse artigo do Dr. Dobbs explica de uma maneira bem completa como fazer uma lib de log leve e configurável. O que eu peguei desse exemplo foi a forma mais C&#43;&#43; de formatar as linhas, deixando para trás o estilão printf que depois de variadic templates já está datado.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;sstream&amp;gt;inline void Log(std::ostringstream&amp;amp; os){std::cout &amp;lt;&amp;lt; os.str() &amp;lt;&amp;lt; std::endl;}template&amp;lt;typename First, typename...Rest &amp;gt;void Log(std::ostringstream&amp;amp; os, First parm1, Rest...parm){os &amp;lt;&amp;lt; parm1;Log(os, parm...);}template&amp;lt;typename...Rest &amp;gt;void Log(Rest...parm){std::ostringstream os;LogHeader(os);Log(os, parm...);}Por que eu acho a minha versão mais legal (não valendo falar que foi porque eu fiz):
 É mais simples ainda, tem poucas linhas e pode ser copiada sem peso na consciência. Pode até estar em um header que o overhead é mínimo. Não requer configuração de arquivo, debug output, named pipe, etc. Isso tem a ver com o uso de cada um. O próximo motivo explica melhor isso. Se for executado em um prompt já exibe as informações para serem filtradas; se for executado como um serviço encapsulo a saída.  Encapsular a saída e o comportamento de um serviço hoje em dia é algo banal. Há diversos programas que fazem isso para você, sendo desnecessário programar toda aquela parte de comunicação com o Windows. O cara do DriverEntry (vulgo o kernel-mode programmer motta-focka Fernando) fez um aplicativo que faz isso, que é simples de usar e continua funcionando no Windows 8.1. Atualmente uso um outro encontrado pelo igualmente fodástico Rodrigo Strauss: o Non Sucking Service Manager (seu nome já explica por que defendo utilizar o mínimo possível das firulas da Microsoft).
Além de ser extremamente flexível e não ter falhado nas vezes que o utilizei, o NSSM consegue redirecionar a saída do aplicativo que encapsula como um serviço para um arquivo e rotacionar o arquivo por tamanho ou data (ou reexecução do serviço):
Abaixo uma receitinha básica para configurar seu aplicativo:
nssm.exe install MyService C:\Path\MyService.exe &amp;lt;args&amp;gt;nssm set MyService AppStdout C:\Path\Logs\MyService.lognssm set MyService AppStderr C:\Path\Logs\MyService.lognssm set MyService AppRotateFiles 1nssm set MyService AppRotateOnline 1nssm set MyService AppRotateBytes 10485760(para quem está se perguntando, 10485760 bytes são 10 MB.)
Com essa forma de fazer serviços, há uma dupla vantagem:
 Retirar todo o código para lidar com o Service Manager do Windows das suas mãos. Continuar tendo um aplicativo que roda pelo prompt e já imprime seu comportamento (e pode ser redirecionado também).  E ainda uma vantagem-bônus:
 Você pode executar programas-filho que o redirect para o log vai funcionar do mesmo jeito.  Bônus final Acho que cada um deve escrever no seu header o que achar melhor para depurar seus programas. No entanto, acho válido compartilhar quais são as informações que tem sido úteis para mim:
inline void LogHeader(std::ostringstream&amp;amp; os){SYSTEMTIME st;char buffer[48] = &amp;#34;&amp;#34;;GetLocalTime(&amp;amp;st);sprintf_s(buffer, &amp;#34;%04d-%02d-%02d %02d:%02d:%02d %04X.%04X %08X &amp;#34;,st.wYear, st.wMonth, st.wDay,st.wHour, st.wMinute, st.wSecond,GetCurrentProcessId() &amp;amp; 0xFFFF, GetCurrentThreadId() &amp;amp; 0xFFFF,GetLastError());os &amp;lt;&amp;lt; buffer;}</description>
</item>

     
        <item>
  <title>Depurando até o fim do mundo e de volta de novo: source server com GitHub</title>
  <link>http://www.caloni.com.br/depurando-ate-o-fim-do-mundo-e-de-volta-de-novo-source-server-com-github/</link>
  <pubDate>2015-05-26</pubDate>
  
  <guid>http://www.caloni.com.br/depurando-ate-o-fim-do-mundo-e-de-volta-de-novo-source-server-com-github/</guid>
  <description>Semana passada fiquei sabendo que o vídeo da minha palestra &amp;quot;Depurando até o fim do mundo&amp;quot; do TDC 2014 estava disponível online. Resolvi assistir para ver se aprendia alguma coisa. A despeito do palestrante ser muito ruim, ele disse uma coisa interessante: com o Debugging Tools (WinDbg para os íntimos) seria possível além de indexar os símbolos (PDBs para os íntimos) usando o esquema de Symbol Server que a própria Microsoft adota usar algumas ferramentas embutidas para conseguir obter o fonte através de um símbolo indexado.
E de onde viria esse fonte? Bom, a priori é necessário que exista algum controle de fonte para que as versões estivessem já &amp;quot;indexadas&amp;quot; nesse controle e fossem mapeados com strings internas no PDB. Através dessas strings o WinDbg ao analisar um crash dump ou até mesmo depurando um processo com o uso do PDB conseguiria baixar os fontes automagicamente desse controle de fonte, desde que ele estivesse acessível (na internet, na intranet da própria empresa, na rede, em um disco rígido externo ou na própria máquina do desenvolvedor que não quer se matar para conseguir obter a versão exata dos fontes daquele binário).
O detalhe que o palestrante (Caloni é o nome do sujeito) citou era que já existiam scripts prontos para realizar essa tarefa para os controles de fonte mais comuns, sendo que os mais comuns são: Source Safe (?????), CVS (????????) e, claro, Subversion! (?!?!?!?!??!??!?!). OK, pelo visto o pessoal da Microsoft mora em uma caverna ou não estão muito interessados em indexar os fontes para alguns controles de fonte que estão surgindo por aí, como Git sendo um exemplo aleatório.
Já que o tal do Caloni disse que ainda não fizeram scripts para controles mais modernos. Nenhum descentralizado ainda está na lista. Os scripts são feitos em Perl, ou seja, estão disponíveis em uma linguagem um pouco mais fácil que .BAT. Ou talvez não. De qualquer forma, não parece muito difícil de entender a dinâmica do WinDbg e simplesmente gerar o que tem que gerar dentro dos PDBs.
Pensando nisso, resolvi fazer uma primeira versão, em Python, de um script em que você passa alguns dados e ele processa seus PDBs. Depois você pode jogá-los em um Symbol Server e quando o WinDbg encontrá-lo através de um binário analisado, este irá conter o endereço no GitHub e um comando do Curl para baixá-lo, passando a exibi-lo imediatamente na tela do WinDbg. E nada mais lógico do que criar um repositório no GitHub para compartilhá-lo, certo?
O funcionamento é muito simples, mas pede muitos parâmetros (recomendo criar um batch para armazená-los). Então vejamos:
 dbgtools é o caminho onde está o Debugging Tools for Windows; pdbpath é o caminho de onde devem ser pegos os PDBs, como um output da vida; projname é porque preciso do nome do projeto com escopo do usuário para compor a URL, e.g. Caloni/GitIndex; repo é o caminho do repositório local, pois o remoto eu já consigo pegar com o projname.  Um detalhe importante: o revno que será usado é o HEAD do repositório local. Sim, futuramente podemos adicionar esse argumento como opcional. Porém, no momento, coisas mais urgentes devem ser feitas. Uma delas é que estou usando a visualização raw do GitHub para conseguir pegar um único arquivo-fonte, e para isso uso a ferramenta curl. Ou seja, quem é de Windows vai precisar baixar uma de suas versões e deixar no path do sistema. Quem não é de Windows... o que você está fazendo com um PDB, rapaz?
Como esse ainda é um projeto muito cru, mas gostaria de compartilhar com vocês (pois algo muito cru é melhor que nada), deixei diversos batchs de teste para ficar mais claro o funcionamento do srcsrv. Há um doc muito bom (er... ou mais ou menos) sobre o seu funcionamento na pasta srcsrv (chama-se srcsrv.doc). Usei algumas informações de lá para conseguir fazer a coisa funcionar. Se quiser me ajudar no projeto, tiver alguma dúvida, sugestão de melhoria/evolução, vamos conversar! Esse projeto será muito útil para mim no futuro, e espero que seja muito útil para outras pessoas, também.
</description>
</item>

     
        <item>
  <title>Analisando Erros Pelo Filtro do File Monitor</title>
  <link>http://www.caloni.com.br/analisando-erros-pelo-filtro-do-file-mon/</link>
  <pubDate>2015-05-06</pubDate>
  
  <guid>http://www.caloni.com.br/analisando-erros-pelo-filtro-do-file-mon/</guid>
  <description>As ferramentas da SysInternals fazem a gente economizar um tempo considerável na resolução de problemas. Não que elas sejam indispensáveis. Tudo que elas fazem é encurtar o caminho entre a análise de um bug e sua resolução, o que acaba sendo muito se considerarmos que programação é 20% codificação e 80% transpiração. Ela é um atalho para muitas coisas, desde achar uma ordem errada de includes no header durante a compilação ou descobrir que por que um processo morreu durante o login.
Curiosamente ambos os exemplos que citei são de uma mesma ferramenta: Process Monitor, ou carinhosamente chamado de procmon. Ele é um filho de duas ferramentas hoje extintas, FileMon e RegMon (acho que não preciso explicar o que ambas faziam). Todas são baseadas em drivers que escutam eventos do sistema operacional e um aplicativo que mastiga essa informação e as filtra de diferentes e criativas formas. Vamos utilizá-lo depurando um instalador muito sacana.
A SoSo Company é uma empresa criada na China e que possui programadores muito bons. Eles são altamente especializados em fazer instaladores, e nas horas vagas ainda fritam pastéis de frango (ou &amp;quot;flango&amp;quot;, como os nativos costumam chamar). Porém, alguma coisa está acontecendo com uma nova versão do instalador que está dando erro ao rodar o aplicativo após atualizado. Isso só acontece em algumas máquinas, na maioria delas tudo funciona perfeitamente. Tanto que esse erro só foi encontrado depois de centenas de máquinas terem sido atualizadas (oh, não).
O primeiro a descobrir esse erro foi um cliente muito importante para a SoSo, e entre as máquinas desse cliente muito importante o erro foi acontecer justamente na máquina do CEO da empresa. (Qualquer semelhança com a vida real não é mera coincidência.)
O analista Juquinha do suporte técnico terceirizado na Índia sul-americana foi chamado para dar uma olhada nesse problema. Como os chineses não confiam em um não-comedor de pastel de flango Juquinha não terá acesso ao código-fonte do produto, mas poderá dar uma espiada no instalador, que faz algo parecido com o código abaixo:
print(&amp;quot;Happy installing...&amp;quot;);CreateDir(&amp;quot;/soso&amp;quot;);CpFile(L&amp;quot;soso.exe&amp;quot;);CpFile(L&amp;quot;soso.dll&amp;quot;);CpFile(L&amp;quot;soso_ui.exe&amp;quot;);print(&amp;quot;All light =)&amp;quot;); O instalador copia tudo e não verifica erro nenhum; afinal de contas, o que pode dar errado, não é mesmo? Haja o que houver, o mundo continua maravilhoso. Porém, depois da atualização esse erro explodiu na máquina do diretor. E agora?
Sem saber muito bem o que fazer, mas com a possibilidade de testar a situação em uma nova máquina (de outro diretor), Juquinha resolveu rodar novamente o instalador, mas dessa vez com a companhia do ProcMon. Depois disso, para efeitos de comparação, rodou o instalador em uma máquina qualquer onde a atualização funciona. Ciente de que o ProcMon por padrão captura centenas de milhares de eventos e mostra na tela, Juquinha filtra os eventos pelos quais mais interessam e exporta-os para um arquivo CSV. Com isso ele pode agora usar um comparador de arquivos como o WinMerge para terminar o serviço. No entanto, para conseguir comparar muitas informações de máquinas distintas, tenha em mente que algumas colunas precisam ser eliminadas, como o horário de execução dos eventos e o PID dos processos.
Depois de muito fuçar nessa comparação eis que nosso herói encontra um evento-chave, que ocorre apenas na máquina do diretor:
Date: 2015-05-08 20:29:52Class: File SystemOperation: CreateFileResult: SHARING VIOLATIONPath: /soso/soso.dllTID: 1512Duration: 0.0000458Desired Access: RWDDisposition: OverwriteIfOptions: Seq, Sync IO, NDFAttributes: AShareMode: NoneAllocationSize: 65,024 E voilà! Parece que alguém está bloqueando a atualização de soso.dll, embora soso.exe conseguisse ser atualizado (logo concluímos que não é ele).
Se Juquinha é analista de nível 1 ele precisará compartilhar suas descobertas com outras pessoas da equipe. Para isso, basta duplo-clicar o evento no ProcMon e usar o botão de cópia. O resultado será um texto com todas as informações necessárias para uma análise mais aprofundada.
OK, mas onde está o problema? Bom, aqui começa a pesquisa, mas se você já programou para Windows API já há algum tempo sabe que alguém abriu esse arquivo antes com um modo de compartilhamento incompatível com uma escrita (que é o que o nosso instalador tenta fazer). Para saber quem é o culpado, mais uma ferramenta da SysInternals vem a calhar: Process Explorer (eu ia dizer handle.exe, mas ele não funcionou em meus testes).
No Process Explorer existe uma opção no menu chamada Find, Find Handle or DLL, onde o culpado se mostra rapidamente. No caso em questão (fictício, mas com uma ponta de verdade) o culpado foi o soso_ui.exe, que fica bloqueando a dll no momento da atualização! Na verdade, o grande culpado foi mesmo o programador desse instalador, que sequer tem ideia das centenas de erros que podem ocorrer durante uma atualização. Azar do suporte técnico desse produto.
</description>
</item>

     
        <item>
  <title>Convenção de Chamada</title>
  <link>http://www.caloni.com.br/convencao-de-chamada/</link>
  <pubDate>2015-04-20</pubDate>
  
  <guid>http://www.caloni.com.br/convencao-de-chamada/</guid>
  <description>Pergunta de um leitor:
Leitor: Olhe essa bizarrice em C: void func(){}int main(){func(&amp;#34;sbrubles&amp;#34;);return 0;}Leitor: Embora isso seja permitido, caso você coloque &amp;quot;void func(void)&amp;quot; já não funciona mais. Por quê? Resposta do Autor: Por que C é zoado :P
OK, a verdade é que não existem (existiam?) muitas regras de sintaxe a serem respeitadas na linguagem pelo compilador. Antigamente, se não fosse colocado nenhum tipo de retorno era como se ele fosse int por default. Da mesma forma, se não colocar parâmetros vale tudo. É como se fossem os três pontinhos do printf. Afinal, você não ia querer ficar repetindo os parâmetros no .c e no .h, não é mesmo :D
Isso me lembra também que havia a declaração &amp;quot;arcaica&amp;quot; da linguagem (já era arcaica antes mesmo do padrão de 1998 sair):
void func()char* sbrubles; /* isso é um argumento de entrada */{}Leitor: OK, entendi. Mas voltando para meu primeiro exemplo: supostamente usar um va_args pra ler &amp;quot;alguma coisa&amp;quot; certamente leria os parâmetros, certo? E este parâmetro, só fica inutilizado ou chega a dar algum problema mais sério? Sim, sua suposição a respeito do va_args faz todo sentido. E não, os parâmetros não são inutilizados justamente porque a função chamada pode fazer o que quiser que no retorno o chamador limpa a pilha (e o chamador sabe como ele empilhou os parâmetros-extra).
O padrão de chamada da linguagem (lembra disso?) é cdecl. Isso quer dizer que o chamador é que &amp;quot;limpa a sujeira&amp;quot; depois da chamada. Isso é o que permite o &amp;quot;milagre&amp;quot; do printf (oooohhh ooohh oooooohhhh... sons de anjos) receber n argumentos.
Só vai dar problema se definir outro padrão de chamada ou se a função chamada mexer no que não devia (se esperar outros tipos ou número de argumentos, por exemplo).
StdArgs na mão Agora que sabemos disso, o comportamento do va_list nem deve parecer tão mágico assim. Na verdade, apenas saber que a pilha é onde estão todas as variáveis locais e os endereços de retorno das funções é o suficiente para explorar essa área de memória.
Porém, o uso canônico na linguagem C e a forma mais educada de navegar nos parâmetros extras é usando o header stdarg.h. Isso porque C é uma linguagem independente de plataforma, e a priori não temos a mínima ideia de como os dados estão estruturados no computador. Essa visão das variáveis locais e etc é apenas algo que sabemos sobre a arquitetura PC (8086) porque já brincamos demais de assembly e seus registradores.
int soma(int argc, ...);int main(){int resultado = soma(5, 2, 3, 4, 5, 6);}// soma.cpp#include &amp;lt;stdarg.h&amp;gt;int soma(int argc, ...){int ret = 0;va_list vl;va_start(vl, argc);while( --argc ){int next = va_arg(vl, int);ret &#43;= next;}return ret;}Uma versão de quem já manja dos internals da arquitetura onde está programando e não se importa com portabilidade poderia simplesmente caminhar pela pilha a partir do endereço de argc.
int soma(int argc, ...){int ret = 0;int* argv = &amp;amp;argc &#43; 1;while ( argc-- ){int next = *argv&#43;&#43;;ret &#43;= next;}return ret;}Repetindo: isso não é bonito, apesar de simpático. No entanto, se o objetivo é explorar a arquitetura, fique à vontade para navegar pela pilha a partir do endereço das variáveis locais.
</description>
</item>

     
        <item>
  <title>Guia de alocação (nos clientes)</title>
  <link>http://www.caloni.com.br/guia-alocacao-nos-clientes/</link>
  <pubDate>2015-03-04</pubDate>
  
  <guid>http://www.caloni.com.br/guia-alocacao-nos-clientes/</guid>
  <description>Se você trabalha com T.I. (nem precisa ser programação) e mora em São Paulo (ou qualquer outro lugar com pessoas paranoicas) então talvez em algum momento da sua carreira teve que ficar alocado (como uma memória que contém um vírus) em algum de seus clientes (ou da empresa onde trabalha/ou). Usando seus apetrechos pessoais dentro de uma mochila para zarpar no final do dia sem deixar rastros.
Não é muito elegante deixar seus logins, seu perfil, seus favoritos e histórico no navegador que está usando, além de ser uma falha de segurança, já que trocar a senha de um perfil no Windows é procedimento natural , além da própria segurança do SO deixar a desejar em alguns momentos. Por isso, segue algumas dicas que tenho usado e recomendo para quem também é essa memória corrompida, nem que seja por pouco tempo.
O TrueCrypt está aposentado graças ao Bit Locker. No entanto, ele ainda pode ser uma mão na roda. E portátil. Basta carregar seu executável e seus drivers em algum lugar e executar e poderá criar um novo volume facilmente.
Dentro desse volume devidamente encriptado com uma senha forte (ou talvez uma chave forte portátil) e algoritmos escolhidos fortes é possível colocar uma miríade de coisas. Eu gosto, por exemplo, de manter meus arquivos do Dropbox/Google Drive/One Drive dentro dele, escolhendo um drive fixo (adicionando aos favoritos). O jeito que meu DropBox se comporta é dar erro quando o volume não está montado, sendo que eu sou obrigado a me lembrar de montar o drive antes de começar a sincronização de arquivos de outros lugares que eu confio (meu notebook, por exemplo). Não que tenha nada muito relevante, mas a ideia é não deixar um rastro sequer, certo?
Por fim, outra possibilidade para o navegador é também usá-lo a partir do drive encriptado. Existem versões portáteis do Firefox e Google Chrome. O Chrome funciona razoavelmente bem, perdendo alguns logins de vez em quando. Mas, ei, perder logins não é exatamente um problema de segurança, certo?
</description>
</item>

     
        <item>
  <title>Por que o Visual Studio gera executáveis mutantes</title>
  <link>http://www.caloni.com.br/por-que-o-visual-studio-gera-executaveis-mutantes/</link>
  <pubDate>2015-01-11</pubDate>
  
  <guid>http://www.caloni.com.br/por-que-o-visual-studio-gera-executaveis-mutantes/</guid>
  <description> Esse é um post antigo que encontrei no meio dos meus emails de 2006, mas que contém uma boa dica para quem já entendeu o passo-a-passo da compilação, mas ainda tem sérios problemas quando os projetos ficam gigantes.
 Essa é a segunda vez que encontro esse mesmo problema. Como acredito que outras almas podem estar sofrendo do mesmo mal, coloco aqui uma breve descrição de como o VC8 faz para gerar um executável que, mesmo não dependendo das DLLs de runtime, não são executados em sistemas que suportam a interpretação do &amp;quot;.manifest&amp;quot;. De canja, um pequeno programa que exibe a lista dos programas instalados no sistema.
Primeiro, precisamos de um solution que contenha um projeto console e uma LIB. O projeto console deve usar a LIB para fazer alguma coisa. No exemplo abaixo, estarei listando os programas instalados no Windows (os mostrados no painel de controle através da opção &amp;quot;Adicionar/remover programas&amp;quot;.
/** library.h*/#pragma once#include &amp;lt;string&amp;gt;#include &amp;lt;vector&amp;gt;typedef std::vector&amp;lt;std::string&amp;gt; InstalledSoftwareList;int getInstalledSoftware(InstalledSoftwareList&amp;amp;);/** library.cpp*/#include &amp;#34;library.h&amp;#34;#include &amp;lt;windows.h&amp;gt; // aqui precisamos do windows para as funções de registro#include &amp;lt;tchar.h&amp;gt; // suporte a unicode condicional#define SW_ROOT_KEY &amp;#34;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall&amp;#34;#define SW_DISPLAY_NAME &amp;#34;DisplayName&amp;#34;/** Retorna o número de elementos em um array. */template&amp;lt;typename T, size_t Sz&amp;gt;DWORD SizeofArray(const T(&amp;amp;arr)[Sz]) { return Sz; }/** Retorna lista com descrição de cada programa instalado no sistema. */int getInstalledSoftware(InstalledSoftwareList&amp;amp; installedSoftware){HKEY swRoot = NULL;DWORD err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(SW_ROOT_KEY), 0, KEY_READ, &amp;amp;swRoot);if( err == ERROR_SUCCESS ){DWORD swIndex = 0;TCHAR swKeyName[MAX_PATH] = _T(&amp;#34;&amp;#34;);// para cada chave dentro da raiz de programas instalados while( (err = RegEnumKey(swRoot, swIndex&#43;&#43;, swKeyName, SizeofArray(swKeyName))) == ERROR_SUCCESS ){HKEY swCurrent = NULL;err = RegOpenKeyEx(swRoot, swKeyName, 0, KEY_READ, &amp;amp;swCurrent);if( err == ERROR_SUCCESS ){CHAR swDisplay[MAX_PATH] = &amp;#34;&amp;#34;; // vamos obter a string já em mb DWORD swDisplaySz = SizeofArray(swDisplay);if( (err = RegQueryValueExA(swCurrent, SW_DISPLAY_NAME, 0, NULL, reinterpret_cast&amp;lt;PBYTE&amp;gt;(swDisplay), &amp;amp;swDisplaySz)) == ERROR_SUCCESS ){installedSoftware.push_back(swDisplay);}RegCloseKey(swCurrent);}}// se não tem mais itens, então não é um erro if( err == ERROR_NO_MORE_ITEMS )err = ERROR_SUCCESS;RegCloseKey(swRoot);}return int(err);}/** console.cpp*/#include &amp;#34;../library/library.h&amp;#34; // include da nossa lib#include &amp;lt;algorithm&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;int main(){int ret;InstalledSoftwareList swList;cout &amp;lt;&amp;lt; &amp;#34;MSVC Mutant - v. beta\n&amp;#34;&amp;lt;&amp;lt; &amp;#34;by Wanderley Caloni (www.caloni.com.br)\n\n&amp;#34;;// obtém a lista de programas instalados e exibe na tela ret = getInstalledSoftware(swList);if( ret == 0 ){cout &amp;lt;&amp;lt; &amp;#34;Programs installed on your system\n&amp;#34;&amp;lt;&amp;lt; &amp;#34;=================================\n&amp;#34;;copy(swList.begin(), swList.end(), ostream_iterator&amp;lt;string&amp;gt;(cout, &amp;#34;\n&amp;#34;));}elsecout &amp;lt;&amp;lt; &amp;#34;Error &amp;#34; &amp;lt;&amp;lt; ret &amp;lt;&amp;lt; &amp;#34; trying to list installed programs.\n&amp;#34;;return ret;}Observação importante: para ignorar todas as estripulias da versão Debug, todos os testes foram compilados em Release.
Primeiramente, modifico a configuração padrão dos dois projetos para não depender da DLL de runtime do VC. Isso está em Project, Properties, C/C&#43;&#43;, Code Generation, Runtime Library. Depois executo em uma máquina virtual sem as runtimes do VC8 instaladas:
MSVC Mutant - v. betaby Wanderley Caloni (www.caloni.com.br)Programs installed on your system=================================Windows XP Service Pack 2WebFldrs XPVMware Tools Perfeito. Exatamente o que eu queria: um executável console que não dependesse de DLL nenhuma exceto as que já estão instaladas em um Windows ordinário.
Agora, vamos imaginar que esse é um daqueles projetos enormes de 5 * 10 ^ 42 de linhas (obs: dramatização) e que meu aplicativo console está linkado com cerca de 3 * 10 ^ 666 de LIBs. E uma delas (a library do exemplo) está com a configuração original, ou seja, com a dependência da DLL de runtime. E ela usa a STL. Provavelmente o aplicativo console não irá compilar, mas isso não é problema, pois estamos acostumados a colocar a msvcrt.lib na lista de LIBs ignoradas, pois em muitos outros casos (que não vale a pena discutir aqui) esse workaround é válido. E tudo volta a funcionar. Quer dizer, linkar:
O sistema no pode executar o programa especificado.
Tudo bem, meu executável não é mutante ainda. Mas agora vamos trocar a chamada da nossa função que usa STL por uma função que não usa:
/** library.h*/int doesNothing();/** library.cpp*//** Essa função não faz nada. Quer dizer, ela retorna 0. Mas é só isso. */int doesNothing(){return 0;}/** console.cpp*/#include &amp;#34;../library/library.h&amp;#34; // include da nossa libint main(){int ret;// não faz nada. bom, chama uma função. mas isso é quase nada. ret = doesNothing();return ret;}Linking=======library.lib(library.obj) : warning LNK4049: locally defined symbol __invalid_parameter_noinfo importedRunning=======O sistema no pode executar o programa especificado.Depends=======Error: The Side-by-Side configuration information in &amp;quot;blablabla\CONSOLE.EXE&amp;quot; contains errors.Falha na inicialização do aplicativo devido a configuração incorreta.A reinstalação do aplicativo pode resolver o problema (14001). Agora sim, a mutação fez efeito! Temos um aplicativo que não depende da DLL de runtime, mas que no meio das n LIBs que ele utiliza existe uma configurada com a dependência. Ignorando a msvcrt.lib e um warning na compilação encontramos uma mensagem de erro um tanto exdrúxula.
Até agora, a maneira que eu tenho utilizado para rastrear esse problema é não ignorar a msvcrt e ir tirando as dependências das LIBs pouco a pouco, até que ocorra o erro de símbolo duplicado. Algo assim:
MSVCRT.lib(ti_inst.obj) : error LNK2005: &amp;quot;private: __thiscall type_info::type_info(class type_info const &amp;amp;)&amp;quot; (??0type_info@@AAE@ABV0@@Z) already defined in LIBCMT.lib(typinfo.obj)MSVCRT.lib(ti_inst.obj) : error LNK2005: &amp;quot;private: class type_info &amp;amp; __thiscall type_info::operator=(class type_info const &amp;amp;)&amp;quot; (??4type_info@@AAEAAV0@ABV0@@Z) already defined in LIBCMT.lib(typinfo.obj)LINK : warning LNK4098: defaultlib &#39;MSVCRT&#39; conflicts with use of other libs; use /NODEFAULTLIB:libraryBlablabla\console.exe : fatal error LNK1169: one or more multiply defined symbols found Se você tiver realmente 3 * 10 ^ 666 de LIBs, boa sorte =).
</description>
</item>

     
        <item>
  <title>Entendendo a Compilação</title>
  <link>http://www.caloni.com.br/entendendo-a-compilacao/</link>
  <pubDate>2015-01-04</pubDate>
  
  <guid>http://www.caloni.com.br/entendendo-a-compilacao/</guid>
  <description>Fiz alguns slides a pedido dos organizadores do TDC 2014, já que a palestra que ministrei com esse tema foi para ajudar meu amigo-sócio Rodrigo Strauss que não havia preparado nenhum slide a respeito.Felizmente eu já havia explicado alguns conceitos-chave para quem programa em C/C&#43;&#43; e precisa -- eu disse: PRECISA -- conhecer todo o passo-a-passo que leva o seu código-fonte a gerar um executável com código de máquina pronto para rodar.
Como havia explicado anteriormente, existem três processos principais e clássicos (pode haver mais, dependendo do compilador, ambiente, etc) na formação de um código de máquina a partir de arquivos-fontes escritos em C ou C&#43;&#43; (ou ambos, são intercambiáveis). São eles: preprocessamento, compilação e linkedição.
O preprocessamento é um trocador de textos. No máximo há macros, em que é possível passar argumentos (no formato texto). Exemplos são include, ifdef e define.
A compilação é o núcleo da linguagem. Regras de sintaxe e gramática são validadas aqui pelo compilador. Cada compilação bem-sucedida recebe uma unidade de tradução e cospe um arquivo-objeto, que ainda não é executável, mas que já passou pela validação da linguagem.
Por fim, a linkedição junta todos os arquivos-objeto, procurando ligar os nomes das funções e variáveis referenciadas um pelo outro. Os nomes externos são importantes neste passo para que o linker encontre as lacunas que precisa para consertar os saltos e assim gerar o executável final, que pode ser um programa com uma função main ou uma biblioteca dinâmica carregada por outro programa compilado seguindo esses três passos.
</description>
</item>

     
        <item>
  <title>Houaiss Para *</title>
  <link>http://www.caloni.com.br/houaiss-para/</link>
  <pubDate>2014-10-25</pubDate>
  
  <guid>http://www.caloni.com.br/houaiss-para/</guid>
  <description>O projeto Houaiss2Babylon, iniciado há mais de 6 anos, já devia estar ultrapassado. Porém, cada vez mais pessoas compartilham seus usos e desusos do que foi um dia uma base de dados ofuscada e presa a apenas uma interface Windows. Agora, além de já ter sido convertido para Kindle, em Python e agora através do nodejs para o MySql!
O jornalista e programador Arthur da Paz desenvolveu esta última novidade no programa e gentilmente compartilhou conosco direto no repositório original do HouaissParaBabylon, colaborando felizmente para que esse nome perdesse um pouco mais do sentido (Babylon já está meio ultrapassado, não?). Além disso ele encontrou a solução para um bug que invertia a ordem de apresentação das Rubricas, cujos detalhes ele explica nos comentários do post sobre a última versão.
Muito obrigado ao Da Paz e a todos que colaboram e compartilham melhorias para esse projeto. Um dicionário não é nada sem as pessoas que o utilizam.
</description>
</item>

     
        <item>
  <title>Shareando Ponteiros</title>
  <link>http://www.caloni.com.br/shareando-ponteiros/</link>
  <pubDate>2014-09-03</pubDate>
  
  <guid>http://www.caloni.com.br/shareando-ponteiros/</guid>
  <description>Apesar de já ter palestrado algumas vezes sobre Boost e STL, acho que eu nunca escrevi muito sobre esses assuntos no blogue. Acho que o tamanho dessas bibliotecas assusta um pouco. Mas temos que começar de algum lugar, certo? E já que é pra começar, eu gostaria muito de saber de você, programador miserável, que passou poucas e boas nesses 10 anos de padrão 98 brincando com templates quando eles ainda estavam em beta: se fosse para melhorar um aspecto da sua vida de código, qual seria? Qual é aquela coisa que te atormenta como insetos vidrados no seu monitor noite adentro?
Que tal alocação de memória e ponteiros? Vamos matar dois coelhos com um template só?
A triste realidade do código legado &amp;quot;Ah, mas tem que usar alguma biblioteca bizarra com milhões de dependências e que vai quebrar todo o fonte aqui da empresa. Sem contar que vai ter que passar de novo pelos unit tests, vai dar erro de compilação, a LIB XPTO não funciona sem dar três pulinhos virado para a cafeteira e...&amp;quot;
Cada caso é um caso, existe o melhor dos mundos e o pior. Mas (quase) todos têm solução. Mesmo que tudo que você tenha disponível seja um bartante e um clipe, podemos tentar alguma mágica/gambiarra/adaptação técnica. Vamos ver os casos mais comuns:
Aqui no trampo não tem frescura: posso usar C&#43;&#43;11 (acho que até 14, 17, 34...), Visual Studio mais novo, Windows 9 Um cenário perfeito para começar. A única coisa que você precisa fazer em seus novos projetos e refatorações é incluir um único cabeçalho:
#include &amp;lt;memory&amp;gt;E pronto! Se abriu um mundo mágico onde as alocações serão compartilhadas entre funções sem se perder quem deleta o quê. Não precisa nem checar se o ponteiro é nulo, basta alocar direto e jogar para dentro do nosso mais novo smart pointer da STL:
#include &amp;lt;memory&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;struct Person{Person() { std::cout &amp;lt;&amp;lt; &amp;#34;Person created\n&amp;#34;; }~Person() { std::cout &amp;lt;&amp;lt; &amp;#34;Person destroyed\n&amp;#34;; }std::string name;std::string surname;int age;std::string phone;};typedef std::shared_ptr&amp;lt;Person&amp;gt; PersonRef;PersonRef CreatePerson(){return PersonRef(new Person);}void GetName(PersonRef person){person-&amp;gt;name = &amp;#34;Carl&amp;#34;;}void GetSurName(PersonRef person){person-&amp;gt;surname = &amp;#34;Sagan&amp;#34;;}void GetAge(PersonRef person){person-&amp;gt;age = 79;}void GetPhone(PersonRef person){person-&amp;gt;phone = &amp;#34;&#43;01 042 4242-4242&amp;#34;;}void PrintPerson(PersonRef person){std::cout &amp;lt;&amp;lt; &amp;#34;Name: &amp;#34; &amp;lt;&amp;lt; person-&amp;gt;name &amp;lt;&amp;lt; &amp;#34; &amp;#34; &amp;lt;&amp;lt; person-&amp;gt;surname&amp;lt;&amp;lt; &amp;#34;\nAge: &amp;#34; &amp;lt;&amp;lt; person-&amp;gt;age&amp;lt;&amp;lt; &amp;#34;\nPhone: &amp;#34; &amp;lt;&amp;lt; person-&amp;gt;phone&amp;lt;&amp;lt; std::endl;}void CreateAndPrintPerson(){PersonRef person = CreatePerson();GetName(person);GetSurName(person);GetAge(person);GetPhone(person);PrintPerson(person);}int main(){CreateAndPrintPerson();}E pronto: você nunca mais vai precisar se preocupar com quem deleta o ponteiro, nem quantas cópias desse ponteiro andam por aí. O shared_ptr da STL, assim como a versão que já tem faz um tempo no boost, mantém um contador de referência para cada cópia do objeto que mantém o mesmo ponteiro &amp;quot;dentro de si&amp;quot;. Só quando esse contador chegar a zero, ou seja, não há mais ninguém referenciando essa região da memória, o ponteiro é deletado.
O std::shared_ptr funciona desde o SP1 do Visual Studio 2010. Sem Service Pack ou em versões mais antigas pode haver disponível no namespace tr1, resquício de quando esse novo padrão ainda estava em definição.
Aqui no trampo vivemos na era pré-jurássica, onde pessoas mais velhas torcem o nariz quando veem um tal de template. Vou imaginar que você usa o Visual Studio 2003, um dos primeiros da safra &amp;quot;.NET&amp;quot;, que, mais uma vez, NÃO TEM QUALQUER RELAÇÃO COM C&#43;&#43; .NET.
Bem, nesse caso, &amp;quot;welcome... to the desert... of the double&amp;quot;:
&amp;lt;code&amp;gt;------ Build started: Project: VS2003, Configuration: Debug Win32 ------Compiling...usando-shared-ptr.cppshared-ptr.cpp(15) : error C2039: &#39;shared_ptr&#39; : is not a member of &#39;std&#39;shared-ptr.cpp(15) : error C2143: syntax error : missing &#39;;&#39; before &#39;&amp;lt;&#39;shared-ptr.cpp(18) : error C2146: syntax error : missing &#39;;&#39; before identifier &#39;CreatePerson&#39;shared-ptr.cpp(18) : error C2501: &#39;PersonRef&#39; : missing storage-class or type specifiersshared-ptr.cpp(20) : error C2064: term does not evaluate to a function taking 1 argumentsshared-ptr.cpp(20) : warning C4508: &#39;CreatePerson&#39; : function should return a value; &#39;void&#39; return type assumedshared-ptr.cpp(23) : error C2146: syntax error : missing &#39;)&#39; before identifier &#39;person&#39;shared-ptr.cpp(23) : error C2182: &#39;GetName&#39; : illegal use of type &#39;void&#39;shared-ptr.cpp(23) : error C2059: syntax error : &#39;)&#39;shared-ptr.cpp(24) : error C2143: syntax error : missing &#39;;&#39; before &#39;{&#39;shared-ptr.cpp(24) : error C2447: &#39;{&#39; : missing function header (old-style formal list?)shared-ptr.cpp(28) : error C2146: syntax error : missing &#39;)&#39; before identifier &#39;person&#39;shared-ptr.cpp(28) : error C2182: &#39;GetSurName&#39; : illegal use of type &#39;void&#39;shared-ptr.cpp(28) : error C2059: syntax error : &#39;)&#39;shared-ptr.cpp(29) : error C2143: syntax error : missing &#39;;&#39; before &#39;{&#39;shared-ptr.cpp(29) : error C2447: &#39;{&#39; : missing function header (old-style formal list?)shared-ptr.cpp(33) : error C2146: syntax error : missing &#39;)&#39; before identifier &#39;person&#39;shared-ptr.cpp(33) : error C2182: &#39;GetAge&#39; : illegal use of type &#39;void&#39;shared-ptr.cpp(33) : error C2059: syntax error : &#39;)&#39;shared-ptr.cpp(34) : error C2143: syntax error : missing &#39;;&#39; before &#39;{&#39;shared-ptr.cpp(34) : error C2447: &#39;{&#39; : missing function header (old-style formal list?)shared-ptr.cpp(38) : error C2146: syntax error : missing &#39;)&#39; before identifier &#39;person&#39;shared-ptr.cpp(38) : error C2182: &#39;GetPhone&#39; : illegal use of type &#39;void&#39;shared-ptr.cpp(38) : error C2059: syntax error : &#39;)&#39;shared-ptr.cpp(39) : error C2143: syntax error : missing &#39;;&#39; before &#39;{&#39;shared-ptr.cpp(39) : error C2447: &#39;{&#39; : missing function header (old-style formal list?)shared-ptr.cpp(43) : error C2146: syntax error : missing &#39;)&#39; before identifier &#39;person&#39;shared-ptr.cpp(43) : error C2182: &#39;PrintPerson&#39; : illegal use of type &#39;void&#39;shared-ptr.cpp(43) : error C2059: syntax error : &#39;)&#39;shared-ptr.cpp(44) : error C2143: syntax error : missing &#39;;&#39; before &#39;{&#39;shared-ptr.cpp(44) : error C2447: &#39;{&#39; : missing function header (old-style formal list?)shared-ptr.cpp(53) : error C2146: syntax error : missing &#39;;&#39; before identifier &#39;person&#39;shared-ptr.cpp(53) : error C2065: &#39;person&#39; : undeclared identifiershared-ptr.cpp(54) : error C3861: &#39;person&#39;: identifier not found, even with argument-dependent lookupshared-ptr.cpp(55) : error C3861: &#39;person&#39;: identifier not found, even with argument-dependent lookupshared-ptr.cpp(56) : error C3861: &#39;person&#39;: identifier not found, even with argument-dependent lookupshared-ptr.cpp(57) : error C3861: &#39;person&#39;: identifier not found, even with argument-dependent lookupshared-ptr.cpp(58) : error C3861: &#39;person&#39;: identifier not found, even with argument-dependent lookupVS2003 - 37 error(s), 1 warning(s)&amp;lt;/code&amp;gt; Pois é, 37 erros. Depois perguntam por que as pessoas ficam com medo de programar em C&#43;&#43;...
Porém, a correção é mais simples do que parece: baixar o boost e trocar o nome do namespace.
#include &amp;lt;boost/shared_ptr.hpp&amp;gt;//...typedef boost::shared_ptr&amp;lt;Person&amp;gt; PersonRef;//...ATENÇÃO! Nos meus testes a única versão funcionando com o VS2003 foi a 1.47. Mas já é alguma coisa
Aqui não tem jeito, não. O pessoal olha feio quando usamos classe e a palavra boost é proibida de ser usada no escritório. Não existe situação difícil que não possa piorar. Porém, mesmo nesse caso ainda há algo a se fazer, já que smart pointer utilizam mecanismos existentes na linguagem C&#43;&#43; desde os primórdios (ou bem próximo disso). Tudo que você precisa para criar seu próprio shared_ptr é do construtor padrão, do destrutor padrão, do construtor de cópia e dos operadores de atribuição e ponteiro. E, claro, não se esqueça de usar template se for permitido. Se não for, a coisa complica, mas não se torna impossível.
#pragma once// Não façam isso em casa! Usem modelo de smart pointers já construídos (como o do boost).template&amp;lt;typename T&amp;gt;class shared_ptr{public:shared_ptr() : m_p(), m_counter(){}shared_ptr(T* p) : m_p(p), m_counter(new int(1)) {}shared_ptr(const shared_ptr&amp;amp; left): m_p(left.m_p), m_counter(left.m_counter){if( m_counter )&#43;&#43;*m_counter;}shared_ptr&amp;amp; operator = (const shared_ptr&amp;amp; left){if( m_p ){if( --*m_counter == 0 ){delete m_counter;delete m_p;m_counter = 0;m_p = 0;}}if( m_counter = left.m_counter )&#43;&#43;*m_counter;m_p = left.m_p;}~shared_ptr(){if( --*m_counter == 0 ){delete m_counter;delete m_p;m_counter = 0;m_p = 0;}}T* operator -&amp;gt; (){return m_p;}private:int* m_counter;T* m_p;};#include &amp;#34;shared_ptr.h&amp;#34;//...typedef shared_ptr&amp;lt;Person&amp;gt; PersonRef;//...E é isso. A lição de hoje é: quem quer, arruma um jeito. Quem não quer, uma desculpa.
</description>
</item>

     
        <item>
  <title>Se iterando com os pseudo-ponteiros: uma breve introdução</title>
  <link>http://www.caloni.com.br/se-iterando-com-os-pseudo-ponteiros-uma-breve-introducao/</link>
  <pubDate>2014-06-24</pubDate>
  
  <guid>http://www.caloni.com.br/se-iterando-com-os-pseudo-ponteiros-uma-breve-introducao/</guid>
  <description>Como já vimos algumas vezes, a STL não prima por interfaces intuitivas, preferindo abstrações que criem um leque de ferramentas genéricas para tratamento uniformizado de coleções de dados através de algoritmos. O problema disso é que novos programadores da linguagem terão que aprender uma maneira nova de lidar com problemas baseada na percepção dos criadores do padrão na época em que foi lançado de como seria a evolução da ciência da computação nos próximos anos. Muitos dos conceitos ali abordados realmente se tornaram padrão de facto, mas na briga pela expansão da linguagem quem perdeu por muito tempo foi o próprio desenvolvedor, que teve que se contentar com uma lista de algoritmos genéricos parcialmente compilado.
Dito isto, a abstração dos iteradores é a coisa mais linda do mundo.

Iteradeiros ou Ponteradores? Os dois únicos conceitos que é preciso se lembrar para sempre quando se trata de iteradores é que ele:
  Um iterador se comporta como um ponteiro opaco.
  O final de um contêiner está sempre um elemento além do último.
  Um ponteiro pode ser iterador, mas não o contrário!
Tudo que um ponteiro faz de útil em C/C&#43;&#43; foi emprestado para a STL usar em seus contêiners, e tudo em que ele é prejudicial tentou ficar de fora. E o que um ponteiro faz de útil?
  Um ponteiro pode apontar para elementos sem conhecermos sua posição.
  Podemos incrementar ou decrementar ponteiros para caminhar em listas.
  Dois ponteiros podem ser subtraídos para sabermos a distância entre dois elementos.
  template&amp;lt;typename T&amp;gt;T VaiSomandoVaiSomando(T begin, T end){T current = begin;T next = begin &#43; 1;while( next != end ){*next = *current &#43; *next;&#43;&#43;current;&#43;&#43;next;}return current;}#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;int main(){int aInts[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };std::vector&amp;lt;int&amp;gt; vInts;for( int i = 0; i &amp;lt; 10; &#43;&#43;i )vInts.push_back(i);std::cout &amp;lt;&amp;lt; *VaiSomandoVaiSomando(&amp;amp;aInts[0], &amp;amp;aInts[10]) &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; *VaiSomandoVaiSomando(vInts.begin(), vInts.end()) &amp;lt;&amp;lt; std::endl;}
Da mesma forma, operações como cópia, movimentação, ordenação, caotização, pode ser feito usando dois ponteiros/iteradores de dois contêiners distintos, desde que algumas regras básicas sejam seguidas, como um iterador deve sempre apontar para algo válido (ou disponibilizar alguma abstração que insira novos elementos em um contêiner menor). Veremos essas regras em um próximo post sobre o tema. Apontarei para ele aqui.
</description>
</item>

     
        <item>
  <title>Dando cabo do WinDbg</title>
  <link>http://www.caloni.com.br/dando-cabo-do-windbg/</link>
  <pubDate>2014-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/dando-cabo-do-windbg/</guid>
  <description>Na semana passada falei sobre a ideia de comentar algumas mudanças entre o Windows XP e o novo mundo Vista/7/8/ que fizeram com que adaptássemos algum código que obviamente não funcionaria mais. Falamos sobre a famigerada GINA (ou famiGINADA), e agora apenas vou comentar brevemente sobre o sistema de boot, que também mudou.
Na verdade, pouca coisa mudou, mas foi o suficiente para dar problemas na hora de usar o WinDbg. Tradicionalmente, o boot era gerenciado no Windows através de um arquivo localizado na raiz da partição ativa (configuração da MBR) chamado bootini. Dentro dele temos uma estrutura semelhante a um .INI (duh), onde a informação que vemos lá podia ser configurada nas configurações do Computador no Windows XP.
Hoje em dia esse arquivo nem existe mais, o que pode dar um friozinho na barriga (&amp;quot;caramba, não vai mais bootar!!&amp;quot;). Agora, para sistemas baseados em BIOS há uma pasta Boot na raiz e um arquivo chamado bcd. Para os mais moderninhos, baseados em EFI, ele fica na partição EFI. Ah, EFI é Extensible Firmware Interface, e faz parte da especificação da UEFI (Universal blá blá blá), mais ou menos um padrão que define como deve ser feita a comunicação entre hardware e sistema operacional.
Para a edição desse novo arquivo (ou partição) é necessário que seja usada a ferramenta BCDEdit no Windows. É ela que agora configura qual partição está ativa e, mais importante para escovadores de bits, qual pode ser depurada pela porta serial através do WinDbg.
Porta serial? Mas que coisa antiga, hein? Pois é, muita coisa mudou desde o Windows Vista, mas algumas coisas precisam permanecer... compatíveis.
Mas... se você precisar:
</description>
</item>

     
        <item>
  <title>Eles querem que a GINA vá embora: três posts sobre evolução Windows</title>
  <link>http://www.caloni.com.br/eles-querem-que-a-gina-va-embora-tres-posts-sobre-evolucao-windows/</link>
  <pubDate>2014-06-11</pubDate>
  
  <guid>http://www.caloni.com.br/eles-querem-que-a-gina-va-embora-tres-posts-sobre-evolucao-windows/</guid>
  <description>Fui convidado pela Fernanda Saraiva do programa de MVPs da Microsoft Brasil a falar sobre alguma história a respeito da evolução do Windows e como isso impactou minha experiência profissional. Pesquisando em meu próprio blogue fui capaz de lembrar não apenas de uma, mas de três mudanças técnicas que fizeram com que eu e minha &amp;quot;equipe&amp;quot; da época (geralmente mais alguém, no máximo) matássemos alguns neurônios tentando descobrir novas maneiras do sistema fazer o que já fazia no Windows XP. Irei compartilhar uma por vez no que tem sido o meu post semanal que eu apelidei carinhosamente de Post da Terça. Já faz mais de um mês que consigo publicar pelo menos na terça algo de novo, e espero manter esse ritmo.
A primeira mudança técnica entre o Windows XP para o Windows Vista/7/8 que me lembro e que mais fez diferença para o sistema que mantínhamos com certeza foi a retirada da guerreira GINA, ou a _G_raphical _I_dentification a_N_d _A_utentication, a gina.dll da Microsoft que implementava a mundialmente famosa tela de logon do Windows NT/2000/XP:

Seja no formato Home Computer (a telinha de boas vindas) ou no tradicional &amp;quot;Pressione Ctrl&#43;Alt&#43;Del&amp;quot; do Windows NT ¿ quando a máquina está no domínio ¿ quem gerencia essa tela é o processo de sistema iniciado a partir do WinLogon.exe. O WINLOGON carrega a nossa amiga gina.dll que é quem realiza a autenticação dos usuários.
Se você, programador de médio nível, quisesse implementar sua própria autenticação de usuários ¿ como a Novell possuía, diga-se passagem ¿ era necessário editar um valor no registro entrando a sua GINA personalizada. Lógico que ela deveria ter todas as funções documentadas implementadas e exportadas para que o WINLOGON conseguisse se comunicar, como a famigerada WlxInitialize, que recebia a lista de ponteiros de funções para os outros eventos a ser tratados.
// Essa funcao sobrescreve a original do Windows no momento do logon.// No codigo abaixo gravamos os dados de autenticacao do usuario.intWINAPI My_WlxLoggedOutSAS(PVOID pWlxContext,DWORD dwSasType, PLUID pAuthenticationId, PSID pLogonSid, PDWORD pdwOptions, PHANDLE phToken, PWLX_MPR_NOTIFY_INFO pNprNotifyInfo, PVOID* pProfile){FWlxLoggedOutSAS *WlxLoggedOutSAS = reinterpret_cast&amp;lt;FWlxLoggedOutSAS*&amp;gt;(GetProcAddress(g_msginaDll, &amp;#34;WlxLoggedOutSAS&amp;#34;) );int ret = WlxLoggedOutSAS(pWlxContext, dwSasType, pAuthenticationId, pLogonSid, pdwOptions, phToken, pNprNotifyInfo, pProfile);if( ret == WLX_SAS_ACTION_LOGON ){tstringstream userName;tstringstream password;// Domain\User userName &amp;lt;&amp;lt; pNprNotifyInfo-&amp;gt;pszDomain &amp;lt;&amp;lt; &amp;#39;\\&amp;#39; &amp;lt;&amp;lt; pNprNotifyInfo-&amp;gt;pszUserName;password &amp;lt;&amp;lt; pNprNotifyInfo-&amp;gt;pszPassword;if( SaveLogonInformation(userName.str(), password.str()) &amp;gt; 5 )if( !IsNetworkAdmin(userName.str(), pNprNotifyInfo-&amp;gt;pszDomain) )ret = 0;}return ret;}Com a vinda do Windows Vista, o WINLOGON continuou gerenciando as sessões e autenticações dos usuários, mas para evitar que a GINA monopolizasse novamente os métodos de autenticação, e com a vinda de métodos concorrentes ¿ como retina e impressão digital ¿ a Microsoft desevolveu uma nova interface chamada de Credential Provider. A implementação dessa interface não sobrescreveria novamente a &amp;quot;GINA&amp;quot; da vez, mas daria apenas uma alternativa para o logon tradicional com login e senha.
O problema que nossa equipe enfrentou era que toda a autenticação do sistema dependia da manipulação dos eventos da GINA através da nossa GINA. Com ela colocada de escanteio, os logins parariam de funcionar.

Depois de uma análise rápida foi constatado que não seria mais possível bloquear o login completamente, uma vez que existiam pelo menos duas alternativas de login que vieram com a instalação do Vista, e o fato de instalar mais uma apenas faria com que essa terceira alternativa não funcionasse, mas o usuário não estaria mais obrigado a &amp;quot;passar por nós&amp;quot;.
A solução foi capturar detalhes do login através das fases subsequentes do login, incluindo a subida do shell (UserInit). Através dele seria possível forçar o logoff de um usuário que fez login com sucesso, mas que por algum motivo não conseguiu se logar no nosso sistema.
Nem sempre o que estava rodando já há anos é a solução mais bonita. Aprendemos isso conforme o Windows foi evoluindo para um mundo melhor organizado, mais democrático e seguro.
</description>
</item>

     
        <item>
  <title>SS</title>
  <link>http://www.caloni.com.br/ss/</link>
  <pubDate>2014-06-03</pubDate>
  
  <guid>http://www.caloni.com.br/ss/</guid>
  <description>Uma das coisas mais cretinas e difíceis para os iniciantes em C&#43;&#43; é conseguir formatar strings de maneira fácil, rápida e indolor. Infelizmente, a biblioteca de printf da linguagem C está fechada para reforma, pois ela é extremamente error-prone e não-intuitiva. Porém, se a printf é não-intuitiva, o que dizer &amp;lt; &amp;lt; daqueles &amp;lt;&amp;lt; sinais &amp;lt;&amp;lt; de &amp;lt;&amp;lt; flechinhas apontando para cout? Bem melhor, não?
#include &amp;lt;iostream&amp;gt;int main(){int x = 0x00000001;int y = 4;int z = x &amp;lt;&amp;lt; y; // isso desloca 4 bits para a &amp;#34;esquerda&amp;#34; std::cout &amp;lt;&amp;lt; z // WHAT?? &amp;lt;&amp;lt; &amp;#34;\nestranho...&amp;#34; &amp;lt;&amp;lt; std::endl; // WHAT^^2!?!?!?!??!?!}
A resposta é, pra variar, depende. Se você combinar com seu cérebro que o operador de shift que você aprendeu em C para cout não tem a mesma semântica, OK. No fundo eu acredito que os criadores dessa sobrecarga de operador pensaram sinceramente que hoje em dia quase ninguém conhece os operadores de shift binário, então tudo bem reaproveitá-lo de uma maneira mais miguxa.
Porém, isso depende da maneira com que você usa streams C&#43;&#43;. Vai haver momentos de sua vida que você vai se questionar por que tiraram todo o controle, a elegância e simplicidade de um bom printf, quando os homens eram homens e sabiam configurar jumpers para instalar a nova placa EISA.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int main(){int x = 0x00AB3451;printf(&amp;#34;int x = 0x%08X;\n&amp;#34;, x); // nao eh tao legivel, mas da conta do recado std::cout &amp;lt;&amp;lt; &amp;#34;int x = 0x&amp;#34; &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#34;;&amp;#34; &amp;lt;&amp;lt; std::endl; // pois eh, parece que melhoramos mesmo com streams...}
A coisa mais fácil do jeito mais difícil A questão dos streams fica mais complicada quando precisamos realizar atividades corriqueiras no código, como retornar uma string formatada, ou até mesmo transformar um inteiro em string.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;sstream&amp;gt; // digam oi para nosso novo amiguinho!std::string FuncaoCorriqueira(int x, int y){std::ostringstream ss; // credo, que tipo eh esse? ss &amp;lt;&amp;lt; (x &#43; y);return ss.str();}int main(){std::cout &amp;lt;&amp;lt; FuncaoCorriqueira(20, 42);}Já pensou termos que criar uma função dessas sempre que quisermos converter números em string? Ou pior, ter que fazer o que fizemos dentro dessa função: declarar um ostringstream (um cout com buffer interno de string), usá-lo como cout e obter seu buffer interno através do método str. Tudo isso para converter um número para string.
Quando uma tarefa muito comum exige mais de dois passos para ser realizada é de bom tom criarmos algum código reutilizável, certo? Um código que trará de uma vez por todas a solução final!
SS #include &amp;lt;sstream&amp;gt;struct ss{template&amp;lt;typename T&amp;gt;ss&amp;amp; operator &amp;lt;&amp;lt; (const T&amp;amp; t){_ss &amp;lt;&amp;lt; t; return *this;}operator std::string (){ return _ss.str();}std::ostringstream _ss;};O código acima serve bem ao nosso propósito de formatar strings em uma linha como um cout, mas retornar uma string no lugar. Ele é simples, ele é direto, ele tem defeitos que não vem ao caso (como não suportar endl), mas pode ser usado de maneira... simples e direta!
#include &amp;#34;ss.h&amp;#34;#include &amp;lt;iostream&amp;gt;int main(){for( int i = 0; i &amp;lt; 5; &#43;&#43;i ){std::string s = ss() &amp;lt;&amp;lt; &amp;#34;Teste numero &amp;#34; &amp;lt;&amp;lt; i;std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;}}OK, o código de exemplo foi idiota, mas você pegou a ideia. Tudo que precisamos fazer para reutilizar essa pequena classe é definí-la (ss() resolve) e usá-la. Seu conversor de string retorna o buffer interno de ostringstream para nós como num passe de mágica.
Obs.: Com certeza deve existir uma centena de bibliotecas que implementam algo do gênero, só que melhor. Essa é a típica fica isolante para continuar trabalhando.
</description>
</item>

     
        <item>
  <title>Desmontando o Aulete Digital</title>
  <link>http://www.caloni.com.br/desmontando-o-aulete-digital/</link>
  <pubDate>2014-05-27</pubDate>
  
  <guid>http://www.caloni.com.br/desmontando-o-aulete-digital/</guid>
  <description>Este post não estará mais disponível devido ao mau uso de pessoas que se aproveitaram das minhas explicações didáticas a respeito do funcionamento da versão Desktop do dicionário e, agindo de má-fé, começaram a baixar a base de dados indiscriminadamente, fazendo com que o serviço que é disponibilizado gratuitamente aos usuários tivesse que ser desligado. É uma lástima que isso tenha ocorrido, e peço desculpas às pessoas que prejudiquei direta ou indiretamente.
É condenável esse tipo de &amp;quot;ataque&amp;quot; a um serviço que é disponibilizado gratuitamente. Meu artigo teve apenas fins didáticos e não tem por objetivo o uso ilegal de uma ferramenta tão útil aos seus usuários.
</description>
</item>

     
        <item>
  <title>Estruturas VS Classes: fight!</title>
  <link>http://www.caloni.com.br/estruturas-vs-classes-fight/</link>
  <pubDate>2014-05-20</pubDate>
  
  <guid>http://www.caloni.com.br/estruturas-vs-classes-fight/</guid>
  <description>
Uma dúvida besta e importante ao mesmo tempo que muitos iniciantes em C&#43;&#43; possuem é saber qual a diferença entre um objeto declarado como class e um objeto declarado como struct. A causa dessa dúvida é uma linguagem que se derivou de outra (C) que não possuía classes, e portanto criou a palavra-chave class para &amp;quot;ficar bonito&amp;quot;, pois, na prática, não muda muita coisa. Tomemos como exemplo o código mais simples de todos:
struct MinhaEstrutura{};class MinhaClasse{};int main(){MinhaEstrutura me;MinhaClasse mc;}Ele compila e roda sem problemas:

&amp;quot;Estruturalmente&amp;quot; falando, MinhaEstrutura e MinhaClasse são idênticas, pois são os detalhes de sintaxe que diferem, e diferem pouco. Abrindo o jogo, a única diferença que poderá ser sentida em usar um ou outro é que structs possuem seus membros públicos por padrão e classes possuem seus membros privados por padrão. Apenas isso. O resto, nada muda.
Isso pode ser visto quando adicionamos um construtor para nossos tipos de teste:
struct MinhaEstrutura{MinhaEstrutura() {}};class MinhaClasse{MinhaClasse() {}};int main(){MinhaEstrutura me;MinhaClasse mc;}
Antes não havia problemas para MinhaClasse porque o construtor padrão criado para ela é público por default. Porém, explicitando no código um construtor e deixando sua privacidade ligada por padrão temos esse erro que NÃO ocorre em MinhaEstrutura.
Mas, então, posso criar todas minhas classes usando a palavra-chave struct?
Isso mesmo! Nada lhe obriga tecnicamente a usar class. Porém, assim como nada lhe obriga a usar uma linha para cada comando na linguagem ¿ afinal, todos poderiam estar na mesma linha separados por ponto-e-vírgula ¿ o uso da palavra struct para classes no sentido de &amp;quot;objetos que possuem inteligência, métodos, herança, polimorfismo e outras firulas&amp;quot; não se enquadra nas boas práticas dos programadores C&#43;&#43;.
Geralmente uma struct é uma forma de concatenar tipos primitivos e só. Algumas liberdades além disso geralmente são permitidas, mas desencorajadas, como um construtor que inicia os membros da struct com valores-default.
#include &amp;lt;iostream&amp;gt;struct MinhaEstrutura{MinhaEstrutura(){x = 0;y = 2;c = &amp;#39;C&amp;#39;;}int x;int y;char c;};int main(){MinhaEstrutura me;std::cout &amp;lt;&amp;lt; &amp;#34;x: &amp;#34; &amp;lt;&amp;lt; me.x &amp;lt;&amp;lt; &amp;#34;, y: &amp;#34; &amp;lt;&amp;lt; me.y &amp;lt;&amp;lt; &amp;#34;, c: &amp;#34; &amp;lt;&amp;lt; me.c &amp;lt;&amp;lt; std::endl;}
E, por que não, uma sobrecarga do operador de stream para imprimirmos diretamente os valores de MinhaEstrutura para a saída com apenas um comando?
#include &amp;lt;iostream&amp;gt;struct MinhaEstrutura{MinhaEstrutura() { x = 0; y = 2; c = &amp;#39;C&amp;#39;; }int x; int y; char c;};std::ostream&amp;amp; operator &amp;lt;&amp;lt; (std::ostream&amp;amp; os, const MinhaEstrutura&amp;amp; me){std::cout &amp;lt;&amp;lt; &amp;#34;x: &amp;#34; &amp;lt;&amp;lt; me.x &amp;lt;&amp;lt; &amp;#34;, y: &amp;#34; &amp;lt;&amp;lt; me.y &amp;lt;&amp;lt; &amp;#34;, c: &amp;#34; &amp;lt;&amp;lt; me.c;return os;}int main(){MinhaEstrutura me;std::cout &amp;lt;&amp;lt; me &amp;lt;&amp;lt; std::endl;}
Enfim, não há nenhum limite que se aplica a uma struct além do bom senso. A criação da palavra class não foi por falta do que fazer. Ela diz claramente que estamos definindo um objeto que contém usos mais adequados à orientação a objetos de C&#43;&#43; do que a programação estruturada de C, e vice-versa. É uma forma de tornar o código mais legível, mas nada do outro mundo. Sabemos, no final das contas, que o compilador trata as duas (quase) da mesma maneira.
Qual será a próxima batalha épica? Você escolhe!
https://www.youtube.com/watch?v=zn7-fVtT16k
</description>
</item>

     
        <item>
  <title>50 Anos de BASIC</title>
  <link>http://www.caloni.com.br/50-anos-de-basic/</link>
  <pubDate>2014-05-13</pubDate>
  
  <guid>http://www.caloni.com.br/50-anos-de-basic/</guid>
  <description>Minha primeira linguagem de programação foi o BASIC. Aprendi durante minhas frequentes visitas à biblioteca lendo livros dos anos 80. Na verdade, eu não me lembro muito bem por que diabos resolvi aprender a programar, já que eu estava mais interessado em entender como um computador funciona. Por que? Não sei bem ao certo, parece que já nasci com um chip embutido que foi ativado quando comecei a tender muito para o lado de humanas ao iniciar a faculdade de Letras... um chip salvador!
Enfim, um dos melhores livros que já li na minha vida não foi um cheio de letras, mas muito mais figuras: a Introdução Ilustrada à Computação, de Larry Gonick. Ele foi traduzido e publicado no Brasil pela Itautec e é um clássico absoluto sobre a história da computação, explicada de uma maneira que até um leigo completo conseguiria entender. E quando eu digo &amp;quot;computação&amp;quot; não estou me referindo a noções vagas sobre como o computador processa a entrada e gera saída. O ilustrador Larry Gonick fez um excelente trabalho em capturar a essência de cada inventor da história ¿ como Alan Turing, John Von Newmann, Charles Babbage e Ada Lovelace ¿ e cada conceito básico aplicado à invenção do computador, desde saldos condicionais (Lovelace), lógica booleana (George Boole), codificação binária e, pasmem... flip-flops!
Enfim, depois de explicar tudo isso e mais um pouco, no seu último capítulo ainda há uma pequena introdução ao BASIC que vinha instalado nas máquinas daquela época. Bem rústico, mas capaz de enviar comandos para a máquina e executá-los. Não aprendi todos os comandos nesse livro, mas ele foi minha porta de entrada para leituras mais &amp;quot;densas&amp;quot;, que me fizeram evoluir de uma calculadora capenga (meu primeiro programa!) para um emulador do jogo Genius, com direito a efeitos sonoros, cores configuráveis e gravação de recordes, tudo no próprio executável (na época um .COM, onde isso era possível). Esse foi meu primeiro programa com mais de 1000 linhas que eu me lembro (e com mais de 10 GOTOs e GOSUBs, também).
A modalidade mais popular do BASIC quando me interessei pelo assunto rodava no Windows 95 e se chamada QuickBASIC, ou QBasic, já em sua clássica versão 4.5. Passei longas horas com aquela tela de fundo azul na madrugada corrigindo erros, anotando detalhes no papel, refazendo a lógica mentalmente, até conseguir resolver o problema. Podia ser qualquer problema, pois ele viraria inevitavelmente a diversão da noite. Podia até ser um detalhe de implementação de uma função específica embutida: o F1 funcionava e era bem rápido.
O BASIC é uma linguagem fácil de aprender, não tem muitos limites e seria a minha escolha para ensinar programação para crianças caso ainda não tivessem inventado Python. Ela tem o tipo de sintaxe que você pode literalmente sair programando. Uma linha de código já imprime alguma coisa na tela. A lógica do fluxo de execução é simples, e os GOTOs ajudam a ilustrar como funciona. A depuração é sem frescuras, e os erros de tantos saltos sem nó, para variar, é do programador. Se vira, agora, com tanta SUB!
Os puristas irão dizer que o aprendiz precisa ser educado de acordo com as novas tendências de programação estruturada, orientada a objetos, ou 100% funcional. Porém, eles esquecem que a programação aprendida por autodidatas como eu não era algo que podia-se chamar trabalho. Ninguém imaginava naquela época, naquela idade, fazer algo tão divertido e ser pago para isso. Exatamente, divertido. Uma linguagem precisa ser divertida para que o programador se interesse em conversar através dela com a máquina. É óbvio que, quando amadurecer, enxergará as óbvias limitações de uma linguagem imperativa como BASIC e irá passar para algo mais elaborado, seja Pascal, Java, C, C&#43;&#43;. Não importa. A ambição técnica e perfeccionista do programador, enquanto não o engole, torna qualquer linguagem divertida. E no começo, onde erros de compilação e a falta de ponto-e-vírgula pode desanimar qualquer um, BASIC tinha esse espírito selvagem de &amp;quot;faço tudo o que quiser nessa linguagem até virar homem e programar em C&amp;quot; (ou Assembly).
Por tudo isso, e por muito mais, parabéns pelos seus 50 anos de vida, minha linguagem favorita para me fazer lembrar que programar pode ser divertido e despretensioso. BASIC, você é um amigão!
</description>
</item>

     
        <item>
  <title>2048 motivos para não programar</title>
  <link>http://www.caloni.com.br/2048-motivos-para-nao-programar/</link>
  <pubDate>2014-04-24</pubDate>
  
  <guid>http://www.caloni.com.br/2048-motivos-para-nao-programar/</guid>
  <description>Pronto, posso programar em paz. O jogo 2048 é uma lástima para todos os trabalhadores intelectuais que dependem de suas mentes para produzir algo que preste. Ele gerou mais posts no Hacker News do que a moda dos bitcoins (talvez não) e mais projetos no GitHub do que a busca para a cura do câncer (talvez não). Obviamente que este post vai gerar mais um gist Python para minha coleção.
Não sou fã de jogos, e dos poucos que participei logo parei (exceções honrosas: Portal e Portal 2, esses malditos). Posso dizer o mesmo de 2048, a versão de uma espécie de jogo já conhecido feita pelo italiano Gabriele Cirulli em um fds para descobrir se seria capaz de fazê-lo. Ele o fez e de brinde também fez o índice de produtividade mundial desabar.
Houve pelo menos dois projetos de I.A. para resolver o problema, que consiste em dobrar números múltiplos de 2 em um quadrado 4 x 4 até que se consiga o quadrado com o valor 2048 (e além). O artigo de Nicola Pezzotti, An Artificial Intelligence for the 2048 game, explica o mais efetivo deles, de autoria de Robert Xiao (eu acho). O programa desenvolvido por Xiao otimiza o tabuleiro do jogo guardando-o em um inteiro de 64 bits, deixando 4 bits para cada casa, mais que o suficiente para que seja armazenada a potência de 2 localizada no quadrado (o limite fica sendo de 2 16, ou 65536). Ao rodar a versão executável console ele imprime cada posição do tabuleiro em um formato &amp;quot;fácil&amp;quot; de ser lido.
Move #69, current score=5841356005100120000 Como pode-se perceber, cada número diferente de zero contém a potência de dois que ocupa a casa (1 é igual a 2, 5 é igual a 2 elevado a 5, que é igual a 32, e assim por diante). Para alinhar corretamente o tabuleiro os números estão impressos em hexadecimal, ou seja, os valores válidos vão de 0 a f (15).
A estratégia do programa de IA é ordenar as casas em um lado e, assim que acumular valores o suficiente, consolidar tudo na última casa. Nem sempre isso é possível, pois uma virada de jogo pode deixar a casa com o maior valor no meio de um dos lados. Nesse caso, é interessante ver como a I.A. se sai, já que com apenas uma execução ela foi até 8192 e mais um 4096. Dá-lhe, computador!
</description>
</item>

     
        <item>
  <title>Lambda: o Retorno!</title>
  <link>http://www.caloni.com.br/lambda-o-retorno/</link>
  <pubDate>2014-04-08</pubDate>
  
  <guid>http://www.caloni.com.br/lambda-o-retorno/</guid>
  <description>
Na última vez que foi abordado o tema &amp;quot;lambda na ferida&amp;quot; falamos brevemente sobre como C&#43;&#43; agora permite criar funções dentro de funções. Hoje vamos apenas falar que aquela construção bizarra que criamos fica ainda mais bizarra se precisarmos retornar alguma coisa dessa função ou usá-la mais de uma vez.
O padrão do lambda é supor que sua função embutida e enlatada não precisa retornar nada, o que torna a sintaxe mais simples: é um void AlgumaCoisa(argumentos). No entanto, para algoritmos como o find_if isso não funciona, então é necessário retornar algo. E, no caso de find_if, chamá-lo mais de uma vez pode ser feito facilmente criando uma variável lambda:
#include &amp;#34;Common.h&amp;#34;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string&amp;gt;int main(){std::vector&amp;lt;Employee&amp;gt; employees; // um bando de empregados	std::string currentDate = GetCurrentDate();// definindo uma função, como quem não quer nada, dentro de uma função	auto FindByBithDate = [&amp;amp;](Employee&amp;amp; employee)-&amp;gt;bool // &amp;lt;-- tipo de retorno	{return employee.birthDate == currentDate;};GetEmployees(employees);auto findIt = std::find_if(employees.begin(), employees.end(), FindByBithDate);while( findIt != employees.end() ){SendMail(*findIt);findIt = std::find_if(findIt &#43; 1, employees.end(), FindByBithDate);}}O tipo de retorno que colocamos através de uma flechinha é obrigatória? De fato, não. Se eu omiti-la vai funcionar do mesmo jeito porque o único ponto de saída da minha função retorna um bool.
Esses compiladores estão ficando cada vez mais espertos.
</description>
</item>

     
        <item>
  <title>Real Programmers Don&#39;t Use Java</title>
  <link>http://www.caloni.com.br/real-programmers-dont-use-java/</link>
  <pubDate>2014-02-20</pubDate>
  
  <guid>http://www.caloni.com.br/real-programmers-dont-use-java/</guid>
  <description>When I was a newbie (and a wanna-be) I enjoyed reading &amp;quot;Real Programmers Don&#39;t Use Pascal&amp;quot;, a satiric text that influenced and encouraged me into the path of &amp;quot;C/C&#43;&#43; enlightenment&amp;quot;, most even than K&amp;amp;R&#39;s book. Since then I thought that being a &amp;quot;Real Programmer&amp;quot; was something close to everything one needs to know to get (hard) things done (quickly). Being a &amp;quot;Quiche Eater&amp;quot; was, in couterpart, comparable to nothing. Real Programmers solve real problems! Quiche Eaters are losers who study the academic concepts of computer science and never do a damn useful and/or working program (maybe you know some guy like this).
Jokes apart, the spirit of the text can also be used by those who already find them very good programmers and believe no longer have to grow professionally. The times my ego inflates I still remember that my code use child APIs and an operating system that is a joke. I also remember that there are some people out there designing a starship that will leave the orbit of the Solar System!
On the other hand, many people that just got out of CS course still find programming a difficult matter. This text reminds us that life was difficult 20, 40, 70 years ago, when engineers and programmers were the same person and when you didn&#39;t know that what you were doing could put millions at risk in a project.
Hence, the Real Programmer live in the past. And he always will be worthier than young folks, because he knows how to solve that blue screen problem that nobody else does. As I always say, paraphrasing an illustrious figure in Brazilian television, who is afraid to open Visual Studio and is eternally designing the software instead does not go very far: &amp;quot;who knows to do, do it right way!&amp;quot; .
Here follows a brief summary of the original text adapted to the current times and with my prejucided view of thinking about it. If you wish to use your politically correct piece of mind and criticize me, be my guest!
Languages. Remember: the need to invent more languages/resources to do your job is to remind yourself about your own incompetence to invent such excuse. You are one of those who says &amp;quot;every problem has a specific tool&amp;quot; or something like that. In other words: an inefficient programmer. Don&#39;t you see that everything you need is C. If C won&#39;t do, then assembly will. If none of them, then is isn&#39;t worth doing.
Structured Programming. It is the first and last paradigm to be applied. After all, Object Orientation is another excuse to not program. They are more abstractions that, once you are a dead weight, you are unable to solve a problem using just functions and variables. No, you need classes, inheritance, templates and whatever the hell that will transform your simple and straight code into a magical horn of plenty that will only impress others at the futility and complexity of the solution.
Data structure. Another great concept to fool yourself. Today are many who enslave us to weird SQL layouts and weird frameworks that do all the work. We all know that the only really useful to know the structure is the array. The rest are variants of the same theme: queues and stacks.
Operating system. Mac and Windows are just toys and Linux is a video game that takes more work to set up than playing. The programmer actually uses something like mainframes or other beta operating system, which are too weird and can make a real mess in the hands of those who have not read the WHOLE manual. And knowing all known major kernel bugs and its location by heart at the time of booting is vital.
Tools. If you depend on an IDE that have Code Completion and other fancy stuff or any other editor that depends on your favorite 17,459 plugins installed, then you are not a Real Programmer. A Real Programmer actually use what he have on hand at the time, like notepad, hexdump or even some beeps . The tool is no limit to one that can really code.
Debugging. Are you saying that you need the source code in order to debug? So you do not have a clue of what the program does. Just a few glances at call stack and the registers can make a Real Programmer solve a bug that Quiche Eaters would not get after analyzing those charts with boxes inside UML and use cases for months.
The Real Programmers Work is certainly not doing trivial databases to trivial programs that access SQL with trivial queries. Neither are those horrible websites with PHP/Apache and scripts and more scripts written by kids. No, sir. These are programs that deal with the OS in a more intimate way (HD encryption, file system drivers, critical communication services, etc.), or are programs that do something really useful (compilers, the operating system itself). Or maybe those programs that deal directly with hardware (complex microcontrollers, robots, ships, medical devices, etc.).
The Fun of every Real Programmer is actually chat with friends (about programming), read something (about programming) and watch intelligent movies (about programming or people who have some kind of intellectual challenge to solve &amp;quot;the hard way&amp;quot;). Is there anything more fun than that?
And, finally, in their Natural Habitat, we can find pages and pages of assembly code scattered around the table, a computer locked by a remote kernel debugging serial cable, some notes in hex on a piece of paper, a few dozen browser pages openned about the behavior of functions in BIOS SATA HDDs with 500 GB working on RAID4, coffee (of course), chips, stains on the carpet. When there&#39;s nothing to do the environment is pretty tidy and one cannot notice the presence of Real Programmers in sight.
And the Future of Real Programmer? Well, C may even be dying. But so what? It seems C&#43;&#43; supports pointers as well. The rest of the useless abstractions like classes and inheritance may be totally ignored. The basics will always exist. Forget versions with multiple inheritance and enigmatic concepts. Be a (wo)man!
The real, happy, final truth is: regardless of how much more the world becomes &amp;quot;managed&amp;quot; behind frameworks and programmers who prefer to &amp;quot;do projects&amp;quot; behind their office packages and use cases, when problems pop up, some bug murky life threatening useful for a project, a Real Programmer will be there to save the day, because only a programmer really knows how to do his job well done and have a good night of sleep knowing that everything will just be OK.
If it doesn&#39;t, there will be always a Real Programmer to save the day.
&amp;quot;As long as there are ill-defined goals, bizarre bugs, and unrealistic schedules, there will be Real Programmers willing to jump in and Solve The Problem, saving the documentation for later. Long live FORTRAN!&amp;quot;
</description>
</item>

     
        <item>
  <title>Uma nova linguagem</title>
  <link>http://www.caloni.com.br/uma-nova-linguagem/</link>
  <pubDate>2013-12-04</pubDate>
  
  <guid>http://www.caloni.com.br/uma-nova-linguagem/</guid>
  <description>Tenho que me atualizar. Faz um tempo (anos) em que deixei de lado esse mundo &amp;quot;frescurento&amp;quot; de C&#43;&#43;2030 e me foquei única e exclusivamente em resolver problemas da melhor forma possível com o que a linguagem já tinha a oferecer em uma implementação estável de compilador e bibliotecas.
Agora o mundo está mudando. Para quem é do Universo Windows/Microsoft, a empresa do Uncle Bill vem liberando algumas versões interessantes do seu compilador (VS2012, 2013 e agora o CTP), cada vez mais próxima de um C&#43;&#43;11/14 100% compliance. Não acredito que cheguem lá, mas o fato de estarem empenhados indica para a indústria e seus clientes que há uma demanda sendo atendida. Não é mais frescurite de acadêmicos. Algumas features ultra-novas começam a ser usadas e permitidas em projetos.
Estamos falando de uma nova linguagem que se forma com um novo ritmo. O padrão C&#43;&#43;11 demorou &amp;quot;apenas&amp;quot; 2 anos para cair em nossas linhas de comando, há um patch já confirmado para o ano que vem e já existem menções para um novo release em 2017. Para o programador C&#43;&#43; que se acostumou a contar as evoluções em décadas, um novo ritmo se impõe. Não há tempo para cristalização de conceitos. O boost já nos forneceu isso por todos esses anos e hoje ele é reconhecidamente a versão alpha que precisávamos.
Veremos o que o futuro cada vez mais presente nos reserva.
</description>
</item>

     
        <item>
  <title>Ponto Flutuante Afundando</title>
  <link>http://www.caloni.com.br/ponto-flutuante-afundando/</link>
  <pubDate>2013-11-07</pubDate>
  
  <guid>http://www.caloni.com.br/ponto-flutuante-afundando/</guid>
  <description>Quando armazenamos valores monetários em doubles seus cálculos conseguem manter a precisão e na maioria das vezes o ajuste de precisão funciona. Porém, encontrei alguns casos onde a subtração de dois valores fazia &amp;quot;perder&amp;quot; um centavo (ou comparações exatas) justamente pela limitação da precisão do ponto flutuante. Nesse exemplo os valores são 2.358,93 - 1.386,93, que em uma conta de padaria (mas correta) dá 972,00 (até a Calc do Windows e o Excel funcionam), mas pelo Visual Studio 2010 chega perto, mas erra o alvo:
#include &amp;lt;iostream&amp;gt;int main(){double d1 = 2358.93;double d2 = 1386.93;double d3 = d1 - d2;std::cout &amp;lt;&amp;lt; &amp;#34;d1: &amp;#34; &amp;lt;&amp;lt; d1 &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;std::cout &amp;lt;&amp;lt; &amp;#34;d2: &amp;#34; &amp;lt;&amp;lt; d2 &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;std::cout &amp;lt;&amp;lt; &amp;#34;d1 - d2 = 3d: &amp;#34; &amp;lt;&amp;lt; d3 &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;// comparando armazenamentos que diferem	std::cout &amp;lt;&amp;lt; &amp;#34;d3 == 972.0: &amp;#34; &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; ( d3 == 972.0 ) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;// comparando armazenamentos similares	std::cout &amp;lt;&amp;lt; &amp;#34;d1 == 2358.93: &amp;#34; &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; ( d1 == 2358.93 ) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;std::cout &amp;lt;&amp;lt; &amp;#34;d2 == 1386.93: &amp;#34; &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; ( d2 == 1386.93 ) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;}Isso ocorre porque sua representação dentro da variável double é diferente de 272.0 do outro double. Depurando vemos mais claramente:

Ou seja, quando fazemos a subtração de d2 em d1, nossa precisão raspa um pouquinho e escapa pela beirada:
d1 2358.9299999999998d2 1386.9300000000001======================d3 971.999999999999777||||||Esse é o valor &amp;quot;desejado&amp;quot;. Na comparação com o valor redondo aparece a falha, mas note que isso não ocorre com os outros valores d1 e d2, já que o armazenamento adquire o mesmo formato:

Corrigindo o incorrigível Há uma forma de arredondamento já disponível no C99 (mas não no Visual Studio 2010) que pode ser útil para esses casos. A única coisa que é preciso fazer é arredondar os valores antes do cálculo:
#include &amp;lt;iostream&amp;gt;double round(double r){return (r &amp;gt; 0.0) ? floor(r &#43; 0.5) : ceil(r - 0.5);}int main(){double d1 = 2358.93;double d2 = 1386.93;double d3 = round(d1) - round(d2);std::cout &amp;lt;&amp;lt; &amp;#34;d1: &amp;#34; &amp;lt;&amp;lt; d1 &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;std::cout &amp;lt;&amp;lt; &amp;#34;d2: &amp;#34; &amp;lt;&amp;lt; d2 &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;std::cout &amp;lt;&amp;lt; &amp;#34;d1 - d2 = 3d: &amp;#34; &amp;lt;&amp;lt; d3 &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;std::cout &amp;lt;&amp;lt; &amp;#34;d3 == 972.0: &amp;#34; &amp;lt;&amp;lt; std::boolalpha &amp;lt;&amp;lt; ( d3 == 972.0 ) &amp;lt;&amp;lt; &amp;#34;\n&amp;#34;;}É uma decisão arbitrária essa de arredondar para cima, mas se for adotada em todo o sistema (e já fazendo parte de um padrão, no caso, o C99), não deverão existir problemas de interpretação de cálculos entre os componentes.
O mercado financeiro agradece =).
UPDATE
Não estou de acordo com o armazenamento de valores monetários em doubles em vez de inteiros pelo simples motivo que não há moedas no sistema financeiro com unidades que se dividem ad infinitum. Por consequência, existe sempre uma unidade básica e indivisível (que no caso do Brasil é o centavo de real). Ou seja, como o objetivo é contar o total dessas unidades que não se dividem, o uso de inteiros é brainless.
UPDATE 2
Existe uma discussão exatamente sobre isso no Grupo C/C&#43;&#43; Brasil, que recomendo a leitura, o que me levou a escrever o post. Particularmente, sigo o raciocínio do Pedro Lamarão.
</description>
</item>

     
        <item>
  <title>eXtreme Go Horse</title>
  <link>http://www.caloni.com.br/extreme-go-horse/</link>
  <pubDate>2012-09-27</pubDate>
  
  <guid>http://www.caloni.com.br/extreme-go-horse/</guid>
  <description>O Go Horse Power (GHP) foi criado por um blogue hoje extinto. As premissas dessa nova metodologia de desenvolvimento era que o projeto fosse feito da maneira mais rápida possível.
Contudo, eles não contavam com a versão turbinada do desleixo humano.
A eXtreme Go Horse (XGP) é o suprassumo das metodologias do mercado brasileiro de desenvolvimento. Quem nunca trabalhou em uma empresa gerida por essas regras? (Bom, pelo menos XGH pelo jeito tem até controle de fonte, algo que era até meio raro uns anos atrás):
1- Pensou, não é XGH
XGH não pensa, faz a primeira coisa que vem à mente. Não existe segunda opção, a única opção é a mais rápida
2- Existem três formas de se resolver um problema
Estas são: a correta, a errada e a XGH, que é igual à errada, só que mais rápida. XGH é mais rápido que qualquer metodologia de desenvolvimento de software que você conhece (Vide Axioma 14).
3- Quanto mais XGH você faz, mais precisará fazer
Para cada problema resolvido usando XGH, mais uns 7 são criados. Mas todos eles serão resolvidos da forma XGH. XGH tende ao infinito.
4- XGH é totalmente reativo
Os erros só existem quando aparecem.
5- XGH vale tudo, só não vale dar o toba
Resolveu o problema? Compilou? Commit e era isso.
6- Commit sempre antes de update
Se der merda, a sua parte estará sempre correta.. E seus colegas que se fodam.
7- XGH não tem prazo
Os prazos passados pelo seu cliente são meros detalhes. Você SEMPRE conseguirá implementar TUDO no tempo necessário (nem que isso implique em acessar o BD por um script malaco)
8- Esteja preparado para pular fora quando o barco começar a afundar¿
Ou coloque a culpa em alguém ou algo. Pra quem usa XGH, um dia o barco afunda. Quanto mais o tempo passa, mais o sistema vira um monstro. O dia que a casa cair, é melhor seu curriculum estar cadastrado na APInfo, ou ter algo pra colocar a culpa
9- Seja autêntico, XGH não respeita padrões
Escreva o código como você bem entender, se resolver o problema, commit e era isso
10- Não existe refactoring, apenas rework
Se der merda, refaça um XGH rápido que solucione o problema. O dia que o rework implicar em reescrever a aplicação toda, pule fora, o barco irá afundar (Vide Axioma 8)
11- XGH é totalmente anárquico
A figura de um gerente de projeto é totalmente descartável. Não tem dono, cada um faz o que quiser na hora que os problemas e requisitos vão surgindo (Vide Axioma 4)
12- Se iluda sempre com promessas de melhorias
Colocar TUDO no código como uma promessa de melhoria ajuda o desenvolvedor XGH a não sentir remorso ou culpa pela cagada que fez. É claro que o refactoring nunca será feito (Vide Axioma 10)
13- XGH é absoluto, não se prende à coisas relativas
Prazo e custo são absolutos, qualidade é totalmente relativa. Jamais pense na qualidade e sim no menor tempo que a solução será implementada, aliás¿ não pense, faça!
14- XGH é atemporal
Scrum, XP¿Tudo isso é modinha. O XGH não se prende às modinhas do momento, isso é coisa de viado. XGH sempre foi e sempre será usado por aqueles que desprezam a qualidade
15- XGH nem sempre é POG
Muitas POG¿s exigem um raciocínio muito elevado, XGH não raciocina (Vide Axioma 1).
16- Não tente remar contra a maré
Caso seus colegas de trabalho usam XGH para programar e você é um coxinha que gosta de fazer as coisas certinhas, esqueça! Pra cada Design Pattern que você usa corretamente, seus colegas gerarão dez vezes mais código podre usando XGH.
17- O XGH não é perigoso até surgir um pouco de ordem
Este axioma é muito complexo, mas sugere que o projeto utilizando XGH está em meio ao caos. Não tente por ordem no XGH (Vide Axioma 16), é inútil e você pode jogar um tempo precioso no lixo. Isto fará com que o projeto afunde mais rápido ainda (Vide Axioma 8). Não tente gerenciar o XGH, ele é auto suficiente (Vide Axioma 11), assim como o caos.
18- O XGH é seu brother, mas é vingativo
Enquanto você quiser, o XGH sempre estará do seu lado. Mas cuidado, não o abandone. Se começar um sistema utilizando XGH e abandoná-lo para utilizar uma metodologia da moda, você estará fudido. O XGH não permite refactoring (vide axioma 10), e seu novo sistema cheio de frescurites entrará em colapso. E nessa hora, somente o XGH poderá salvá-lo.
19- Se tiver funcionando, não rela a mão
Nunca altere, e muito menos questione um código funcionando. Isso é perda de tempo, mesmo porque refactoring não existe (Vide Axioma 10). Tempo é a engrenagem que move o XGH e qualidade é um detalhe desprezível.
20- Teste é para os fracos
Se você meteu a mão num sistema XGH, é melhor saber o que está fazendo. E se você sabe o que está fazendo, vai testar pra que? Testes são desperdício de tempo, se o código compilar, é o suficiente.
21- Acostume-se ao sentimento de fracasso iminente
O fracasso e o sucesso andam sempre de mãos dadas, e no XGH não é diferente. As pessoas costumam achar que as chances do projeto fracassar utilizando XGH são sempre maiores do que ele ser bem sucedido. Mas sucesso e fracasso são uma questão de ponto de vista. O projeto foi por água abaixo mas você aprendeu algo? Então pra você foi um sucesso!
22- O problema só é seu quando seu nome está no Doc da classe
Nunca ponha a mão numa classe cujo autor não é você. Caso um membro da equipe morra ou fique doente por muito tempo, o barco irá afundar! Nesse caso, utilize o Axioma 8.
Este texto foi copiado daqui e daqui. Não existem donos conhecidos do XGH (já devem ter morrido de desgosto). Fiquei com medo de não encontrar mais essa metologia, que é pouco divulgada e muito útil.
</description>
</item>

     
        <item>
  <title>Minha palestra do TDC 2012</title>
  <link>http://www.caloni.com.br/minha-palestra-do-tdc-2012/</link>
  <pubDate>2012-07-21</pubDate>
  
  <guid>http://www.caloni.com.br/minha-palestra-do-tdc-2012/</guid>
  <description>Duas semanas atrás rolou a trilha C&#43;&#43; do TDC 2012, que contou com além da minha presença com a dos já conhecidos Fernando Roberto (DriverEntry), Rodrigo Strauss (1Bit), etc. Uma novidade: meu colega e programador .nerd Gabriel Guilherme também participou em uma palestra sobre um assunto que acredito que deveria ser mais promovido: interop. Afinal de contas, o poder de C&#43;&#43; não seria nada se não houvesse motivos práticos para usá-lo. Entre esses motivos, construir soluções com linguagens mais acessíveis é um deles.
Na minha palestra foquei no conteúdo dos meus dois artigos sobre um fictício Patch de Emergência (parte 1 e parte 2 from Wanderley Caloni
</description>
</item>

     
        <item>
  <title>Meus repositórios no GitHub</title>
  <link>http://www.caloni.com.br/meus-repositorios-no-github/</link>
  <pubDate>2012-06-04</pubDate>
  
  <guid>http://www.caloni.com.br/meus-repositorios-no-github/</guid>
  <description>Depois de vacilar por alguns meses, incentivado pelo meu amigo Chico Pimenta, resolvi experimentar o tal do GitHub, e consequentemente o sistema de controle de fontes distribuído Git, que antes era meio exclusivo do Linux (continua meio sendo, mas com suporte um pouco melhor para Windows).
Com isso, dei uma pequena lida no livro de introdução e comecei a migrar meus fontes perdidos num canto do HD. O que notei de vantagem com relação a outros DRCSs foi que é muito fácil e rápido criar branches e que a comunicação remota e os commits são feitos de uma maneira mais organizada e estruturada, além da própria estrutura interna do repositório ser muito simples de entender: um bando de arquivos compactados cujo nome é o hash do que ele contém.
Meus repositórios estão armazenados em alguns branches que distribuí de acordo com o uso/importância:
 OpenSource. Projetos de fonte aberto que mantenho/ive e que poderiam se perder se alguém não fizesse backup (como o mouse tool ou regmon). Samples. Códigos de exemplo, de palestras e de testes feitos para escrever os artigos do blogue cujo autor vos fala. Caloni. Os códigos que fazem algo de útil, como o Houaiss2Babyulon, CopiaExata e DayToDay. Book. Um projeto em estado de larva sobre escrever um livro de engenharia reversa. Já possui um índice básico. Sugestões são bem-vindas. DriverEntry. Códigos do curso de desenvolvimento de drivers que estou fazendo com o Fernando, da DriverEntry Company. Recomendo!  </description>
</item>

     
        <item>
  <title>Sobrecarga de função às avessas</title>
  <link>http://www.caloni.com.br/sobrecarga-de-funcao-as-avessas/</link>
  <pubDate>2012-05-20</pubDate>
  
  <guid>http://www.caloni.com.br/sobrecarga-de-funcao-as-avessas/</guid>
  <description> Nota do autor: navegando pelo Archive.org, que possibilita viajar no tempo e encontrar coisas enterradas que seria melhor deixar por lá, consegui encontrar um post que se perdeu na dobra espaço-temporal entre o old-fashioned Caloni.com.br (com direito à velha joaninha psicodélica, desenho do meu amigo que uso até hoje no blogue) e um finado outro domínio meu, o CThings. No final, consegui matar a marmota, chegar a 80 milhas por hora e voltar para o presente. Enjoy!
 Alguém já se perguntou se é possível usar sobrecarga de função quando a diferença não está nos parâmetros recebidos, mas no tipo de retorno? Melhor dizendo, imagine que eu tenha o seguinte código:
void CreateNewGUID(wstring&amp;amp;);void CreateNewGUID(GUID&amp;amp;);GUID guid;wstring guidS;CreateNewGUID(guidS);CreateNewGUID(guid); É um uso sensato de sobrecarga. Mas vamos supor que eu queira uma sintaxe mais intuitiva, com o retorno sendo atribuído à variável:
wstring CreateNewGUID();GUID CreateNewGUID();GUID guid;wstring guidS;guid = CreateNewGUID();guidS = CreateNewGUID(); Voltando às teorias de C&#43;&#43; veremos que o código acima NÃO funciona. Ou, pelo menos, não deveria. Só pelo fato das duas funções serem definidas o compilador já reclama com um &amp;quot;error C2556: &#39;GUID CreateNewGUID(void)&#39;: overloaded function differs only by return type from &#39;std::wstring CreateNewGUID(void)&#39;&amp;quot;. E obviamente ele está correto. O tipo de retorno não é uma propriedade da função que exclua a ambiguidade em sua chamada. Apenas a assinatura pode fazer isso (que são os tipos dos parâmetros recebidos pela função).
Como não podemos utilizar funções ordinárias o jeito é criar nosso próprio tipo de função que dê conta do recado usando a sobrecarga do operador de conversão de tipos. O operador de conversão suporta sobrecarga porque é na conversão que o compilador decide qual função chamar.
struct CreateNewGUID{operator wstring ();operator GUID ();}; guid = CreateNewGUID();guidS = CreateNewGUID(); Agora com o novo tipo CreateNewGUID é possível chamá-lo como uma função, o que na prática cria uma nova instância da struct. Ao atribuir o retorno dessa instância a uma variável do tipo wstring ou GUID os operadores de conversão serão requisitados, cada um dependendo do tipo da variável a qual será atribuído o retorno.
Uma vez que criamos um novo tipo, e considerando que este tipo é, portanto, diferente dos tipos wstring e GUID já existentes, devemos simplesmente converter nosso novo tipo para cada um dos tipos de retorno desejados:
struct CreateNewGUID{operator wstring (){wstring ret;// cria guidreturn ret;}operator GUID (){GUID ret;// cria guidreturn ret;}}; E isso conclui a solução meio esquizofrênica de nossa sobrecarga às avessas. E voltando à pergunta original, penso que, com criatividade e C&#43;&#43;, nada é impossível. =)
</description>
</item>

     
        <item>
  <title>Consumo abusivo de memória</title>
  <link>http://www.caloni.com.br/consumo-abusivo-de-memoria/</link>
  <pubDate>2012-05-19</pubDate>
  
  <guid>http://www.caloni.com.br/consumo-abusivo-de-memoria/</guid>
  <description>Era um belo dia em um ambiente de processamento fictício de filas fictícias e threads fictícias. Eis um belo código com filas, threads e processamentos feitos em stop-motion:
#include &amp;lt;windows.h&amp;gt; // critical section, create thread...#include &amp;lt;list&amp;gt; // nossa lista interna#include &amp;lt;time.h&amp;gt; // randomizaçãostruct Queue // uma fila (duh){size_t bufferSize; // cada item é um buffer de tamanho fixo DWORD wait; // antes de processar, aguardemos esse tempo fixo CRITICAL_SECTION cs; // stl é thread-safe, pero no mucho std::list&amp;lt;char*&amp;gt; items; // os itens!};DWORD WINAPI InsertItems(LPVOID pvQueue) // insere, insere, insere....{Queue&amp;amp; queue = *(Queue*) pvQueue;for( int i = 0; i &amp;lt; 10 * 1000; &#43;&#43;i ) // 10k itens! {char* buffer = new char[queue.bufferSize];memset(buffer, (int) (i % (&amp;#39;Z&amp;#39; - &amp;#39;A&amp;#39;)) &#43; &amp;#39;A&amp;#39;, queue.bufferSize); // teoricamente de A a Z buffer[queue.bufferSize - 1] = 0; // string C pra facilitar nossa depuração EnterCriticalSection(&amp;amp;queue.cs); // deixa eu entrar! queue.items.push_back(buffer);LeaveCriticalSection(&amp;amp;queue.cs); // deixa eu sair! Sleep(10); // dá uma dormidinha (sempre menor dormidinhas do processamento) }return ERROR_SUCCESS; // &amp;#34;tá tudo certo!&amp;#34; (by Starcraft 2)}DWORD WINAPI ProcessItems(LPVOID pvQueue) // processa, processa, processa...{Queue&amp;amp; queue = *(Queue*) pvQueue;DWORD wait = 2;Sleep(10000); // como um advogado oportunista, aguardamos por alguém pra processar while( ! queue.items.empty() ) // agora vai até esvaziar o recinto {EnterCriticalSection(&amp;amp;queue.cs); // deixa eu entrar! char* buffer = queue.items.front();queue.items.pop_front();LeaveCriticalSection(&amp;amp;queue.cs); // deixa eu sair! delete [] buffer;Sleep(queue.wait); // aguarda por... por quanto mesmo? }return ERROR_SUCCESS; // &amp;#34;tá tudo certo!&amp;#34; (by Starcraft 2)}int main(int argc, char* argv[]) // No princípio havia a pilha, quando Deus disse: &amp;#39;int main!&amp;#39;{static const size_t QUEUES_SIZE = 20; // número de filas sendo processadas static const size_t QUEUE_ITEM_SIZE = 0x1000; // 1KB é o chunk alocado por item static const DWORD WAIT_TIMES[] = { 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1000 }; // alguém vai esperar demaisQueue queues[QUEUES_SIZE]; // as filas HANDLE queueThreads[QUEUES_SIZE * 2]; // as threads que processam as filassrand((unsigned int)time(0)); // randomizemos tudofor( size_t i = 0; i &amp;lt; QUEUES_SIZE; &#43;&#43;i ){queues[i].bufferSize = QUEUE_ITEM_SIZE &#43; i; // para diferenciarmos as filas queues[i].wait = WAIT_TIMES[ rand() % (sizeof(WAIT_TIMES) / sizeof(DWORD)) ]; // vamos esperar por... por quanto mesmo? InitializeCriticalSection(&amp;amp;queues[i].cs); // deu crash em algumas situações em release (stl deveria ser thread-safe...) queueThreads[i] = CreateThread(NULL, 0, InsertItems, &amp;amp;queues[i], 0, NULL); // criamos thread de inserção queueThreads[QUEUES_SIZE &#43; i] = CreateThread(NULL, 0, ProcessItems, &amp;amp;queues[i], 0, NULL); // criamos thread de processamento }WaitForMultipleObjects(QUEUES_SIZE * 2, queueThreads, TRUE, INFINITE); // espera a &amp;#39;gaguera&amp;#39; return 0; // &amp;#34;tá tudo certo!&amp;#34; (by Starcraft 2)}Se olharmos de perto o processamento e a memória consumida por esse processo, veremos que no início existe um boom de ambos, mas após um momento de pico, o processamento praticamente pára, mas a memória se mantém:

Depois de pesquisar por meus tweets favoritos, fica fácil ter a receita para verificarmos isso usando nosso depurador favorito: Visual StudioWinDbg!

windbg -pn MemoryConsumption.exe

Achamos onde está a memória consumida. Agora precisamos de dicas do que pode estar consumindo essa memória. Vamos começar por listar os chunks alocados por tamanho de alocação:
0:004&amp;gt; !heap -stat -h 0Allocations statistics forheap @ 00670000group-by: TOTSIZE max-display: 20size #blocks total ( %) (percent of total busy bytes)1037 25e5 - 2667433 (33.04)1025 25e6 - 263da3e (32.90)1024 25e4 - 2639410 (32.89)... O Top 3 é de tamanhos conhecidos pelo código, de 1024 a 1024 &#43; QUEUES_SIZE - 1. O de tamanho 1037, por exemplo, possui 0x25e5 blocos alocados. Vamos listar cada um deles:
0:004&amp;gt; !heap -flt s 1037_HEAP @ 420000_HEAP @ 670000HEAP_ENTRY Size Prev Flags UserPtr UserSize - state&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt; 00558600 0221 0000 [00] 00558618 01037 - (busy)&amp;lt;/span&amp;gt; &amp;lt;--- vamos usar esse primeiro mais tarde0055fd38 0221 0221 [00] 0055fd50 01037 - (busy)00561f48 0221 0221 [00] 00561f60 01037 - (busy)00565260 0221 0221 [00] 00565278 01037 - (busy)0056c998 0221 0221 [00] 0056c9b0 01037 - (busy)0056daa0 0221 0221 [00] 0056dab8 01037 - (busy)0056eba8 0221 0221 [00] 0056ebc0 01037 - (busy)00570db8 0221 0221 [00] 00570dd0 01037 - (busy)00572fc8 0221 0221 [00] 00572fe0 01037 - (busy)005740d0 0221 0221 [00] 005740e8 01037 - (busy)0058abc8 0221 0221 [00] 0058abe0 01037 - (busy)00595618 0221 0221 [00] 00595630 01037 - (busy)00599a38 0221 0221 [00] 00599a50 01037 - (busy)0059de58 0(...) A listagem do depurador nos dá o endereço onde o chunk foi alocado no heap e o endereço devolvido para o usuário, onde colocamos nossas tralhas. Através de ambos é possível trackear a pilha da chamada que alocou cada pedaço de memória. Isso, claro, se previamente tivermos habilitado essa informação através do GFlags:

0:004&amp;gt; !heap -p -a &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;00558600&amp;lt;/span&amp;gt;address 00558600 found in_HEAP @ 670000HEAP_ENTRY Size Prev Flags UserPtr UserSize - state&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;00558600 0221 0000 [00] 00558618 01037 - (busy)&amp;lt;/span&amp;gt;Trace: b7a247722dfa2 ntdll!RtlAllocateHeap&#43;0x000002745b628343 MSVCR100D!_heap_alloc_base&#43;0x000000535b63697c MSVCR100D!_nh_malloc_dbg&#43;0x000002dc5b63671f MSVCR100D!_nh_malloc_dbg&#43;0x0000007f5b6366cc MSVCR100D!_nh_malloc_dbg&#43;0x0000002c5b639c5b MSVCR100D!malloc&#43;0x0000001b5b627db1 MSVCR100D!operator new&#43;0x00000011e84dee MemoryConsumption!operator new[]&#43;0x0000000e&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt; e818be MemoryConsumption!InsertItems&#43;0x0000004e&amp;lt;/span&amp;gt;7679339a kernel32!BaseThreadInitThunk&#43;0x0000000e771e9ef2 ntdll!__RtlUserThreadStart&#43;0x00000070771e9ec5 ntdll!_RtlUserThreadStart&#43;0x0000001b Dessa forma temos onde cada memória foi alocada, o que nos dará uma informação valiosa, dependendo qual o tipo de problema estamos tentando resolver.
0:004&amp;gt; u &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;e818be&amp;lt;/span&amp;gt;MemoryConsumption!InsertItems&#43;0x4e [c:\...\memoryconsumption.cpp @ 18]:00e818be 83c404 add esp,400e818c1 898514ffffff mov dword ptr [ebp-0ECh],eax00e818c7 8b9514ffffff mov edx,dword ptr [ebp-0ECh]00e818cd 8955e0 mov dword ptr [ebp-20h],edx00e818d0 8b45f8 mov eax,dword ptr [ebp-8]00e818d3 8b08 mov ecx,dword ptr [eax]00e818d5 51 push ecx00e818d6 8b45ec mov eax,dword ptr [ebp-14h] Outra informação relevante é o que está gravado na memória, que pode nos dar insights de que tipo de objeto estamos lidando:
0:004&amp;gt; db &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;00558618&amp;lt;/span&amp;gt;00558618 c0 b7 8c 0b 98 03 55 00-00 00 00 00 00 00 00 00 ......U.........00558628 13 10 00 00 01 00 00 00-15 94 00 00 fd fd fd fd ................00558638 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ00558648 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ00558658 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ00558668 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ00558678 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ00558688 51 51 51 51 51 51 51 51-51 51 51 51 51 51 51 51 QQQQQQQQQQQQQQQQ Não é o caso, mas vamos supor que fosse um objeto/tipo conhecido. Poderíamos simplesmente &amp;quot;importar&amp;quot; o tipo diretamente do PDB que estamos para modelar a memória que encontramos em volta. Mais detalhes em outro artigo.
Funções/classes usadas nesse artigo   CreateThread. Cria uma nova linha de execução.
  WaitForMultipleObjects. Pode aguardar diferentes linhas de execução terminarem.
  std::list. Lista na STL para inserir/remover objetos na frente e atrás (ui).
  Initialize, Enter e LeaveCriticalSection. Uma maneira simples de criar blocos de entrada atômica (apenas uma thread entra por vez).
  memset. Se você não sabe usar memset, provavelmente não entendeu nada desse artigo.
  </description>
</item>

     
        <item>
  <title>Coletando dumps automaticamente</title>
  <link>http://www.caloni.com.br/coletando-dumps-automaticamente/</link>
  <pubDate>2012-05-17</pubDate>
  
  <guid>http://www.caloni.com.br/coletando-dumps-automaticamente/</guid>
  <description>   Value Description Type Default value     DumpFolder [1] REGEXPANDSZ %LOCALAPPDATA%\CrashDumps   DumpCount [2] REGDWORD 10   DumpType [3] REGDWORD 1   CustomDumpFlags [4] REGDWORD [5]    Chave: HKEYLOCALMACHINE\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps.
 [1] The path where the dump files are to be stored. If you do not use the default path, then make sure that the folder contains ACLs that allow the crashing process to write data to the folder.For service crashes, the dump is written to service specific profile folders depending on the service account used. For example, the profile folder for System services is %WINDIR%\System32\Config\SystemProfile. For Network and Local Services, the folder is %WINDIR%\ServiceProfiles. [2] The maximum number of dump files in the folder. When the maximum value is exceeded, the oldest dump file in the folder will be replaced with the new dump file. [3] Specify one of the following dump types: 0 = Custom dump, 1 = Mini dump, 2 = Full dump [4] The custom dump options to be used. This value is used only when DumpType is set to 0.The options are a bitwise combination of the MINIDUMP_TYPE enumeration values. [5] MiniDumpWithDataSegs or MiniDumpWithUnloadedModules or MiniDumpWithProcessThreadData.  Fonte: MSDN (Collecting User-Mode Dumps).
</description>
</item>

     
        <item>
  <title>Header Inútil</title>
  <link>http://www.caloni.com.br/header-inutil/</link>
  <pubDate>2012-03-27</pubDate>
  
  <guid>http://www.caloni.com.br/header-inutil/</guid>
  <description>O Visual Studio é uma ótima ferramenta para depurar rapidamente programas sendo desenvolvidos e para editar vários arquivos ao mesmo tempopara o resto usamos Vim. No entanto, a versão 2010 do ambiente (ainda não testei a 2011 beta) possui um pequeno deslize com sua árvore de dependências que não chega a prejudica o desenvolvedor, mas o deixa com um bug atrás da orelha.
Vamos supor que você crie seu super-projeto ZeroMQ e no meio dele acabe evoluindo uma nova forma de vida inútil e descartável, que aqui iremos chamar de HeaderInutil e seu fiel companheiro CppInutil:

OK. Ele não está fazendo nada, mas e daí? Compilo meu projeto normalmente e depuro ele como se nada estivesse acontecendo.
------ Rebuild All started: Project: ZeroMasQueCoisaProj, Configuration: Debug Win32 ------ Build started 27/03/2012 11:40:32. _PrepareForClean: Deleting file &amp;quot;Debug\ZeroMasQueCoisaProj.lastbuildstate&amp;quot;. InitializeBuildStatus: Creating &amp;quot;Debug\ZeroMasQueCoisaProj.unsuccessfulbuild&amp;quot; because &amp;quot;AlwaysCreate&amp;quot; was specified. ClCompile: stdafx.cpp ZeroMasQueCoisaProj.cpp CppInutil.cpp Generating Code... Manifest: Deleting file &amp;quot;Debug\ZeroMasQueCoisaProj.exe.embed.manifest&amp;quot;. LinkEmbedManifest: ZeroMasQueCoisaProj.vcxproj -&amp;gt; c:...\Debug\ZeroMasQueCoisaProj.exe FinalizeBuildStatus: Deleting file &amp;quot;Debug\ZeroMasQueCoisaProj.unsuccessfulbuild&amp;quot;. Touching &amp;quot;Debug\ZeroMasQueCoisaProj.lastbuildstate&amp;quot;.
Build succeeded.
Time Elapsed 00:00:00.73 ========== Rebuild All: 1 succeeded, 0 failed, 0 skipped ==========
&#39;ZeroMasQueCoisaProj.exe&#39;: Loaded &#39;C:...\Debug\ZeroMasQueCoisaProj.exe&#39;, Symbols loaded. &#39;ZeroMasQueCoisaProj.exe&#39;: Loaded &#39;C:\Windows\SysWOW64\ntdll.dll&#39;, Cannot find or open the PDB file &#39;ZeroMasQueCoisaProj.exe&#39;: Loaded &#39;C:\Windows\SysWOW64\kernel32.dll&#39;, Cannot find or open the PDB file &#39;ZeroMasQueCoisaProj.exe&#39;: Loaded &#39;C:\Windows\SysWOW64\KernelBase.dll&#39;, Cannot find or open the PDB file &#39;ZeroMasQueCoisaProj.exe&#39;: Loaded &#39;C:\Windows\SysWOW64\msvcr100d.dll&#39;, Symbols loaded. The program &#39;[5212] ZeroMasQueCoisaProj.exe: Native&#39; has exited with code 0 (0x0).
Show.
Mas o que acontece se eu precisar no momento do refactory (que deve, sim, existir) eu decidir remover meus arquivos inúteis?
Continuo compilando normalmente o projeto, mas na hora de depurar...

Mas o que ocorre? Eu acabei de compilar o projeto! E se eu compilar novamente e pressionar F5, ele continua apresentando o mesmo problema!
OK, não estou admitindo aqui o famigerado Rebuild All. Se você mantém projetos com mais de 200 arquivos, acho que deve repensar seus conceitos ao usar Rebuild All para tudo nessa vida.
Acontece que existe uma árvore de dependências que o Visual Studio mantém para saber se seu projeto foi atualizado com tudo que tem mais de novo no que diz respeito ao File System, mas às vezes se esquece de checar o FS com o que está na solution. Por conta disso, o HeaderInutil e o CppInutil continuam dentro da árvore de dependência como zumbis.
O que pode ser feito nesse caso (além do que os personagens de The Walking Dead costumam fazer) é configurar o arquivo devenv.exe.config (presente em %programfiles(x86)%\Microsoft Visual Studio 10.0\Common7\IDE) e adicionar as seguintes linhas após a seção **configSections. (**Esses passos estão descritos no blogue da equipe do VC.)
&amp;lt;system.diagnostics&amp;gt; &amp;lt;/system.diagnostics&amp;gt;

Depois de modificar o arquivo, reinicie o Visual Studio e tente novamente apertar F5 no mesmo projeto, mas com o DebugView aberto.

Como um amigo meu diria: &amp;quot;AHÁ!!&amp;quot;. Descobrimos o culpado.
A solução? Nesse caso não tem jeito: dar um clean no projeto e build novamente para que o VS reconstrua a árvore de dependências. Porém, agora sabemos por que precisamos do Rebuild All. Não é RebuildAllMania.
</description>
</item>

     
        <item>
  <title>RValue é o novo LValue</title>
  <link>http://www.caloni.com.br/rvalue-e-o-novo-lvalue/</link>
  <pubDate>2012-01-11</pubDate>
  
  <guid>http://www.caloni.com.br/rvalue-e-o-novo-lvalue/</guid>
  <description>As grandes discussões filosóficas que participei durante meu estudo da linguagem C, e mais tarde de C&#43;&#43;, muitas vezes convergiam para o significado místico daquela figura que nós da gramática da linguagem conhecemos como lvalue, ou l-value, ou left-value. Enfim, a definição de uma expressão que representa um lugar na memória e, portanto, pode ocupar o lado esquerdo de uma atribuição/cópia/passagem de argumentos qualquer. Porém, os &amp;quot;grandes&amp;quot; embates daquela época hoje parecem brincadeira de criança, como a diferença sutil entre &#43;&#43;x e x&#43;&#43; ou convergência de tipos em templates.
Agora o buraco é mais embaixo. Agora temos referências r-value.
Agora o mundo mudou.
Foi necessário que mudasse. C&#43;&#43;, conhecido internacionalmente como a vanguarda das linguagens, mesmo mantendo sua fama de alta performance, precisava voltar às suas origens performáticas de qualquer forma. O Criador da linguagem e seus seguidores estavam cientes: cópia de strings é uma coisa muito, muito má. Imperfect forwarding (direcionamento imperfeito?) é algo ainda pior, pois é mais sutil.
Todos concordam, então, que a mudança é necessária. Nem todos concordam, contudo, com o preço a ser pago. As coisas começam a ficar cada vez mais difíceis de entender, e agora, com r-values vindo à superfície, o universo de criaturas bizarras volta a mostrar as caras.
Desde o começo de meus estudos em C&#43;&#43; tenho admirado a linguagem com um certo distanciamento. Enquanto a linguagem C continua sendo o supra-sumo das linguagens de médio-nível, C&#43;&#43; continua sendo uma abominação cujos detalhes muitos preferem esquecer. Mas esquecer tem se tornado cada vez mais difícil frente às adaptações técnicas que a linguagem vem sofrendo.
No caso de Rvalues, se antes existia uma discussão interminável sobre sua inclusão no novo padrão, agora existem discussões acerca do que tudo isso significa. Existe até um ótimo guia (thanks to pepperchico) sobre as principais mudanças de conceitos, feito para simplificar o entendimento. Mas ele mesmo é exageradamente complexo para o programador médio. É de forçar a barra, mesmo. É pedir demais.
No próximo dia 28, sábado, nos reuniremos em mais um evento C&#43;&#43; organizado pelo Grupo C/C&#43;&#43; Brasil e pelos agora dois MVPs do Brasil, o veterano Fabio Galuppo e o novato Rodrigo Strauss (meu amigo, mas acima de tudo muito bem-vindo ao cargo). Estou na lista de palestrantes e conversarei com vocês sobre as otimizações que o famigerado RValue deve trazer à mesa. Espero conseguir entender um pouco mais sobre essa criatura fantástica até lá.
Se o Cebolinha for um programador C&#43;&#43;, deve estar se debatendo nesse momento.
 C&#43;&#43; Rvalue References Explained A Brief Introduction to Rvalue References Want Speed? Pass by Value MSDN Community: C&#43;&#43; Renaissance, São Paulo - SP.  Faça sua incrição!
</description>
</item>

     
        <item>
  <title>Depuração de emergência: receita de bolo</title>
  <link>http://www.caloni.com.br/depuracao-de-emergencia-receita-de-bolo/</link>
  <pubDate>2011-10-18</pubDate>
  
  <guid>http://www.caloni.com.br/depuracao-de-emergencia-receita-de-bolo/</guid>
  <description>Continuando o papo sobre o que fazer para analisar rapidamente um crash no servidor com o pacote WinDbg, na maioria das vezes a exceção lançada pelo processo está diretamente relacionada com um acesso indevido à memória, o que tem diversas vantagens sobre problemas mais complexos:
  Possui localização precisa de onde ocorreu a violação (inclusive com nome do arquivo-fonte e linha).
  Não corrompe a pilha (ou, se corrompe, não chega a afetá-la a ponto da thread ficar irreconhecível).
  A thread que contém a janela de crash é a culpada imediata (basta olha a pilha!).
  Bom, resumindo: basta olhar a pilha! Mas, para isso ser efetivo, precisaremos do PDB do executável que gerou o crash, pois através dele é possível puxar a tal localização da violação de acesso.
[caption id=&amp;quot;attachment_1221&amp;quot; align=&amp;quot;aligncenter&amp;quot; width=&amp;quot;511&amp;quot; caption=&amp;quot;SEMPRE ative a geração de PDBs, até em RELEASE!&amp;quot;][/caption]
Se você mantiver executável (DLL também é executável) juntinho com seu PDB, sua vida será mais fácil e florida.
[caption id=&amp;quot;attachment_1222&amp;quot; align=&amp;quot;aligncenter&amp;quot; width=&amp;quot;498&amp;quot; caption=&amp;quot;EXE e PDB, juntinhos, cantando e rodando.&amp;quot;][/caption]
Mesmo que, em alguns momentos trágicos, apareça uma tela indesejada.

Seu caminho a partir dessa tela pode ser analisar um dump gerado (visto no artigo anterior) ou podemos atachar o WinDbg diretamente no processo (visto aqui e agora):
 WinDbg: &amp;quot;mas que bagunça é essa na memória desse processo?&amp;quot;
O comando mais útil na maioria dos casos é mostrar a pilha em modo verbose (kv e ). Porém, antes disso, precisamos:
  Ajeitar o path dos símbolos.
  Recarregar o PDB do executável suspeito.
  Mostrar a pilha de todas as threads (até descobrir a culpada).
  Todos esses comandos podem ser vistos abaixo. São, respectivamente, .symfix, .reload e novamente o kv (mas para todas threads).
&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;0:001&amp;gt; .symfix&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;0:001&amp;gt; .reload /f CrashOnServer.exe&amp;lt;/span&amp;gt;*** WARNING: Unable to verify checksum for C:\Users\wanderley.caloni\Documents\Projetos\Caloni\Posts\Debug\CrashOnServer.exe0:001&amp;gt; kvChild-SP RetAddr : Args to Child : Call Site0030f918 77679198 : 00000000`00000000 `00000000 : ntdll!DbgBreakPoint0030f920 775e244d : 00000000`00000000 `00000000 : ntdll!DbgUiRemoteBreakin&#43;0x380030f950 00000000 : 00000000`00000000 `00000000 : ntdll!RtlUserThreadStart&#43;0x25&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;0:001&amp;gt; ~* kv&amp;lt;/span&amp;gt;0 Id: 1dc.978 Suspend: 1 Teb: 00000000`7efdb000 UnfrozenChild-SP RetAddr : Args to Child : Call Site0008ea48 751f282c : 00000000`77770190 00000000`001dfb50 : wow64cpu!CpupSyscallStub&#43;0x90008ea50 7526d07e : 00000000`00000000 00000000`775b3501 : wow64cpu!WaitForMultipleObjects32&#43;0x320008eb10 7526c549 : 00000000`00000000 00000000`7ffe0030 : wow64!RunCpuSimulation&#43;0xa0008eb60 775cae27 : 00000000`003b3710 00000000`7efdf000 : wow64!Wow64LdrpInitialize&#43;0x4290008f0b0 775c72f8 : 00000000`00000000 00000000`00000000 : ntdll!LdrpInitializeProcess&#43;0x17800008f5b0 775b2ace : 00000000`0008f670 00000000`00000000 : ntdll! ?? ::FNODOBFM::`string&#39;&#43;0x2af200008f620 00000000 : 00000000`00000000 00000000`00000000 : ntdll!LdrInitializeThunk&#43;0xe Ops! Estamos rodando um processo 32 dentro de um SO 64 (Windows 7, por exemplo). Isso pode acontecer. Seguimos com o workaround .load wow64exts e .effmach x86:
&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;0:001&amp;gt; .load wow64exts&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;0:001&amp;gt; .effmach x86&amp;lt;/span&amp;gt;Effective machine: x86 compatible (x86)&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;0:001:x86&amp;gt; ~* kv&amp;lt;/span&amp;gt;0 Id: 1dc.978 Suspend: 1 Teb: 7efdb000 UnfrozenChildEBP RetAddr Args to Child001df24c 761a0bdd 00000002 001df29c 00000001 ntdll_77760000!NtWaitForMultipleObjects&#43;0x15 (FPO: [5,0,0])001df2e8 7727162d 001df29c 001df310 00000000 KERNELBASE!WaitForMultipleObjectsEx&#43;0x100 (FPO: [Non-Fpo])001df330 77271921 00000002 7efde000 00000000 KERNEL32!WaitForMultipleObjectsExImplementation&#43;0xe0 (FPO: [Non-Fpo])001df34c 77299b2d 00000002 001df380 00000000 KERNEL32!WaitForMultipleObjects&#43;0x18 (FPO: [Non-Fpo])001df3b8 77299bca 001df498 00000001 00000001 KERNEL32!WerpReportFaultInternal&#43;0x186 (FPO: [Non-Fpo])001df3cc 772998f8 001df498 00000001 001df468 KERNEL32!WerpReportFault&#43;0x70 (FPO: [Non-Fpo])001df3dc 77299875 001df498 00000001 38239b1e KERNEL32!BasepReportFault&#43;0x20 (FPO: [Non-Fpo])001df468 777d0df7 00000000 777d0cd4 00000000 KERNEL32!UnhandledExceptionFilter&#43;0x1af (FPO: [Non-Fpo])001df470 777d0cd4 00000000 001dfb34 7778c550 ntdll_77760000!__RtlUserThreadStart&#43;0x62 (FPO: [SEH])001df484 777d0b71 00000000 00000000 00000000 ntdll_77760000!_EH4_CallFilterFunc&#43;0x12 (FPO: [Uses EBP] [0,0,4])001df4ac 777a6ac9 fffffffe 001dfb24 001df5e8 ntdll_77760000!_except_handler4&#43;0x8e (FPO: [Non-Fpo])001df4d0 777a6a9b 001df598 001dfb24 001df5e8 ntdll_77760000!ExecuteHandler2&#43;0x26001df580 7777010f 001df598 001df5e8 001df598 ntdll_77760000!ExecuteHandler&#43;0x24001df584 001df598 001df5e8 001df598 001df5e8 ntdll_77760000!KiUserExceptionDispatcher&#43;0xf (FPO: [2,0,0])WARNING: Frame IP not in any known module. Following frames may be wrong.001df9ac 010d141e 00000000 00000000 00000000 0x1df598001dfa90 010d19af 00000001 00321410 00321c70 CrashOnServer!main&#43;0x2e (FPO: [Non-Fpo]) (CONV: cdecl)[c:\users\wanderley.caloni\documents\projetos\caloni\posts\crashonserver\&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;crashonserver.cpp @ 13&amp;lt;/span&amp;gt;]001dfae0 010d17df 001dfaf4 77273677 7efde000 CrashOnServer!__tmainCRTStartup&#43;0x1bf (FPO: [Non-Fpo]) (CONV: cdecl)[f:\dd\vctools\crt_bld\self_x86\crt\src\crtexe.c @ 555]001dfae8 77273677 7efde000 001dfb34 77799f02 CrashOnServer!mainCRTStartup&#43;0xf (FPO: [Non-Fpo]) (CONV: cdecl)[f:\dd\vctools\crt_bld\self_x86\crt\src\crtexe.c @ 371]001dfaf4 77799f02 7efde000 6b3e1b48 00000000 KERNEL32!BaseThreadInitThunk&#43;0xe (FPO: [Non-Fpo])001dfb34 77799ed5 010d1109 7efde000 00000000 ntdll_77760000!__RtlUserThreadStart&#43;0x70 (FPO: [Non-Fpo])001dfb4c 00000000 010d1109 7efde000 00000000 ntdll_77760000!_RtlUserThreadStart&#43;0x1b (FPO: [Non-Fpo])# 1 Id: 1dc.1b0 Suspend: 1 Teb: 7efd8000 UnfrozenChildEBP RetAddr Args to Child0056ffe8 00000000 00000000 00000000 00000000 ntdll_77760000!RtlUserThreadStart (FPO: [0,2,0]) Nosso depurador favorito acusa uma pilha que contém a função WerpReportFault (Web Error Report, mas qualquer outra função com Exception no meio seria uma candidata). E, nessa mesma thread, a última linha nossa conhecida está no arquivo crashonserver.cpp:13. Isso nos revela o seguinte:
[caption id=&amp;quot;attachment_1224&amp;quot; align=&amp;quot;aligncenter&amp;quot; width=&amp;quot;534&amp;quot; caption=&amp;quot;A raiz de todos os nossos problemas!&amp;quot;][/caption]
E essa situação, caro leitor, é 10% de tudo o que você precisa saber sobre WinDbg para resolver, mas que já resolve 90% dos casos. Belo custo-benefício, não?
</description>
</item>

     
        <item>
  <title>Coders at Work: Reflections on the Craft of Programming</title>
  <link>http://www.caloni.com.br/coders-at-work/</link>
  <pubDate>2011-10-14</pubDate>
  
  <guid>http://www.caloni.com.br/coders-at-work/</guid>
  <description> &amp;quot;Personally I have never believed that it is possible to be a good coder without being a good programmer nor a good programmer without being a good designer, communicator, and thinker.&amp;quot; - Jamie Zawinski
 Como Joel e Atwood disseram, a leitura de Coders At Work é tão útil quanto ler o código dos outros, só que em um estilo mais condensado, que se aproveita das décadas de experiência dessa gente para aprimorarmos nossos processos de desenvolvimento e, muitas vezes, a forma de pensarmos sobre software.
No meu estilo de leitura circular, adaptada do brilhante (maluco?) método de Dmitry Vostokov, as coisas vão mais devagar, e estou apenas no início do livro, tendo passado por Jamie Zawinski (desenvolvedor da equipe original do Netscape), Brad Fitzpatrick (criador do Live Journal) e terminado recentemente Douglas Crockford. O artigo de Joel sobre Zawinski demonstra seu apreço pelo codificador pensante, ou aquele que faz as coisas acontecerem e não fica preso eternamente na armadilha da arquitetura. Eu acredito que as seguintes passagens do livro demonstram seu pensamento melhor do que se eu fosse tentar traduzi-los, começando por Jamie Zawinski:
 Personally I have never believed that it is possible to be a good coder without being a good programmer nor a good programmer without being a good designer, communicator, and thinker. (...) Start converting it into the bad one until it stops working. That&#39;s primary tool of reverse engineering. (...) Your competitor&#39;s six-month 1.0 has crap code and they&#39;re going to have to rewrite it in two years but, guess what: they can rewrite it because you don&#39;t have a job anymore. (...) The design process is definitely an ongoing thing; you never know what the design is until the program is done. So I prefer to get my feet wet as early as possible; get something on the screen so I can look at it sideways.(...) I&#39;ve noticed that one thing that separates good programmers from bad programmers is that good programmers are more facile at jumping between layers of abstraction they can keep the layers distinct while making changes and choose the right layer to make changes in. (...) I think one of the most important things, for me anyway, when building something from the ground up like that is, as quickly as possible, getting the program to a state that you, the programmer, can use it. Even a little bit. Because that tells you where to go next in a really visceral way. (...) I don&#39;t want to be a mathematician but I&#39;m not going to criticize someone who is a mathematician. It&#39;s weird that people often confuse those two pursuits. People who are into very theoretical computer science are thought of in this same way as people who are shipping desktop applications. And they don&#39;t really have a lot to do with each other. (...) Then there was another book that everybody thought was the greatest thing ever in that same period&#39;Design Patterns&#39;which I just thought was crap. It was just like, programming via cut and paste. Rather than thinking through your task you looked through the recipe book and found something that maybe, kinda, sorta felt like it, and then just aped it. That&#39;s not programming; that&#39;s a coloring book. (...
 De certa forma, o mesmo pragmatismo pode ser observado em Douglas Crockford, que utiliza o método de leitura de código tanto na entrevista por candidatos (&amp;quot;traga-me o código que tem orgulho de ter escrito e explique-o pra mim&amp;quot;) quanto no dia-a-dia do projeto, para que todos entendam e aproveitem a evolução do projeto como um todo, além de constituir, na minha visão, uma das melhores dicas de auto-management que uma equipe de programadores poderia ter.
 One of the things I&#39;ve been pushing is code reading. I think that is the most useful thing that a community of programmers can do for each other&#39;spend time on a regular basis reading each other&#39;s code. There&#39;s a tendency in project management just to let the programmers go off independently and then we have the big merge and then we have the big merge and if it builds then we ship it and we&#39;re done and we forget about it. One of the consequences of that is that if you have weak or confused programmers you&#39;re not aware of their actual situation until much too late. And so the risks to the project, that you&#39;re that you&#39;re going to have to build with stuff that&#39;s bad and the delays that that causes, that&#39;s unacceptable. The other thing is that you may have brilliant programmers on the project who are not adequately mentoring the other people on the team. Code reading solves both of those problems.
 Can you talk a bit about how you conduct a code reading?
 At each meeting, someone&#39;s responsible for reading their code, and they&#39;ll walk us through everything, and the rest of us will observe. It&#39;s a really good chance for the rest of the team to understand how their stuff is going to have to fit with that stuff. We get everybody around the table; everybody gets a stack of paper. We also blow it up on the screen. And we all read through it together. And we&#39;re all commenting on the code as we go along. People say, &#39;I don&#39;t understand this comment,&#39; or, &#39;This comment doesn&#39;t seem to describe the code.&#39; That kind of stuff can be so valuable because as a programmer you stop reading your own comments and you&#39;re not aware that you&#39;re misdirecting the reader. Having the people you work with helping to keep your code clean is a huge service&#39;you find defects that you never would&#39;ve found on your own. I think an hour of code reading is worth two weeks of QA. It&#39;s just a really effective way of removing errors. If you have someone who is strong reading, then the novices around them are going to learn a lot that they wouldn&#39;t be learning otherwise, and if you have a novice reading, he&#39;s going to get a lot of really good advice.
 So if you don&#39;t clean up every seventh cycle you may be faced with the choice of whether or not to do a big rewrite. How do you know when, if ever, it&#39;s time for a big rewrite?
 Generally the team knows when it&#39;s time. Management finds out a lot later. The team is getting beat up pretty regularly, making too many pretty regularly, making too many bugs; the code&#39;s too big, it&#39;s too slow; we&#39;re falling behind. They know why. It&#39;s not because they became stupider or lazier. It&#39;s because the code base is no longer serving the purpose that it needs to.
 Esse pequeno trecho da entrevista de Brendan Eich, de Coders at Work, revela parte das frustações que os programadores de linha de frente sofrem com os ambientes de depuração, muitas vezes aquém dos desafios atuais. Sinceramente, não sinto isso em meu dia-a-dia, e acho o Visual Studio um excelente depurador com interface (mas que perde feio para o WinDbg em casos mais hardcore). Porém, fica a percepção curiosa do criador do JavaScript.
 Proofs are hard. Most people are lazy. Larry Wall is right. Laziness should be a virtue. So that&#39;s why I prefer automation. Proofs are something that academics love and most programmers hate.&amp;quot; - Brendan Eic
 SGI:
 Diagnosing it was hard because it was timing-sensitive. It had to do with these machines being abused by terminal concentrators. People were hooking up a bunch of PTYs to real terminals. Students in a lab or a bunch of people in a mining software company in Brisbane, Australia in this sort of &#39;70s sea of cubes with a glass wall at &#39;70s sea of cubes with a glass wall at the end, behind which was a bunch of machines including the SGI two-processor machine. That was hard and I&#39;m glad we found it. These bugs generally don&#39;t linger for years but they are really hard to find. And you have to sort of suspend your life and think about them all the time and dream about them and so on. You end up doing very basic stuff, though. It&#39;s like a lot of other bugs. You end up bisecting&#39;you know &#39;wolf fence.&#39; You try to figure out by monitoring execution and the state of memory and try to bound the extent of the bug and control flow and data that can be addressed. If it&#39;s a wild pointer store then you&#39;re kinda screwed and you have to really start looking at harder-to-use tools, which have only come to the fore recently, thanks to those gigahertz processors, like Valgrind and Purify.
 Ferramentas de Depuração Avançadas:
 Instrumenting and having a checked model of the entire memory hierarchy is big. Robert O&#39;Callahan, our big brain in New Zealand, did his own debugger based on the Valgrind framework, which efficiently logs every instruction so he can re-create the entire program state at any point. It&#39;s not just a time-traveling debugger. It&#39;s a full database so you see a data structure and there&#39;s a field with a scrogged value and you can say, &#39;Who wrote to that last?&#39; and you get the full stack. You can reason from effects back to causes. Which is the whole game in debugging. So it&#39;s very slow. It&#39;s like a hundred times slower than real time, but there&#39;s hope. Or you can use one of these faster recording VMs&#39;they checkpoint only at system call and I/O boundaries. They can re-create corrupt program states at any boundary but to go in between those is harder. But if you use that you can probably close in quickly at near real time and then once you get to that stage you can transfer it into Rob&#39;s Chronomancer and run it much slower and get all the program states and find the bug.
 Depuradores da Indústria:
 Debugging technology has been sadly underresearched. That&#39;s another example where there&#39;s a big gulf between industry and academia: the academics are doing proofs, sometimes by hand, more and more mechanized thanks to the POPLmark challenge and things like that. But in the real world we&#39;re all in debuggers and they&#39;re pieces of shit from the &#39;70s like GDB. Yeah. So I use GDB, and I&#39;m glad GDB, at least on the Mac, has a watch-point facility that mostly works. So I can watch an address and I can catch it changing from good bits to bad bits. That&#39;s pretty helpful. Otherwise I&#39;m using printfs to bisect. Once I get close enough usually I can just try things inside GDB or use some amount of command scripting. But it&#39;s incredibly weak. The scripting language itself is weak. I think Van Jacobson added loops and I don&#39;t even know if those made it into the real GDB, past the FSF hall monitors.
 Multithreading:
 But there&#39;s so much more debugging can do for you and these attempts, like Chronomancer and Replay, are good. They certainly changed the game for me recently. But I don&#39;t know about multithreading. There&#39;s The multithreaded stuff, frankly, scares me because before I was married and had kids it took a lot of my life. And not everybody was ready to think about concurrency and all the possible combinations of orders that are out there for even small scenarios. Once you combine code with other people&#39;s code it just gets out of control. You can&#39;t possibly model the state space in your head. Most people aren&#39;t up to it. I could be like one of these chestthumpers on Slashdot&#39;when I blogged about &#39;Threads suck&#39; someone was saying, &#39;Oh he doesn&#39;t know anything. He&#39;s not a real man.&#39; Come on, you idiot. I got a trip to New Zealand and Australia. I got some perks. But it was definitely painful and it takes too long. As Oscar Wilde said of socialism, &#39;It takes too many evenings.
 E isso é tudo que guardarei deste livro. Talvez o revisite daqui a algumas décadas para comparar os novos tempos que viveremos.
 In the real world one big split is between people who use symbolic debuggers and people who use print statements. - Peter Seibe
 </description>
</item>

     
        <item>
  <title>Cuidado com variáveis temporárias</title>
  <link>http://www.caloni.com.br/cuidado-com-variaveis-temporarias/</link>
  <pubDate>2011-07-26</pubDate>
  
  <guid>http://www.caloni.com.br/cuidado-com-variaveis-temporarias/</guid>
  <description>Um dos problemas que a linguagem C&#43;&#43; possui para seus iniciantes é o de não deixar muito explícito partes do seu comportamento, principalmente as partes que lidam com ponteiros/referências e o jogo da vida dos objetos. Às vezes a coisa fica de tal como complexa que fica até difícil explicar o porquê das coisas.
Por exemplo, vejamos o singelo caso de alguém que precisa formatar uma saída de erro e para isso escolheu um stringstream:
#include &amp;lt;sstream&amp;gt;#include &amp;lt;exception&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std;void LogError(const char* msg){cerr &amp;lt;&amp;lt; &amp;#34;** &amp;#34; &amp;lt;&amp;lt; msg &amp;lt;&amp;lt; endl;}void func(){//doSomething(); throw exception(&amp;#34;sbrubles exception&amp;#34;);}int main(){try{func();}catch(exception&amp;amp; e){stringstream ss;ss &amp;lt;&amp;lt; &amp;#34;Error calling func: &amp;#34; &amp;lt;&amp;lt; e.what() &amp;lt;&amp;lt; endl;const char* errorMessage = ss.str().c_str();LogError(errorMessage);}}Quando chamamos func, ele lança uma exceção que é capturada no main que, por sua vez, formata uma stream e obtém sua string (através do método str) e através dessa string obtém o ponteiro da string em C puro (através do método c_str). Porém, a mensagem resultante na saída-padrão de erro não era o esperado:

Depurando diretamente, vemos que a stream, de fato, contém o que esperávamos. O único elemento errante é justamente o ponteiro obtido através da chamada dupla de métodos.

O porquê isso ocorre só fica óbvio quando vemos a ajuda (ou a assinatura) da função str da classe stringstream:
 &amp;lt;strong&amp;gt;&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;string str ( ) const;&amp;lt;/span&amp;gt;&amp;lt;/strong&amp;gt;&amp;lt;strong&amp;gt;void str ( const string &amp;amp; s );&amp;lt;/strong&amp;gt;&amp;lt;strong&amp;gt;Get/set the associated string object&amp;lt;/strong&amp;gt;   &amp;lt;strong&amp;gt;The first version &amp;lt;span style=&amp;quot;text-decoration: underline; color: #ff0000;&amp;quot;&amp;gt;returns a copy of the string object&amp;lt;/span&amp;gt; currently associated with the string stream buffer.&amp;lt;/strong&amp;gt;  Ora, a função str retorna uma cópia do objeto string usado internamento pelo buffer de nossa string stream. Duas coisas ocorrem em qualquer cópia de um objeto retornada por uma função:
  A cópia do objeto original e seu desacoplamento (óbvio).
  A construção de um objeto baseado no original e que, após o fim da expressão onde foi chamado o método, é destruído.
  Uma vez que a chamada a str termina, é entregue uma instância de uma string que contém a string original que está sendo usada pela string stream para a expressão da chamada, que geralmente vem seguida de uma cópia:
//// 1. str retorna uma cópia;// 2. atribuição copia retorno para buf.//string buf = ss.str(); A variável buf no exemplo acima será, portanto, a terceira string usada aqui até então. Ao final da expressão, a string intermediária retornada por str é automaticamente destruída, por se trata de uma cópia temporária para obedecer a sintaxe de retorno da função.
Agora, o que acontece se, na cópia temporária, é feita uma operação para obter seu ponteiro interno usado para armazenar sua string estilo C?
Obviamente ele fica inválido após o fim da expressão!
Vamos ver em câmera lenta:

Nada como assembly fresquinho para refrescar os conceitos de C&#43;&#43; por baixo dos panos.
Update Após uma enxurrada de programadores gerenciáveis perguntarem qual seria, então, a solução ideal, segue o snipet mais explicitado:
// 1. Copie a string retornada para uma variável não-temporáriastring buf = message.str();// 2. Use essa string dentro de seu escopo válido (até o final do catch, no exemplo do artigo).const char* text = buf.c_str(); Update 2 Outro leitor sugeriu fazer toda a chamada em uma única instrução, economizando em expressividade e ainda evitando a destruição da variável temporária criada ao chamar str.
// 1. Matar três coelhos com uma instrução só.LogError(ss.str().c_str()); Particularmente, gosto de instruções simples que me permitam ver claramente o que está acontecendo de forma simples pelo depurador (até porque sei que o compilador irá otimizar tudo no final em versão Release, ainda mais se estiver quebrado em instruções simples). Porém, toda solução que evita o uso da variável temporária após a execução do método str é válida.
</description>
</item>

     
        <item>
  <title>Depuração de emergência</title>
  <link>http://www.caloni.com.br/depuracao-de-emergencia/</link>
  <pubDate>2011-07-26</pubDate>
  
  <guid>http://www.caloni.com.br/depuracao-de-emergencia/</guid>
  <description>O programa está rodando no servidor do cliente, que é acessível por sessão remota do Windows, mas de repente ele capota. Existem aí duas possibilidades fora o debug remoto (que, nesse caso, não é possível):
  Analisar um dump gerado.
  Depurar localmente o problema.
  
Analisar um dump gerado Para a primeira opção, basta abrir o Gerenciador de Tarefas, localizar o processo e gerar o dump através do menu de contexto.

Com o dump e o Windbg em mãos, basta analisá-lo. Porém, se o seu processo é 32 bits e o servidor é 64 bits (geralmente é), o dump gerado será de 64 bits, EMBORA seja de um process 32. Ou seja, ao abri-lo, o sistema vai mostrar as threads de manipulação do SO para sistemas 32 (todos com o nosso amigo wow64cpu).
Microsoft (R) Windows Debugger Version 6.12.0002.633 AMD64Copyright (c) Microsoft Corporation. All rights reserved.Loading Dump File [C:\Tests\CrashOnServer.DMP]User Mini Dump File with Full Memory: Only application data is availableExecutable search path is:Windows 7 Version 7600 MP (2 procs) &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;Free x64&amp;lt;/span&amp;gt;Product: WinNt, suite: SingleUserTSMachine Name:Debug session time: Tue Jul 26 09:26:23.000 2011 (UTC - 3:00)System Uptime: 0 days 0:35:47.425Process Uptime: 0 days 0:00:42.000...........WARNING: MSVCR100D overlaps MSVCP100D*** ERROR: Symbol file could not be found. Defaulted to export symbols for ntdll.dll -*** ERROR: Symbol file could not be found. Defaulted to export symbols for wow64cpu.dll -wow64cpu!TurboDispatchJumpAddressEnd&#43;0x690:00000000`745d2dd9 c3 ret0:000&amp;gt; kvChild-SP RetAddr : Args to Child : Call Site00000000`001ce6c8 00000000`745d282c : : wow64cpu!TurboDispatchJumpAddressEnd&#43;0x690*** ERROR: Symbol file could not be found. Defaulted to export symbols for wow64.dll -00000000`001ce6d0 00000000`7464d07e : : wow64cpu!TurboDispatchJumpAddressEnd&#43;0xe300000000`001ce790 00000000`7464c549 : : wow64!Wow64SystemServiceEx&#43;0x1ce00000000`001ce7e0 00000000`76deae27 : : wow64!Wow64LdrpInitialize&#43;0x42900000000`001ced30 00000000`76de72f8 : : ntdll!LdrGetKnownDllSectionHandle&#43;0x1a700000000`001cf230 00000000`76dd2ace : : ntdll!RtlInitCodePageTable&#43;0xe800000000`001cf2a0 00000000`00000000 : : ntdll!LdrInitializeThunk&#43;0xePara entrar dentro do Inception, é necessário usar a extensão wow64exts e usar o comando &amp;quot;.effmach x86&amp;quot;.0:000&amp;gt; .load wow64exts0:000&amp;gt; .effmach x86Effective machine: x86 compatible (x86)0:000:x86&amp;gt; kvChildEBP RetAddr Args to Child..0035ec98 0035ecac 0035ecfc 0035ecac 0035ecfc ntdll_76f80000!KiUserExceptionDispatcher&#43;0xf (FPO: [2,0,0])*** WARNING: Unable to verify checksum for CrashOnServer.exeWARNING: Frame IP not in any known module. Following frames may be wrong.0035f0bc 01181ca9 0035f198 0035f19c 00000000 0x35ecac0035f190 01181b7d 009d80a0 5fb4d717 00000000 CrashOnServer!Log::LogError&#43;0x290035fb08 01186f1f 00000001 009d1410 009d1c68 CrashOnServer!main&#43;0x12d0035fb58 01186d4f 0035fb6c 76543677 7efde000 CrashOnServer!__tmainCRTStartup&#43;0x1bf0035fb60 76543677 7efde000 0035fbac 76fb9f02 CrashOnServer!mainCRTStartup&#43;0xf0035fb6c 76fb9f02 7efde000 771dc110 00000000 kernel32!BaseThreadInitThunk&#43;0xe0035fbac 76fb9ed5 01181316 7efde000 00000000 ntdll_76f80000!__RtlUserThreadStart&#43;0x700035fbc4 00000000 01181316 7efde000 00000000 ntdll_76f80000!_RtlUserThreadStart&#43;0x1b Após esse último passo, siga para o último passo desse tutorial. Ou escolha a segunda opção:
Depurar localmente o problema Para depurar localmente, supondo que seja um executável simples, você precisa dos seguintes itens:
  Pasta do WinDbg copiado (a Debugging Tools instalada pelo SDK, ou sua pastinha particular guardada no PenDrive).
  Símbolos dos binários envolvidos (em sincronia com os binários que iremos analisar).
  Fontes da compilação dos binários (a versão exata seria ideal; grave o revno do controle de fonte pra facilitar).
  Os fontes, no caso de uma conexão por Terminal Server, podem ser disponibilizados através do mapeamento de drives entre as máquinas. Os símbolos, no entanto, por serem usados extensivamente pelo WinDbg, é recomendável que estejam locais na máquina depurada, pois do contrário você terá que tomar uma quantidade excessiva de cafés para executar meia-dúzia de instruções.
Supondo que temos tudo isso, só precisamos executar alguns passos básicos para o setup:
1. Abrir o WinDbg e escolher File, Open Executable. Escolha o executável e pare por aí. 
2. Na tela de comando do WinDbg (View, Command, ou Alt &#43; 1) execute os comandos abaixo: &amp;lt;span style=&amp;quot;font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px; white-space: pre;&amp;quot; class=&amp;quot;Apple-style-span&amp;quot;&amp;gt;.symfix .sympath&#43; .reload&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px; white-space: pre;&amp;quot; class=&amp;quot;Apple-style-span&amp;quot;&amp;gt;.srcpath &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;font-family: Consolas, Monaco, monospace; font-size: 12px; line-height: 18px; white-space: pre;&amp;quot; class=&amp;quot;Apple-style-span&amp;quot;&amp;gt;.reload /f CrashOnServer.exe&amp;lt;/span&amp;gt; 3. Ao executar lm, o módulo cujo símbolo foi carregado deve conter o nome do pdb logo à frente. 0:000&amp;gt; .symfix c:\tools\symbols0:000&amp;gt; .sympath&#43; C:\Projetos\Caloni\Posts\DebugSymbol search path is: srv*;C:\Projetos\Caloni\Posts\DebugExpanded Symbol search path is: SRV*c:\tools\symbols*http://msdl.microsoft.com/download/symbols;c:\projetos\caloni\posts\debug0:000&amp;gt; .reloadReloading current modules......0:000&amp;gt; .srcpath C:\Projetos\Caloni\PostsSource search path is: C:\Projetos\Caloni\Posts0:000&amp;gt; .reload /f CrashOnServer.exe*** WARNING: Unable to verify checksum for CrashOnServer.exe0:000&amp;gt; lmstart end module name00000000`01170000 00000000`01193000 CrashOnServer C (private pdb symbols) C:\Projetos\Caloni\Posts\Debug\CrashOnServer.pdb00000000`745d0000 00000000`745d8000 wow64cpu (deferred)00000000`745e0000 00000000`7463c000 wow64win (deferred)00000000`74640000 00000000`7467f000 wow64 (deferred)00000000`76da0000 00000000`76f4c000 ntdll (pdb symbols) c:\tools\symbols\ntdll.pdb\\ntdll.pdb00000000`76f80000 00000000`77100000 ntdll32 (deferred) 4. Feito isso, está tudo OK. Podemos colocar breakpoints, monitorar variáveis, verificar stacks, etc. Por último, execute o seguinte comando na tela de comandos do WinDbg:
.hh E boa sorte =)
</description>
</item>

     
        <item>
  <title>Comparando strings no WinDbg</title>
  <link>http://www.caloni.com.br/comparando-strings-no-windbg/</link>
  <pubDate>2011-05-22</pubDate>
  
  <guid>http://www.caloni.com.br/comparando-strings-no-windbg/</guid>
  <description>O WinDbg fornece aos programadores diversos meios (muitos redundantes) de comparar valores inteiros em quaquer lugar da memória, em qualquer tamanho (8, 16, 32, 64 bits). Porém, quando precisamos comparar strings, que todos sabem ser uma sequência de bytes de tamanho arbitrário (se for em C, até o zero terminador).
Uma solução simples e rápida é comparar os 4 primeiros bytes de uma string, ou os 4 primeiros bytes que diferem de uma lista grande.
Por exemplo, imagine o seguinte código que abre todos os arquivos da pasta de sistema:
#define _CRT_SECURE_NO_WARNINGS#include &amp;lt;Windows.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;int main(){CHAR sysPath[MAX_PATH];CHAR findPath[MAX_PATH];GetSystemDirectory(sysPath, MAX_PATH);sprintf(findPath, &amp;#34;%s\\*.*&amp;#34;, sysPath);WIN32_FIND_DATA findData;HANDLE findH = FindFirstFile(findPath, &amp;amp;findData);if( findH != INVALID_HANDLE_VALUE ){do{CHAR filePath[MAX_PATH];sprintf(filePath, &amp;#34;%s\\%s&amp;#34;, sysPath, findData.cFileName);HANDLE fileH = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);if( fileH ){CHAR firstBytes[4];DWORD wasRead = 0;if( ReadFile(fileH, firstBytes, 4, &amp;amp;wasRead, NULL) &amp;amp;&amp;amp; wasRead == 4 ){printf(&amp;#34;%s: %02X %02X %02X %02X\n&amp;#34;, findData.cFileName,(int) firstBytes[0], (int) firstBytes[1], (int) firstBytes[2], (int) firstBytes[3]);}CloseHandle(fileH);}}while( FindNextFile(findH, &amp;amp;findData) );FindClose(findH);}}Queremos colocar um breakpoint no momento em que o arquivo shell32.dll estiver sendo aberto. Para isso, devemos nos atentar para os parâmetros passados para a função CreateFile.
windbg strcmpwindbg1.exe0:000&amp;gt; bp kernel32!CreateFileABreakpoint 0 hiteax=001bf918 ebx=7efde000 ecx=001bf7e0 edx=001bf7e0 esi=001bf824 edi=001bfd90eip=7663ca6e esp=001bf804 ebp=001bfd90 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246kernel32!CreateFileA:7663ca6e 8bff mov edi,edi0:000&amp;gt; da poi(esp&#43;4)001bf918 &amp;quot;C:\Windows\system32\accessibilit&amp;quot;001bf938 &amp;quot;ycpl.dll&amp;quot;0:000&amp;gt; gBreakpoint 0 hiteax=001bf918 ebx=7efde000 ecx=001bf7e0 edx=001bf7e0 esi=001bf824 edi=001bfd90eip=7663ca6e esp=001bf804 ebp=001bfd90 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246kernel32!CreateFileA:7663ca6e 8bff mov edi,edi0:000&amp;gt; da poi(esp&#43;4)001bf918 &amp;quot;C:\Windows\system32\ACCTRES.dll&amp;quot;&amp;lt;span style=&amp;quot;font-family: Georgia, &#39;Times New Roman&#39;, &#39;Bitstream Charter&#39;, Times, serif; font-size: 13px; line-height: 19px; white-space: normal;&amp;quot;&amp;gt;O padrão aqui é que todo path passado para o CreateFile vai começar com c:\windows\system32, o que não é uma informação que podemos usar para buscar um arquivo específico.&amp;lt;/span&amp;gt; Temos que nos atentar para o padrão de bits após esse path. Vamos dar uma olhada por dentro da string.
0:000&amp;gt; db 001bf918001bf918 43 3a 5c 57 69 6e 64 6f-77 73 5c 73 79 73 74 65 C:\Windows\syste001bf928 6d 33 32 5c 41 43 43 54-52 45 53 2e 64 6c 6c 00 m32\ACCTRES.dll.001bf938 79 63 70 6c 2e 64 6c 6c-00 cc cc cc cc cc cc cc ycpl.dll........ O nome do arquivo começa no offset 16&#43;4 = 20, ou 14 em hexa. Dessa forma, podemos capturar o padrão de bits da seguinte maneira:
0:000&amp;gt; dd poi(esp&#43;4)&#43;14 l1001bf92c 54434341 Para nos certificarmos que é realmente esse o padrão, e para já montarmos nosso próprio padrão para o shell32.dll, vamos alocar um pedaço de memória e verificar se a sequência de bits está correta.
0:000&amp;gt; dd poi(esp&#43;4)&#43;14 l1001bf92c 544343410:000&amp;gt; .dvalloc 100Allocated 1000 bytes starting at 000300000:000&amp;gt; ea 00030000 &amp;quot;ACCTRES.dll&amp;quot;0:000&amp;gt; dd 00030000 l100030000 54434341 Ótimo. Os padrões bateram, então podemos colocar um breakpoint condicional partindo do padrão de bits do nome do arquivo que precisamos.
0:000&amp;gt; bp kernel32!CreateFileA &amp;quot;j (poi(poi(esp&#43;4)&#43;14)=6c656873) &#39;&#39;; &#39;g&#39;&amp;quot;breakpoint 0 redefined0:000&amp;gt; geax=0021f48c ebx=7efde000 ecx=0021f354 edx=0021f354 esi=0021f398 edi=0021f904eip=7663ca6e esp=0021f378 ebp=0021f904 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246kernel32!CreateFileA:7663ca6e 8bff mov edi,edi0:000&amp;gt; da poi(esp&#43;4)0021f48c &amp;quot;C:\Windows\system32\shell32.dll&amp;quot;&amp;lt;span style=&amp;quot;font-family: Georgia, &#39;Times New Roman&#39;, &#39;Bitstream Charter&#39;, Times, serif; font-size: 13px; line-height: 19px; white-space: normal;&amp;quot;&amp;gt;Com isso, economizamos alguns minutos de puro tédio, verificando os nomes um a um conforme eles são abertos. Ou, dependendo da massa de dados, algumas décadas. Quem sabe. Pode ser muito mais útil um outro dia.&amp;lt;/span&amp;gt; </description>
</item>

     
        <item>
  <title>Sem reflection</title>
  <link>http://www.caloni.com.br/sem-reflection/</link>
  <pubDate>2011-05-18</pubDate>
  
  <guid>http://www.caloni.com.br/sem-reflection/</guid>
  <description>Em C&#43;&#43; não temos (ainda) a possibilidade de listarmos, por exemplo, a lista de métodos de um determinado tipo, a fim de chamá-lo pelo nome em tempo de execução. Algo assim:
class MyClass{public:void Method1();void Method2();void Method3();};int main(){MyClass c;if( auto m = typeid(c).methods.getaddresof(&amp;#34;Method1&amp;#34;) )m();}OK, foi apenas um exemplo tosco de como seria um reflection em C&#43;&#43;.
Porém, existem algumas maneiras de contornar esse problema. A solução, é claro, depende de qual problema você está tentando resolver.
Vamos supor, por exemplo, que você queira cadastrar funções para serem chamadas de maneira uniforme pelo prompt de comando. Vamos chamar nossa classe tratadora de CommandPrompt.
typedef void (Method*)(vector&amp;lt;string&amp;gt;&amp;amp; args);class CommandPrompt{public:void Add(string name, Method m); // adiciona novo método void Interact(ostream&amp;amp; os, istream&amp;amp; is); // começa interação com usuário};Internamente, para armazenar as funções de acordo com o nome dado, basta criarmos um mapeamento entre esses dois tipos e fazemos a amarração necessária para o método principal de parseamento:
typedef map&amp;lt;string, Method&amp;gt; MethodList; // uma variável desse tipo armazena todas as funçõesvoid CommandPrompt::Interact(ostream&amp;amp; os, istream&amp;amp; is){while( is ){string func;vector&amp;lt;string&amp;gt; args;if( ParseLine(is, func, args) ){// se a função desejada está em nossa lista, // podemos chamá-la, mesmo sem conhecer qual é if( Method m = m_funcs[func] )m(args);}}}Essa solução não é exatamente um reflection, mas apenas parte do que o verdadeiro reflection possibilita. Existem outras funcionalidades, como traits, que a STL já consegue se virar razoavelmente bem, por exemplo.
</description>
</item>

     
        <item>
  <title>Houaiss 1.3</title>
  <link>http://www.caloni.com.br/houaiss-1-3/</link>
  <pubDate>2011-04-28</pubDate>
  
  <guid>http://www.caloni.com.br/houaiss-1-3/</guid>
  <description>Os problemas relacionados com acesso negado durante a conversão/construção do dicionário foram corrigidos na novíssima versão disponível no GitHub.
Erroneamente imaginando que a falta de acesso tinha alguma coisa a ver com a escrita de arquivos no disco, ou até mesmo com a execução de processos, descobri depurando (o bom e velho depurador) que a origem do acesso negado estava na função AssignProcessToJobObject.aspx). Misteriosamente, no Windows 7, ao chamar essa função ocorre esse erro, independente da execução ser como administrador ou não.
Como já está se tornando tradição de uns tempos pra cá, a solução veio de um artigo do Stack Overflow, cuja melhor solução foi exatamente a que eu segui: inserir o manifesto do UAC e usar a flag CREATEBREAKAWAYFROMJOB.
Agora é só esperar pelo próximo bug =)
</description>
</item>

     
        <item>
  <title>Houaiss no Kindle</title>
  <link>http://www.caloni.com.br/houaiss-no-kindle/</link>
  <pubDate>2011-03-22</pubDate>
  
  <guid>http://www.caloni.com.br/houaiss-no-kindle/</guid>
  <description>O blogue de José Ribeiro Pena Neto, aparentemente recém-criado, conseguiu utilizar minha solução de conversão do dicionário Houaiss para Babylon em algo mais incrívei ainda: converter, em alguns passos, a base de dados do Houaiss para o Amazon Kindle.
De uma maneira simples e efetiva, ele cita o passo-a-passo para a conversão da base Houaiss para o formato Babylon e, a partir disso, reconverter para o formato usado pelo gratuito e multiplataforma Stardict.
</description>
</item>

     
        <item>
  <title>Loucuras multithreading</title>
  <link>http://www.caloni.com.br/loucuras-multithreading/</link>
  <pubDate>2011-03-18</pubDate>
  
  <guid>http://www.caloni.com.br/loucuras-multithreading/</guid>
  <description>Estava eu depurando um sistema cliente/servidor com um tantão de threads e me veio à cabeça na volta pra casa como que um programador iniciante entenderia aquela bagunça de dar F10 em uma função e cair no meio de outra, dar outro F10 na outra e voltar pra primeira.
Loucura, não?
Nem tanto. O multithreading de um sistema operacional está aí pra isso. O que ocorre, no caso de depurações em uma única IDE, é que os breakpoints temporários que são definidos ao usar o comando de step into/over podem ser ativados em paralelo, simultaneamente.
Mas confesso que, de vez em quando, depurar múltiplas threads fica parecendo coisa de maluco.
</description>
</item>

     
        <item>
  <title>Base64</title>
  <link>http://www.caloni.com.br/base64/</link>
  <pubDate>2011-03-09</pubDate>
  
  <guid>http://www.caloni.com.br/base64/</guid>
  <description>No meio dos meus artigos pendentes, encontrei esse, de Luiz Rocha, que fala sobre a dificuldade de entender o que seria Base64:
Já leio o seu site a algum tempo. Realmente acho complicado, alguns eu nem entendo =D. Mais eh o seguinte, eu estou montando um projeto, mas eu não entendo nada de trabalhar com binários. Então pesquisei na internet, e achei um algoritmo que pode me ajudar, na lógica. É o base64 mas eu não entendi como ele converte e desconverte em binário. Será que vc pode me ajudar, obrigado!!&amp;quot;Não é a primeira pessoa que pede informações sobre algo específico demais para explicar (para isso existe a Wikipedia e o Google, não?). No meio da minha escrita, percebi que já havia escrito sobre os fundamentos do conhecimento por trás da criação do Base64, conhecimento esse, acredito eu, todo programador que quer sair do lugar com os próprios pés deve ter.
  Básico do básico: assembly
  Básico do básico: binário &amp;lt;-- Luiz, você está procurando por esse!
  Básico do básico: tipos
  Básico do básico: ponteiros
  Bônus:
  Como ofuscar strings
  Passagem por valor e emails com anexo
  Como funcionam as strings
  REALMENTE para iniciantes:
  Configurando seus projetos no Visual Studio
  Como criar uma LIB no Visual Studio
  Acredito que tudo que um programador precisa saber é o básico. O problema é que esse básico cresce a cada ano, mas, de qualquer forma, continua sendo necessário voltar às raízes de vez em quando, e se existe algo que ele nunca deve esquecer, é isso.
Até porque na programação, 90% não se cria, se copia.
Imaginemos o cenário para a criação do Base64:
Alguns meios de comunicação, notadamente envio de e-mails e a navegação web, por incrível que pareça, trabalham em um protocolo totalmente em modo texto. É até fácil de entender, pois quando essas tecnologias nasceram as limitações de velocidade e estabilidade das conexões permitiam apenas o envio de texto puro de uma ponta a outra.
Isso quer dizer que, na prática, os anexos de um e-mail e as imagens de uma página trafegam, pelo protocolo definido, em modo texto.
Como isso é possível?
A solução não é tão obscura quanto possa parecer. Se um programador médio tivesse esse problema e nenhuma solução existisse ainda, ele faria o que sempre fez para resolver problemas desse tipo: codificar a mensagem na forma permitida. Isso já é feito com o próprio texto, que é apenas uma interpretação de tabelas de caracteres.
Tudo que é necessário fazer é o contrário, mas usando a mesma lógica: montar uma tabela de caracteres válidos e traduzir para um conteúdo binário, sendo que todas as combinações possíveis devem caber nessa tabela.
A forma mais básica binária de comunicação é um byte, constituído por 8 bits, que combinados darão 2^8 entradas em nossa tabela, que precisaria de 256 caracteres diferentes. Como isso ultrapassa o limite dos protocolos que estamos lidando, que em sua maioria utilizam a tabela ascii básica, que possui 128 posições, sendo que algumas posições não possuem caracteres imprimíveis, decidiu-se usar o múltiplo anterior: 64 posições, o que nos dá a chance de codificar 6 bits de cada vez (2^6).
Esse padrão de codificação se chama Base64. Se quiser mais detalhes, basta ler a RFC, que é pequena e muito simples de se ler.
Agora, como codificar essa solução? Só entendendo o básico, é claro.
</description>
</item>

     
        <item>
  <title>Projeto DayToDay</title>
  <link>http://www.caloni.com.br/projeto-daytoday/</link>
  <pubDate>2011-03-03</pubDate>
  
  <guid>http://www.caloni.com.br/projeto-daytoday/</guid>
  <description>O DayToDay é um projetinho que criei para fazer tracking das minhas atividades diárias. Eu o criei há mais de 6 anos, e provavelmente se tivesse pensado em como isso seria útil para as pessoas compartilharem suas ideias e limitasse o número de caracteres para 140, estaria rico hoje.
O &amp;quot;conceito&amp;quot; é bem simples: executo o programa, ele exibe um campo texto para digitar o que estou fazendo, digito enter ou clico no botão de OK e ele fecha. O que eu digitei cai em um arquivo texto com o mesmo nome do programa.
Algumas &amp;quot;features&amp;quot; avançadas que é bom saber:
 Ele gera o arquivo texto em UNICODE. Na época em que eu digitava em russo, isso era importante. Ele já gera suas anotações com data e hora. Você pode gerar um atalho para chamá-lo rapidamente e definir um diretório de trabalho diferente: o arquivo será gerado no diretório de trabalho especificado, e não onde está o executável. Existe uma versão em .NET que fiz na época que estudava C#. Felizmente eu perdi esse projeto.  </description>
</item>

     
        <item>
  <title>VTable</title>
  <link>http://www.caloni.com.br/vtable/</link>
  <pubDate>2011-03-01</pubDate>
  
  <guid>http://www.caloni.com.br/vtable/</guid>
  <description>Acho que na breve história desse blogue nunca contei a história do vtable. No máximo fizemos um hookzinho nos métodos de um componente COM. Mas só.
Não encontro uma analogia simples, assim, de cabeça. Então vou contar no cru, mesmo. Talvez seja até mais divertido.
A vtable foi um mecanismo criado para implementar o polimorfismo em C&#43;&#43; quando falamos de ponteiros para classes base cujos métodos virtuais foram sobrescritos por uma classe derivada.
A coisa fica mais simples quando explicamos que em C&#43;&#43; você só paga pelo que usa. Se você declarar uma classe que não tenha nenhum método virtual, os objetos dessa classe não precisarão de uma vtable. No entanto, você não conseguirá sobrescrever um método dessa classe através de uma derivada:
#include &amp;lt;iostream&amp;gt;class C{public:void method(){std::cout &amp;lt;&amp;lt; &amp;#34;C::method\n&amp;#34;;}};class D : public C{public:void method(){std::cout &amp;lt;&amp;lt; &amp;#34;D::method\n&amp;#34;;}};void func(C* c){c-&amp;gt;method(); }int main(){D d;func(&amp;amp;d); // passa endereço de C &amp;#34;dentro de D&amp;#34;}Saída=====C::method No exemplo acima, a chamada feita em func irá chamar o método da classe C, mesmo que a classe D tenha sobrescrito esse método. O programador semi-experiente deve pensar &amp;quot;lógico, ela não é virtual!&amp;quot;, e está certo, assim como qualquer pessoa que decora essas formulazinhas de vestibular.
Para criarmos polimorfismo de verdade, precisamos declarar o método em C como virtual:
class C{public:virtual void method();}; Agora sim, a chamada em func irá ser para D::method.
Pergunte para o programador semi-experiente em C&#43;&#43; por que as coisas são assim e provavelmente ele irá falar algo sobre vtable, mesmo que não saiba exatamente como ela funciona.
A vtable é uma tabela que guarda o endereço dos métodos virtuais de uma classe. Se uma classe derivada sobrescrever um ou mais métodos de sua classe base, ela terá uma outra vtable com os endereços dos métodos &amp;quot;corrigidos&amp;quot;.

Dessa forma, algo um pouco diferente ocorre na chamada c-&amp;gt;method() quando estamos lidando com classes polimórficas: o início de um objeto dessa classe terá um ponteiro para a vtable de sua classe. Quando um método virtual é chamado, em vez do compilador gerar uma chamada estática para o endereço do método da classe cujo tipo estamos usando, ele irá redirecionar essa chamada para uma posição na vtable para onde esse objeto aponta. No caso de um objeto do tipo D, a entrada para method em sua vtable apontará não para C::method, mas para D::method, uma função com a mesma assinatura contida na classe base C e que, portanto, a sobrescreve.
Façamos um pequeno teste para comprovar o que falamos. Vamos escancarar a chamada feita a partir de uma instância de D e a partir de uma instância de C. Nada que um WinDbg não resolva de braços cruzados:
int main(){D d;C c;func(&amp;amp;d);func(&amp;amp;c);}cl /Zi vtable3.cppwindbg vtable3.exe 
</description>
</item>

     
        <item>
  <title>Esse ponteiro vai até onde?</title>
  <link>http://www.caloni.com.br/esse-ponteiro-vai-ate-onde/</link>
  <pubDate>2011-01-17</pubDate>
  
  <guid>http://www.caloni.com.br/esse-ponteiro-vai-ate-onde/</guid>
  <description>Brincando com obtenções e conversões de SIDs, tive uma pequena dificuldade de usar a função ConvertStringSidToSid, de Sddl.h. Seu objetivo é receber uma string-SID no formato usado pela ferramenta PsGetSid e retornar uma sequência de bytes de tamanho arbitrário, que é o SID como o sistema o enxerga. Como ela retorna apenas o ponteiro final, do tipo PSID, o que parece fácil pode se tornar tricky se quisermos copiar o SID binário para algum buffer na pilha, já que não sabemos o número de bytes no buffer de origem. Tudo que sabemos é que, após o uso, devemos desalocar essa memória retornada pela API com outra API: LocalFree.
Ora, mesmo que não venhamos a escrever nessa memória de tamanho obscuro, não é de bom tom ler além da conta. Não há garantias que o que estiver após o SID é seguro. Pode até ser o final de uma página de memória, por exemplo, e o seu programa capota por causa de um singelo &amp;quot;Memory could not be read&amp;quot;. Que coisa sem graça!
[](/images/SXf7NsR.png)
Sempre que me vejo com problemas desse tipo procuro informações primeiro no próprio MSDN, segundo na cabeça e terceiro no Google. Nesse caso em específico a cabeça deu um jeito, pois imaginei que houvesse alguma forma de pegar o tamanho da memória alocada através das funções Local (se a API precisa de LocalFree para desalocar sua memória, é óbvio que ela usou LocalAlloc para alocá-la, mesmo que não tenhamos o código-fonte para comprovar).
A partir de LocalHandle posso obter o HANDLE para a memória alocada localmente. Com esse handle a API me dá outra função, LocalSize, de onde posso obter o tamanho da memória previamente alocada através do seu handle. Isso é ótimo, pois em um primeiro momento pensei não haver saída, como nas funções de alocação em C e C&#43;&#43;, por exemplo.
</description>
</item>

     
        <item>
  <title>Dependência pedindo carona</title>
  <link>http://www.caloni.com.br/dependencia-pedindo-carona/</link>
  <pubDate>2011-01-04</pubDate>
  
  <guid>http://www.caloni.com.br/dependencia-pedindo-carona/</guid>
  <description>Mesmo as vezes que você não queira, algumas dependências pedem carona e o compilador deixa entrar. Daí mesmo que você não use uma função API, ela acaba te atazanando a vida.
Foi o caso da ToolHelp32 no Windows NT 4.
Como as coisas funcionam Quando compilamos, cada CPP vira uma coleção de funções que serão usadas, mais tarde, pelo linker, para juntar a bagunça. Para mais detalhes dessa fascinante história, recomendo o fantástico artigo sobre Os diferentes erros na linguagem C, seção Linkedição.
Para as dependências localizadas fora do executável final, por exemplo, as DLLs do sistema, o linker cria uma entrada no formato padrão de executável que adiciona essa dependência extra que será resolvida na hora do programa rodar, quando o loader do sistema operacional terá que fazer um linker on-the-fly, catando todas as DLLs e funções necessárias para colocar o bichinho no ar.
Dessa forma, quando existirem unresolved externals fora do executável final, o responsável por dar o erro é o loader do sistema:

Isso significa que o seu processo não poderá ser executado, pois faltam funções no ambiente que ele depende.
Um recurso muito útil para ver essas funções é o Dependency Walker, meu amigo de infância:

Pois é. As coisas nem sempre acabam sendo como o esperado. Se você possuir uma LIB, por exemplo, e nela existirem duas funções, como abaixo, e você se limitar a usar em seu programa apenas a primeira, todas as dependências da segunda também irão parar no executável final.
#include &amp;#34;LibMod.h&amp;#34;#include &amp;lt;windows.h&amp;gt;#include &amp;lt;Tlhelp32.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;// Essa função é usada pelo nosso Appint UsingOldApis(){DWORD ver = GetVersion(); // API paleozoica, OK.	return int( (DWORD)(LOBYTE(LOWORD(ver))) );}// Essa função NÃO é usada pelo nosso Appvoid UsingNewApis(){// Opa: função moderninha!!	if( HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL) ){PROCESSENTRY32 procEntry;// Tudo bem, nosso App não vai usar essa função.	if( Process32First(snapshot, &amp;amp;procEntry) ){printf(&amp;#34;Process list:\n&amp;#34;);do{printf(&amp;#34;%s\n&amp;#34;, procEntry.szExeFile);}while( Process32Next(snapshot, &amp;amp;procEntry) );}CloseHandle(snapshot);}}#include &amp;#34;LibMod.h&amp;#34;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int main(){// Usando apenas funções paleozoicas, certo?	printf(&amp;#34;Our Major OS version is %d\n&amp;#34;, UsingOldApis() );system(&amp;#34;pause&amp;#34;);}Por que isso ocorre? Acontece que o nosso amigo linker gera uma lista de dependências por módulo (CPP), e não por função. Dessa forma, tudo que vier é lucro.
Só que às vezes é prejuízo, também. Quando usamos um SO da época do guaraná com rolha, como o Windows NT 4, por exemplo, não conseguimos usar um programa porque este possuía uma função moderninha nunca usada, mas que estava dentro de um CPP junto de uma função comportada, usando apenas APIs documentadas no primeiro papiro da Microsoft.
Solução? Sempre existe. Nesse caso, migrarmos as funções moderninhas para um segundo CPP, recompilarmos a LIB e a dependência milagrosamente desaparecerá!
#include &amp;#34;LibMod.h&amp;#34;#include &amp;lt;windows.h&amp;gt;#include &amp;lt;Tlhelp32.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;// Essa função é usada pelo nosso Appint UsingOldApis(){DWORD ver = GetVersion(); // API paleozoica, OK.	return int( (DWORD)(LOBYTE(LOWORD(ver))) );}#include &amp;#34;LibMod.h&amp;#34;#include &amp;lt;windows.h&amp;gt;#include &amp;lt;Tlhelp32.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;// Essa função NÃO é usada pelo nosso Appvoid UsingNewApis(){// Opa: função moderninha!!	if( HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL) ){PROCESSENTRY32 procEntry;// Tudo bem, nosso App não vai usar essa função.	if( Process32First(snapshot, &amp;amp;procEntry) ){printf(&amp;#34;Process list:\n&amp;#34;);do{printf(&amp;#34;%s\n&amp;#34;, procEntry.szExeFile);}while( Process32Next(snapshot, &amp;amp;procEntry) );}CloseHandle(snapshot);}}
Agora a aplicação poderá rodar em paz naquele que é, como diz meu amigo, um sistema operacional de ponta... da outra ponta!
</description>
</item>

     
        <item>
  <title>Patch de emergência 2</title>
  <link>http://www.caloni.com.br/patch-de-emergencia-2/</link>
  <pubDate>2010-11-09</pubDate>
  
  <guid>http://www.caloni.com.br/patch-de-emergencia-2/</guid>
  <description>No artigo anterior fizemos um patch rapidinho na memória se aproveitando de um Sleep nojento que o código nos forneceu.
E se não houvesse Sleep?
As chances de estarmos escrevendo no momento em que a função está sendo executada são tremendas, de forma que não poderíamos sobrescrevê-la sem correr o risco de um crash.
Uma solução alternativa para isso é alocar um novo pedaço de memória para a versão corrigida e trocar o endereço de chamada na função main.
windbg criticalservice3.exe0:000&amp;gt; uf DoProcesscriticalservice3!DoProcess [s:\docs\artigos\criticalservice3.cpp @ 8]:8 00401020 55 push ebp...12 0040107d 5d pop ebp12 0040107e c3 ret0:000&amp;gt; .writemem &amp;lt;font color=&amp;quot;#008000&amp;quot;&amp;gt;DoProcess.func&amp;lt;/font&amp;gt; 00401020 0040107eWriting &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;5f bytes&amp;lt;/font&amp;gt;.windbg -pvr -pn criticalservice2.exe0:000&amp;gt; .dvalloc 0x5fAllocated 1000 bytes starting at 000300000:000&amp;gt; .readmem &amp;lt;font color=&amp;quot;#008000&amp;quot;&amp;gt;DoProcess.func&amp;lt;/font&amp;gt; 00030000 &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;L5f&amp;lt;/font&amp;gt;Reading &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;5f bytes&amp;lt;/font&amp;gt;.0:000&amp;gt; uf 0003000000030000 55 push ebp...0003005d 5d pop ebp0003005e c3 ret Antes de trocarmos o endereço dentro do main precisamos &amp;quot;consertar&amp;quot; a função copiada. Ela está usando as funções globais rand e printf, e as chamadas usam offsets relativos. Como agora a função está em outro offset, temos que reconstruir as chamadas:
00401026 e8da000000 call criticalservice3!rand (00401105)00030006 e8da000000 call 000300e50:000&amp;gt; a 0003000600030006 call 0x00401105call 0x004011050003000b 00401073 e852000000 call criticalservice3!printf (004010ca)00030053 e852000000 call 000300aa0:000&amp;gt; a 0003005300030053 call 0x004010cacall 0x004010ca00030058 Agora a função está pronta para ser usada.
0:000&amp;gt; uf 0003000000030000 55 push ebp00030001 8bec mov ebp,esp00030003 83ec0c sub esp,0Ch00030006 e8fa103d00 call criticalservice2!rand (00401105)0003000b 99 cdq...0003004e 6828a04000 push offset criticalservice2!GetSystemInfo00030053 e872103d00 call criticalservice2!printf (004010ca)00030058 83c40c add esp,0Ch0003005b 8be5 mov esp,ebp0003005d 5d pop ebp0003005e c3 ret0:000&amp;gt; uf maincriticalservice2!main [s:\docs\artigos\criticalservice2.cpp @ 16]:16 00401080 55 push ebp...criticalservice2!main&#43;0x1f [s:\docs\artigos\criticalservice2.cpp @ 21]:21 0040109f e861ffffff call criticalservice2!ILT&#43;0(?DoProcessYAXXZ) (00401005)22 004010a4 ebf0 jmp criticalservice2!main&#43;0x16 (00401096) É nessa parte que trocaremos o endereço o endereço 00401005 pela memória alocada. Note que essa escrita é muito rápida e o programa lê esse endereço por muito pouco tempo se compararmos com todas as intruções que são executadas. No entanto, essa escrita não é atômica, e mesmo que as chances sejam extremamente remotas, ainda assim pode haver uma colisão no acesso à essa parte.
É salutar rezar por 10 segundos.
0:000&amp;gt; a 0040109f0040109f call 0x00030000call 0x00030000004010a4 E voilà! A partir do momento em que digitei o call seguido de , a função nova já começou a operar em cima do processo ainda rodando. Se quisermos voltar a função antiga, sem problemas:
0:000&amp;gt; a 0040109f0040109f call 0x00401005call 0x00401005004010a4 Não façam isso em casa, crianças ;)
</description>
</item>

     
        <item>
  <title>Patch de emergência</title>
  <link>http://www.caloni.com.br/patch-de-emergencia/</link>
  <pubDate>2010-11-08</pubDate>
  
  <guid>http://www.caloni.com.br/patch-de-emergencia/</guid>
  <description>Após um projeto muito bem sucedido, entregue no prazo e homologado em tempo recorde, você e sua equipe estão aproveitando suas devidas férias nas Bahamas, tomando água de coco na sombra de uma palmeira e apreciando a beleza natural da região. Ambas as belezas. =)
]
Mas eis que liga o seu gerente para o celular vermelho que te entregou no caso de emergências críticas e te avisa que um problema crítico foi detectado em um serviço crítico: o detector de pares. Consegue ver o erro?
Com toda a calma do mundo, você saca o seu netbook, baixa a versão homologada do controle de fonte e descobre facilmente o problema, gerando um patch e recompilando o projeto.
#include &amp;lt;windows.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;time.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;void DoProcess(){int nextNumber = rand() % 1000;//bool even = nextNumber % 2;	bool even = !(nextNumber % 2);printf(&amp;#34;%d =&amp;gt; %s\n&amp;#34;, nextNumber, even ? &amp;#34;even&amp;#34; : &amp;#34;odd&amp;#34;);}int main(){srand( time(0) );while( true ){DoProcess();Sleep(3000);}}Feliz da vida, avisa o seu chefe que a única coisa que precisam trocar é o serviço crítico. Parar, trocar o arquivo, reiniciar o serviço. Simples.
Porém, ele lhe avisa que esse é um serviço crítico, que não pode parar por nenhum segundo sequer. A atualização terá que ser feita sem parar o ciclo ininterrupto de pares/ímpares chegando do gerador de números randômicos.
Mais uma vez calmo da vida, você diz que isso é coisa de criança. Tudo que precisa fazer é atualizar a versão certa na memória. O arquivo poderá ser renomeado e, quando o serviço puder ser reiniciado, a versão nova será executada. Enquanto isso, o patch na memória bastará para corrigir o problema e não causar nenhum momento inoperante.
Tudo que você precisa é abrir o processo pelo WinDbg, encontrar a versão defeituosa e substituir os bytes certos.
Analisando o disassembly da função nova e antiga podemos perceber que o tamanho delas não mudou (bom sinal), mas o uso dos registradores e a lógica interna teve uma alteração significativa (mau sinal):
Função antiga: bool even = nextNumber % 2;test edx,edxsetne almov byte ptr [ebp-1],almovzx ecx,byte ptr [ebp-1]test ecx,ecxje criticalservice!DoProcess&#43;0x3f (0040105f)Função nova: bool even = !(nextNumber % 2);neg edxsbb edx,edxinc edxmov byte ptr [ebp-1],dlmovzx eax,byte ptr [ebp-1]test eax,eaxje criticalservice!DoProcess&#43;0x3f (0040105f) Podemos começar escrevendo a função nova da memória do processo de teste para um arquivo, e lendo em seguida para cima da função antiga. Só que para isso temos que nos certificar que os endereços que referenciam para fora da função sejam os mesmos. Nesse caso, felizmente, são.
0:001&amp;gt; .writemem c:\tests\newfunc.dat criticalservice!DoProcess 0040107eWriting 5f bytes. Em seguida iremos sobrescrever a função antiga no processo em execução. Para evitar crashes é vital que tenhamos certeza que a função não estará sendo executada nesse momento. No nosso caso basta aguardar a entrada na função Sleep da API, que dorme por 3 segundos, tempo suficiente para a atualização.
0:000&amp;gt; .readmem c:\tests\newfunc.dat criticalservice!DoProcess 0040107eReading 5f bytes. Atualizada a função, apenas nos lembramos de renomear o arquivo antigo e atualizar o novo para evitar reativar o problema. Agora podemos voltar para a apreciação das belezas da natureza...
</description>
</item>

     
        <item>
  <title>FormatMessage para... dumies?</title>
  <link>http://www.caloni.com.br/formatmessage-para-dumies/</link>
  <pubDate>2010-10-26</pubDate>
  
  <guid>http://www.caloni.com.br/formatmessage-para-dumies/</guid>
  <description>
Já foi comentado em alguns círculos de ótimos programadores que a função da Win32 API FormatMessage é uma das criaturas mais bizarras já criadas.
O objetivo da FormatMessage é formatar uma string, assim como sprintf, mas voltado mais a escrever uma descrição de um código de erro. Sendo assim ela é essencial para que o usuário não receba um número no lugar de uma explicação de por que a operação falhou.
Os códigos de erro que ela se propõe a formatar podem ser os erros padrões descritos em winerror.h ou qualquer outro código cuja explicação esteja em algum módulo carregado pelo processo (DLL ou o próprio executável). Isso nos dá a liberdade de, por exemplo, criar uma DLL apenas com códigos e descrições dos erros dos nossos produtos.
Para que seja criada a mensagem final, uma definição de mensagem é requirida como entrada, que pode vir do próprio chamador ou da já mencionada tabela de erros de algum módulo qualquer. No caso de querermos a descrição de um erro de sistema (em winerror.h, retornado por GetLastError ou similares) a definição da mensagem já está embutida no sistema, bastando para nós passarmos o código.
É importante lembrar que, como estamos falando de uma descrição de erro, ou seja, de um texto, este pode vir em diversos idiomas, sendo que é nossa obrigação também definir para qual idioma desejamos traduzir nosso código de erro, sendo também nossa obrigação, no caso de mensagens específicas do nosso programa, fornecer o modelo da mensagem nos idiomas que formos suportar.
O resto da função funciona mais ou menos como o sprintf, cuspindo a mensagem-modelo em uma saída formatada de acordo com os parâmetros de entrada.
DWORD WINAPI FormatMessage(__in DWORD dwFlags,__in_opt LPCVOID lpSource,__in DWORD dwMessageId,__in DWORD dwLanguageId,__out LPTSTR lpBuffer,__in DWORD nSize,__in_opt va_list *Arguments); Flags As flags do parâmetro dwFlags mudam radicalmente o funcionamento da rotina, o que me lembra de outra figura bizarra: o realloc da biblioteca padrão.
No caso do FormatMessage, a variável dwFlags se divide em dois para especificar dois grupos de opções distintos. A parte maior contém as opções armazenadas tradicionalmente como um mapa de bits, enquanto o byte menos significativo define como será tratada a saída final, com respeito às novas linhas e qual será a largura máxima de uma linha na saída.

Source O parâmetro mais polêmico é o que possui vários significados. No caso de lpSource, existem dois significados possíveis:
  FORMAT_MESSAGE_FROM_HMODULE. Ele é um HANDLE para um módulo.
  FORMAT_MESSAGE_FROM_STRING. Ele é um ponteiro para string.
  Isso explica por que essas duas flags são exclusivas: ou uma ou outra. Mesmo que a flag FORMAT_MESSAGE_FROM_SYSTEM seja usada, a função tentará achar a definição da mensagem no módulo especificado por lpSource primeiro, antes de ir buscar nas tabelas do sistema.
O código do erro Chamado de dwMessageId, esse é o argumento onde podemos passar um código de GetLastError ou nossos próprios códigos de erro. Se já tivermos uma string em lpSource, no entanto, não faz sentido existir um código de erro.
Idioma Para definir o idioma é usado o mesmo sistema de resources: monta-se uma DWORD com MAKELANGID que contém informações do idioma primário e secundário. Se quisermos usar o idioma padrão do sistema (99% dos casos) basta passarmos o retorno de MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL).
Buffer de saída Mais um argumento polêmico. Se a flag FORMAT_MESSAGE_ALLOCATE_BUFFER, lpBuffer não é um buffer, mas um ponteiro que será preechido com um endereço de memória alocada usando a função API LocalAlloc. Isso quer dizer que, após usar a mensagem formatada, devemos desalocar essa memória com LocalFree.
Por outro lado, se o buffer for nosso, então seu tamanho deve ser especificado no próximo argumento, nSize.
Tamanho do buffer Só que nem o parâmetro que especifica o tamanho do buffer é simples, assim. Se for especificado a flag FORMAT_MESSAGE_ALLOCATE_BUFFER, em vez de não fazer sentido esse argumento, ele significa o número MÍNIMO de caracteres que devem ser alocados, independente do tamanho da mensagem.
Obs.: Lembre-se que são caracteres, e não bytes. Se estivermos programando em UNICODE o número de bytes dobra.
Argumentos Essa seria uma lista simples de argumentos va_list que, para quem já fez funções ao estilo printf sabe muito bem usar. A lógica da função determina que os valores &amp;quot;%1&amp;quot;, &amp;quot;%2&amp;quot; e assim por diante dentro da definição de mensagem sejam trocados por estes argumentos.
Se eles são strings terminadas em nulo (interpretação padrão), inteiros ou estruturas específicas, isso vai depender da mensagem que está sendo formatada, o que é outro if a ser lembrado na hora de formatar mensagens do sistema.
Também é importante lembrar que, uma vez chamada a função, o conteúdo de va_list não pode ser usado novamente se não for reinicializado com va_end seguido de va_start.
Agora, se todo esse negócio de va_sbrubles é muito complicado pra você, é possível passar um array de DWORD_PTRs com o uso da flag FORMAT_MESSAGE_ARGUMENT_ARRAY.
Retorno Se tudo der certo e você passar todos os argumentos certinhos, o retorno é o número de caracteres armazenados no buffer de saída, independente dele ter sido alocado dinamicamente ou não. Ah, sim, excluindo o nulo terminador.
Se der errado a função retorna zero. É possível obter o erro através de GetLastError, o que muito provavelmente será 87 nas primeiras vezes que você usar essa função.
Escapes na definição de mensagem Pensou que acabaria por aqui? E qual o significado das sequências de escape dentro da mensagem-modelo? O formato básico para inserção de um argumento segue o seguinte padrão:
%n!!
Onde n é o número que identifica o argumento, como já vimos, e é um espaço reservado para identificarmos o tipo do argumento e como ele aparecerá na mensagem de saída.
Existe uma longa explicação sobre o uso de controladores de largura e precisão da saída formatada e sua localização na lista de argumentos, cujo número irá depender se estamos usando va_list ou array de DWORD_PTRs, sendo que alguns problemas podem surgir se repetirmos esses números de inserção. Em dois momentos da explicação o artigo seja a sugerir que seja usada a função StringCchPrintf, primeiro por que FormatMessage não suporta formatação de ponto flutuantes, e segundo, porque, mesmo que seja possível formatar valores de 64 bits, seria mais fácil se você usasse outra função.
Ainda existe um uso específico para &amp;quot;%0&amp;quot;, que é evitar quebra de linha durante a formatação da mensagem, inclusive no final. Esse uso entra em conflito com o nosso flag quando este determina um número máximo de caracteres por linha.
Ainda existe &amp;quot;de bônus&amp;quot; outras strings para preencher limitações que o próprio printf possui, como %%, %t, etc.
Falha de segurança Como os programadores habituados com ataques de stack overrun devem deduzir, uma mensagem-modelo mal intencionada pode conter sequências de inserção que não existem na formatação habitual, forçando o vazamento de bytes na string final, o que pode forçar ataques planejados. Como o próprio artigo diz, usar um código de erro arbitrário retornado por uma API qualquer e usar FormatMessage sem a flag FORMAT_MESSAGE_IGNORE_INSERTS pode levar a resultados desastrosos.
Exemplos Esse também é um bônus da MSDN, que te presenteia com exemplos de código tão fantasiosos quanto a própria função, veja o primeiro exemplo, por exemplo:
#include windows.h#include stdio.hvoid main(void){LPWSTR pMessage = L%1!.s! %4 %5!s!;DWORD_PTR pArgs[] = { (DWORD_PTR)4, (DWORD_PTR)2, (DWORD_PTR)LBill, %1!.s! refers back to the first insertion string in pMessage(DWORD_PTR)LBob, %4 refers back to the second insertion string in pMessage(DWORD_PTR)6, (DWORD_PTR)LBill }; %5!s! refers back to the third insertion string in pMessageconst DWORD size = 100&#43;1;WCHAR buffer[size];if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING FORMAT_MESSAGE_ARGUMENT_ARRAY,pMessage, 0,buffer, size, (va_list)pArgs)){wprintf(LFormat message failed with 0x%xn, GetLastError());return;}Buffer contains Bi Bob Bill.wprintf(LFormatted message %sn, buffer);}Depois ele chega a reimplementar o exemplo usando va_list, o que é muito interessante, mas... bom, deixa pra lá. Vamos fazer nosso próprio teste.
Uso padrão para GetLastError Esse é o uso clássico: precisamos de uma descrição de um código de erro para o usuário; um código Win32. A chamada para esse tipo de uso pode ser encapsulada em uma função mais simples:
#define _CRT_SECURE_NO_WARNINGS // quanta frescura...#include &amp;lt;tchar.h&amp;gt;#include &amp;lt;windows.h&amp;gt;#include &amp;lt;string&amp;gt;using namespace std;wstring GetErrorDescription(DWORD errNumber){wstring ret;bool msgOk = false;LPVOID lpMsgBuf = NULL;if( FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER // aloque pra mim (não sei o tamanho)	| FORMAT_MESSAGE_FROM_SYSTEM // descrição do erro está no sistema	| FORMAT_MESSAGE_IGNORE_INSERTS, // ignora os inserts pra não sofrer com hackerzinhos	NULL, // sem fonte:	errNumber, // a fonte é o código de erro	MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // idioma padrão	(LPTSTR)&amp;amp;lpMsgBuf,// isso é um ponteiro para um ponteiro para um buffer que será alocado	0, // nada disso	NULL // e nem disso	) &amp;gt; 0 ) // maior que zero quer dizer &amp;#34;beleza!&amp;#34;	{if( lpMsgBuf ) // só pra...	{ret = (PCWSTR) lpMsgBuf; // ok, vamos usar essa string	msgOk = true;LocalFree(lpMsgBuf); // não precisamos mais da memória alocada	}}if( ! msgOk ) // alguma coisa não deu certo	{wchar_t msgBuf[100]; // o suficiente	_snwprintf(msgBuf, 100, L&amp;#34;Unknown error (code %d)&amp;#34;, errNumber);ret = msgBuf;}return ret;}int CALLBACK wWinMain(HINSTANCE, HINSTANCE, PWSTR errNumberStr, int){int errNumber = _wtoi(errNumberStr);wstring errDesc = GetErrorDescription(errNumber);MessageBox(NULL, errDesc.c_str(), L&amp;#34;GetLastError&amp;#34;, MB_OK | MB_ICONINFORMATION);return errNumber;}Existem milhares de forma de usar essa função, como você deve ter percebido pelos parâmetros. Não seja tímido: se você conhece algum truquezinho esperto e quer compartilhar com os usuários da FormatMessage, essa é a hora!
</description>
</item>

     
        <item>
  <title>Atualizando HouaissParaBabylon no saite</title>
  <link>http://www.caloni.com.br/atualizando-houaissparababylon-no-saite/</link>
  <pubDate>2010-10-22</pubDate>
  
  <guid>http://www.caloni.com.br/atualizando-houaissparababylon-no-saite/</guid>
  <description>O último comentário no meu último artigo sobre o conversor Houaiss para Babylon me fez lembrar de algo muito importante: eu não atualizei o branch do saite com a última versão. Deve ser por isso que as pessoas estão tendo problemas com o uso do código. Resolvo isso já:
Essa é a versão 1.2 descrita no meu último artigo sobre o projeto.
De qualquer forma, qual não foi minha surpresa quando tentei recompilar o projeto e ocorreram erros no atlcom. Depois de uma breve pesquisa descobri que precisava rodar alguns &amp;quot;patches&amp;quot; para o include funcionar direito. Então, provavelmente, Willians, era esse o problema. Tente de novo.
</description>
</item>

     
        <item>
  <title>Como ofuscar strings</title>
  <link>http://www.caloni.com.br/como-ofuscar-strings/</link>
  <pubDate>2010-08-30</pubDate>
  
  <guid>http://www.caloni.com.br/como-ofuscar-strings/</guid>
  <description>Já fiz ofuscamento e embaralhamento de dados acho que umas três ou quatro vezes. Dessa vez, parti para o batidíssimo esquema de fazer o pré-processamento de um header com defines que irão virar estruturas reaproveitadas por uma função padrão que desofusca e ofusca aquela tripa de bytes em algo legível: a string original.
Vamos ver um exemplo:
#define MY_STR &amp;quot;Essa é minha string do coração&amp;quot; Conseguimos capturar os três elementos desse define (um descartável) por um simples scanf:
scanf(&amp;quot;#define %s \&amp;quot;%[^\&amp;quot;]&amp;quot;, def, str); A função scanf retorna o número de argumentos capturados. Então se a coisa funcionou é só comparar com 2.
Depois de capturado, imprimimos na saída (o arquivo pós-processado) uma estrutura que irá conter nosso amigo embaralhado:
printf(&amp;quot;struct ST_%s { byte key; size_t bufferSize; byte buffer[%d] }\n&amp;quot;&amp;quot; %s = { %d, %d, { &amp;quot;;for( ; ; ) printf(Cada byte ofuscado);printtf(&amp;quot; } };\n&amp;quot;); Pronto. Agora o usuário da string precisa abri-la usando uma macro esperta que irá chamar uma função esperta para desofuscar a string e entregar o ponteiro de buffer devidamente &amp;quot;casteado&amp;quot;:
#include &amp;quot;header-pos-processado.h&amp;quot;#define ABRE_VAR(var, type) (type) OpenVar( (GENERIC_STRUCT) var)int main(){char* str = ABRE_VAR(MY_STR, char*);} Uma vez que a abertura se faz &amp;quot;inplace&amp;quot;, ou seja, a memória da própria variável da estrutura original é alterada, pode-se fechar a variável novamente, se quiser, após o uso.
FECHA_VAR(MY_STR); A GENERIC_STRUCT do exemplo se trata apenas de um esqueleto para que todas as estruturas das 500 strings ofuscadas sejam entendidas a partir de um modelo. Sim, essa é uma solução usando linguagem C apenas, então não posso me dar ao luxo daqueles templates frescurentos.
struct GENERIC_STRUCT{byte key;size_t bufferSize;byte buffer[1];}; Como a string é ofuscada? Sei lá, use um XOR:
for( size_t i = 0; i &amp;lt; bufferSize; &#43;&#43;i )buffer[i] ^= key; Dessa forma abrir ou fechar a variável pode ser feito usando a mesma função.
Alguém aí gostaria de uma explicação didática sobre o operador XOR?
</description>
</item>

     
        <item>
  <title>Foto dos melhores momentos</title>
  <link>http://www.caloni.com.br/foto-dos-melhores-momentos/</link>
  <pubDate>2010-08-12</pubDate>
  
  <guid>http://www.caloni.com.br/foto-dos-melhores-momentos/</guid>
  <description>Mais um quebra-cabeças antes da nossa palestra, esse &amp;quot;baseado em fatos reais&amp;quot;.
A história é a seguinte: o cliente instalou uma versão nova do produto em algumas máquinas que, ato contínuo, começaram a apresentar telas azuis constantemente. Como essas máquinas tinham que ser usadas pelos funcionários, a administradora rapidamente desinstalou essa versão buguenta, e logo em seguida pediu por uma correção.
Até aí tudo bem. O problema maior era que ninguém havia capturado dump de nada.
Por isso pedi encarecidamente por qualquer fragmento de tela azul (minidumps) que pudessem ainda estar nas máquinas afetadas. Dito isso, ela confessou que havia voltado a imagem padrão nesses equipamentos para que os funcionários pudessem voltar ao trabalho rapidamente. Só que sem dump eu não conseguiria trabalhar rapidamente.
Mas eis que no dia seguinte ela me liga, comentando que um funcionário, empolgado (?) pela tela azul em sua máquina, havia tirado uma foto da mesma para &amp;quot;recordação&amp;quot;. Sem nenhuma cerimônia, então, pedi rapidamente que ela conseguisse essa foto para a minha coleção. A foto que ela me manda é exatamente a que está no início desse artigo (clique na foto para ampliá-la), apenas censurado o nome do driver, o que não vem ao caso. Assim que a recebi pude constatar o problema direto no código-fonte, corrigi-lo e enviar uma nova versão, que após alguns dias de testes se revelou bem sucedida.
A questão é: como eu resolvi o problema? Como você teria procedido nessa situação?
A resposta para esse enigma também contará pontos para nossa brincadeira com o livro Windows Internals, como foi explicado no artigo anterior. Vamos lá, Sherlock!
</description>
</item>

     
        <item>
  <title>Não é minha culpa</title>
  <link>http://www.caloni.com.br/nao-e-minha-culpa/</link>
  <pubDate>2010-08-08</pubDate>
  
  <guid>http://www.caloni.com.br/nao-e-minha-culpa/</guid>
  <description>Recebi a dica de meu amigo kernel-mode sobre o aplicativo NotMyFault, escrito como ferramenta do livro Windows Internals e que basicamente gera telas azuis para análise.
Como os problemas gerados pela ferramenta são todos de kernel, resolvi escrever meu próprio conjunto de bugs para o pessoal da userland. E como nada na vida se cria, tudo se copia, tenho o orgulho de apresentar a vocês o NotMyFaultEither!
Seu uso é bem simples. Escolha o problema, aperte a teclar &amp;quot;Fazer Bug&amp;quot; e pronto!
O resultado pode variar dependendo do sistema operacional e da arquitetura (há versões 32 e 64 bits, ambas UNICODE). Um Access Violation no Windows Seven 64 bits, por exemplo, o processo pára de reponder.
Após a análise do SO ele exibe uma tela onde é possível achar onde está o despejo de memória que podemos usar.
Esse é um minidump (mdmp), que possui a pilha da thread faltosa e informações de ambiente. Podemos gerar um dump completo através do Gerenciador de Tarefas.
No caso do Windows XP, podemos executar processo semelhante para gerar o dump através do aplicativo ProcDump, muito útil para preparar o material da minha palestra do próximo fim de semana.
E por falar em palestra, criei um pacote-surpresa de alguns minidumps para análise. Se alguém tiver a curiosidade de já ir mexendo, ou de mexer na hora da apresentação, fique à vontade. Quem montar uma lista relacionando cada dump com o tipo de problema encontrado (não precisa estar completa) irá concorrer, no dia da palestra, à quarta edição do livro Windows Internals, de Mark Russinovich. É minha cópia pessoal, mas está bem novinho, visto que a original pesa pra caramba e consulto sempre o e-book.
Estarei usando estes mesmos minidumps na palestra, junto dos dumps completos. Mas é claro que eu não iria deixar um despejo de memória completo pra vocês. Iria tornar as coisas muito fáceis ;)
Portanto, junte suas grandes dúvidas para o grande dia e nos vemos lá.
</description>
</item>

     
        <item>
  <title>Novas diferenças no Bazaar</title>
  <link>http://www.caloni.com.br/novas-diferencas-no-bazaar/</link>
  <pubDate>2010-08-04</pubDate>
  
  <guid>http://www.caloni.com.br/novas-diferencas-no-bazaar/</guid>
  <description>Novidade incrível nas novas versões do Bazaar. Dando continuidade à sua versão boiola gráfica, agora é possível configurar quantos visualizadores de diferenças você quiser. Na hora de ver a diferença em algum código-fonte, você pode optar pelo enrustido embutido ou, no caso, o meu favorito, WinMerge.
E por que o WinMerge é meu favorito? Porque você pode ignorar toda aquela discussão se devemos usar tabs ou três espaços para indentar o código. Cada um indenta como quer, na hora que mexer no código, que o WinMerge não vai nem ligar para essas diferencinhas (já que o compilador não liga). Ele até detecta blocos de código inteiros que foram movidos dentro do arquivo.
Na hora de ver as diferenças no worktree podemos usar a velha opção de criar um alias para o WinMerge. Mas no meio de um log, podemos ativar tanto o view embutido quanto o de qualquer outra ferramenta que escolhermos.
Vendo essas coisas fico imaginando como ainda tem gente que usa arquivos zip com data para armazenar versões de documentos diferentes. Tsc, tsc.
</description>
</item>

     
        <item>
  <title>Como achar o código-fonte sem símbolos</title>
  <link>http://www.caloni.com.br/como-achar-o-codigo-fonte-sem-simbolos/</link>
  <pubDate>2010-08-03</pubDate>
  
  <guid>http://www.caloni.com.br/como-achar-o-codigo-fonte-sem-simbolos/</guid>
  <description>Continuo escovando bits. Dessa vez de forma mais nervosa. Se trata de um serviço que trava durante seu stop. Um colega muito esperto do suporte gerou um dump para mim, tornando as coisas mais fáceis. O problema era que não havia símbolos nem código-fonte que batessem exatamente com aquela compilação de 2004. Solução? Analisar as pilhas das threads restantes.
É sabido que esse serviço responde requisições de milhares de máquinas em um período curto de tempo, então por isso a primeira coisa que me atentei foi verificar quantas threads haviam:
0:000&amp;gt; ~*. 0 Id: 4c8.30c Suspend: 1 Teb: 7ffde000 UnfrozenStart: *** WARNING: Unable to verify checksum for Service.exe*** ERROR: Module load completed but symbols could not be loaded for Service.exeService&#43;0xc60c (0040c60c)Priority: 0 Priority class: 32 Affinity: f1 Id: 4c8.4d8 Suspend: 1 Teb: 7ffdd000 UnfrozenStart: ADVAPI32!AccessCheckByTypeResultListAndAudit(...)Priority: 0 Priority class: 32 Affinity: f2 Id: 4c8.580 Suspend: 1 Teb: 7ffdc000 UnfrozenPriority: 0 Priority class: 32 Affinity: f3 Id: 4c8.adc Suspend: 1 Teb: 7ffd9000 UnfrozenStart: rtutils!TraceServerThread (778321fe)Priority: 0 Priority class: 32 Affinity: f4 Id: 4c8.f1c Suspend: 1 Teb: 7ffa5000 UnfrozenStart: rpcrt4!ThreadStartRoutine (77d37e70)Priority: 0 Priority class: 32 Affinity: f...1426 Id: 4c8.1464 Suspend: 1 Teb: 7fa0c000 UnfrozenStart: rpcrt4!ThreadStartRoutine (77d37e70)Priority: 0 Priority class: 32 Affinity: f1427 Id: 4c8.144c Suspend: 1 Teb: 7fa0b000 UnfrozenStart: rpcrt4!ThreadStartRoutine (77d37e70)Priority: 0 Priority class: 32 Affinity: f1428 Id: 4c8.12dc Suspend: 1 Teb: 7fa09000 UnfrozenStart: rpcrt4!ThreadStartRoutine (77d37e70)Priority: 0 Priority class: 32 Affinity: f1429 Id: 4c8.1410 Suspend: 1 Teb: 7fa08000 UnfrozenStart: rpcrt4!ThreadStartRoutine (77d37e70)Priority: 0 Priority class: 32 Affinity: f 1430
Id: 4c8.143c Suspend: 1 Teb: 7fa06000 UnfrozenPriority: 0 Priority class: 32 Affinity: f São muitas.
Analisar essa quantidade absurda de threads seria um saco. Além de inútil. Foi por isso deus inventou a função !uniqstack, que encontra automagicamente quais threads estão com a pilha duplicada.
0:000&amp;gt; !uniqstackProcessing 1431 threads, please wait. 0 Id: 4c8.30c Suspend: 1 Teb: 7ffde000 UnfrozenStart: Service&#43;0xc60c (0040c60c)Priority: 0 Priority class: 32 Affinity: fChildEBP RetAddr0012f9f8 7c586381 NTDLL!ZwReadFile&#43;0xb0012fa6c 7c2dd578 KERNEL32!ReadFile&#43;0x181...0012fff0 00000000 KERNEL32!BaseProcessStart&#43;0x3d. 1 Id: 4c8.4d8 Suspend: 1 Teb: 7ffdd000 UnfrozenStart: ADVAPI32!AccessCheckByTypeResultListAndAudit(...)Priority: 0 Priority class: 32 Affinity: fChildEBP RetAddr00cefec0 7c59a0a2 NTDLL!ZwWaitForSingleObject&#43;0xb...00cf000c 007a0000 0x1366e000cf000c 00000000 0x7a0000. 2 Id: 4c8.580 Suspend: 1 Teb: 7ffdc000 UnfrozenPriority: 0 Priority class: 32 Affinity: fChildEBP RetAddr010efe24 77d59815 NTDLL!ZwReplyWaitReceivePortEx&#43;0xb...010effec 00000000 KERNEL32!BaseThreadStart&#43;0x52. 3 Id: 4c8.adc Suspend: 1 Teb: 7ffd9000 UnfrozenStart: rtutils!TraceServerThread (778321fe)Priority: 0 Priority class: 32 Affinity: fChildEBP RetAddr0150fd20 7c59a26d NTDLL!ZwWaitForMultipleObjects&#43;0xb...0150ffec 00000000 KERNEL32!BaseThreadStart&#43;0x52....1430 Id: 4c8.143c Suspend: 1 Teb: 7fa06000 UnfrozenPriority: 0 Priority class: 32 Affinity: fChildEBP RetAddr6665f0dc 7c59a0a2 NTDLL!ZwWaitForSingleObject&#43;0xb...6665ffec 00000000 KERNEL32!BaseThreadStart&#43;0x52Total threads: 1431Duplicate callstacks: 1092
(windbg thread #s follow):7, 9, 11, 12, 13, 14, 15, 17, 18, 20, 21, (...), 1428, 1429 Muitas threads duplicadas. Isso quer dizer que podemos nos focar na pilha de uma delas. Basta pegar uma.
0:000&amp;gt; ~1429 kv ChildEBP
RetAddr Args to Child6645f334 7c59a0a2 ... NTDLL!ZwWaitForSingleObject&#43;0xb (FPO: [3,0,0])6645f35c 7c57b40f ... KERNEL32!WaitForSingleObjectEx&#43;0x71 (FPO: [Non-Fpo])6645f36c 004054c3 ... KERNEL32!WaitForSingleObject&#43;0xf (FPO: [2,0,0])WARNING: Stack unwind information not available. Following frames may be wrong. 6645f690 004060ec ... Service&#43;0x54c3 6645f764 77d79970
... Service&#43;0x60ec6645f788
77d96460 ... rpcrt4!Invoke&#43;0x306645f7a0 77d9637a ... rpcrt4!NdrCallServerManager&#43;0x15 (FPO: [4,0,2])6645fa90 77d9076f ... rpcrt4!NdrStubCall&#43;0x200 (FPO: [Non-Fpo])6645faf4 7cef55fd ... rpcrt4!CStdStubBuffer_Invoke&#43;0xc1 (FPO: [Non-Fpo])6645fb38 7cef58d8 ... OLE32!SyncStubInvoke&#43;0x61 (FPO: [Non-Fpo])6645fb80 7ce8833d ... OLE32!StubInvoke&#43;0xa8 (FPO: [Non-Fpo])6645fbe4 7ce7a711 ... OLE32!CCtxComChnl::ContextInvoke&#43;0xbb (FPO: [Non-Fpo])6645fc00 7cef54e2 ... OLE32!MTAInvoke&#43;0x18 (FPO: [Non-Fpo])6645fc30 7cef5c06 ... OLE32!AppInvoke&#43;0xb5 (FPO: [Non-Fpo])6645fcf0 7cef3360 ... OLE32!ComInvokeWithLockAndIPID&#43;0x297 (FPO: [Non-Fpo])6645fd30 77d545b1 ... OLE32!ThreadInvoke&#43;0x1b7 (FPO: [Non-Fpo])6645fd68 77d39463 ... rpcrt4!DispatchToStubInC&#43;0x32 (FPO: [Non-Fpo])6645fdc0 77d39337 ... rpcrt4!RPC_INTERFACE::DispatchToStubWorker&#43;0x100 (FPO: [Non-Fpo])6645fde0 77d39603 ... rpcrt4!RPC_INTERFACE::DispatchToStub&#43;0x5e (FPO: [Non-Fpo])6645fe10 77d4740d ... rpcrt4!RPC_INTERFACE::DispatchToStubWithObject&#43;0xa9 (FPO: [Non-Fpo])6645fe44 77d47634 ... rpcrt4!OSF_SCALL::DispatchHelper&#43;0xa1 (FPO: [Non-Fpo])6645fe58 77d46f3b ... rpcrt4!OSF_SCALL::DispatchRPCCall&#43;0x121 (FPO: [Non-Fpo])6645fe90 77d466ac ... rpcrt4!OSF_SCALL::ProcessReceivedPDU&#43;0x68f (FPO: [Non-Fpo])6645feb0 77d48730 ... rpcrt4!OSF_SCALL::BeginRpcCall&#43;0x183 (FPO: [Uses EBP] [2,0,4])6645ff10 77d5154b ... rpcrt4!OSF_SCONNECTION::ProcessReceiveComplete&#43;0x326 (FPO: [Non-Fpo])6645ff20 77d516b8 ... rpcrt4!ProcessConnectionServerReceivedEvent&#43;0x1b (FPO: [7,0,0])6645ff74 77d514bd ... rpcrt4!LOADABLE_TRANSPORT::ProcessIOEvents&#43;0xcd (FPO: [Non-Fpo])6645ff78 77d3af8d ... rpcrt4!ProcessIOEventsWrapper&#43;0x9 (FPO: [1,0,0])6645ffa8 77d37e88 ... rpcrt4!BaseCachedThreadRoutine&#43;0x4f (FPO: [Non-Fpo])6645ffb4 7c57b3bc ... rpcrt4!ThreadStartRoutine&#43;0x18 (FPO: [Non-Fpo])6645ffec 00000000 ... KERNEL32!BaseThreadStart&#43;0x52 (FPO: [Non-Fpo]) Através das funções de RPC e OLE32 podemos concluir que se trata de uma chamada direta para uma interface COM. Bom, existem centenas de métodos e dezenas de interfaces nesse serviço, tornando mais fácil tentar desmontar a chamada inicial que o rpcrt4 faz ao nosso módulo.
0:000&amp;gt; ub 77d79970
rpcrt4!Invoke&#43;0x20:77d79960 fd std77d79961 f3a5 rep movs dword ptr es:[edi],dword ptr [esi]77d79963 8b45f4 mov eax,dword ptr [ebp-0Ch]77d79966 50 push eax77d79967 669d popf77d79969 669d popf77d7996b 8b4508 mov eax, dword ptr [ebp&#43;8]
77d7996e ffd0 call eax Nossa função é obtida em ebp&#43;8. Podemos obter esse endereço pelo campo **ChildEBP **da função em questão.
0:000&amp;gt; dd 6645f788
&#43;8 l16645f790 004060610:000&amp;gt; uf 00406061Service&#43;0x6061:00406061 55 push ebp00406062 8bec mov ebp,esp00406064 81ecc8000000 sub esp,0C8h0040606a 833db09f410000 cmp dword ptr [Service&#43;0x19fb0 (00419fb0)],0
00406071 751b jne Service&#43;0x608e (0040608e) Service&#43;0x6073
:00406073 6a00 push 000406075 6860514100 push offset Service&#43;0x15160 (00415160)0040607a b9609e4100 mov ecx,offset Service&#43;0x19e60 (00419e60)0040607f e822080000 call Service&#43;0x68a6 (004068a6)00406084 8b4514 mov eax,dword ptr [ebp&#43;14h]00406087 66c7002f00 mov word ptr [eax],2Fh
0040608c eb65 jmp Service&#43;0x60f3 (004060f3)Service&#43;0x608e:0040608e 56 push esi0040608f 8b7508 mov esi,dword ptr [ebp&#43;8]00406092 837e5200 cmp dword ptr [esi&#43;52h],000406096 7430 je Service&#43;0x60c8 (004060c8)Service&#43;0x6098:00406098 8d8538ffffff lea eax,[ebp-0C8h]0040609e 6830514100 push offset Service&#43;0x15130 (00415130)004060a3 50 push eax004060a4 e85f4d0000 call Service&#43;0xae08 (0040ae08)004060a9 59 pop ecx004060aa 59 pop ecx004060ab 6a00 push 0004060ad 8d8538ffffff lea eax,[ebp-0C8h]004060b3 50 push eax004060b4 b9609e4100 mov ecx,offset Service&#43;0x19e60 (00419e60)004060b9 e8e8070000 call Service&#43;0x68a6 (004068a6)004060be 8b4514 mov eax,dword ptr [ebp&#43;14h]004060c1 66c7000a40 mov word ptr [eax],400Ah004060c6 eb2a jmp Service&#43;0x60f2 (004060f2)Service&#43;0x60c8:004060c8 6804010000 push 104h004060cd 8d868c010000 lea eax,[esi&#43;18Ch]004060d3 50 push eax004060d4 ff750c push dword ptr [ebp&#43;0Ch]004060d7 ff158c304100 call dword ptr [Service&#43;0x1308c (0041308c)]004060dd 668b4510 mov ax,word ptr [ebp&#43;10h]004060e1 8bce mov ecx,esi004060e3 66894648 mov word ptr [esi&#43;48h],ax004060e7 e892f2ffff call Service&#43;0x537e (0040537e)004060ec 8b4d14 mov ecx,dword ptr [ebp&#43;14h]004060ef 668901 mov word ptr [ecx],axService&#43;0x60f2:004060f2 5e pop esiService&#43;0x60f3:004060f3 33c0 xor eax,eax004060f5 c9 leave004060f6 c21000 ret 10h Note como a função compara algo com zero. Caso não seja zero ela continua. Caso contrário ela vai para um ponto que chama uma função interna e move um código de erro para um ponteiro recebido como parâmetro, o que é muito normal, se lembrarmos que as funções COM de um programa em C devem retornar o código da chamada no retorno (S_OK) e o código de erro em um lResult da vida.
STDMETHODIMP CService::Open(&amp;lt;params&amp;gt;, PLONG *pctReturn){if( DeuErrado() ){*pctReturn = ERR_DEU_ERRADO;return S_OK;}//...}O código retornado é 2Fh, e agora temos uma boa pista para encontrar a localização no fonte. A primeira coisa é encontrar o define responsável por esse erro, o que exige um pouco de familiaridade com o sistema, pois não se trata aqui de um código Windows.
#define OSRL_ERR	44	/* Data file serial number overflow */#define KLEN_ERR	45	/* Key length exceeds MAXLEN parameter */#define	FUSE_ERR	46	/* File number already in use */#define FINT_ERR	47	/* database has not been initialized */#define FMOD_ERR	48	/* Operation incompatible with type of file */#define	FSAV_ERR	49	/* Could not save file */#define LNOD_ERR	50	/* Could not lock node */ Ótimo. 2F, para os leigos (leigos? o que vocês estão fazendo aqui?), é 47 em decimal, exatamente nosso código listado acima. Com esse define podemos agora procurar no código-fonte e analisar todas as funções que retornam esse código em seu início. Para nossa sorte, existe apenas uma.
STDMETHODIMP CService::Open(BYTE *fileName, COUNT keyNo, COUNT *pctReturn){char szMsg[200];// Verifica se o banco de dados foi inicializado	if (!_Main.m_bDBInitialized){_Main.Log(&amp;#34;Error opening file before database to be initialized.&amp;#34;);*pctReturn = FINT_ERR;return S_OK;}// Verifica se o arquivo já foi aberto	if (m_pData){sprintf(szMsg, &amp;#34;Error on open file \&amp;#34;%s\&amp;#34;. File already opened.&amp;#34;);_Main.Log(szMsg);*pctReturn = ERR_BLABLABLA;return S_OK;}//...}Para confirmar que não estamos sonhando, podemos dar uma olhada no parâmetro passado para a função Log antes do código retornar. A memória deverá conter uma string idêntica a do código-fonte.
Service&#43;0x6073:00406073 6a00 push 000406075 6860514100 push offset Service&#43;0x15160 ( 00415160
)0040607a b9609e4100 mov ecx,offset Service&#43;0x19e60 (00419e60)0040607f e822080000 call Service&#43;0x68a6
 (004068a6)00406084 8b4514 mov eax,dword ptr [ebp&#43;14h]00406087 66c7002f00 mov word ptr [eax],2Fh0040608c eb65 jmp Service&#43;0x60f3 (004060f3)0:000&amp;gt; da 00415160
00415160 &amp;quot;Error opening file before databa&amp;quot;00415180 &amp;quot;se to be initialized.&amp;quot; E, agora sim, encontramos o culpado!

Mais para a frente em minha análise consegui encontrar o objeto pelo qual todas as threads esperavam. Não tive tanta sorte, pois se tratava de um mutex, e mutexes não conseguem ser rastreados tão facilmente em user mode. Mas isso não vem ao caso. O que tentei descrever aqui foi mais ou menos o processo que você deverá seguir caso tenha que analisar um binário compilado em outras vidas. Espero que você tenha tanta sorte quanto eu.
</description>
</item>

     
        <item>
  <title>Const e Volatile</title>
  <link>http://www.caloni.com.br/const-e-volatile/</link>
  <pubDate>2010-06-04</pubDate>
  
  <guid>http://www.caloni.com.br/const-e-volatile/</guid>
  <description>Padrão C (ISO/IEC 9899:1990)
6.5.3 type-qualifierconstvolatilePadrão C&#43;&#43; (ISO/IEC 14882:1998)cv-qualifierconstvolatile Qualificadores de tipo Chamamos de qualificador de tipo as palavrinhas mágicas **const **e volatile. Na prática elas definem como uma determinada variável será usada e se comportará durante a vida do programa.
Const Uma variável const não pode ser alterada pelo programa durante sua execução, apenas durante sua inicialização:
const float pi = 3.14; // até onde sabemos, pi não irá mudar neste Universo No exemplo acima, o valor de pi não pode mais ser alterado. Só que repare que ele foi, em determinado momento, alterado com um valor constante: na sua inicialização. Isso quer dizer que:
  pi é uma variável no programa representada por um local na memória **endereçável **pelo programa
  pi não é um define do pré-processador que irá virar uma constante literal (3.14, por exemplo)
// eu posso endereçar uma constante, // desde que qualifique corretamente meu ponteiro const float* ppi = &amp;amp; pi;
  Teoricamente a região da memória que contiver uma variável const pode ser qualificada pelo sistema operacional como somente-leitura, mas isso não é uma obrigação. É obrigação do compilador avisar sobre tentativas de alteração da variável no meio do programa, mas nem sempre é possível enxergar que a memória não é alterável. Dessa forma, resultados imprevisíveis podem ocorrer.
Uso prático Eu costumo usar variáveis const no lugar de defines. Além de ganhar na tipagem as constantes não precisam ser necessariamente globais, nem acessíveis por outros módulos. Um outro uso muito comum é criar variáveis locais que você sabe que não devem ser alteráveis por ninguém, como o tamanho de matrizes primitivas.
namespace Math{const float Pi = 3.14;}//...int func1(int x){float calc = x * Math::Pi;return calc;}//...int func2(int y){const size_t PathSize = MAX_PATH * 2;//...	char path[PathSize];//...}Volatile O significado do volatile teoricamente muda de implementação para implementação, mas na prática é uma forma de definir uma variável que está sendo acessada por outros programas/threads/entidades espíritas que podem alterar o seu valor sem seu programa notar quando.
O exemplo clássico da API Win32 é o InterlockedIncrement, que realiza operações atômicas em valores inteiros. Para fazer isso é necessário usar um recurso interno disponível pelo processador que irá modificar a memória sem intrusão de outras threads/processadores.
Uso prático Variáveis volatile geralmente interagem de alguma forma com o sistema em que rodam, e são representadas por ponteiros para memória retornada por esse sistema ou documentada como sendo de uso específico.
Const e Volatile É possível que exista uma variável que não pode ser modificada pelo seu programa, mas é modificada pelo sistema, de forma que ela é uma mutante!
/// endereça o relógio do sistema, atualizado a cada 1/100 milissegundosconst volatile int* g_systemClock = (const volatile int*) 0x7689B9D4; 
A definição de *g_systemClock é de uma memória que não pode ser alterada; só que ela é, pelo sistema. Então a variável também é volatile. No entanto, independente de ser const ou volatile, o tipo nunca será alterado, apenas qualificado. São duas coisas diferentes na linguagem.
</description>
</item>

     
        <item>
  <title>Enum</title>
  <link>http://www.caloni.com.br/enum/</link>
  <pubDate>2010-05-31</pubDate>
  
  <guid>http://www.caloni.com.br/enum/</guid>
  <description>Padrão C (ISO/IEC 9899:1990)
6.5.2.2 enum-specifier&amp;lt;strong&amp;gt;enum&amp;lt;/strong&amp;gt;Padrão C&#43;&#43; (ISO/IEC 14882:1998)type-specifierenum-specifierenum-specifier&amp;lt;strong&amp;gt;enum&amp;lt;/strong&amp;gt; Uma enumeração faz duas coisas: define um novo tipo, parecido com um inteiro, e cria uma lista de constantes com nomes significativos. A definição técnica do tipo de um enum é mais complicada, mas basicamente ele é um novo int.
Como funciona: definimos uma lista com cada elemento tendo um valor inteiro, geralmente único. Todos os nomes usados na lista passam a fazer parte do espaço de nomes atual e funcionam como constantes com o seu valor definido no início.
enum FileType // criamos o novo tipo inteiro FileType{Binary = 1, // Binary é uma constante com valor igual a 1 Text = 2, // Text é uma constante com seu sizeof igual a sizeof(FileType) Mixed = 3 // Todas as constantes da enumeração são do mesmo tipo};Obs.: Os elementos que não possuem valor definido são definidos automaticamente como o valor do elemento anterior acrescidos de um. Se for o primeiro elemento, seu valor padrão é zero.
enum Numbers{zero, // igual a zero one, // igual a um two, // igual a dois three // igual a tres};enum Hexa{JulioCesar = 1,Lucio = 3,Juan, // Juan = 3 &#43; 1 = 4 Gilberto Silva = 6,Felipe Melo // 6 &#43; 1 = 7}; Detalhe bizarro: você sabia que, apesar da vírgula ser usada para separar valores de enumeração, ela pode também terminar uma listagem? Por algum motivo exdrúxulo (se alguém quiser explicar), um valor de enumeração foi definido de tal forma que sempre poderá existir uma vírgula terminando ele:
enum VirgulaSafada { um = 1, dois, tres, // o que essa vírgula no final tá fazendo aqui?}; Uso prático Geralmente usamos enumerações para definir valores únicos (tag) em um argumento de função, ou, mais moderno, como substituto daqueles antigos defines em C para mapas de bits. Nesse último caso não usamos o tipo da enumeração, pois ele pode conter apenas um valor único definido, e não um conjunto deles:
enum ModoDeServir{assado,cozido,frito,cru};void Cook(Prato p, ModoDeServir ms);main(){Cook(frango, cozido);}enum FileOpenMode{fomRead = 0x0001,fomWrite = 0x0002,fomOver = 0x0004,fomDel = 0x0008,};void OpenFile(DWORD fileOpenMode);main(){OpenFile(fomRead | fomWrite);} Note que usamos uma enumeração nesse último caso para termos um nome significativo para uma flag, além desse nome fazer de fato parte dos nomes do programa, e não um define que, para o compilador, não existe.
Boas práticas Como os tipos da enumeração passam a pertencer ao namespace atual, eles podem se misturar facilmente com todos os nomes daquele namespace. Dessa forma, é útil e bem organizado definir um prefixo para os nomes, que pode ser formado pelas iniciais do nome da enumeração, como no exemplo acima (fom = FileOpenMode).
O surgimento do enum veio como evolução de uma prática já consagrada pelo uso na linguagem C, que eram as listas de valores constantes criados através de defines com algum prefixo em comum (FILE_SHARE_*, SW_SHOW_*, etc). Portanto, sempre que se encontrar em uma situação para criar esse tipo de lista, a enumeração é o caminho atualmente ideal.
// A listagem abaixo pode virar um enum...#define FOM_READ 0x0001#define FOM_WRITE 0x0002#define FOM_OVER 0x0004#define FOM_DEL 0x0008// ... como este aqui!enum FileOpenMode{FOM_READ = 0x0001,FOM_WRITE = 0x0002,FOM_OVER = 0x0004,FOM_DEL = 0x0008,};// esse pedaço de código abaixo...int main(){OpenFile(path, FOM_WRITE);}// ... vira isso após ser pré-processado...int main(){OpenFile(path, 0x0002);}// ... mas isso se fossem usados enums...int main(){OpenFile(path, FOM_WRITE); // FOM_WRITE faz parte da linguagem}Atualização: e qual a diferença? Perguntado por um leitor sobre qual a diferença prática do último exemplo, onde temos praticamente o mesmo resultado entre usar defines e enumerações, imaginei que a mesma dúvida pode ter surgido para várias pessoas, porque é uma boa dúvida. Dá a entender que o autor deste artigo está se atentando a preciosismos da linguagem (e está mesmo!), mas à vezes as aparências enganam.
Para ilustrar melhor fiz um mais elaborado. Aqui, estamos lendo pedaços de dados que tiveram que ser alinhados com alguma &amp;quot;gordura&amp;quot;.
// alinhamento obrigatório pelo leiaute dos dados#define CHUNKSZ_BASE 0x5000#define CHUNKSZ_TINY 0x1000 &#43; CHUNKSZ_BASE#define CHUNKSZ_SMALL 0x2000 &#43; CHUNKSZ_BASE#define CHUNKSZ_MEDIUM 0x4000 &#43; CHUNKSZ_BASE#define CHUNKSZ_HUGE 0x8000 &#43; CHUNKSZ_BASE// alinhamento obrigatório pelo leiaute dos dadosstatic const int chunkSizeBase = 0x5000;enum ChunkSize{chunkszTiny = 0x1000 &#43; chunkSizeBase,chunkszSmall = 0x2000 &#43; chunkSizeBase,chunkszMedium = 0x4000 &#43; chunkSizeBase,chunkszHuge = 0x8000 &#43; chunkSizeBase,};// Fonte originalint main(){// lendo quadro pedaços de dados (tamanho médio) ReadChunkFromFile(file, CHUNKSZ_MEDIUM * 4);// lendo quadro pedaços de dados (tamanho médio) ReadChunkFromFile(file, chunkszMedium * 4);}// Pós-processadoint main(){// lendo sei lá o que (perde alinhamento) ReadChunkFromFile(file, 0x4000 &#43; CHUNKSZ_BASE * 4);// lendo quadro pedaços de dados (tamanho médio) ReadChunkFromFile(file, chunkszMedium * 4);}Aviso para os programadores mais calejados, eu omiti propositalmente os parênteses obrigatórios para qualquer define que tenha cálculos matemáticos, para ilustrar que muitas vezes o que vemos antes não é o que aparece depois.
</description>
</item>

     
        <item>
  <title>Modificadores e qualificadores de tipo</title>
  <link>http://www.caloni.com.br/modificadores-e-qualificadores-de-tipo/</link>
  <pubDate>2010-05-28</pubDate>
  
  <guid>http://www.caloni.com.br/modificadores-e-qualificadores-de-tipo/</guid>
  <description>Uma coisa de cada vez: existem **modificadores **(ou qualificadores) de tipo e especificadores de tipo. Volatile e extern se encaixam na primeira categoria, enum e union na segunda. Veremos um pouco desses dois lados da linguagem em doses paliativas.
Padrão C (ISO/IEC 9899:1990) 6.5.2.2 enum-specifier&amp;lt;a href=&amp;quot;http://www.caloni.com.br/enum&amp;quot;&amp;gt;enum&amp;lt;/a&amp;gt;6.5.3 type-qualifier&amp;lt;a href=&amp;quot;http://www.caloni.com.br/const-e-volatile&amp;quot;&amp;gt;const&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;http://www.caloni.com.br/const-e-volatile&amp;quot;&amp;gt;volatile&amp;lt;/a&amp;gt;6.5.2.1 struct-or-unionstructunion6.5.1 storage-class-specifiertypedefexternstaticautoregister Padrão C&#43;&#43; (ISO/IEC 14882:1998) type-specifier&amp;lt;a href=&amp;quot;http://www.caloni.com.br/enum&amp;quot;&amp;gt;enum-specifier&amp;lt;/a&amp;gt;enum-specifier&amp;lt;a href=&amp;quot;http://www.caloni.com.br/enum&amp;quot;&amp;gt;enum&amp;lt;/a&amp;gt;cv-qualifier&amp;lt;a href=&amp;quot;http://www.caloni.com.br/const-e-volatile&amp;quot;&amp;gt;const&amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;http://www.caloni.com.br/const-e-volatile&amp;quot;&amp;gt;volatile&amp;lt;/a&amp;gt;class-keyclassstructunionstorage-class-specifierautoregisterstaticexternmutabledecl-specifierstorage-class-specifiertypedef Modificadores de tipo Um modificador de tipo é opcional na definição de um tipo e deve estar sempre relacionado com a declaração de alguma variável. Ele determina, em termos gerais, qual será a função dessa variável. Ela pode ser modificada? Onde ela se encontra no programa? Como ela será modificada?
Como exemplo rápido, temos abaixo uma variável que é atualizada pelo clock do processador e uma variável que não pode ser alterada após sua primeira atribuição:
volatile int* clockSecs = &amp;lt;algum-endereço-do-sistema&amp;gt;;const float pi = 3.14; Fica meio óbvio que a primeira variável possui seu valor volátil, ou seja, muda conforme o tempo passa, e não depende do próprio código (pode mudar sem sua permissão). A segunda variável também tem um uso explícito, uma vez que o valor de pi nunca será alterado (não nesse Universo).
Especificadores de tipo Os especificadores de tipo possuem cada um sua peculiaridade. Os mais peculiares, que veremos nos próximos artigos, serão as enumerações e as construções bizarras de structs e unions.
enum Contador { um = 1, dois, tres, };union Atoms { struct { int part1; int part2; } parts; int64 total; }; Aqui não é um compêndio teórico sobre a linguagem. Vamos falar particularmente da programação Windows, mas esteja livre para dar seus pitacos com respeito a outros sistemas operacionais e suas implementações igualmente exdrúxulas =)
</description>
</item>

     
        <item>
  <title>Analogicamente perfeito</title>
  <link>http://www.caloni.com.br/analogicamente-perfeito/</link>
  <pubDate>2010-05-19</pubDate>
  
  <guid>http://www.caloni.com.br/analogicamente-perfeito/</guid>
  <description>É possível explicar tudo no mundo da informática através de analogias? Pela minha singela experiência de professor informal, eu acredito que sim. Durante esses dois anos, explanei diversos assuntos e, em todos eles, difíceis ou não, consegui um certo grau de sucesso graças ao uso de metáforas e parábolas.
De memória (ou buscando no meu blogue) consigo lembrar alguns tópicos e a forma como os expliquei. Em alguns até fiz um artigo sobre o assunto:
 Ponteiros 16 bits: rua e número de uma casa. Typedefs: apelidos para nomes de pessoas. Depuração: a ciência médica de House. Passagem de argumentos por valor e por referência: e-mails com anexo e com linques. Ponteiros: armário de gavetas. Programadores: programadores de verdade não usam Java (brincadeira). Agendamento de threads: guichê de CPUs. Seções críticas: fila de threads dentro de uma sala. Funções com retorno booleano: o dedo polegar dos romanos. Pilha: uma pilha, só que de pratos e não bytes. Binário: bichos-preguiça contando com seus únicos dois dedos. Tipos: uma forma de bolo que só faz bolos com um único formato. Definições x declarações de variáveis: hardware e software; OK, podemos chamar esse de meta-analogia =) Depuração 2: séries de investigação forense como CSI.  Acredito ser essa a melhor forma de desmistificar esse pequeno mundinho que parece incompreensível aos outros mortais. Até porque tudo que é criado no mundo dos computadores são abstrações do mundo real, que por sua vez são abstrações da mente humana.
É por isso que sempre digo que ciência da computação é uma arte-ciência da área de humanas.
</description>
</item>

     
        <item>
  <title>Por que Long Pointer</title>
  <link>http://www.caloni.com.br/por-que-long-pointer/</link>
  <pubDate>2010-04-21</pubDate>
  
  <guid>http://www.caloni.com.br/por-que-long-pointer/</guid>
  <description>Esse artigo continua a explicação sobre os typedefs arcaicos, já que ainda falta explicar por que diabos os ponteiros da Microsoft começam com LP. Tentei explicar para minha pupila que, por ser código dos anos 80, as pessoas usavam LP para tudo, pois os CDs ainda não estavam tão difundidos.
&amp;lt;span style=&amp;quot;color: #808000;&amp;quot;&amp;gt;/** @brief Para instanciar um Bozo. @date 1982-02-21 */ typedef struct _BOZO { char helloMsg[100]; /* definir para &amp;quot;alô, criançada, o bozo chegou...&amp;quot; */ float currentTime; /* definir para 5e60 */ }BOZO, &amp;lt;strong&amp;gt;&amp;lt;span style=&amp;quot;text-decoration: underline;&amp;quot;&amp;gt;&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;*LP&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/strong&amp;gt;BOZO;&amp;lt;/span&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;span style=&amp;quot;color: #339966;&amp;quot;&amp;gt;/** @brief Para instanciar um Pokemon. @date 1996-03-01 */&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;typedef&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt;struct&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;_PIKACHU&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #ff00ff;&amp;quot;&amp;gt;{&amp;lt;/span&amp;gt; &amp;lt;/strong&amp;gt;&amp;lt;strong&amp;gt;&amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt; char&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;helloMsg&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #ff00ff;&amp;quot;&amp;gt;[&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #00ccff;&amp;quot;&amp;gt;100&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #ff00ff;&amp;quot;&amp;gt;]&amp;lt;/span&amp;gt;; &amp;lt;span style=&amp;quot;color: #339966;&amp;quot;&amp;gt;// setar para &amp;quot;pika, pika pikachuuuuuuu...&amp;quot;&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #0000ff;&amp;quot;&amp;gt; int &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;pokemonID&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #ff00ff;&amp;quot;&amp;gt;;&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #339966;&amp;quot;&amp;gt;// setar para &amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #ff00ff;&amp;quot;&amp;gt;24&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #ff00ff;&amp;quot;&amp;gt;}&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #808080;&amp;quot;&amp;gt;PIKACHU&amp;lt;/span&amp;gt;&amp;lt;span style=&amp;quot;color: #ff00ff;&amp;quot;&amp;gt;,&amp;lt;/span&amp;gt; &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;&amp;lt;span style=&amp;quot;text-decoration: underline;&amp;quot;&amp;gt;*CD&amp;lt;/span&amp;gt;&amp;lt;/span&amp;gt;PIKACHU&amp;lt;span style=&amp;quot;color: #ff00ff;&amp;quot;&amp;gt;;&amp;lt;/span&amp;gt;&amp;lt;/strong&amp;gt; Não colou. Então vou tentar explicar do jeito certo.
Antigamente, as pessoas mandavam cartas umas para as outras. Carta, para você, caro leitor de quinze anos, era um e-mail implementado em hardware.
Para mandar um e-mail, usamos o nome da pessoa e o domínio em que seu e-mail é endereçado, ex: nome-da-pessoa@dominio.com.br. Para mandar uma carta usamos duas informações básicas: o nome da rua e o número da casa.

Consequentemente enviamos dois comandos ao carteiro: meu amigo, vá para a rua tal. Chegando lá, encontre o número 1065.
Considere que estamos falando do mesmo bairro ou cidade, o que na minha analogia seria um computador e sua memória. Para enviar cartas para outros bairros em outras cidades (outros computadores em outras redes) teríamos que informar também outros dados, como nome da cidade e CEP.

Nesse exemplo também podemos usar o Juquinha do bairro para entregar a carta e economizarmos 10 centavos.
Agora, repare que interessante: em uma rua, cabem no máximo N casas. Se você tentar construir mais casas vai acabar invadindo o espaço de outra rua.
E, já que estamos falando do endereço do destinatário, já podemos relevar que esse endereço constitui um ponteiro em nossa analogia. Se você está usando dois dados para informar o endereço, então estamos falando de um ponteiro longo, long pointer, ou LP!

Long Pointers Na terminologia Intel para as plataformas 16 bits, a memória do computador era acessível através de segmentos (ruas) e offsets (números), que eram pedaços da memória onde cabiam no máximo N bytes. Para conseguir mais bytes é necessário alocar memória em outro segmento (outra rua).
Os ponteiros que conseguiam fazer isso eram chamados de long pointers, pois podiam alcançar uma memória mais &amp;quot;longa&amp;quot;. Os ponteiros que apenas endereçavam o offset (número) eram chamados, em detrimento, short pointers, pois podiam apenas apontar para a memória do seu segmento (rua).
Ora, se seu destinatário está na mesma rua que você, tudo que você tem a dizer ao Juquinha é: &amp;quot;Juquinha, seu moleque, entrega essa carta no número 1065, e vai rápido!&amp;quot;. Nesse caso você está usando um short pointer.
Porém, no exemplo que demos, o destinatário está em outra rua. Se o Juquinha entregar a carta no número 1065, mas na rua errada, estará errando o destinatário. Por isso é que você deve usar um long pointer e falar para o Juquinha do segmento!

&amp;quot;Juquinha, seu moleque safado, entrega essa carta no Segmento 0xAC89, Offset 0x496E. E vê se anda logo!&amp;quot;
Essa frase era muito usada nos anos 80, com seus 16 bits e tudo mais.
Voltando ao Windows Com toda essa analogia, fica fácil perceber que o Windows não cabe em uma rua só. Seus aplicativos precisam de muitas ruas para rodar. Isso exige que todos seus ponteiros sejam long, pois do contrário o Juquinha estará entregando as cartas sempre nos endereços errados. Dessa forma, foi estipulado o typedef arcaico padrão para todos os tipos da API que usasse LP (Long Pointer) como prefixo:
typedef unsigned long WORD, *LPDWORD;typedef const char* LPCSTR;typedef &amp;lt;coloque-seu-tipo-aqui&amp;gt; APELIDO, *LPAPELIDO; E é por isso que, historicamente, todos os ponteiros para os apelidos da API Win32 possuem sua contraparte LP.
Com a era 32 bits (e mais atualmente 64 bits) os endereços passaram a ser flat, ou seja, apontam para qualquer lugar na memória. Se eu quisesse continuar minha analogia falaria que é o equivalente a uma coordenada GPS, também muito na moda, e que pode apontar para qualquer lugar do planeta. Eu, por exemplo, já trabalhei trabalhoperto das coordenadas -23.563596,-46.653885, o que eu costumo dizer que fica bem próximo do Paraíso =).
Largando velhos hábitos De uns anos pra cá, existem novos typedefs nos headers que permitem o uso dos apelidos Win32 apenas com um P inicial.
typedef unsigned long WORD, *LPDWORD, *PDWORD;typedef const char *LPCSTR, *PCSTR;typedef &amp;lt;coloque-seu-tipo-aqui&amp;gt; APELIDO, *LPAPELIDO, *PAPELIDO; A escolha é livre. Assim como com o typedef arcaico.
</description>
</item>

     
        <item>
  <title>Typedef arcaico</title>
  <link>http://www.caloni.com.br/typedef-arcaico/</link>
  <pubDate>2010-04-20</pubDate>
  
  <guid>http://www.caloni.com.br/typedef-arcaico/</guid>
  <description>A API do Windows geralmente prima pela excelência em maus exemplos. A Notação Húngara e o Typedef Arcaico são duas técnicas que, por motivos históricos, são usados a torto e a direito pelos códigos de exemplo.
Já foi escrito muita coisa sobre os prós e contras da notação húngara. Já o typedef arcaico, esse pedacinho imprestável de código, ficou esquecido, e hoje em dia traz mais dúvidas na cabeça dos principiantes em C&#43;&#43; do que deveria. Para tentar desobscurecer os mitos e fatos, vamos tentar explicar o que significa essa construção tão atípica, mas comum no dia-a-dia.
Vejamos um exemplo típico desse pequeno Frankenstein semântico:
typedef struct _MINHASTRUCT {int x;int y;}MINHASTRUCT, *LPMINHASTRUCT; Bom, eu nem sei por onde começar. Talvez pelo conceito de typedef.
Typedefs Um typedef, basicamente, é um apelido. Você informa um tipo e define &amp;quot;outro tipo&amp;quot;.
typedef &amp;lt;tipo&amp;gt; apelido; O é tudo que fica entre o typedef e o novo nome, que deve ser um identificador válido na linguagem. Por exemplo, a empresa onde trabalho fez um typedef informal do meu nome:
typedef Wanderley Caloni Wandeco; Se, futuramente, eu sair da empresa e entrar outro &amp;quot;Wanderley alguma-coisa&amp;quot;, será possível usar o apelido novamente, bastando alterar o typedef:
typedef Wanderley Cardoso Wandeco; using namespace std;
struct Struct { int x; int y; };
typedef Struct Struct1; typedef Struct Struct2;
int main() { Struct1 s1; Struct2 s2;
cout &amp;lt;&amp;lt; typeid(s1).name() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; typeid(s2).name() &amp;lt;&amp;lt; endl; }
&amp;lt;/blockquote&amp;gt;&amp;lt;blockquote&amp;gt;&amp;gt; &amp;gt; C:\Tests&amp;gt;cl /EHsc dois_apelidos.cpp&amp;gt; ...&amp;gt; /out:dois_apelidos.exe&amp;gt; dois_apelidos.obj&amp;gt; &amp;gt; C:\Tests&amp;gt;dois_apelidos.exe&amp;gt; struct Struct struct Struct&amp;lt;/blockquote&amp;gt;#### Granularidade dos tiposTipos simples são fáceis de entender porque possuem seus símbolos no mesmo lugar:int x;char c;long p;Já os tipos um pouco mais complicados permite alguma mudança aqui e acolá:int*x;char *y;long *p;Essa liberdade da linguagem, mesmo sendo um recurso útil, pode ser bem nocivo dependendo de quem olha o código:int x, y; // dois inteirosint * x, y; // um ponteiro para inteiro e um inteiroint x, *y; // um inteiro e um ponteiro para inteiroint *x, y; // um ponteiro para inteiro e um inteiroEm algumas formas da sintaxe, além de ser inevitável, gera bastante desconfiança:// Um ponteiro para função que recebe dois inteiros e não retorna nada.typedefvoid (*FP)(int, int);// Um ponteiro para função que recebe dois inteiros e não retorna nada.void (*)(int, int);// Um cast para ponteiro para função que recebe dois inteiros e não retorna nada.( (void (*)(int, int)) pf )(x, y);```cpp#include &amp;lt;iostream&amp;gt;void func(int x, int y){std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &#39;-&#39; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &#39;\n&#39;;}int main(){void* pf = func;( ( void (*)(int, int) ) pf )(3, 14);}Structs em C&#43;&#43; Antigamente, as structs eram construções em C que definiam um agregado de tipos primitivos (ou outras structs) e que poderiam gerar variáveis desse tipo em qualquer lugar, desde que informado seu nome e que se tratasse de uma struct:
/** @file structs.cpp */struct MyStruct { int x, y; };void func1(){struct MyStruct ms;//...}void func2(struct MyStruct msa){//...}int main(){struct MyStruct ms;func2(ms);}Para evitar toda essa digitação, os programadores usavam um pequeno truque criando um apelido para a estrutura, e usavam o apelido no lugar da struct (apesar de ambas representarem a mesma coisa).
struct MyStruct
 { int x, y; };typedef struct MyStruct
 MS; ou
typedef struct MyStruct { int x, y; } MS; struct MyStruct
 ms1; // ainda prolixo MS
 ms2; // mais simples Com a definição da linguagem C&#43;&#43; padrão, e mais moderna, essa antiguidade foi removida, apesar de ainda suportada. Era possível usar apenas o nome do struct como seu tipo:
/** @file structs.cpp */struct MyStruct { int x, y; };void func1(){/*struct*/ MyStruct ms;//...}void func2(/*struct*/ MyStruct msa){//...}int main(){/*struct*/ MyStruct ms;func2(ms);}Porém, isso vai um pouco além de quando a Microsoft começou a fazer código para seu sistema operacional. Naquela época, o padrão ainda estava se formando e existia mais ou menos um consenso de como seria a linguagem C&#43;&#43; (sem muitas alterações do que de fato a linguagem C já era). De qualquer forma, a linguagem C imperava bem mais que C&#43;&#43;. Dessa forma, já era bem formada a ideia de como declarar uma struct: a forma antiga.
typedef struct _MINHASTRUCT {int x;int y;}MINHASTRUCT, *LPMINHASTRUCT; Além do uso controverso do** _sublinhado** para nomear entidades (que no padrão foi recomendado que se reservasse aos nomes internos da biblioteca-padrão) e do uso de **MAÍUSCULAS_NO_NOME** (historicamente atribuído a nomes definidos no pré-processador), o uso do typedef atracado a um struct era muito difundido. E ficou ainda mais depois que a API do Windows foi publicada com essas definições.
Como fazer,então? Ora, do mesmo jeito que é feito há vinte anos: sem typedefs. O próprio paradigma da linguagem, independente de padrões de APIs, de sistemas operacionais ou de projetos específicos já orienta o programador para entender o que o espera na leitura de um código-fonte qualquer. Qualquer pessoa que aprendeu o básico do básico sobre ponteiros e structs consegue ler o código abaixo:
// Papai, o que que é isso?// Ora, filho, apenas uma definição de estrutura!//struct MinhaStruct {int x;int y;};// muitas linhas abaixo...void func(MinhaStruct* ms){// asterisco significa ponteiro para MinhaStruct!}int main(){MinhaStruct ms;func(&amp;amp;ms);}Agora, para entender a forma antiga, ou você se baseou no copy&amp;amp;paste dos modelos Microsoftianos, ou seja, decoreba, ou você é PhD em Linguagem C/C&#43;&#43; e padrões históricos de linguagens legadas. Se não é, deveria começar o curso agora.
// Papai, o que que é isso?// Ora, filho, apenas uma definição de sinônimo da struct// _MINHASTRUCT, cujo nome não é usado, para dois nomes// em maiúsculas, apesar se não serem defines, com uma// nomenclatura de ponteiro que eu nunca vi na vida (obs: // papai programa em um sistema não-Windows).//typedef struct _MINHASTRUCT {int x;int y;}MINHASTRUCT, *LPMINHASTRUCT;// muitas linhas abaixo...void func(LPMINHASTRUCT ms){// o que diabos é um LP, mesmo?}int main(){MINHASTRUCT ms;func(&amp;amp;ms);}Da mesma forma, o uso de uma estrutura simples de tipos mantém a lista de nomes do seu projeto limpa e clara. Compare o visualizador de classes em projetos Windows com algo mais C&#43;&#43; para ter uma ideia.
É claro, essa é apenas uma sugestão. Existem vantagens em sua utilização. Existe alguma vantagem no modo antigo? Existe: a Microsoft usa, e talvez mais pessoas usem. Basta a você decidir qual deve ser o melhor caminho.
Atualização De acordo com o leitor Adriano dos Santos Fernandes, a obrigatoriedade do nome struct após seu nome continua valendo para a linguagem C padrão, assim como no compilador GCC ocorre um erro ao tentar omiti-la. Apenas na linguagem C&#43;&#43; essa obrigatoriedade não existe mais.
Eu não fiz meus testes, mas confio no diagnóstico de nosso amigo. A maior falha do artigo, no entanto, é usar a linguagem C como base, quando na verdade ele deveria falar sobre o uso desses typedefs em C&#43;&#43;. Esse erro também foi corrigido no original.
</description>
</item>

     
        <item>
  <title>Using TodoList and Microsoft Project together</title>
  <link>http://www.caloni.com.br/using-todolist-and-microsoft-project-together/</link>
  <pubDate>2010-04-10</pubDate>
  
  <guid>http://www.caloni.com.br/using-todolist-and-microsoft-project-together/</guid>
  <description>The next article about bits is still in the oven. Taking vacation (40 days) had drop me out of ideas! At the moment, I can explain the tips and tricks using TodoList to manage my team and synchronize my tasks in a Microsoft Project timesheet.
The reasons why I am using TodoList are kind of obvious: it does everything I need to organize my day to day tasks and it is portable. Meanwhile, the Project, besides not being portable (I need to carry on with me a 200 MB installer? And do install?) it uses a hard to change format and it was made to project the world, and not to be easily shared.
So, let&#39;s go. Everything we need is a current edition of TodoList and Microsoft Project. The first thing we must to do é to export the tasks we want to a default CSV, using the columns we would like to import to Project:
After that it comes the tricky thing, but not so much. We open the project to where we want to import the tasks and choose the option Open again, but this time we select our friend exported-tasks.CSV.
Before we do import, we got to create a new column that will keep the TodoList tasks IDs, to make sure that in the next imports we make we could merge datum together. So, create this column using a significant name.
Now we can go on the import process. Imagining to be the first one, let&#39;s create a inicial map for this migration:
The time we choose who is who in the columns list, we just need to setup which columns in Project are the counterpart for the columns in TodoList, and remember to allocate our special column ID.
Just more a few Nexts and voilà! We got our tasks properly imported.
But of course all this work would be useless if we had to (sigh) open the Project. To avoid this impure job, we keep on updating the project status in our tiny, tidy TodoList and, when we need, we just import the data again, but this time using a already saved map (follow the screenshots above) and setting our TodoList ID as the key. This way the tasks already present will be just updated, and the unknown tasks will be added. That&#39;s the most important trick in this post.
After I researched all this, I just found out the Project won&#39;t be necessary anymore. Lucky me. Now, if you don&#39;t have such luck, you can use this post =)
</description>
</item>

     
        <item>
  <title>Houaiss Para Babylon!</title>
  <link>http://www.caloni.com.br/houaiss-para-babylon-12/</link>
  <pubDate>2010-04-08</pubDate>
  
  <guid>http://www.caloni.com.br/houaiss-para-babylon-12/</guid>
  <description>Os últimos comentários de Henrique Esteves (quando havia seção de comentários no blogue) sobre o HouaissParaBabylon me fizeram dar mais uma fuçada nele e ver se tento deixá-lo compatível com o Houaiss 3. Foram apenas algumas horas e acho que resolvi os probleminhas relacionados com a troca do registro de instalação e o nome dos arquivos que armazenam os verbetes.
Apenas para constar, segue a lista de artigos sobre este projeto:
 Conversor de Houaiss para Babylon - parte 1 Conversor de Houaiss para Babylon - parte 2 Segunda versão do Houaiss2Babylon HouaissParaBabylon versão beta HouaissParaBabylon versão 1.1  Foi uma odisseia e tanto. E ainda está longe de ser perfeito. Contudo, fico feliz que muitas pessoas já tenham conseguido usá-lo com sucesso e com a qualidade técnica dos meus visitantes. O Henrique, por exemplo, teve que entender o processo interno que o programa faz para renomear os arquivos do dicionário e assim conseguir a conversão. Pessoas como essa faltam na equipe de suporte técnico de programadores de baixaria.
Isso me faz lembrar que uma das motivações do programador, fora programar, é saber que os usuários usam seu programa. E saber que existem melhorias a ser feitas que vão ser úteis para esses usuários é muito legal. Por isso, continuem assim, caros usuários. E bom proveito!
Obs.: Essa versão foi testada em um Windows XP com o Houaiss 3, Babylon 8 e o Babylon Builder mais atual.
</description>
</item>

     
        <item>
  <title>Convivendo entre TodoList e Microsoft Project</title>
  <link>http://www.caloni.com.br/convivendo-entre-todolist-e-microsoft-project/</link>
  <pubDate>2010-03-15</pubDate>
  
  <guid>http://www.caloni.com.br/convivendo-entre-todolist-e-microsoft-project/</guid>
  <description>O próximo artigo sobre escovação de bits ainda está no forno. Tirar férias (de 40 dias) é uma escassez de ideias! No momento, posso explicar a facilidade que tive para continuar usando o TodoList para gerenciar minha equipe e ainda assim sincronizar nossas tarefas em um cronograma do Microsoft Project.
As razões de eu usar o TodoList são meio óbvias: ele faz tudo que eu preciso para organizar minhas tarefas do dia-a-dia e é portátil. Enquanto isso, o Project, além de não ser portátil (eu preciso levar comigo o instalador de 200 MB? E Instalar?) possui um formato difícil de mudar, já que foi feito para projetar o mundo e não para ser compartilhado facilmente.
Mas vamos lá. Tudo que precisamos é de uma edição atual do TodoList e do Microsoft Project. A primeira coisa que devemos fazer é exportar as tarefas que queremos do TodoList para um CSV padrão, usando as colunas que gostaríamos de importar para o Project:
Depois vem a parte complicada, mas nem tanto. Abrimos o projeto para onde queremos importar essas tarefas e escolhemos a opção Abrir novamente, só que dessa vez selecionando o nosso amigo tarefas-exportadas.CSV.
Só que antes de importarmos, calma lá. Temos que criar uma nova coluna que irá guardar os IDs das tarefas do TodoList, para que nas próximas importações consigamos mesclar os dados já existentes. Portanto, crie uma nova coluna (pode ser qualquer NúmeroX não-alocado ainda) com um nome significativo.
Agora podemos partir para a importação. Imaginando que seja a primeira, vamos criar um mapeamento inicial para essa primeira migração:
Na hora de escolher quem é que, só precisamos definir quais colunas no Project correspondem a quais colunas do TodoList, e lembrar de alocar o ID na nossa coluna especial.
Mais alguns Next da vida e pronto! Temos nossas tarefas devidamente importadas.
Mas é claro que todo esse trabalho não valeria a pena se tivéssemos que (arght) mexer no Project. Para evitar esse trabalho impuro, continuamos atualizando o andamento dos projetos no nosso pequeno, leve e sagaz TodoList e, quando precisarmos, é só importarmos novamente os dados, só que dessa vez usando um mapa já salvo (siga os screenshots acima) e marcando nosso ID do TodoList como chave. Dessa forma as tarefas já importadas são apenas atualizadas, e não criadas novamente. Esse é o famoso &amp;quot;pulo do gato&amp;quot; (que eu ouvia matinalmente na minha época de office-boy).
Depois de eu pesquisar toda essa trama, descobri que o uso do Project não será necessário. Sorte minha. Agora, se você não tiver sorte...
</description>
</item>

     
        <item>
  <title>Correção de bugs instantânea</title>
  <link>http://www.caloni.com.br/correcao-de-bugs-instantanea/</link>
  <pubDate>2010-02-01</pubDate>
  
  <guid>http://www.caloni.com.br/correcao-de-bugs-instantanea/</guid>
  <description>Um programador tarimbado sabe que a melhor situação da vida dele para corrigir um bug é quando esse bug acontece em sua máquina de desenvolvimento, na versão Debug e ainda passo-a-passo. Como nessa situação a correção é um verdadeiro &amp;quot;passeio no parque&amp;quot; (ou na mesa do café) ela tende a quase nunca acontecer. Isso é Murphy Aplicado.
Para quem programa para sistemas, então, só o fato de acontecer no mesmo processo toda vez que ele for executado já é o máximo (quem já programou serviços, plugins, GINAs e afins sabe do que eu estou falando).
Porém, saber que uma determinada situação é mel na chupeta (by Thiago) por si só não adianta de muita coisa. É preciso conhecer as verdadeiras técnicas ninjas que conseguem resolver um bug escabroso num instante, coisa de deixar seu gerente de projetos tão feliz ao ponto dele não botar nenhum defeito na solução.
Dentre as mais conhecidas entre os malloqueiros, temos:
  Comenta-descomenta-comenta
  Faz do zero
  Essas duas técnicas são tão úteis e tão fáceis de usar que merecem um artigo a respeito.
Essa técnica milenar corresponde em tirar pedaços do código-fonte que poderiam estar causando o problema até que seja possível criar uma versão em que o problema não ocorra mais. Quando chega-se nesse nível, então volta-se a descomentar o código retirado até que o problema ocorra novamente. O processo é um fluxo de tira-código com volta-código, sendo que é necessário o bom conhecimento do projeto para não gerar outros problemas com a mutilação temporária do projeto.
Se o código começa a ser tão mutilado que chegamos quase em uma versão vazia (sem código), então talvez a melhor forma de atacar o problema seja criar um esqueleto que contenha apenas o código necessário para que ele não faça nada. Isso mesmo. Não fazendo nada, mas instalado. Com isso prova-se que é possível estar lá sem fazer cagadas. A partir daí vai colocando-se o código do projeto real aos poucos no projeto-esqueleto, até que ele apresente o problema. Ou não. Já vi casos em que todo o código foi migrado e o problema sumiu. Ce la vie.
</description>
</item>

     
        <item>
  <title>Passagem por valor e emails com anexo</title>
  <link>http://www.caloni.com.br/passagem-por-valor-e-emails-com-anexo/</link>
  <pubDate>2010-01-18</pubDate>
  
  <guid>http://www.caloni.com.br/passagem-por-valor-e-emails-com-anexo/</guid>
  <description>Mais uma analogia vencedora para ponteiros, chamadas por valor e chamadas por referência: e-mails.
Quando passamos um parâmetro por valor, estamos enviando um e-mail com um arquivo em anexo. Não importa o que o destinatário faça com o arquivo: nós não vamos saber o que foi mudado se ele não enviar uma outra cópia.
Por outro lado, ao passar um parâmetro por referência, estamos enviando um e-mail com um endereço de onde está o arquivo. Se o usuário alterar o arquivo diretamente do endereço que enviamos será possível ver essa alteração imediatamente, pois ambos estão olhando para o mesmo valor na memória.
A analogia pode ser levada mais longe, com ponteiros de ponteiros: enviamos um e-mail com o endereço de um arquivo; dentro desse arquivo existe um endereço para outro arquivo. Dessa forma é possível tanto alterar o arquivo final quanto o endereço de onde ele está; ou ainda &amp;quot;apontar&amp;quot; para outro arquivo, trocando o endereço de dentro do primeiro arquivo.
Assim é fácil de visualizar que os dados estão sempre em um arquivo que ocupa espaço na memória (do disco ou da RAM), mas endereços também podem ocupar espaço, se estiverem salvos em um arquivo.
Dessa forma, um e-mail que contenha um arquivo em anexo vai ser muito maior que um e-mail apenas com o endereço do arquivo, mas é porque todo o conteúdo do arquivo está dentro do e-mail no primeiro caso. No segundo caso, o endereço ocupa apenas alguns caracteres que identificam a localização do arquivo.
</description>
</item>

     
        <item>
  <title>Importando tipos de outros projetos</title>
  <link>http://www.caloni.com.br/importando-tipos-de-outros-projetos/</link>
  <pubDate>2010-01-11</pubDate>
  
  <guid>http://www.caloni.com.br/importando-tipos-de-outros-projetos/</guid>
  <description>A engenharia reversa das entranhas do kernel não tem limites se você sabe o que está fazendo. No entanto, algumas facilidades do depurador podem ajudar a minimizar o tempo que gastamos para analisar uma simples estrutura. Por exemplo, o Process Environment Block de um processo específico.
windbg -klMicrosoft (R) Windows Debugger Version 6.9.0003.113 X86Copyright (c) Microsoft Corporation. All rights reserved.Connected to Windows XP 2600 x86 compatible target, ptr64 FALSESymbol search path is: SRV*c:\tools\symbols*http://msdl.microsoft.com/download/symbolsExecutable search path is:*******************************************************************************WARNING: Local kernel debugging requires booting with kerneldebugging support (/debug or bcdedit -debug on) to work optimally.*******************************************************************************Windows XP Kernel Version 2600 (Service Pack 3) MP (2 procs) Free x86 compatibleProduct: WinNt, suite: TerminalServer SingleUserTSBuilt by: 2600.xpsp_sp3_gdr.090804-1435Kernel base = 0x804d7000 PsLoadedModuleList = 0x8055d720Debug session time: Mon Jan 11 10:36:50.061 2010 (GMT-2)System Uptime: 5 days 1:05:24.958Microsoft (R) Windows Debugger Version 6.9.0003.113 X86Copyright (c) Microsoft Corporation. All rights reserved.lkd&amp;gt; !process 0 0 notepad.exe&amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;PROCESS 89068700 &amp;lt;/font&amp;gt; SessionId: 0 Cid: 0ec4 &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt; Peb: 7ffda000&amp;lt;/font&amp;gt; ParentCid: 0b0cDirBase: 0ac80a80 ObjectTable: e143a7d8 HandleCount: 152.Image: notepad.exe O comando !peb traz inúmeras informações sobre essa estrutura. Mas talvez estivéssemos interessados em coisas não mostradas por esse comando, mas que existem na estrutura.
Nesse caso, podemos criar um projeto vazio que contenha a definição da estrutura como acreditamos que esteja na versão do kernel que estamos depurando.
Compilamos e geramos um PDB (arquivo de símbolos) que contém a definição desse tipo. Tudo que precisamos fazer agora é carregar esse símbolo na sessão que estivermos depurando.
É claro que nosso executável não vai existir na sessão de kernel local, mas isso não importa. Podemos usar qualquer módulo carregado e usá-lo como _host _de nosso conjunto de símbolos:
lkd&amp;gt; lmstart end module name804d7000 806e5000 nt (pdb symbols) c:\tools\symbols\ntkrpamp.pdb\D8743252F83B4F59985D6E19F33BFCAF1\ntkrpamp.pdbUnloaded modules:a5513000 a553e000 kmixer.sys&amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;bac50000 bac57000 USBSTOR.SYS&amp;lt;/font&amp;gt;a5711000 a5746000 truecrypt.sysa5731000 a5746000 wudfrd.sysa5a19000 a5a23000 wpdusb.sys...a5731000 a5746000 wudfrd.sysa57a9000 a57b3000 wpdusb.sysa571b000 a5746000 kmixer.sysbabf0000 babf5000 Cdaudio.SYSba489000 ba48c000 Sfloppy.SYSbabe8000 babed000 Flpydisk.SYSbabe0000 babe7000 Fdc.SYS ------ Build started: Project: KernelTypes, Configuration: Debug Win32 ------Compiling...KernelTypes.cppLinking...LINK : program database c:\Tests\KernelTypes\Debug\&amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;KernelTypes.pdb&amp;lt;/font&amp;gt; missing; performing full linkEmbedding manifest...Build log was saved at &amp;quot;file://c:\Tests\KernelTypes\Debug\BuildLog.htm&amp;quot;KernelTypes - 0 error(s), 0 warning(s)========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========Microsoft Windows XP [versÎáÎ÷Îýo 5.1.2600](C) Copyright 1985-2001 Microsoft Corp.C:\Tests\KernelTypes\Debug&amp;gt;ren KernelTypes.pdb &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;usbstor.pdb&amp;lt;/font&amp;gt;lkd&amp;gt; .sympath C:\Tests\KernelTypes\DebugSymbol search path is: C:\Tests\KernelTypes\Debug&amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;lkd&amp;gt; .reload /i /f usbstor.sys&amp;lt;/font&amp;gt;lkd&amp;gt; lm m usb*start end module namebac60000 bac66700 USBSTOR M (private pdb symbols) &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;C:\Tests\KernelTypes\Debug\usbstor.pdb&amp;lt;/font&amp;gt; Depois que o símbolo foi carregado em nosso módulo de mentirinha, tudo que temos a fazer é alterar o contexto do processo atual (para que os endereços de user mode façam sentido) e moldar nossa memória com o comando dt, usando o tipo importado do símbolo carregado.
lkd&amp;gt; .process 89068700Implicit process is now 89068700lkd&amp;gt; dt &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;usbstor!_peb&amp;lt;/font&amp;gt; 7ffda000&#43;0x000 InheritedAddressSpace : 0xdc &#39;&#39;&#43;0x001 ReadImageFileExecOptions : 0xff &#39;&#39;&#43;0x002 BeingDebugged : 0x35 &#39;5&#39;&#43;0x003 SpareBool : 0x1 &#39;&#39;&#43;0x004 Mutant : 0x01360000&#43;0x008 ImageBaseAddress : 0x0135e000&#43;0x00c Ldr : (null)&#43;0x010 ProcessParameters : 0x00001e00 _RTL_USER_PROCESS_PARAMETERS&#43;0x014 SubSystemData : (null)&#43;0x018 ProcessHeap : 0x7ffda000&#43;0x01c FastPebLock : (null)&#43;0x020 SparePtr1 : 0x00000efc&#43;0x024 SparePtr2 : 0x000008b8&#43;0x028 EnvironmentUpdateCount : 0&#43;0x02c KernelCallbackTable : (null)&#43;0x030 SystemReserved : [1] 0x7ffde000&#43;0x034 ExecuteOptions : 0y00&#43;0x034 SpareBits : 0y000000000000000000000011111100 (0xfc)&#43;0x038 FreeList : (null)&#43;0x03c TlsExpansionCounter : 0... Para que isso funcione, a estrutura definida tem que bater offset por offset com os dados na memória, o que envolve alinhamento (se lembre do pragma pack) e versionamento corretos. Se isso não ocorrer, logo aparecerá algum lixo nos membros da estrutura que não fará sentido. Se isso ocorrer, detecte onde o lixo começa e verifique se o membro existe nessa versão do sistema operacional, ou se o alinhamento está de acordo com o módulo analisado.
Acho que não é preciso dizer que isso não serve apenas para kernel mode =)
</description>
</item>

     
        <item>
  <title>O boot no Windows: Kernel</title>
  <link>http://www.caloni.com.br/o-boot-no-windows-kernel/</link>
  <pubDate>2009-12-04</pubDate>
  
  <guid>http://www.caloni.com.br/o-boot-no-windows-kernel/</guid>
  <description>Finalmente chegamos em um pouco onde podemos usar o WinDbg.
Podemos espetar o depurador e fazê-lo parar assim que conectado. Se estiver rodando antes do próprio sistema operacional, teremos um sistema sem processos e sem threads, pois ele irá parar assim que o executivo puder enviar o sinal de início pela porta serial, após carregar na memória os módulos básicos.
windbg -k com:pipe,port=\\.\pipe\com_1 &amp;lt;strong&amp;gt;&amp;lt;font color=&amp;quot;#000000&amp;quot;&amp;gt;-b&amp;lt;/font&amp;gt;&amp;lt;/strong&amp;gt;Microsoft (R) Windows Debugger Version 6.11.0001.404 AMD64Copyright (c) Microsoft Corporation. All rights reserved.Opened \\.\pipe\com_1Waiting to reconnect...Connected to Windows XP 2600 x86 compatible target at (Tue Sep 8 22:33:27.267 2009 (GMT-3)), ptr64 FALSEKernel Debugger connection established. (Initial Breakpoint requested)Symbol search path is: *** Invalid ******************************************************************************** Symbol loading may be unreliable without a symbol search path. ** Use .symfix to have the debugger choose a symbol path. ** After setting your symbol path, use .reload to refresh symbol locations. *****************************************************************************Executable search path is:********************************************************************** Symbols can not be loaded because symbol path is not initialized. ** ** The Symbol Path can be set by: ** using the _NT_SYMBOL_PATH environment variable. ** using the -y &amp;lt;symbol_path&amp;gt; argument when starting the debugger. ** using .sympath and .sympath&#43; ************************************************************************* ERROR: Symbol file could not be found. Defaulted to export symbols for ntkrnlpa.exe -Windows XP Kernel Version 2600 UP Free x86 compatibleBuilt by: 2600.xpsp_sp2_rtm.040803-2158Machine Name:Kernel base = 0x804d7000 PsLoadedModuleList = 0x805531a0System Uptime: not availableBreak instruction exception - code 80000003 (first chance)******************************************************************************** ** You are seeing this message because you pressed either ** CTRL&#43;C (if you run kd.exe) or, ** CTRL&#43;BREAK (if you run WinDBG), ** on your debugger machine&#39;s keyboard. ** ** THIS IS NOT A BUG OR A SYSTEM CRASH ** ** If you did not intend to break into the debugger, press the &amp;quot;g&amp;quot; key, then ** press the &amp;quot;Enter&amp;quot; key now. This message might immediately reappear. If it ** does, press &amp;quot;g&amp;quot; and &amp;quot;Enter&amp;quot; again. ** *********************************************************************************** ERROR: Symbol file could not be found. Defaulted to export symbols for ntkrnlpa.exe -nt!DbgBreakPointWithStatus&#43;0x4:80526da8 cc int 3kd&amp;gt; lmstart end module name804d7000 806ce300 nt (export symbols) ntkrnlpa.exe806cf000 806ef380 hal (deferred)f96f0000 f970a580 Mup (deferred)f970b000 f9737a80 NDIS (deferred)f9738000 f97c4480 Ntfs (deferred)f97c5000 f97db780 KSecDD (deferred)f97dc000 f97edf00 sr (deferred)f97ee000 f980c780 fltMgr (deferred)f980d000 f9824800 SCSIPORT (deferred)f9825000 f983c480 atapi (deferred)f983d000 f985bb80 ftdisk (deferred)f985c000 f986cd80 pci (deferred)f986d000 f989b000 ACPI (deferred)f999c000 f99a4d80 isapnp (deferred)f99ac000 f99b6500 MountMgr (deferred)f99bc000 f99c9000 VolSnap (deferred)f99cc000 f99d4e00 disk (deferred)f99dc000 f99e8200 CLASSPNP (deferred)f99ec000 f99f6580 agp440 (deferred)f9c1c000 f9c22200 PCIIDEX (deferred)f9c24000 f9c28900 PartMgr (deferred)f9dac000 f9daf000 BOOTVID (deferred)f9db0000 f9db2480 compbatt (deferred)f9db4000 f9db7700 BATTC (deferred)f9db8000 f9dbab00 vmscsi (deferred)f9e9c000 f9e9db80 kdcom (deferred)f9e9e000 f9e9f100 WMILIB (deferred)f9ea0000 f9ea1600 intelide (deferred)kd&amp;gt; .sympathSymbol search path is: &amp;lt;empty&amp;gt;Expanded Symbol search path is: &amp;lt;empty&amp;gt;kd&amp;gt; .symfixkd&amp;gt; .sympathSymbol search path is: srv*Expanded Symbol search path is: cache*C:\Tools\DbgTools\sym;SRV*http://msdl.microsoft.com/download/symbolskd&amp;gt; !process 0 0**** NT ACTIVE PROCESS DUMP ****NT symbols are incorrect, please fix symbolskd&amp;gt; .reloadConnected to Windows XP 2600 x86 compatible target at (Tue Sep 8 22:34:41.661 2009 (GMT-3)), ptr64 FALSELoading Kernel Symbols...........................Loading User Symbolskd&amp;gt; !process 0 0**** NT ACTIVE PROCESS DUMP ****NULL value in PsActiveProcess List&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt; &amp;lt;strong&amp;gt;&amp;lt;font color=&amp;quot;#000000&amp;quot;&amp;gt; &amp;lt;-- Nenhum processo por aqui&amp;lt;/font&amp;gt;&amp;lt;/strong&amp;gt;&amp;lt;/font&amp;gt;kd&amp;gt; !thread0 0No export thread0 foundkd&amp;gt; !thread 0 000000000: Unable to get thread content&amp;lt;font color=&amp;quot;#000000&amp;quot;&amp;gt;s&amp;lt;/font&amp;gt;&amp;lt;font color=&amp;quot;#000000&amp;quot;&amp;gt; &amp;lt;strong&amp;gt; &amp;lt;-- Nenhuma thread também!&amp;lt;/strong&amp;gt;&amp;lt;/font&amp;gt;kd&amp;gt; reax=00000001 ebx=80087000 ecx=80548c74 edx=80548c44 esi=80087000 edi=00000000eip=80526da8 esp=80548c60 ebp=80548de8 iopl=0 nv up ei pl nz na po nccs=0008 ss=0010 ds=0023 es=0023 fs=0030 gs=0000 efl=00000202nt!RtlpBreakWithStatusInstruction:80526da8 cc int 3kd&amp;gt; kChildEBP RetAddr80548c5c 80682baa nt!RtlpBreakWithStatusInstruction80548de8 8068fd48 nt!ExpInitializeExecutive&#43;0x35080548e3c 8068d99b nt!KiInitializeKernel&#43;0x3b200000000 00000000 nt!KiSystemStartup&#43;0x2bfkd&amp;gt; kvChildEBP RetAddr Args to Child80548c5c 80682baa 00000001 80551920 00000000 nt!RtlpBreakWithStatusInstruction (FPO: [1,0,0])80548de8 8068fd48 00000000 80087000 8003fc00 nt!ExpInitializeExecutive&#43;0x350 (FPO: [2,93,4])80548e3c 8068d99b 80551b80 80551920 80549100 nt!KiInitializeKernel&#43;0x3b2 (FPO: [Non-Fpo])00000000 00000000 00000000 00000000 00000000 nt!KiSystemStartup&#43;0x2bf Todos os módulos carregados antes dessa fase são os drivers que tiveram seu Start definido em zero no registro. Todos os programadores que desenvolvem esses drivers gostariam de um dia poder usar o WinDbg. Mas não podem. Quem inicia a comunicação serial com o depurador é o kernel, que só recebe o controle do ntldr depois que os drivers básicos foram carregados.
Brincadeira. É claro que esses programadores usam o WinDbg, usam até demais. Mas só a partir desse ponto. Se algum problema evitar que o sistema chegue nessa fase, o desenvolvedor terá que usar métodos alternativos de depuração, como teste de mesa (risos incontroláveis).
De qualquer forma, estamos aí. Agora podemos depurar a criação de qualquer thread, qualquer processo, o carregamento de qualquer módulo, e a chamada a qualquer função do kernel.
Para depurar a criação de qualquer thread: coloque um breakpoint na função PsCreateSystemThread.
kd&amp;gt; bp PsCreateSystemThreadkd&amp;gt; bl0 e 805c732e 0001 (0001) nt!PsCreateSystemThreadkd&amp;gt; gBreakpoint 0 hitnt!PsCreateSystemThread:805c732e 8bff mov edi,edikd&amp;gt; kChildEBP RetAddr805499a8 8069c17e nt!PsCreateSystemThread80549a4c 8069c419 nt!PspInitPhase0&#43;0x3f0&amp;lt;strong&amp;gt;80549a58 8068509c nt!PsInitSystem&#43;0x33&amp;lt;/strong&amp;gt;80549be8 80691f28 nt!ExpInitializeExecutive&#43;0x74280549c3c 8068fa9f nt!KiInitializeKernel&#43;0x3b200000000 00000000 nt!KiSystemStartup&#43;0x2bf Para depurar a criação de qualquer processo: coloque um breakpoint na função PspCreateProcess, logo no começo. Será possível capturar a criação do processo System, o processo onde roda a primeira thread do kernel, que inicializa o resto dos componentes.
kd&amp;gt; bp PspCreateProcesskd&amp;gt; bl0 e 805c6a8c 0001 (0001) nt!PspCreateProcesskd&amp;gt; gBreakpoint 0 hitnt!PspCreateProcess:805c6a8c 681c010000 push 11Chkd&amp;gt; kChildEBP RetAddr805499a0 8069c0dc nt!PspCreateProcess&amp;lt;strong&amp;gt;80549a4c 8069c419 nt!PspInitPhase0&#43;0x34e&amp;lt;/strong&amp;gt;80549a58 8068509c nt!PsInitSystem&#43;0x3380549be8 80691f28 nt!ExpInitializeExecutive&#43;0x74280549c3c 8068fa9f nt!KiInitializeKernel&#43;0x3b200000000 00000000 nt!KiSystemStartup&#43;0x2bf E não é lindo ver que, após a chamada ao Process Manager o processo REALMENTE foi criado e está na lista de processos?
kd&amp;gt; !process 0 0**** NT ACTIVE PROCESS DUMP ****TYPE mismatch for process object at 8055a0d0kd&amp;gt; gunt!PspInitPhase0&#43;0x34e:8069c0dc 85c0 test eax,eaxkd&amp;gt; !process 0 0**** NT ACTIVE PROCESS DUMP ****PROCESS 81bcc830 SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000DirBase: 00319000 ObjectTable: e1000cc0 HandleCount: 1.&amp;lt;strong&amp;gt; Image: System Process&amp;lt;/strong&amp;gt; É nesse momento que percebemos que um processo, uma thread, um qualquer-coisa dentro do kernel não é nada mais nada menos que um item em uma lista. Quase tudo no kernel será um item numa lista com um monte de ponteiros referenciando outras estruturas. É isso que mantém a lógica e a coerência no sistema inteiro. Tudo isso é basicamente software, construído como castelos no ar.
O próximo processo a ser criado, logo após carregar todos os drivers, é o nosso amigo SMSS, o Gerenciador de Sessão, o primeiro pedacinho do iceberg que desponta no oceano. É ele que irá iniciar toda a &amp;quot;parte user-mode do kernel&amp;quot;.
Breakpoint 0 hitnt!PspCreateProcess:805c6a8c 681c010000 push 11Chkd&amp;gt; kvChildEBP RetAddr Args to Childf9dc365c 805c73e1 f9dc3858 001f0fff f9dc37c0 nt!PspCreateProcess (FPO: [Non-Fpo])f9dc36b0 805c745d f9dc3858 001f0fff f9dc37c0 nt!NtCreateProcessEx&#43;0x77 (FPO: [Non-Fpo])f9dc36dc 8053d638 f9dc3858 001f0fff f9dc37c0 nt!NtCreateProcess&#43;0x3d (FPO: [Non-Fpo])f9dc36dc 804fe155 f9dc3858 001f0fff f9dc37c0 nt!KiFastCallEntry&#43;0xf8 (FPO: [0,0] TrapFrame @ f9dc3704)f9dc3774 8069caa3 f9dc3858 001f0fff f9dc37c0 nt!ZwCreateProcess&#43;0x11 (FPO: [8,0,0])f9dc3818 80686681 &amp;lt;strong&amp;gt;f9dc38b0&amp;lt;/strong&amp;gt; 00000040 00040000 nt!RtlCreateUserProcess&#43;0x125 (FPO: [Non-Fpo])f9dc3dac 805c6160 80087000 00000000 00000000 nt!Phase1Initialization&#43;0x1059 (FPO: [Non-Fpo])f9dc3ddc 80541dd2 80685628 80087000 00000000 nt!PspSystemThreadStartup&#43;0x34 (FPO: [Non-Fpo])00000000 00000000 00000000 00000000 00000000 nt!KiThreadStartup&#43;0x16kd&amp;gt; !ustr &amp;lt;strong&amp;gt;f9dc38b0&amp;lt;/strong&amp;gt;&amp;lt;strong&amp;gt;String(58,520) at f9dc38b0: \SystemRoot\System32\smss.exe&amp;lt;/strong&amp;gt;kd&amp;gt; gukd&amp;gt; !process 0 0**** NT ACTIVE PROCESS DUMP ****PROCESS 81bcc830 SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000DirBase: 00319000 ObjectTable: e1000cc0 HandleCount: 52.Image: SystemPROCESS 81a2a430 SessionId: none Cid: 0218 Peb: 7ffd6000 ParentCid: 0004DirBase: 08500020 ObjectTable: e1584818 HandleCount: 0.&amp;lt;strong&amp;gt; Image: smss.exe&amp;lt;/strong&amp;gt; Como podemos ver, isso é muito divertido e muito extenso. Poderíamos ir para qualquer lado da evolução do boot. Talvez em artigos futuros daremos uma olhada no processo de logon de um usuário, o que nos obrigaria a ter uma leve noção de como o Windows autentica e autoriza as pessoas. ou talvez daremos uma passadinha no sistema de escalonamento de threads do kernel, um assunto pra lá de complicado e esotérico.
Então até lá. Com licença que eu preciso ver a criação do System mais uma vez.
.reboot </description>
</item>

     
        <item>
  <title>O boot no Windows: NTLDR</title>
  <link>http://www.caloni.com.br/o-boot-no-windows-ntldr/</link>
  <pubDate>2009-11-26</pubDate>
  
  <guid>http://www.caloni.com.br/o-boot-no-windows-ntldr/</guid>
  <description>Minhas análises estão demorando muito para ser feitas. Talvez seja a hora de revelar o pouco que sei (e pesquisei) sobre o próximo processo de boot do Windows: o NTLDR.
O nosso amigo NT Loader pode ser entendido através da leitura do já citado Windows Internals ou através de uma outra leitura que estou fazendo atualmente e que pouquíssimos amigos blogueiros irão se lembrar: o livro da galinha preta; formalmente conhecido como Windows Nt File System Internals.
Para os sabichões de plantão, inclusive os que me criticaram (?) no meu último texto humorístico sobre como Java é podre, eu sei que o bicho da capa não é uma galinha, mas um urubu. A troca de urubu por galinha vem do requisito básico para você fazer trabalhos esotéricos, como macumba e desenvolvimento de drivers: uma galinha preta na encruzilhada. Alguns usam um papel dentro da boca de um sapo, mas vai do gosto de cada um. =)
E, para os que leram o livro, devem entender que para explicar sobre o funcionamento do sistema de arquivos do Windows, parte intrínseca do funcionamento do próprio kernel, foi necessário ao autor explicar várias partes do kernel, inclusive sua inicialização; e é nessa parte que podemos aprender algo mais sobre o NT Loader.
Podemos aprender, por exemplo, que ele é carregado logo depois do NT Detect, que é o executável que dá uma olhada no hardware e ajusta a configuração do boot de acordo com o ambiente encontrado. Após esse ajuste, o nosso amigo NT Loader faz algumas coisas pra lá de interessantes.
O NTLDR é um executável &amp;quot;híbrido&amp;quot; que possui tanto código em modo real quanto código em modo protegido. Com isso podemos supor que é ele o responsável por entrar em modo protegido, uma tarefa que exige alguns conhecimentos da arquitetura.
Além disso, como o próprio nome diz, ele tecnicamente &amp;quot;sobe&amp;quot; o sistema operacional, pois provê a comunicação entre o hardware (processador e periféricos da máquina) e o software (kernel e drivers de boot). O hardware é o que está espetado na máquina e o kernel é o arquivo ntoskrnl.exe; para a comunicação entre eles existe uma camada de abstração, o hal.dll.
Esses dois arquivos, juntos dos drivers de boot, são carregados pelo NTLDR.
Depois de todo aquele trabalhão do setor de boot para analisar o sistema de arquivos, achar o NTLDR, carregá-lo na memória e executá-lo, o controle passa para o nosso amigo híbrido, ainda em modo real. Ele então abre a partição de boot e procura pelo arquivo boot.ini (estamos falando de um boot antes de bcdedit, mas o funcionamento seria aproximado). Como o driver do sistema de arquivos ainda não subiu, isso quer dizer que o NTLDR usa o próprio código embutido para interpretar uma FAT, NTFS ou outros sistemas suportados (um dos motivos por que não é possível instalar o Windows em um ReiserFS).
Nesse ponto o nosso amigo loader faz o que todo mundo já fez na infância (não fez?): trocar o modo de tela fazendo uma chamada para a BIOS para modo texto 80x50 em 16 cores. Ah, ele também faz algo que eu adorava fazer (você não?): encher a memória de vídeo de pixels pretos para limpar a tela!
Como ele leu a lista de kernels bootáveis, é isso que ele exibe naquela famosa tela que qualquer um que depura o kernel vê:
Escolheu seu boot, é a partir daí que ele acha o executável do kernel: ntoskrnl.exe. Ele deve estar na pasta system32 (em ambientes 32 bits). Também é nesse momento que é carregada a HAL (hal.dll) e isola-se o hardware do software a partir daí. As DLLs que esses dois componentes dependem são identificadas e carregadas na memória.
Agora é hora de abrir o registro. Quer dizer, parte dele. Dentro da pasta system32/config deve estar a hive SYSTEM, que é onde ficam os drivers que devem ser carregados a partir daí em vários níveis. Inicialmente são carregados os que possuem o valor Start igual a zero, como o driver Atapi (controlador de disco):
A partir daí vários componentes do kernel serão carregados progressivamente. Só que a partir do momento que é chamada a rotina interna KiInitializeKernel o NTLDR não tem mais nada pra fazer: o kernel, em sua forma básica e primitiva, está carregado.
windbg notepad$$&amp;gt;a&amp;lt;&amp;lt;a href=&amp;quot;http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg-parte-2&amp;quot;&amp;gt;scripts\loadlibrary.txt&amp;lt;/a&amp;gt; &amp;lt;strong&amp;gt;ntoskrnl.exe&amp;lt;/strong&amp;gt;0:000&amp;gt; lm m nt*start end module name00400000 00629000 ntoskrnl (pdb symbols) c:\tools\symbols\ntkrnlmp.pdb\46DFBE2D3E484140A0909F7519B1700A2\ntkrnlmp.pdb7c900000 7c9b6000 ntdll (pdb symbols) c:\tools\symbols\ntdll.pdb\6992F4DAF4B144068D78669D6CB5D2072\ntdll.pdb0:000&amp;gt; x ntoskrnl!KiInit*005ef332 ntoskrnl!KiInitializePcr = &amp;lt;no type information&amp;gt;005eefc0 ntoskrnl!KiInitQueuedSpinLocks = &amp;lt;no type information&amp;gt;005ef1de ntoskrnl!KiInitSystem = &amp;lt;no type information&amp;gt;00439ded ntoskrnl!KiInitializeTSS = &amp;lt;no type information&amp;gt;&amp;lt;strong&amp;gt;005eadd2 ntoskrnl!KiInitializeKernel = &amp;lt;no type information&amp;gt;&amp;lt;/strong&amp;gt;0043aefb ntoskrnl!KiInitializeAbios = &amp;lt;no type information&amp;gt;005e4add ntoskrnl!KiInitMachineDependent = &amp;lt;no type information&amp;gt;0058faa4 ntoskrnl!KiInitializePAT = &amp;lt;no type information&amp;gt;005dde52 ntoskrnl!KiInitializeTSS2 = &amp;lt;no type information&amp;gt;004105e5 ntoskrnl!KiInitializeUserApc = &amp;lt;no type information&amp;gt;00415619 ntoskrnl!KiInitializeContextThread = &amp;lt;no type information&amp;gt;0043afdb ntoskrnl!KiInitializeAbiosGdtEntry = &amp;lt;no type information&amp;gt;005dde01 ntoskrnl!KiInitializeMachineType = &amp;lt;no type information&amp;gt;005e51f7 ntoskrnl!KiInitializeMTRR = &amp;lt;no type information&amp;gt;0:000&amp;gt; u ntoskrnl!KiInitializeKernelntoskrnl!KiInitializeKernel:005eadd2 6a28 push 28h005eadd4 68c0784300 push offset ntoskrnl!KiDebugRegisterContextOffsets&#43;0x3c (004378c0)005eadd9 e8a510e2ff call ntoskrnl!_SEH_prolog (0040be83)005eadde e8b531ffff call ntoskrnl!KiSetProcessorType (005ddf98)005eade3 e8cfffffff call ntoskrnl!KiSetCR0Bits (005eadb7)005eade8 e8d334ffff call ntoskrnl!KiIsNpxPresent (005de2c0)005eaded 8845e7 mov byte ptr [ebp-19h],al005eadf0 64a11c000000 mov eax,dword ptr fs:[0000001Ch] Veremos nos próximos capítulos como podemos nos aproveitar do ntoskrnl.exe para poder depurar o código a partir daí. Até lá.
</description>
</item>

     
        <item>
  <title>O boot no Windows: pré-NTLDR</title>
  <link>http://www.caloni.com.br/o-boot-no-windows-pre-ntldr/</link>
  <pubDate>2009-09-09</pubDate>
  
  <guid>http://www.caloni.com.br/o-boot-no-windows-pre-ntldr/</guid>
  <description>Conforme fui estudando para recordar os momentos sublimes do boot do Windows me deparei com o artigo mais &amp;quot;espetaculoso&amp;quot; de todos os tempos sobre esse assunto, parte integrante do livro Windows Internals e escrito pelo nada mais nada menos Mark Russinovich: Boot Process, no capítulo 5, &amp;quot;Startup and Shutdown&amp;quot;.
O meu primeiro artigo sobre o boot sem Windows foi 80% escrito com o que eu já sabia de cabeça de tanto mexer na MBR e de tanto depurar o processo de boot em 16 bits. Os artigos posteriores seriam escritos com uma pitada do que sei mais a &amp;quot;inspiração&amp;quot; da minha pesquisa. Apesar de não parecer pouco para os que não sabem inglês, deixa a desejar para os que sabem (boa parte dos meus leitores, imagino).
Nesse caso decidi salpicar a explicação com uma boa dose de reversing para aproveitarmos a caminhada e fuçarmos um pouco no funcionamento interno dos componentes de boot e ver no que dá. Antes de começar, porém, aviso que este não é um tratado sobre o sistema de boot. Eu diria que é apenas o resultado de algumas mexidas inconsequentes pelo _disassembly _do código de boot. Espero encontrar alguém tão curioso (ou mais) do que eu que compartilhe o que achou de todo esse processo. Antes de mais nada um mapinha para vermos até onde chegamos:
[](http://i.imgur.com/MfxtBx5.png)

Pelo visto esse foi só o começo. O próximo passo é saber como do setor de boot chegamos ao NTLDR. O que não é nenhum segredo, uma vez que o NTLDR é um arquivo que fica na pasta raiz do sistema de arquivos. Como todos sabemos, qualquer assembly 16 bits de 400 bytes de tamanho consegue ler um arquivo de 250 KB na memória e executá-lo.
Se o NTLDR não conseguir ser encontrado, o seguinte erro será exibido:
Que usuário merece ver isso?
Bom, se ele soubesse analisar o assembly do setor de boot, seria fácil entender essa mensagem. E analisar o assembly é simples demais, quase tão simples quanto entender a mensagem acima. Tudo que precisamos é do programa Debug 16 bits, como o que já vem com o Windows ou aquele mais turbinado do FreeDOS.
Podemos usar o Debug 16 bits para abrir o setor de boot salvo em algum arquivo e analisá-lo. Esse &amp;quot;salvo em algum arquivo&amp;quot; nós podemos obter usando o HxD, um sofware bom demais que eu uso quase todos os dias da minha vida, ou para analisar os primeiros setores do disco ou ler arquivos binários que caem na minha caixa de e-mails.
Eu não vou explicar como salvar um setor do disco em um arquivo. Pelamordedeus, isso é fácil demais. É só fuçar que se acha um jeito.
Se bem que, como esse é um quase-tutorial, vão abaixo apenas algumas dicas:
(1) no primeiro setor do disco de boot, podemos encontrar a tabela de partições;
(2) nessa tabela, a partição ativa é a que começa com 0x80;
(3) existe um campo onde é possível obter o offset de onde está o primeiro setor dessa partição (em setores);
(4) uma simples conversão de Little Endian e de hexadecimal para decimal nos retorna o número do setor que precisamos;
(5) o próprio HxD nos consegue levar para esse setor, de onde podemos selecioná-lo e salvá-lo em um arquivo!
Isso é tudo o que você precisa para fazer engenharia reversa do setor de boot. Bom divertimento!
Análise estática x análise dinâmica Existem duas formas que conheço para analisar o _disassembly _de um setor de boot pelo Debug. Para os que gostam de aventuras radicais (RPG em modo texto?) existe a análise dinâmica, que consiste em digitar no prompt do DOS o comando Debug e o nome do arquivo salvo com o setor de boot. O primeiro comando u irá desmontar os primeiros bytes do setor (e, portanto, as primeiras instruções). Eu costumo fazer isso para uma visão geral de cinco minutos.
A segunda forma de análise que exixte é para os preguiçosos que não conseguem fazer tudo no mesmo dia e optam por salvar o dump do disasssembly em um segundo arquivo. Para realizar essa proeza usando o Debug não é preciso mais que três neurônios:
(1) digite em um arquivo chamado u.bat o seguinte conteúdo:
u 100 400q (2) rode o debug como a linha abaixo:
debug &amp;lt; u.bat &amp;gt; a.asm (3) Pronto! Temos um a.asm com toda a saída do setor de boot. Agora podemos analisá-la e editá-la:
; Salto inicial0CDD:0100 EB52 JMP 0154; Esses são dados que percebi que são usados pelo código, então copiei do HxDOffset(h) 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F00000000 4E 54 46 53 20 20 20 20 00 02 08 00 00 NTFS .....00000010 00 00 00 00 00 F8 00 00 3F 00 FF 00 00 20 3F 01 .....ø..?.ÿ.. ?.00000020 00 00 00 00 80 00 80 00 FF 1F 03 00 00 00 00 00 ....¿.¿.ÿ.......00000030 55 21 00 00 00 00 00 00 02 00 00 00 00 00 00 00 U!..............00000040 F6 00 00 00 01 00 00 00 8E 4F 78 94 71 78 94 5C ö.......¿Ox¿qx¿\00000050 00 00 00 00 ....; Inicializa pilha e registradores0CDD:0154 FA CLI0CDD:0155 33C0 XOR AX,AX0CDD:0157 8ED0 MOV SS,AX0CDD:0159 BC007C MOV SP,7C000CDD:015C FB STI0CDD:015D 68C007 PUSH WORD 07C00CDD:0160 1F POP DS0CDD:0161 1E PUSH DS0CDD:0162 686600 PUSH WORD 00660CDD:0165 CB RETF; Confere assinatura &#39;NTFS&#39; inicial0CDD:0166 88160E00 MOV [000E],DL0CDD:016A 66813E03004E544653 CMP DWORD PTR [0003],5346544E0CDD:0173 7515 JNZ 018A; Confere instalação do disco0CDD:0175 B441 MOV AH,410CDD:0177 BBAA55 MOV BX,55AA0CDD:017A CD13 INT 130CDD:017C 720C JB 018A0CDD:017E 81FB55AA CMP BX,AA550CDD:0182 7506 JNZ 018A0CDD:0184 F7C10100 TEST CX,00010CDD:0188 7503 JNZ 018D0CDD:018A E9DD00 JMP 026A; Pega os parâmetros do disco0CDD:018D 1E PUSH DS0CDD:018E 83EC18 SUB SP,&#43;180CDD:0191 681A00 PUSH WORD 001A0CDD:0194 B448 MOV AH,480CDD:0196 8A160E00 MOV DL,[000E]0CDD:019A 8BF4 MOV SI,SP0CDD:019C 16 PUSH SS...0CDD:01BE 2BC8 SUB CX,AX0CDD:01C0 66FF061100 INC DWORD PTR [0011]; Loop de leitura do disco0CDD:01C5 03160F00 ADD DX,[000F]0CDD:01C9 8EC2 MOV ES,DX0CDD:01CB FF061600 INC WORD PTR [0016]0CDD:01CF E84B00 CALL 021D0CDD:01D2 2BC8 SUB CX,AX0CDD:01D4 77EF JA 01C5; O que será isso? RFIL não nos diz nada...0CDD:01D6 B800BB MOV AX,BB000CDD:01D9 CD1A INT 1A0CDD:01DB 6623C0 AND EAX,EAX0CDD:01DE 752D JNZ 020D0CDD:01E0 6681FB54435041 CMP EBX,415043540CDD:01E7 7524 JNZ 020D0CDD:01E9 81F90201 CMP CX,01020CDD:01ED 721E JB 020D; Algum tipo de inicialização0CDD:01EF 16 PUSH SS0CDD:01F0 6807BB PUSH WORD BB070CDD:01F3 16 PUSH SS0CDD:01F4 68700E PUSH WORD 0E700CDD:01F7 16 PUSH SS0CDD:01F8 680900 PUSH WORD 00090CDD:01FB 6653 PUSH EBX0CDD:01FD 6653 PUSH EBX... Se fuçarmos por um tempo esse código podemos encontrar várias coisas interessantes, como por exemplo a mensagem que é exibida quando o setor de boot não contém a assinatura padrão 0x55 0xAA em seu final:
Outra coisa interessante é encontrar a sub-rotina que carrega blocos e blocos de conteúdo do disco na memória, utilizando-se para isso da interrupção 0x13 função 0x42: a leitura estendida!
; Leitura de blocos bem grandes no disco0CDD:021D 6660 PUSHAD0CDD:021F 1E PUSH DS0CDD:0220 06 PUSH ES0CDD:0221 66A11100 MOV EAX,[0011]0CDD:0225 6603061C00 ADD EAX,[001C]0CDD:022A 1E PUSH DS0CDD:022B 666800000000 PUSH DWORD 000000000CDD:0231 6650 PUSH EAX0CDD:0233 06 PUSH ES0CDD:0234 53 PUSH BX0CDD:0235 680100 PUSH WORD 00010CDD:0238 681000 PUSH WORD 00100CDD:023B B442 MOV AH,420CDD:023D 8A160E00 MOV DL,[000E]0CDD:0241 16 PUSH SS0CDD:0242 1F POP DS0CDD:0243 8BF4 MOV SI,SP0CDD:0245 CD13 INT 130CDD:0247 6659 POP ECX0CDD:0249 5B POP BX0CDD:024A 5A POP DX0CDD:024B 6659 POP ECX0CDD:024D 6659 POP ECX0CDD:024F 1F POP DS0CDD:0250 0F821600 JB 026A0CDD:0254 66FF061100 INC DWORD PTR [0011]0CDD:0259 03160F00 ADD DX,[000F]0CDD:025D 8EC2 MOV ES,DX0CDD:025F FF0E1600 DEC WORD PTR [0016]0CDD:0263 75BC JNZ 02210CDD:0265 07 POP ES0CDD:0266 1F POP DS0CDD:0267 6661 POPAD0CDD:0269 C3 RET Enfim, todo esse assembly para fazer apenas uma coisa: achar o NTLDR na diretório-raiz da partição onde estamos, carregá-lo na memória e executá-lo. O que se passa a partir daí é o que iremos abordar na futura continuação. Não perca!
</description>
</item>

     
        <item>
  <title>O boot no Windows: sem Windows</title>
  <link>http://www.caloni.com.br/o-boot-no-windows-sem-windows/</link>
  <pubDate>2009-08-18</pubDate>
  
  <guid>http://www.caloni.com.br/o-boot-no-windows-sem-windows/</guid>
  <description>Desde quando o usuário liga o computador até o momento em que ele vê a barra de tarefas e aqueles fundos lindos de papel de parede existem diversas coisas sendo feitas por debaixo do pano. Essa série de artigos irá explicar essas diversas coisas, ou seja, como funciona e quais as fases do boot de uma máquina que possui Windows instalado (plataforma NT).
O que esses artigos não vão fazer muito bem é explicar o lado do kernel mode funcionando, até porque temos artigos melhores explicando esse ponto de vista. Essa é uma abordagem mais &amp;quot;high level&amp;quot;, apesar de &amp;quot;low enough&amp;quot;. No entanto, espero que seja divertido. É esse o mais importante requisito em qualquer aprendizado, certo? Let&#39;s go!
Tudo começa no hardware, que recebe um lampejo de energia que o põe em funcionamento (&amp;quot;levanta-te e anda!&amp;quot;). Isso faz com que um pequeno pedaço de software comece a rodar. Esse pedaço inicial de código é chamado de firmware, que é um meio termo entre hardware e software.
O firmware fica gravado na placa-mãe e normalmente nós ouvimos falar dele pelo nome de BIOS, Basic Input Output System (Sistema Básico de Entrada e Saída). É nele que estão gravadas as rotinas mais básicas para fazer o hardware mais básico funcionar: CPU, memória, vídeo e teclado.
Quando o computador é ligado, o código da BIOS realiza duas operações vitais antes de continuar:
  Ver se todos os componentes de hardware estão bem;
  Ver quem é o dispositivo que inicia o sistema operacional.
  Esse segundo item é o que veremos agora.
Dependendo do computador, podemos iniciá-lo por um disco rígido (HD), por um CD-ROM, por um PenDrive USB e até pela rede. Isso está subordinado ao firmware da máquina, pois é ele que comanda, até segunda ordem, todo o hardware acoplado ao sistema.
Vamos supor que um HD foi configurado para ser o inicializador do sistema operacional. Então será lido um pequeno espaço de 512 bytes, mais conhecido como setor, bem no início desse HD. Esse setor inicial possui código de inicialização (chamado de bootstrapping). Por isso, ele é colocado na memória inicial da máquina e executado. O lugar onde ele fica é fixo e conhecido por todos (lembre-se que estamos rodando em modo real!): 0x7C00.
Agora o próximo passo é com esse setor inicial do disco, que chamamos de MBR: Master Boot Record (ou Registro de Boot Mestre, em tradução livre). Ele contém código 16 bits que não pode depender de runtime nenhuma e faz o que quiser com a memória. Também possui no seu final uma tabela de quatro entradas de partições; é nessa tabela que deve estar a partição ativa, onde está o sistema operacional.
Uma MBR padrão procura por essa partição e lê seu primeiro setor, fazendo um processo bem parecido com o que a BIOS faz inicialmente: carrega na memória o primeiro setor da partição e executa.
Vamos supor que você tenha algum Windows moderno na partição ativa. A MBR irá carregar o primeiro pedaço de código desse sistema operacional moderno, que, até então, estará rodando em modo real desprotegido como o bom e velho MS-DOS.
(Note que, mesmo que se trate de uma MBR escrita por terceiros, se ela se comportar como manda o figurino, irá carregar o primeiro setor da partição ativa descrita na tabela de partições. Isso é o que faz com que MBRs escritas pelo pessoal do Linux (e.g. Lilo) consiga fazer o boot de uma partição Microsoft.)
Agora chegamos em todos os passos iniciais realizados antes de entrar em cena o S.O.:
  O firmware da placa-mãe, conhecida como BIOS, verifica se o hardware básico está funcionando;
  Em seguida, o mesmo código procura pelo dispositivo iniciável que irá dar início ao processo de boot;
  Se for um HD, então o primeiro setor físico desse HD será carregado em memória e executado;
  Esse primeiro setor se chama MBR e contém uma tabela com até quatro entradas de partições no disco;
  O código da MBR procura pela partição ativa onde deve estar o sistema operacional;
  Assim como a BIOS, a MBR carrega na memória o primeiro setor da partição ativa e executa;
  A partir daí temos o código de um possível sistema operacional rodando.
  Todos os componentes principais desse boot podem ser visualizados de uma forma bem macro na figura abaixo.
Alguns detalhes sórdidos que podem fazer alguma diferença para você, desenvolvedor de sistemas operacionais, um dia desses:
  Os setores de que estamos falando (MBR, partição ativa) normalmente devem terminar com uma assinatura de dois bytes (0x55 0xAA), o que &amp;quot;garante&amp;quot; que o código contido nesse setor é válido e pode ser executado.
  No caso do loader do Windows (pré-Vista), existia um arquivo no diretório-raiz da partição ativa chamado boot.ini que continha uma lista de possíveis modos de inicializar o sistema operacional, inclusive com múltiplas versões do Windows, cada um localizado em uma partição/pasta distinta (e.g., multiboot com Windows 98 e XP).
  O limite de quatro partições da MBR pode ser aumentado com o uso de partições estendidas; as partições estendidas apontam para um bloco de setores no HD que inicia com um setor que contém outra tabela de partições exatamente onde fica a tabela da MBR, também com quatro entradas.
  O endereçamento da localização das partições na MBR pode ser feito de duas maneiras distintas: por CHS ou por LBA. A versão CHS é bem antiga, mas ainda usada, e especifica uma localização no HD através de um posicionamento físico de três dimensões, com cilindro/trilha (C - Cylinder), cabeça (H - Head) e setor (S - Sector). Sim, isso é bem old-fashionable. Também existe o LBA (Logical Block Addressing), que é uma forma lógica de endereçar setores no disco, através de deslocamentos (offsets).
  Para detectar problemas de hardware, a BIOS pode ajudar com seus beeps significativos. Isso aparentemente parece ser o fim da picada, mas não é. O DQ sabe muito bem que podemos ter problemas no hardware que exigem análises mais sofisticadas (como comprimento de onda dos sinais).
Se for detectar algum problema no sistema de boot baseado em MBR, então você tem dois caminhos:
  Usar o SoftICE 16 bits e depurar o carregamento da MBR pela BIOS
  Usar o Debug 16 bits do MS-DOS (ou similar) e depurar diretamente o código de boot da MBR, reproduzindo os passos anteriores da BIOS.
  Se o problema for durante o carregamento do próprio sistema operacional, as mensagens de erro do loader são significativas. No entanto, pode-se usar o Debug mais uma vez e depurar essa parte, logo antes, é claro, do sistema entrar em modo protegido de 32 bits, o que daí já é outra história (que pretendo contar em breve).
 Artigo sobre o boot no Linux  </description>
</item>

     
        <item>
  <title>What I&#39;ve been doing in the last 10 years</title>
  <link>http://www.caloni.com.br/what-ive-been-doing-in-the-last-10-years/</link>
  <pubDate>2009-08-17</pubDate>
  
  <guid>http://www.caloni.com.br/what-ive-been-doing-in-the-last-10-years/</guid>
  <description>This week I dedicate myself to update my resumè and I have the brilliant idea of put into it my technical historical, what resuming is a list of things I did or was involved with during my brief ten years stay in the programming world.
So I thought: &amp;quot;this could be useful to the people read me&amp;quot;. Why not? Perhaps you got some doubt waiting to be solved and is unable to find a guy who knows something about this. Perhaps this fork guy even exists and has a blog where he could share some knowledge that is stuck in that empty programmer head.
In this case, it follows bellow a brief description of my professional life, with the things I could remember I did since December 2000. What I haven&#39;t remember probably is not worth of.
 Software and hardware inventory Clipboard and PrintScreen protection using windows hooks and global messages manipulation Driver writing system event log DeviceIoControl user/kernel communication Desktop remote control using VNC technique Remote execution tool PsExec (SysInternals) like Print control using regex (Boost) and shell hook Access policies management during user logon/logoff (register and hooks) Database migration CTree -&amp;gt; SQL (OLE classes) Windows authentication using custom GINA and DCOM; Credential Provider (Vista) CTree database synchronism using custom DCOM service Bootable Linux CD with bash scripts and disk cryptography tools using C language Hard disk encryption and PenDrive (USB) storage control Blue Screen analysis using memory dumps and WinDbg live (Gflags) System account execution using custom COM service MBR (Master Boot Record) customization library Blowfish/SHA-1 encryption library using C&#43;&#43; and 16 bits Assembly Log access driver using shared memory between user and kernel mode Kernel mode API hook for 9X and NT platforms 16 bits Assembly loader; debugging using debug.com tool Executable protection using embedded domain authentication recorded inside files resources Internet Explorer 6/7 and Firefox 1/2 browsing protection using Assembly 32 bits code injection Code, strings and execution protection library (using Win32 interruptions) Centralized log generation library using shared memory and global events Internet Explorer 6/7 BHO (Broser Helper Object) and ActiveX; Mozilla/Firefox XPI plugin Projects management using Source Safe, Bazaar and Batch (Win) scripts Kernel mode debugging using SoftIce and WinDbg for NT platform, SoftIce and WDeb98 for 9X platform Trojans reverse engineering (C&#43;&#43;, Visual Basic, Delphi) using WinDbg and IDA Diagnostic tool listing files, services, drivers, register, disk partitions, processes, etc Jobs monitoring in Win2000&#43; to installation and update control Application use monitoring using noninvasive and invasive windows hooks Houaiss reverse engineering and Babylon importation (dictionaries) Build control with Cruise Control .NET, symbol server with Debugging Tools Projects documentation using Doxygen and Wiki (Trac) Management interfaces using C&#43;&#43; Builder 5/6 and Visual C&#43;&#43; custom libraries E-mails analyzer using regular expressions (ATL classes) Configuration interfaces using Visual C&#43;&#43; (MFC /ATL/WTL) Project and tracing analysis using regular expressions (Vim and Grep) Articles development using technical blog and Code Project community.  Perhaps I update this list frequently. Although I guess the rightest choice would be to update the list with articles about my every day &amp;quot;brushing bits&amp;quot; life . After all, I got a technical blog already!
</description>
</item>

     
        <item>
  <title>AdPlus no cliente, não você!</title>
  <link>http://www.caloni.com.br/adplus-no-cliente-nao-voce/</link>
  <pubDate>2009-08-10</pubDate>
  
  <guid>http://www.caloni.com.br/adplus-no-cliente-nao-voce/</guid>
  <description>O AdPlus é uma das poderosas ferramentas do pacote Debugging Tools for Windows. Se trata basicamente de um script que serve para realizar múltiplas fotografias no estado de um programa em execução usando para isso os depuradores do próprio pacote. Quando alguma coisa estiver errada, principalmente um crash ou travamento, ele paralisa a execução e gera um dump final com toda a história contada desde o começo.
Ele pode ser usado na situação mais comum: o programa trava/quebra em um cliente específico e/ou em um momento específico que pode acontecer em cinco segundos ou daqui a quinze horas. Como você não pode ficar monitorando o tempo todo a execução do programa (haja indexadores no PerfMon!) então você precisa de alguém que monitore por você. Como seres humanos costumam ter deficit de atenção muito facilmente você vai lá no cliente (ou pede para alguém ir) e executa o AdPlus, que dá conta do recado:
AdPlus.vbs -crash -sc notepad.exe Esse notepad, viu! Sempre ele!
Bom, vamos fazer alguma brincadeira de desmontar para ver seu funcionamento. Com o notepad recém-aberto por esse comando, vamos abrir outro depurador em modo de visualização e alterar alguma chamada-chave para quebrar propositadamente. Isso deve fazer o truque:
windbg -pv -pn notepad.exea user32!MessageBoxWjmp 0.detachq Após isso só precisamos abrir um arquivo qualquer que não existe e o notepad deve explodir. Depois desse lapso de memória o AdPlus irá gerar dois &amp;quot;dumpões&amp;quot; e um &amp;quot;dumpinho&amp;quot; para você com o primeiro comando deste post. O dumpinho é a exceção de first chance, que ele iria gerar de qualquer forma se houvesse uma exceção capturada pelo programa. É apenas um minidump. Os outros dois dumpões são o momento da exceção second chance, o que quer dizer que é antes da casa cair, e o segundo é quando a casa já caiu e o processo pegou suas coisas e já tá indo embora. A partir do second chance podemos visualizar a cagada feita pelo nosso WinDbg de passagem.
Se você não é desenvolvedor apenas empacote essa pasta com os dumps e envie para o culpado (ou quem você gostar menos).
Existem alguns outros parâmetros bem comuns e que podem ser muito úteis para outras situações:
 Quando o programa já está rodando e não pode ser parado senão tudo está perdido (adplus -crash -pn processo.exe). Quando o programa não vai capotar, mas vai travar/parar de responder (adplus -hang -sc processo.exe). Quando existem muitos outros processos com o mesmo nome (adplus -crash -p [PID]).  Existem outros mais, mas apenas decorando esses e guardando a pasta do Debugging Tools no PenDrive já garante sucesso em 90% dos casos em que o cliente xingar o suporte.
</description>
</item>

     
        <item>
  <title>Cuidado com a cópia de arquivos na VMWare</title>
  <link>http://www.caloni.com.br/cuidado-com-a-copia-de-arquivos-na-vmware/</link>
  <pubDate>2009-07-27</pubDate>
  
  <guid>http://www.caloni.com.br/cuidado-com-a-copia-de-arquivos-na-vmware/</guid>
  <description>Quebrei a cabeça com uma DLL de hook que não estava funcionando para usuários comuns. No entanto, para qualquer administrador funcionava.
Isso acontece porque quando se arrasta uma DLL recém-compilada para a VMWare ela possui um mecanismo que primeiro cria esse arquivo no temporário do usuário atual e depois move esse arquivo para o lugar onde você de fato arrastou.
Como sabemos, a pasta temporária de um usuário fica em seu perfil, que possui direitos de uso apenas do usuário e dos administradores do sistema. Se eu copio um arquivo de uma pasta restrita para outra pasta os direitos do arquivo permanecem. Isso quer dizer que apenas o usuário atual e os administradores terão acesso ao arquivo, mesmo que se trate de um arquivo para uso de todos.
Resultado: arrastava a nova DLL de hook compilada da pasta de saída direto para a pasta de sistema da máquina virtual e esse caminho através do temporário era seguido, tornando a DLL inacessível para os usuários que eu estava testando.
Solução: após arrastar o arquivo, mude suas permissões. Ou copie-o através do bom e velho copiar/colar. Diferente do arrastar, o Ctrl&#43;C Ctrl&#43;V não gera arquivos temporários.
</description>
</item>

     
        <item>
  <title>Name mangling</title>
  <link>http://www.caloni.com.br/name-mangling/</link>
  <pubDate>2009-07-13</pubDate>
  
  <guid>http://www.caloni.com.br/name-mangling/</guid>
  <description>A sobrecarga estática possui algumas desvantagens em relação ao sistema de nomes da boa e velha linguagem C: ela não foi padronizada entre compiladores. O que isso quer dizer na prática é que funções exportadas de bibliotecas dinâmicas (DLLs) vão possuir nomes diferentes dependendo do compilador utilizado (e sua versão). Isso é o que chamamos name mangling.
Em dois projetos usando Visual C&#43;&#43; 2008 e Borland C&#43;&#43; Builder 5 (última versão que funciona direito) eu fiz uma exportação da função soma em linguagem C (o fonte é um .c). Veja o resultado:
Já usando a linguagem C&#43;&#43; (o fonte é um .cpp) temos outro resultado totalmente diferente para nossas duas funções soma descritas no artigo anterior:
Se quiser tentar entender essas letrinhas bizarras, recomendo baixar projetos de exemplo. Se apenas entender que você não conseguirá juntar classes VC&#43;&#43; e Builder usando dllexport.aspx) para tudo quanto é lado, então terminamos por aqui.
</description>
</item>

     
        <item>
  <title>Polimorfismo estático</title>
  <link>http://www.caloni.com.br/polimorfismo-estatico/</link>
  <pubDate>2009-07-10</pubDate>
  
  <guid>http://www.caloni.com.br/polimorfismo-estatico/</guid>
  <description>Para explicar polimorfismo, nada como ver as coisas como elas eram. Se você fosse um programador C de vinte anos atrás e criasse as seguintes funções:
int soma(int x, int y);double soma(double x, double y);int main(){int zi = soma(2, 3);double zd = soma(2.5, 3.4);return 0;}Imediatamente o compilador iria acusar os seguintes erros:
overload.coverload.c(2) : warning C4028: formal parameter 1 different from declarationoverload.c(2) : warning C4028: formal parameter 2 different from declarationoverload.c(2) : error C2371: &#39;soma&#39; : redefinition; different basic typesoverload.c(1) : see declaration of &#39;soma&#39; Isso acontece porque em C os identificadores são únicos por escopo. Esse é o motivo por que o seguinte código também está errado:
int main(){int x = 0;int x = 1;return 0;}overload.coverload.c(5) : error C2374: &#39;x&#39; : redefinition; multiple initializationoverload.c(4) : see declaration of &#39;x&#39; De volta aos anos 90, isso também está errado em C&#43;&#43;. Até por uma questão de lógica: como o compilador pode saber a qual variável estamos nos referindo se usarmos o mesmo nome para duas delas?
Só que existe um truquezinho para impedir essa ambiguidade quando falamos de funções: os parâmetros que ela recebe.
int soma(int x, int y);double soma(double x, double y);int main(){int zi = soma(2, 3); // dois tipos int: chamar soma(int, int) double zd = soma(2.5, 3.4); // dois tipos double: só pode ser soma(double, double) return 0;}C:\Tests&amp;gt;cl /c overload.cppMicrosoft (R) 32-bit C/C&#43;&#43; Optimizing Compiler Version 13.10.6030 for 80x86Copyright (C) Microsoft Corporation 1984-2002. All rights reserved.overload.cppC:\Tests&amp;gt; Isso permitiu que em C&#43;&#43; fosse criada a sobrecarga estática, que é exatamente isso: chamar a função não apenas de acordo com seu nome, mas também de acordo com sua assinatura, ou seja, o número e o tipo dos parâmetros recebidos. Chamamos de sobrecarga estática porque isso é feito apenas pelo compilador, não pesando em nada durante a execução do programa.
Entre seus usos mais comuns estão os seguintes:
  Ter funções com o mesmo nome mas que tratam de diferentes parâmetros;
  soma(int, int);
  soma(double, double);
  Obs.: Isso ignora, é claro, as facilidades dos templates.
    Versões novas da mesma função que recebem parâmetros adicionais;
  export_data(void* buffer, int size);
  export_data(void* buffer, int size, unsigned long options);
    Mesmo nome de método para setar e obter o valor de uma propriedade;
  Class::Property(int x); // setter
  int x Class::Property() const; // getter
    Bom, o que mais sua imaginação mandar =)
  </description>
</item>

     
        <item>
  <title>Static Polymorphism</title>
  <link>http://www.caloni.com.br/static-polymorphism/</link>
  <pubDate>2009-07-10</pubDate>
  
  <guid>http://www.caloni.com.br/static-polymorphism/</guid>
  <description>To explain the polymorphism nothing is better than see how stuff used to be. If you were a twenty old C programmer in the past and created the following functions:
int soma(int x, int y);double soma(double x, double y);int main(){int zi = soma(2, 3);double zd = soma(2.5, 3.4);return 0;}Immediately the compiler would blame you about the following errors:
overload.coverload.c(2) : warning C4028: formal parameter 1 different from declarationoverload.c(2) : warning C4028: formal parameter 2 different from declarationoverload.c(2) : error C2371: &#39;sum&#39; : redefinition; different basic typesoverload.c(1) : see declaration of &#39;sum&#39; This happens because in C the identifiers are unique into the scope. This is the reason why the following code is wrong also:
int main(){int x = 0;int x = 1;return 0;}overload.coverload.c(5) : error C2374: &#39;x&#39; : redefinition; multiple initializationoverload.c(4) : see declaration of &#39;x&#39; Back to the 90&#39;s, this is also wrong in C&#43;&#43;. Even for a logic issue: how the compiler can pick a variable if we&#39;re using the same name for both of them?
Even though, there&#39;s a little trick to stop the ambiguity when we talk about functions: the parameters that they receives.
int soma(int x, int y);double soma(double x, double y);int main(){int zi = soma(2, 3); // dois tipos int: chamar soma(int, int) double zd = soma(2.5, 3.4); // dois tipos double: só pode ser soma(double, double) return 0;}C:Tests&amp;gt;cl /c overload.cppMicrosoft (R) 32-bit C/C&#43;&#43; Optimizing Compiler Version 13.10.6030 for 80x86Copyright (C) Microsoft Corporation 1984-2002. All rights reserved.overload.cppC:Tests&amp;gt; This allowed in C&#43;&#43; the creation of static overload, that is exactly this: to call a function not just by its name, but also to match its signature, the number and the type of the received parameters. We call static because this is done just by the compiler, not creating any overhead during the execution.
Among the most common uses some are as it follows:
  Functions with the same name treating different parameters;
  sum(int, int);
  sum(double, double);
  Obs.: This ignores, of course, the templates usefulness.
    New version of the same fuction with addictional parameters;
  export_data(void* buffer, int size);
  export_data(void* buffer, int size, unsigned long options);
    Same method name to set and get the value of a class property;
  Class::Property(int x); // setter
  int x Class::Property() const; // getter
    Well, whatever your imagination and needs demand =)
  </description>
</item>

     
        <item>
  <title>Strings</title>
  <link>http://www.caloni.com.br/strings/</link>
  <pubDate>2009-07-07</pubDate>
  
  <guid>http://www.caloni.com.br/strings/</guid>
  <description>Como já vimos centenas e centenas de vezes, memória é apenas memória até que alguém diga que isso vale alguma coisa. Em seu estado latente é o que chamamos formalmente de dados. E dados são bytes armazenados na memória.
No entanto, quando esses dados viram algo de útil em um determinado contexto, não necessariamente alterando-se seu conteúdo na memória, passamos a lidar com informação. Ou seja, é um dado com significado. E informação é a interpretação desses mesmos dados.
A conclusão óbvia para isso, falando de strings, é: uma série de bytes enfileirados na memória pode ser uma string.
Para tanto precisamos apenas de dados (os bytes enfileirados) e significado (uma tabela de símbolos que traduza esses bytes para caracteres e a definição de como a string se organiza).
Por exemplo, uma série de bytes diferentes de zero com valores que representam índices de uma tabela de tradução de caracteres e que termina sua sequência em um byte com o valor zero nele é considerada uma string C, ou string terminada em nulo.
Já uma mesma sequência de bytes no mesmo molde só que sem o byte final com o valor zero, mas com um byte inicial que tem como valor não um índice de caractere, mas o número de bytes subsequentes, isso é uma string Pascal, ou uma string com contador de tamanho.
Agora note por que tanto uma string vazia em Pascal e em C possuem os mesmos dados, mas informação diferente.
Outras strings que não necessariamente possuem terminador nulo: std::string, UNICODESTRING.aspx), strings no kernel.
</description>
</item>

     
        <item>
  <title>Bugs Difíceis de Achar</title>
  <link>http://www.caloni.com.br/bugs-dificeis-de-achar/</link>
  <pubDate>2009-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/bugs-dificeis-de-achar/</guid>
  <description>Saiu um artigo na Wired News sobre os piores bugs da história. Entre eles estão a explosão de um oleoduto soviético em plena guerra-fria (como se não bastasse chernobyl), o primeiro worm da Internet (que se aproveita de um buffer overflow da função gets) e o famoso erro de divisão em ponto flutuante do Pentium; um erro de cálculo de cerca de 0,006% que causou um prejuízo de 457 milhões de dólares para a Intel.
Mas o que achei mais legal, apesar de não estar na lista, estava relacionado com o Mariner 1, primeira espaçonave de um programa da NASA para pesquisar Marte, Vênus e Mercúrio em võos automatizados. Mariner 1 não chegou a sair de órbita, pois houve uma falha na antena de comunicação entre módulos e um bug no programa do computador de bordo.
Falava-se que o bug havia sido gerado ao trocar uma vírgula por um ponto em um loop escrito em FORTRAN. Apesar de não ter sido esse o causador da falha do computador da nave do projeto Mariner, ele existiu de fato em outro projeto da NASA, o Mercury. A linha fatal no caso era essa:
DO 17 I = 1. 10É óbvio que a intenção do programador foi fazer um loop até o label 17 dez vezes, pois a instrução para isso é:
DO 17 I = 1, 10Mas pela troca da vírgula pelo ponto, e como em FORTRAN os caracteres de espaço não são significativos, a linha com o bug não representa mais um loop, mas uma atribuição a uma variável chamada &amp;quot;DO17I&amp;quot;:
DO17I = 1.10Esse detalhe esdrúxulo de uma das linguagens mais famosas da época nos leva a crer que antigamente os programadores deveriam estar muito mais atentos durante a digitação de código do que os programadores de hoje em dia, com seus ambientes com verificação sintática embutida. Existe inclusive um texto humorístico de longa data comparando programadores de verdade e programadores de linguagens estruturadas como PASCAL recém-saídos da faculdade, carinhosamente citados no texto como &amp;quot;Quiche Eaters&amp;quot; (comedores de pastelão).
O tipo de erro de falta de atenção do programa da NASA lembra uma das mais duras críticas às linguagem C e C&#43;&#43;: é fácil escrever um código errado do ponto de vista lógico mas sintaticamente correto (compilável). Alguns exemplos famosos:
// batata entre os iniciantes if( isActived &amp;amp;&amp;amp; isTimeToLaunch );doTheStuff();// dizem que até Brian Kernighan criticava switch( value ){case 10: evaluateSentence();case 11: elevenException();}// programado no notepad value = 12; /* agora somos obrigados a atualizar a variável ratesrates = value * 8; /* nunca apague esta linha! */// mais um &amp;#34;top beginner&amp;#34; if( newValue = 20 )doSpecificStuff();// infelizmente isso é muito comum int calcPayment(){if( testing == true ) return 1000;else if( newValue &amp;gt; 500 ) return 1500;}// o perigo dos brackets opcionais if( value == 12 )//func(); doSpecificStuff();Dessa coleção de problemas, o compilador nos brinda com dois warnings:
warning C4390: &amp;quot;;&amp;quot;: empty controlled statement found; is this the intent?warning C4715: &amp;quot;calcPayment&amp;quot;: not all control paths return a valueEm nível 4 (o padrão de um projeto é 3) há um warning adicional:warning C4706: assignment within conditional expressionAgora imagine o número de horas noturnas em frente ao micro que você não poderia ter economizado em sua vida se aumentasse o nível de warning e lêsse-os de vez em quando? =)
Mais um Bug Colaborando com a lista de bugs difíceis de achar do artigo ai vai código/piadinha:
/** * The Hitch Hiker&amp;#34;s Guide to the Galaxy * The Answer to Life, the Universe, and Everything*/#include &amp;lt;iostream&amp;gt;#define SIX 1 &#43; 5#define NINE 8 &#43; 1using namespace std;int main(void) {cout &amp;lt;&amp;lt; &amp;#34;The Answer to Life, &amp;#34;&amp;#34;the Universe, &amp;#34;&amp;#34;and Everything is &amp;#34; &amp;lt;&amp;lt; SIX * NINE &amp;lt;&amp;lt; endl;return EXIT_SUCCESS;}Esse não é pego pelos alertas dos compiladores (pelo menos não pelos que eu uso)... É um bom motivo para usar const no lugar de define em alguns casos, ou no mínimo cercar o define por parênteses &amp;quot;(&amp;quot; e &amp;quot;)&amp;quot;
Outro bug muito comum entre iniciantes é o de templates aninhados, apesar de que compiladores mais novos lidam melhor com o bug e trazem mensagens de erro mais claras:
list&amp;lt;list&amp;lt;int&amp;gt;&amp;gt; // inválido no caso, é assumido o operador de stream &amp;#34;&amp;gt;&amp;gt;&amp;#34;list&amp;lt;list&amp;lt;int&amp;gt; &amp;gt; // válido</description>
</item>

     
        <item>
  <title>Programadores de verdade não usam Java</title>
  <link>http://www.caloni.com.br/programadores-de-verdade-nao-usam-java/</link>
  <pubDate>2009-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/programadores-de-verdade-nao-usam-java/</guid>
  <description>Quando era um newbie (e um wanna-be) gostava de ler o &amp;quot;Real Programmers Don&#39;t Use Pascal&amp;quot;, um texto humorístico que mais me influenciou e encorajou a caminho da iluminação C/C&#43;&#43; do que o livro de K&amp;amp;R. A partir dele, supunha eu, ser um &amp;quot;programador de verdade&amp;quot; era ser tudo. Ser um Quiche Eater (Comedor de Torta) não era nada. Programadores de verdade é que resolvem os problemas de verdade! Quiche Eaters são os losers que estudam os conceitos acadêmicos da ciência da computação e nunca fazem um maldito programa que preste (conhece alguém assim?).
Piadas à parte, para mim o humor do texto ainda pode ser aproveitado por aqueles que já se acham muito bons e acreditam não terem mais como crescer profissionalmente. Quando meu ego infla demais, ainda me lembro que enquanto programo com APIs de brincadeirinha e um sistema operacional que é uma piada tem gente projetando uma nave que vai sair da órbita do Sistema Solar!
Por outro lado, muitas pessoas recém-saídas da faculdade de computação ainda acham programação uma matéria difícil. Esse texto nos lembra que difícil era a vida 20, 40, 70 anos atrás, quando engenheiros e programadores eram a mesma pessoa, e quando se você não soubesse o que estava fazendo colocaria projetos de milhões em risco.
Por consequência, o programador de verdade vive no passado. E ele sempre se valoriza frente ao povão jovem, porque ele sabe resolver aquele problema de tela azul que mais ninguém sabe. E como eu costumo dizer, parafraseando uma figura ilustre da televisão brasileira, quem tem medo de abrir o Visual Studio e em vez disso fica projetando eternamente o software não vai muito longe: &amp;quot;quem sabe faz na hora!&amp;quot;.
Aqui segue um breve resumo do texto original adaptado para os tempos atuais e com a minha visão preconceituosa de pensar sobre o assunto. Se quiser, use sua parte politicamente correta da mente e critique à vontade!
Linguagens. Lembre-se: inventar que você precisa de mais linguagens/recursos para fazer seu trabalho é lembrar que você é incompetente o suficiente para inventar esse tipo de desculpinha. Você é daqueles que diz &amp;quot;cada problema tem sua ferramenta específica&amp;quot; ou algo do tipo. Ou seja, um programador politicamente correto e ineficiente. Não vê que tudo o que você precisa está na linguagem C. Se não estiver, então está no assembly. Se não estiver nem no C nem no assembly não vale a pena ser pensado a respeito.
Programação Estruturada. É o primeiro e último paradigma a ser aplicado. Afinal de contas, Orientação a Objetos é mais uma desculpinha para não programar. São abstrações e mais abstrações para inventar que, uma vez que você é um peso morto que não consegue resolver um problema com funções e variáveis, precisa de classes, herança, templates e outras tranqueiras que vão transformar seu código simples e reto em uma cornucópia mágica que só vai impressionar os outros pela inutilidade e complexidade da solução!
Estrutura de dados. Outro ótimo conceito para enganar a si mesmo. Hoje são muitos os que se escravizam nos leiautes SQL e classes estranhas de frameworks estranhos que fazem todo o trabalho. Todos sabemos que a única estrutura realmente útil de saber é o array. O resto são variantes do mesmo tema: filas e pilhas.
Sistema operacional. Mac e Windows são brinquedinhos e Linux é um vídeo-game que dá mais trabalho de configurar do que de jogar. O programador de verdade usa algo como mainframes ou qualquer outro sistema operacional beta, que são bem esquisitos de mexer e que podem fazer um verdadeiro estrago nas mãos de quem não tiver lido TODO o manual. E saber todos os bugs conhecidos e importantes do kernel e sua localização de cor na hora de bootar é vital.
Ferramentas. Se você depende de uma IDE que tem Code Completion e outros penduricalhos do tipo, ou depende de algum outro editor seu favorito com seus 17459 plugins instalados, então você não é um programador de verdade. um programador de verdade usa o que tiver à mão na hora que precisar, seja um notepad, um hexdump ou até mesmo alguns beeps. A ferramenta não é limite para quem sabe programar de verdade.
Depuração. Vai dizer que precisa do código-fonte para depurar? Então você não faz a mínima ideia do que o programa faz. Apenas algumas olhadas na call stack e nos registradores podem fazer um programador de verdade solucionar um bug que os comedores de torta não conseguiriam depois de analisar aqueles gráficos UML com caixinhas dentro e casos de uso por meses a fio.
O Trabalho de programadores de verdade com certeza não é fazer programinhas que acessam basezinhas de SQL com opção de consulta e cadastro. Nem são aqueles saitezinhos com PHP/Apache, scripts e mais scripts. Não, senhor. São programas que lidam com o Sistema Operacional de uma forma mais íntima (criptografia de HD, drivers de File System, serviços de comunicação crítica, etc), ou são programas que fazem algo de verdadeiramente útil (compiladores, o próprio sistema operacional). Ou tavez que mexam diretamente com hardware (microcontroladores complexos, robôs, naves, aparelhagem médica, etc).
A Diversão de todo programador de verdade é conversar com os amigos (sobre programação), ler alguma coisa (sobre programação) e assistir filmes inteligentes (sobre programação ou pessoas que fizeram algum tipo de desafio intelectual &amp;quot;na marra&amp;quot;). Existe algo mais divertido que isso?
E, por fim, em seu Habitat Natural, poderemos encontrar páginas de código assembly espalhadas em volta da mesa, um computador travado por uma depuração remota de kernel por cabo serial, algumas anotações em hexa em um pedaço de papel, algumas dezenas de páginas abertas no navegador sobre comportamento das funções BIOS em HDs SATA com mais de 500 GB trabalhando em RAID4, café, salgadinhos, manchas no carpete. Quando não há nada para fazer, o ambiente está arrumadíssimo e não se nota a presença de programadores de verdade à vista.
E o Futuro do programador de verdade? Bom, a linguagem C pode até estar morrendo. Mas, e daí? Essa tal de C&#43;&#43; ainda suporta ponteiros. O resto das abstrações afeminadas como classes e herança podem ser totalmente ignoradas. O básico sempre existirá. Esqueça as versões com herança múltipla e o enigmático concepts. Seja homem!
O fato é que, independente de quanto mais o mundo se tornar &amp;quot;gerenciado&amp;quot; por trás de frameworks e programadores que preferem &amp;quot;fazer projetos&amp;quot; atrás de seus pacotes de escritório e casos de uso, quando algum problema pipocar, algum bug tenebroso ameaçar a vida útil de um projeto, um programador de verdade estará lá para salvar o dia, pois só um programador de verdade sabe fazer o seu trabalho. E bem feito.
PS: Na verdade, me lembrei. Eu peguei esse cacoete de falar &amp;quot;quem sabe faz na hora&amp;quot; do meu amigo Thiago. Ele também dizia &amp;quot;se vira nos 30!&amp;quot;. Bom, se eu citar todas as frases brilhantes que ele usava quando trabalhávamos juntos o texto vai ficar bem longo =)
Se você gostou desse texto, talvez goste de eXtreme Go Horse!
</description>
</item>

     
        <item>
  <title>A sala da fila das threads</title>
  <link>http://www.caloni.com.br/a-sala-da-fila-das-threads/</link>
  <pubDate>2009-04-17</pubDate>
  
  <guid>http://www.caloni.com.br/a-sala-da-fila-das-threads/</guid>
  <description>Quando falei sobre a fila das threads, e como cada thread espera pacientemente em uma fila até chegar sua vez de ser atendida no guichê das CPUs, também vimos como é fácil fazer caquinhas em um programa que roda paralelamente duas threads ou mais.
Também falei que iríamos resolver esse problema, afinal de contas, temos que salvar todos aqueles programas que usam dezenas de threads trabalhando ao mesmo tempo para contar números de um até dez.
A boa notícia é que o salvamento é mais simples do que parece: coloque todas as suas threads em uma sala trancada e deixe apenas uma chave. As threads terão que brigar para sair da sala e, depois que a vencedora sair, as outras terão que ficar esperando ela voltar.
Confuso? Se estiver, ainda bem. Isso quer dizer que estamos novamente em um daqueles artigos com &amp;quot;pseudo-parábolas&amp;quot;, a maneira mais ilustrada de explicar as coisas.
Os SOs modernos possuem inúmeras maneiras de controlar e monitorar o acesso a recursos do sistema. Neste breve artigo irei falar apenas de um: o critical section, ou, em tradução livre, &amp;quot;seção crítica&amp;quot;. O &amp;quot;seção&amp;quot; desse nome diz respeito a uma seção do programa, ou seja, um pedaço de código mesmo. Um pedaço de código crítico.
Resumidamente, um critical section é um recurso que apenas uma thread por vez pode obter. Para que outra thread tenha acesso ao mesmo critical section, a primeira thread que o obteve deve soltá-lo. Enquanto ela não solta, as outras threads ficam paradas, esperando pela chave, na sala trancada.
Do ponto de vista do programador o critical secton é apenas uma estrutura que é usada na chamada de quatro funções básicas: para inicializar o recurso, para entrar na seção crítica, para sair da seção crítica e para liberar o recurso, quando aquele critical section não será usado mais.
Falando assim, parece simples. Bom, na verdade é simples, mesmo. Tudo que você precisa para corrigir o programa do artigo anterior é criar um critical section e fazer com que as threads obtenham-no antes de mexer com o contador compartilhado.
#include &amp;lt;windows.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#define MAX_COUNTER 10int g_counter = 0;CRITICAL_SECTION g_cs;DWORD WINAPI Increment(){DWORD tid = GetCurrentThreadId();while( g_counter &amp;lt; MAX_COUNTER ){// esse é o começo de nossa // seção crítica// só uma thread entra// por vez por aquiEnterCriticalSection(&amp;amp;g_cs);int temp = g_counter;temp = temp &#43; 1;Sleep(0); // indo para // o final da filag_counter = temp;// esse é o fim de nossa // seção crítica// a partir dessa chamada // outra thread pode // entrar pelo começoLeaveCriticalSection(&amp;amp;g_cs);printf(&amp;quot;Counter: %d&amp;quot;&amp;quot;\t\tThread: %d\n&amp;quot;, temp, tid);}return 0;}int main(){HANDLE threads[3];DWORD tids[3];// precisamos inicializar // nosso recurso de // seção críticaInitializeCriticalSection(&amp;amp;g_cs);for( int i = 0; i &amp;lt; 3; &#43;&#43;i ){threads[i] = CreateThread(NULL, 0, IncrementGlobalCounter, 0, 0, &amp;amp;tids[i]);printf(&amp;quot;Thread %i: %d\n&amp;quot;, i, tids[i]);}// aguarda as threadsWaitForMultipleObjects(3, threads, TRUE, INFINITE);// agora precisamos liberar o // recurso de seção críticaDeleteCriticalSection(&amp;amp;g_cs);} Para finalizar, algo para pensar: se uma thread só consegue um critical section depois que outra thread soltá-lo, o que acontece se essa outra thread estiver esperando por outro critical section que uma thread que aguarda estiver segurando?
Acabamos de ilustrar um procedimento muito simples para cagar completamente no código e gerar um travamento que pode demorar de horas a semanas para ser detectado e resolvido. É o conhecido deadlock. Se você não entendeu ainda, imagine que, para voltar à sala das threads, a primeira thread que saiu precisa de duas chaves; só que ela só pegou a primeira, e a segunda está dentro da sala. Para pegar a segunda chave, ela precisa entrar na sala, só que a sala está trancada pelas duas chaves!
Deadlocks são sempre indesejáveis, e é por isso que existem diversas técnicas para tentar evitá-los. A mais conhecida é sempre obter os critical sections na mesma ordem. Dessa forma a obtenção de recursos é hierarquizada, o que impede que dois CSs estejam no mesmo nível de obtenção, evitando que duas threads distintas os obtenham.
Espero que tenha ficado claro nossa breve explanação de como podemos controlar programas multithreading. Espero, pois a próxima tarefa é entender outros conceitos mais abstratos e virtuais, como funções virtuais e classes abstratas.
</description>
</item>

     
        <item>
  <title>A fila das threads</title>
  <link>http://www.caloni.com.br/a-fila-das-threads/</link>
  <pubDate>2009-04-07</pubDate>
  
  <guid>http://www.caloni.com.br/a-fila-das-threads/</guid>
  <description>Em um ambiente multithreading diversas threads disputam &amp;quot;a tapas&amp;quot; a atenção do processador (CPU). Certo? Podemos dizer que, em um ambiente com muito processamento a realizar, de certa forma é isso que acontece. São threads e mais threads rodando um pedacinho de código cada vez que passam pelo processador.
Um ambiente complexo como um sistema operacional executando dezenas (às vezes centenas) de programas é repleto de pequenos detalhes que podem fazer o iniciante logo desanimar quando tentar depurar um programa com mais de uma thread. De fato, eu já percebi que muitos não vão saber nem como começar a pensar sobre o problema.
Uma forma de visualizar o cenário multithread começa na fila das threads. Elas estão indo em direção ao guichê das CPUs onde vão conseguir tempo de processamento para rodar seu código. Depois que elas esgotam seu tempo elas se dirigem para o final da fila esperando por mais tempo para executar mais código.
Para simplificar este cenário vamos imaginar duas threads iniciando com o mesmo código. Esse código incrementa um contador global até ele chegar a dez, quando a função retorna e as threads terminam.
int count = 0;increment() {while( count &amp;lt; 10 ) {count&#43;&#43;;print(tid, count);}}main() {thread t1(increment);thread t2(increment);} O tid no pseudo-código acima é sinônimo para Thread ID, o identificador único de uma thread, que costuma ser um número. Para simplificar vamos dar ao id os apelidos de t1 e t2. Esta é uma possível saída do código acima, dependendo de quantos processadores e cores possui a máquina:
t1 1t1 2t1 3t1 4t1 5t1 6t1 7t1 8t1 9t1 10 Pelo jeito a primeira thread não deu chance para a outra executar. Isso acontece por causa do pequeno espaço de tempo que é necessário para realizar a tarefa de incrementar uma variável. É tão pequena a tarefa que nem foi suficiente para a primeira thread ficar sem tempo e a CPU mandar ela para o fim da fila. Por isso a segunda thread nunca chegou a incrementar o contador.
Quando uma thread quer realizar algum processamento, ela precisa entrar na fila das threads ativas, que aguardam pela CPU que irá atendê-las. Nessa fila ela pega uma senha e aguarda a sua vez. Só que cada vez que uma thread é atendida ela ganha um tempo limitado de atendimento, que na arquitetura do sistema operacional é chamado de quantum ou time slice. Se o quantum de uma thread estoura, ou a thread não tem mais nada pra fazer, ela sai do guichê de atendimento e volta a ficar inativa, ou volta para o final da fila, aguardando por mais processamento.
Uma thread pode opcionalmente ir para o final da fila por conta própria. Para isso, basta que ela chame uma função do sistema operacional pedindo para dormir. Por isso geralmente essa função é chamada de sleep na API do sistema operacional. Nessa função costuma haver um parâmetro de quanto tempo a thread deseja dormir. Se for maior que zero ela vai para a fila de threads dormindo até passar esse tempo, para depois se dirigir à fila de threads ativas, aguardar para ser processada. Se o tempo passado for exatamente zero ela vai direto para essa última fila, mas ficará sem executar do mesmo jeito, pois esta é a fila de quem está aguardando pela sua próxima fatia de tempo de processamento.
Se chamarmos a função para dormir no código da thread antes de voltar a incrementar o contador é possível que a segunda thread tenha chance de executar.
increment() {while( count &amp;lt; 10 ) {count&#43;&#43;;print(tid, count);sleep();}} Agora cada thread, depois de incrementar uma vez o contador, volta para o final da fila. Dessa forma vemos uma thread de cada vez incrementando o mesmo contador.
t1 1t2 2t1 2t2 3t1 4t2 4t2 6t2 7t1 5t1 8t2 8t2 9t2 10 Peraí, o mesmo contador? Isso pode gerar problemas. Se duas threads tentarem incrementar o mesmo contador ao mesmo tempo, quem garante que elas não irão incrementar o mesmo valor? Bom, se você é bom observador já deve ter reparado que na execução acima ocorreu exatamente isso, com mais de uma thread incrementando o contador com o mesmo valor.
Para forçar isso acontecer mais rápido e de maneira mais gritante podemos fazer a thread ir para o final da fila antes de incrementarmos e após pegarmos o valor atual do contador. Note que nesses testes a saída muda completamente dependendo de quantos processadores sua máquina tem. O resultado às vezes pode ser bem bizarro do que o visto nesse artigo. 1
increment() {while( count &amp;lt; 10 ) {int c = count;sleep();c&#43;&#43;;print(tid, c);count = c;}} O código acima pode gerar a seguinte saída:
t1 1t2 1t1 2t2 2t1 3t2 3t1 4t2 4t1 5t2 5t2 6t1 6t2 7t1 7t1 8t2 8t2 9t1 9t2 10t1 10 Explicando mais uma vez com mais detalhes: quando uma thread guarda o valor do contador na variável local e volta para o final da fila, ela deixa de armazenar o contador atualizado para apenas depois que todas as outras threads passarem na sua frente. Só que as outras threads também pegam o mesmo valor do contador, pois ele ainda não foi alterado. Quando chega a hora da segunda passada no guichê das CPUs, todas as threads incrementaram o mesmo valor do contador. Se houvesse apenas um processador em uma máquina o fluxo de execução do ponto de vista do processamento único para duas threads ficaria mais ou menos o seguinte (zzz é quando uma thread dorme):
t1 c = count (0)t1 zzzt2 c = count (0)t2 zzzt1 c&#43;&#43; (1)t2 c&#43;&#43; (1)t1 print c (1)t2 print c (1)t1 count = c (1)t2 count = c (1)t1 c = count (1)t1 zzzt2 c = count (1)t2 zzz... O exemplo acima forçou essa situação, mas é preciso lembrar que isso pode acontecer mesmo sem a thread dormir. É possível que o tempo da thread se esgote e ela pare de ser atendida justo na hora que iria salvar a variável c no contador global. Dessa forma, ela vai para o final da fila à força e, quando voltar a ser atendida, uma outra thread já terá lido o valor anterior para ela própria incrementar.
O que gostaríamos que acontecesse para corrigir o problema é forçar a segunda thread a esperar antes que a primeira termine todo o processo de incrementar e salvar no contador global, o que resolveria o nosso problema (o wait no exemplo abaixo é uma thread aguardando e não fazendo nada):
t1 c = count (0)t1 zzzt2 waitt1 c&#43;&#43; (1)t2 waitt1 print c (1)t2 waitt1 count = c (1)t2 waitt1 readyt2 c = count (1)t1 waitt2 c&#43;&#43; (2)t1 waitt2 print c (2)t1 waitt2 count = c (2)t2 readyt1 c = count (2)t2 wait... Esse wait do fluxo, ou seja, deixar a próxima thread aguardando a que chegou primeiro incrementar, pode ser obtido se utilizarmos um mecanismo de acesso exclusivo fornecido pelo sistema operacional. Uma outra história para contar, que chamarei de &amp;quot;A sala da fila das threads&amp;quot;.
  Eu mesmo em meus testes não pude usar sleep passando zero como o tempo para dormir porque meu número de processadores não permite que eu faça esse experimento, já que sempre vão existir processadores dispostos a reprocessar a thread que acabou de ir para o final de sua fila. &amp;#x21a9;&amp;#xfe0e;
   </description>
</item>

     
        <item>
  <title>Depurando até o último segundo</title>
  <link>http://www.caloni.com.br/depurando-ate-o-ultimo-segundo/</link>
  <pubDate>2009-03-31</pubDate>
  
  <guid>http://www.caloni.com.br/depurando-ate-o-ultimo-segundo/</guid>
  <description>Como depurar um programa que dá pau logo no final do desligamento de uma máquina?
No cenário em que isso se passa não existem usuários logados no momento, o que significa a impossibilidade de rodar qualquer programa em uma sessão prévia e mantê-lo no ar após o logoff. A não ser que se trate de um serviço.
O nosso programa é justamente um serviço, e por isso ele continua rodando até o final, ou bem perto dele. A primeira ideia que vem à mente é instalar o Msvcmon - depurador remoto do Visual Studio - como um serviço, como aliás já foi demonstrado neste blogue.
Essa é uma boa ideia, de fato. Contudo, não podemos esquecer que a ordem de descarregamento dos serviços pode não favorecer o nosso depurador remoto e ele ir embora antes que consigamos &amp;quot;atachar&amp;quot; nosso VC no programa faltoso. Além do mais, a própria rede, que é disponibilizada com a ajuda de serviços, pode não estar no ar, mesmo que o Msvcmon esteja.
Tudo bem, vamos dizer que você é um expert em configuração de dependências de serviços e conseguiu fazer com que a rede, o Msvcmon e o programa faltoso sejam os últimos serviços - com exceção dos drivers - a serem descarregados. Bravo!
Contudo, isso não vai adiantar de muita coisa se for necessário parar a execução por um breve momento e analisar a pilha por, digamos, cinco segundos. Esse é o tempo que o sistema - que continua rodando - precisa para desligar a máquina.
Agora o problema é outro: não há tempo para análise durante a depuração, pois o sistema continua rodando. Nesse caso, teremos que ser mais radicais e parar o próprio sistema para que possamos depurar calmamente o problema. Isso implica em termos que utilizar um depurador de kernel (WinDbg), pois só ele tem poderes de congelar o sistema inteiro.
Mas, ainda assim, precisamos de um depurador de user para fazer análises mais profundas ou, pelo menos, mais simples, com a ajuda de símbolos e tudo mais. Nesse caso é necessário usar um depurador de user que redireciona o controle para o depurador de kernel. A transição user mode &amp;gt;&amp;gt; kernel mode pode ser feita com apenas algumas configurações antes do reboot.
E, após toda essa bagunça, podemos depurar, no conforto de uma VM, o bendito programa matador.
</description>
</item>

     
        <item>
  <title>Os problemas mais cabeludos</title>
  <link>http://www.caloni.com.br/os-problemas-mais-cabeludos/</link>
  <pubDate>2009-03-05</pubDate>
  
  <guid>http://www.caloni.com.br/os-problemas-mais-cabeludos/</guid>
  <description>Quase todos os problemas do Universo são resolvidos depois de um belo dia de depuração, código comentado, descomentado, recomentado e umas muitas e boas doses de café. Alguns outros problemas mais cabeludos precisam de uma boa noitada na frente do computador, e mais café. E, finalmente, existem aqueles que nem tomando o estoque inteiro de café a coisa anda.
Um exemplo: um hook global do Windows que quando ativado em determinados eventos envia mensagens para uma única janela que cataloga informações sobre diversas janelas e processos no sistema. Esse procedimento é uma subfunção do programa principal, que já possui seus próprios problemas e idiossincrasias. Em momentos aparentemente aleatórios algumas funcionalidades não parecem estar de acordo com o que se espera.
Para esse tipo de situação que envolve 1. o sistema como um todo, 2. processos de terceiros e 3. comportamento obscuro por parte do resto do código, vale a pena seguir um checklist mais rigoroso, colocar seu bonezinho de CSI e partir para desmembrar o funcionamento do código problemático:
  Como o programa deveria funcionar?
  O que exatamente não funciona?
  O que pode ser? O que NÃO pode ser?
  Existe uma maneira de provar?
  Cada uma dessas perguntas deve ser respondida com a maior sinceridade e disciplina, custe o que custar.
Esse deve ser o primeiro e mais importante indício do que pode estar acontecendo. Sem entender o funcionamento do programa, dificilmente conseguiremos passar para os passos seguintes. Na maioria das vezes, sem saber onde a coisa começa e termina, o problema vai ficar rindo da nossa cara até entendermos de fato que aquele if não merece estar naquela linha.
Para facilitar esse entendimento, nada como elaborar uma pequena explicação para si mesmo no estilo How Stuff Works. Não precisa exagerar e fazer uma tese a respeito e criar vídeos explicativos. Só precisa descrever o fluxo com os detalhes aparentemente importantes para a resolução do problema.
Continuando nosso exemplo:
  O programa inicia e cria uma _thread _específica.
  Essa _thread _específica cria uma janela que monitora e carrega uma DLL.
  Essa DLL é chamada pela _thread _e instala um _hook _global no sistema.
  O _hook _recebe eventos de todos os processos que possuem janelas.
  Quando eventos específicos são disparados, o processo atual envia uma mensagem para a janela que monitora.
  A janela que monitora monta uma tabela estatística dos eventos.
  De tempos em tempos, essa tabela é escrita em disco em um arquivo encriptado.
  A lista acima é longa o suficiente para podermos elaborar perguntas interessantes e pequena o suficiente para podermos ter em mente o seu funcionamento como um todo, o que é vital para o sucesso das observações durante a depuração.
Note que a pergunta nos direciona para o sintoma do problema, não o problema em si, que provavelmente ainda não é conhecido. E nunca é demais lembrar que podemos estar lidando com uma série de problemas trabalhando em conjunto para nos deixar acordados por dias a fio.
Exemplos de respostas possíveis: a tabela estatística perde a lógica em determinado momento, o hook algumas vezes não funciona, aleatoriamente um dos processos &amp;quot;hookados&amp;quot; capota.
Essa pergunta deve ser respondida com uma análise das respostas das duas primeiras perguntas. Batendo os sintomas do problema com o seu funcionamento macro, uma ou mais cabeças aos poucos irão elaborando teorias a respeito de onde pode estar falhando.
Ex: talvez por algum motivo a DLL esteja sendo descarregada (que lugares podem ser estes?), alguém está desinstalando o hook (quais as partes do código que fazem isso?), alguma ferramenta de análise está atrapalhando nossos resultados (o que acontece se rodarmos sem o DebugView?).
Ao mesmo tempo que os sintomas do problema acusam que algo está errado, existem os sintomas de que alguma coisa, afinal de contas, está funcionando nessa porcaria de código. Através dos sintomas positivos é possível chegar a algumas conclusões sobre o que está funcionando bem.
Ex: o arquivo de log está sendo atualizado, a thread da janela que monitora recebe mensagens continuamente, algumas informações da tabela não estão corrompidas.
Esse é o pulo do gato, a parte que diferencia meninos e meninas de homens e mulheres. Se conseguirmos, através de código de teste e/ou observação, aos poucos provar nossas conclusões a respeito do problema e conseguir elaborar, passo a passo, uma &amp;quot;maquete mental&amp;quot; de todo o código funcional, será possível aos poucos ir descartando teorias e reforçando nossa confiança sobre o caminho que estamos trilhando.
Às vezes uma pequena mudança no código pode provar inúmeras coisas, como inocentar algumas partes e proteger-se de acusações infundadas feitas anteriormente. É uma briga contra o próprio ego, especialmente se o código foi feito por você mesmo.
Ex: Desabilitei o tratamento dos eventos e o hook continua funcionando.
O importante é nunca parar de pensar sobre o problema, evitando ao máximo agir mecanicamente e por impulso, a não ser que exista um bom motivo para isso. Às vezes apenas pensando de novo sobre o mesmo assunto comprova-se algo. É uma fase muito rica e próspera na resolução de problemas e deve ser aproveitada.
Ex: Quando estava habilitado o tratamento de eventos, o hook parava de funcionar em menos de cinco minutos. Agora, rodando os testes por três horas, o hook continua ativo.
Ex: Desabilitei um dos eventos que possui comunicação remota com o servidor. O hook continuou funcionando, apesar do resto dos eventos.
Por fim, com uma pequena dose de sorte e muitas doses de força de vontade (e café), o problema cansa de se esconder e mostra a cara.
Ex: Quando há falha na comunicação com o servidor com o erro 666 uma exceção é lançada, e quando capturada tenta gerar um logue, só que esse logue está mal formatado e causa com que a thread inteira vá para o espaço.
Essa é a hora em que todos se esquecem do esforço que custou chegar até ali e não documentam nada do que foi feito. Desse jeito perde-se todo esse tempo não apenas uma vez, mas todas as vezes que alguém diferente do time mexer com a mesma situação. Por isso deve-se, com a cuca fresca, escrever algumas dicas de como reproduzir o problema e elaborar um pequeno relatório ou algo que o valha do que foi feito, como foi feito e por que funcionou. Mais uma vez, não exagere. Deixe as apresentações sofisticadas de PowerPoint para os outros departamentos da empresa.
Como deve ter parecido, esse tipo de abordagem leva tempo e não é fácil de ser levado adiante sem disciplina e muita persistência. Por esse motivo é que só deve ser usado naqueles problemas em que já se perdeu uma imensidade de tempo e esperança, uma situação irremediável e que ainda não conseguiu vislumbrar o dia em que finalmente poderemos dedicar nossas vidas profissionais para uma outra tarefa mais interessante.
</description>
</item>

     
        <item>
  <title>WinDbg.info</title>
  <link>http://www.caloni.com.br/windbginfo/</link>
  <pubDate>2009-02-10</pubDate>
  
  <guid>http://www.caloni.com.br/windbginfo/</guid>
  <description>Para os perdidos e desatualizados como eu, notei hoje que Robert Kuster possui um saite onde mantém diversas informações sobre o WinDbg; uma espécie de continuação de sua famosa transparência &amp;quot;WinDbg. From A to Z&amp;quot;.
Como eu descobri? Bom, ele me mandou um e-mail perguntando se poderia deixar sua tradução para inglês do meu artigo como Foreword para os slides =)
</description>
</item>

     
        <item>
  <title>As funções-polegar</title>
  <link>http://www.caloni.com.br/as-funcoes-polegar/</link>
  <pubDate>2009-01-30</pubDate>
  
  <guid>http://www.caloni.com.br/as-funcoes-polegar/</guid>
  <description>Como já havia dito, não há nada mais prazeroso do que ensinar a alguém os velhos truques da profissão e relembrar o porquê de tantas coisas que guardamos na cabeça sobre programação. Hoje tive a oportunidade de explicar como funcionam as funções-polegar.
A função-polegar, uma categoria de função muito peculiar em várias APIs, possui um comportamento padrão de retorno de erros. Entre as diversas funções-polegar que conheço e uso, eis algumas que lembro de cor:
 read, write (C) connect.aspx), send.aspx) (Sockets) ReadFile.aspx), WriteFile.aspx), CreateProcess (Win32)  O que todas essas funções têm em comum? Bom, ignorando seu funcionamento interno ou seu objetivo, todas elas possuem um valor de retorno no estilo sim ou não, ou seja, deu certo ou não deu. Nessas funções o código de erro, o motivo da função não ter dado certo, não é retornado diretamente. É o que chamo de esquema do polegar pra cima ou polegar pra baixo. O retorno da função especifica o ângulo giratório do dedão:
 ssize_t pread, ssize_t write. Retorno de -1 significa que deu algo errado. int connect, int send. Se retornar SOCKET_ERROR BOOL ReadFile, BOOL WriteFile, BOOL CreateProcess. TRUE sucesso, FALSE erro.  Por exemplo, chamamos a função ReadFile para ler um arquivo. Ela retorna FALSE. Isso significa que não deu certo nossa leitura. Por quê? Ora, não sabemos ainda. Apenas sabemos que o polegar está virado para baixo!
Em funções nessas condições, geralmente existe uma segunda função (ou variável) que retorna o último erro que ocorreu na API, ou seja, o erro que fez com que última função chamada retornasse que algo não deu certo. Nas funções de exemplo, são usados três métodos distintos, pois estamos falando de três APIs distintas:
  Variável errno
  Função WSAGetLastError.aspx)
  Função GetLastError.aspx)
  São esses métodos que realmente retornam o porquê da função ter dado errado. E é elas que devemos chamar, eu disse devemos chamar, sempre que a função der errado. Até porque, já que o polegar está virado para baixo, temos que fazer alguma coisa para que nosso programa não morra.
Como bem observado pelo Fernando no comentário abaixo, nem todas as funções-polegar possuem uma função para obter a causa do erro. Vide SysAllocString, ou mesmo malloc. Nesse caso, não há muito o que determinar a não ser que não foi possível alocar o recurso pedido pelo sistema. Paciência.
</description>
</item>

     
        <item>
  <title>Básico do básico: assembly</title>
  <link>http://www.caloni.com.br/basico-do-basico-assembly/</link>
  <pubDate>2009-01-26</pubDate>
  
  <guid>http://www.caloni.com.br/basico-do-basico-assembly/</guid>
  <description>É lógico que não poderia faltar no cinto de utilidades de todo bom programador C conhecimentos básicos da linguagem assembly, sua mãe espiritual. São tantos conceitos em comum que, uma vez aprendido seu funcionamento, fica difícil não pensar no código-assembly gerado pelo compilador C. E é nesse ponto que as coisas começam a ficar mais claras.
Antes de tudo, é importantíssimo lembrar que o foco aqui é apenas a arquitetura 8086, um dos marcos na invenção de computadores de massa, mas que existem trocentros outros modelos de processadores e computadores funcionando mundo afora. Não deixe sua mente fechar para os outros tipos de modelos.
A CPU trabalha em conjunto com a memória RAM. Só que o acesso à essa memória, apesar de rápida, não é comparável à velocidade em que as coisas ocorrem dentro da própria CPU. Esse é apenas um dos motivos para a existência de um conjunto bem menor de memória que vive nas entranhas do processador, bem ao lado dele. São os chamados registradores.
Os registradores são memória do tipo ultra-rápida que funciona no mesmo ritmo do processador. A maioria das instruções executadas pela CPU faz referência a pelo menos um registrador. E por um motivo muito simples: é o modelo de entrada-e-saída funcionando!
No modelo de entrada-e-saída, ultrassimplificado por mim nesse artigo, o processador executa microinstruções muito básicas, que juntas fazem alguma coisa de útil, por exemplo, somar dois números:
x = y &#43; z;
A operação acima é realizada através de microinstruções bem sucintas:
  **Leia memória y para registrador 1 **
  ** Leia memória z para registrador 2 **
  **Some valor de registrador 1 e 2 e coloque resultado no registrador 1 **
  Carregue memória x com valor do registrador 1
  É lógico que o sistema não se baseia apenas em movimentações simples de memória. Existem algumas abstrações que estão incrustadas no funcionamento da arquitetura. Uma das mais importantes é o conceito de pilha, vital tanto em arquitetura, quanto assembly, quanto linguagem C e muitas outras linguagens, também.
Pilha é uma forma de armazenar memória em blocos empilhados um-a-um. Esses blocos são empilhados na ordem a, b, c e desempilhados na ordem c, b, a. Ou seja, quem foi empilhado por último será o primeiro a ser desempilhado. A analogia com uma pilha de pratos é óbvia e simples de imaginar.
Para isso funcionar em termos de memória computacional, o programa reserva um espaço de memória com começo e fim que irá guardar os blocos empilhados. Além de ter começo e fim é necessário ter um marcador de onde estamos para empilhar o próximo item ou desempilhar o último.
Se você pensou rápido, a resposta é sim, existem registradores para guardar a posição na pilha em que estamos. Aliás, quando mudamos de função, o valor desses registradores é salvo na própria pilha, já que voltaremos à mesma posição após a chamada.
Resumidamente, temos no PC os seguintes tipos de registradores e seu uso geral na programação C:
Registradores de uso geral. EAX, EBX, ECX, EDX. Registradores de código e dados. ESP, EBP, EIP.
Você os verá em 90% das ocasiões em que desassemblar seu código C, pois a rotina do código não muda muito: soma, divide, multiplica, muda endereço do código (saltos), compara valores (flags).
Flags? Ah, sim, as flags! Elas são importantíssimas para o funcionamento sadio de nossos programas. Sem as flags, não teríamos coisas maravilhosas e fundamentais na programação moderna, tais como o salto condicional.
As flags são bits que mudam de acordo com algumas instruções, principalmente as de comparação (vide cmp). Após a execução de comparação, o estado de determinadas flags junto da próxima instrução (que deverá ser um salto condicional) irá dizer para onde o programa irá pular sua execução. É assim que temos o if:
if( x == 10 )XEhIgualA10();elseXEhDiferenteDe10();
O código acima seria representado em assembly mais ou menos como abaixo:
 carrega valor de x no registrador 1 2. compara registrador 1 com 10 3. pula para 6 se for diferente 4. chama XEhIgualA105. pula para 76. chama XEhDiferenteDe107. próxima instrução  Opcodes para aprender:   mov
  cmp
  jmp
  jne, jle, jnz, etc
  push e pop
  call e ret
  Pedaços de código que vale a pena estudar:    push ebpmov epb, esp    push eaxmov ecx, dword ptr[variavel]push 10call funcao    cmp somethingjne | jne | jae | ... O que é legal de fazer para treinar assembly Desmonte programas, chamadas API. Veja que funções internas elas chamam para realizar determinada tarefa. Tente mudar o comportamento do programa para provar que suas observações sobre o funcionamento estavam corretas.
</description>
</item>

     
        <item>
  <title>HouaissParaBabylon versão 1.1</title>
  <link>http://www.caloni.com.br/houaissparababylon-versao-11/</link>
  <pubDate>2008-12-30</pubDate>
  
  <guid>http://www.caloni.com.br/houaissparababylon-versao-11/</guid>
  <description>Saindo mais um do forno.
Essa nova versão do conversor do dicionário Houaiss para Babylon corrige o problema de não encontrar o Houaiss 1.0. O problema ocorria porque o conversor se baseava na localização do desinstalador para encontrar o dicionário. Na primeira versão do dicionário o desinstalador fica na pasta c:\Windows, onde obviamente não estava o dicionário.
Nessa nova versão, além de procurar o caminho do dicionário no registro (desinstalador) e antes de pedir para o usuário o caminho correto é tentado o caminho padrão de instalação, %programfiles%\Houaiss. Se mesmo assim o dicionário não existir continuamos perguntando para o usuário, que tem a opção de dizer onde está instalado o dicionário no disco rígido ou apontar diretamente para o CD de instalação.
</description>
</item>

     
        <item>
  <title>Básico do básico: binário</title>
  <link>http://www.caloni.com.br/basico-do-basico-binario/</link>
  <pubDate>2008-12-18</pubDate>
  
  <guid>http://www.caloni.com.br/basico-do-basico-binario/</guid>
  <description>Apesar do tema binário, o assunto de hoje no fundo remete-nos a todo e qualquer tipo de representação. É o faz-de-conta um pouco mais intenso, vindo das profundezas da matemática e dominado com maestria pela nossa mente e sua capacidade lógica de abstrair.
Como todos sabemos, nós, seres humanos, somos dotados de dez dedos: cinco em cada mão. Isso influenciou fortemente nosso sistema de contagem de coisas, e, como consequência, nossa forma de representar números.
No entanto, números serão sempre números, independente de seres humanos e de dedos. Outros seres inteligentes de outras galáxias poderiam representar os mesmo números, sendo um conceito lógico independente de raça, usando qualquer outra forma e quantidade de símbolos. Por falar em símbolos, nós temos dez, a saber:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9 Outros seres poderiam usar, sei lá, dois:
0, 1 É lógico que esse &#39;0&#39; e esse &#39;1&#39; podem ser representados por outros sinais, como pedra e pau, cara e coroa, tico e teco, e por aí vai a valsa.
O importante é que seriam na quantidade de dois.
Último detalhe O nosso sistema de representação ainda possui algumas características singulares, como o valor posicional. Os mesmos dez símbolos, quando colocados em posições diversas, assumem valores diversos.
Dessa forma, quando esgotamos todos os símbolos e chegamos a nove, para irmos ao dez começamos a repetir os símbolos, mas em outra posição:
 7,8,9,10! A nova posição do símbolo &#39;1&#39; possui o próximo valor após o nove. O zero, como sabemos, apenas marca posições e não possui valor algum. Se valesse algo, seria somado, como no número 111, que é uma soma de três valores distintos posicionados de acordo:
100 &#43;10 &#43;1===111 Pronto! Eis toda a base de nosso sistema numérico. O resto é historinha pra boi dormir. Com isso é possível até mudarmos de base, ou seja, o número de símbolos usados, conforme nos convier.
Mudando de base Para nos comunicarmos com a raça alienígena que usa dois símbolos poderíamos contar seguindo o mesmo princípio:
 0,1,10,11,100,101,110,111,... O valor do número, como sabemos, depende de sua posição. Mas, calma lá! O 111 logo acima não é idêntico ao 111 que vimos anteriormente, pois mudamos a base! Agora só temos dois símbolos para representar números, quando antes tínhamos dez.
O &amp;quot;segredo&amp;quot; do valor posicional também está na base, pois o zero, apesar de não possuir valor, marca a quantidade de símbolos que foram utilizados para se esgotar uma posição qualquer. Dessa forma, enquanto o nosso conhecido 10 (dez) vale todos os símbolos não-nulos (nove) mais um (nove &#43; um = dez), o outro 10 (um-zero) da raça alienígena de dois dedos também vale todos os símbolos deles nã-nulos (um) mais um (um &#43; um = dois).
Contando em binário? Como não faz parte do tema, não vou explicar como o sistema binário foi importante para a definição de uma arquitetura simples o suficiente para ser expandida a níveis nunca antes imaginados de processamento e comprimida em espaços que muitos diriam não caber qualquer coisa de útil que fosse. No entanto, apesar de brilhante, o binário no dia-a-dia do programador gera alguns problemas. Principalmente se o programador escreve seus cálculos de ponteiros em binário.
Para entender isso, basta lembrar que, atualmente, a quantidade de memória RAM que é contada e, portanto, valor dos ponteiros que apontam para ela, é muito grande **até **para nosso sistema decimal, que possui, relembrando, dez símbolos. O que dirá, então, um sistema que possui meros dois símbolos para representar, digamos, três gigabytes:
11000000000000000000000000000000 São tantos zeros que aqueles bugs de _leak _de memória, famosos por levar tempo para ser corrigidos, seriam mais famosos ainda, pois o tempo gasto para se entender alguma coisa no meio de ponteiros dessa magnitude seria astronômico!
E, claro, ainda poderia ficar pior, se fosse depurado um desses novíssimos sistemas de 64 bits:
10011101101101101101101101101101101101101101 Contando de dezesseis em dezesseis Eu sei que não vou conseguir explicar tudo sobre bases numéricas em apenas um miniartigo. Porém, vamos dar uma rápida olhada no famoso hexadecimal, que foi o que nos salvou de lidar com os numerozinhos acima.
Nesse sistema, a representação dos número ocupa menos espaço ainda que o sistema decimal, pois usa **dezesseis **símbolos distintos, usando as letras de A a F após os já conhecidos símbolos decimais:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F A grande vantagem de contar as coisas em dezesseis é que sua representação será sempre um múltiplo de dois, o que facilita a conversão para o sistema binário: em um único número hexadecimal cabem quatro números binários, ou quatro bits.
Bin. Hexa Dec.0000 0 00001 1 10010 2 20011 3 30100 4 40101 5 50110 6 60111 7 71000 8 81001 9 91010 A 101011 B 111100 C 121101 D 131110 E 141111 F 15 Tabelinha básica, fácil de achar em qualquer lugar da internet, mas colocada aqui apenas para relembrar a relação entre as três bases.
Bom, acho que é isso. Já ultrapassei o limite do teórico, porque na verdade o que importa aqui, para captar de fato o binário dos fatos, é praticar:
Coisas para pensar a dois   Conte em binário quando não estiver fazendo nada. É simples e ajuda a fixar. Dessa forma: um, um-zero, um-um, um-zero-zero, um-um-zero, um-um-um, ...
  Decore a relação entre os números hexadecimal e binário. Você pode até esquecer isso depois, mas o esforço para decorar será útil para fixar. E nunca se sabe quando você terá que reaver a MBR de um cliente seu.
  Estude a lógica por trás da tabela ASCII e seus valores binários. Irá descobrir que existem relações muito óbvias entre letras, números (maíusculos e minúsculos) e sinais. Tente decorar.
  </description>
</item>

     
        <item>
  <title>Básico do básico: tipos</title>
  <link>http://www.caloni.com.br/basico-do-basico-tipos/</link>
  <pubDate>2008-12-12</pubDate>
  
  <guid>http://www.caloni.com.br/basico-do-basico-tipos/</guid>
  <description>Um tipo nada mais é que do que uma forma (ô) de bolo, que molda a memória como acharmos melhor moldá-la. Bom, para isso fazer sentido é necessário explicar memória, que é um conceito mais básico ainda.
A memória é qualquer lugar onde eu possa guardar alguma coisa. No artigo anterior era um punhado de gavetas. Mas poderiam muito bem ser caixas de presente. Ou um caderno. Ou até uma placa de memória RAM. O que sua criatividade quiser.
O importante no conceito de memória, computacionalmente falando, é saber que ela pode guardar qualquer tipo de informação, mas ela não sabe o que você está guardando. E eis que surge o segredo do tipo: ele conta para você, e seu programa, o que de fato está guardado na memória.
Vamos exemplificar.
Este artigo é um punhado de números na memória Computadores trabalham muito bem com números. A própria memória só guarda valores numéricos. Porém, se é dessa forma, como conseguimos abrir o Bloco de Notas e digitar algum texto?
Para entender essa &amp;quot;mágica&amp;quot; é necessário vir à tona o conceito de representação, um tema que ainda pode dar muito pano pra manga quando estudarmos base numérica. Por enquanto, basta saber que uma representação é um faz-de-conta em que todos concordam com o que for dito. Por exemplo: Faz de conta que a letra &#39;A&#39; é o número 65. Dessa forma, sempre que for visto o número 65, de agora em diante, será vista a letra &#39;A&#39; no lugar.
Existem alguns faz-de-conta que são muito difundidos entre e humanidade informática. Um deles é chamado tabela ASCII (se pronuncia &amp;quot;ásqui&amp;quot;). É uma forma de todos conseguirem entender os textos de todo mundo. Abaixo podemos ver a representação de todas as letras maiúsculas na codificação ASCII:
Número Letra====== =====65 A66 B67 C68 D69 E70 F71 G72 H73 I74 J75 K76 L77 M78 N79 O80 P81 Q82 R83 S84 T85 U86 V87 W88 X89 Y90 Z Agora, imagine que você digitou o seguinte texto no bloco de notas:
CASA Como esse texto é guardado na memória de um computador, se ele só entende números?
Através da nossa já conhecida tabela ASCII! Na verdade, números são armazenados na memória, mas por representarem as letras &#39;C&#39;, &#39;A&#39;, &#39;S&#39; e &#39;A&#39;, são traduzidos de volta para o formato texto pelo Bloco de Notas, que conhece o que guardou na memória.
A memória pode guardar qualquer coisa com números A técnica de representação pode guardar qualquer coisa na memória como números que serão traduzidos por algum programa que consiga abrir aqueles dados. Dessa forma podemos não só armazenar texto, como imagens, vídeos, páginas web e até mesmo os próprios programas que os abrem!
Na programação do dia-a-dia, as coisas funcionam da mesma forma. As tão faladas variáveis reservam um espaço de memória para guardar alguma coisa, mas só sabemos o que essa alguma coisa é através do tipo da variável:
// a variável idade (espaço de memória)// pode guardar um número (tipo)&amp;lt;/font&amp;gt;int idade; // a variável nome (espaço de memória) pode// guardar o nome de alguém de até 99 letras (tipo)char nome[100]; // a variável cad (espaço de memória) pode// guardar o cadastro de uma pessoa (tipo)Cadastro cad; Esses elementos, na memória, são um bando de número que, sem os tipos, não possuem significado algum, como podemos ver na depuração do programa abaixo:

Note que os números não estão aqui representados em decimal, onde se esperaria 35 e 42, pois a representação formal da memória geralmente está no formato hexadecimal, transformando esses números em 0x23 e 0x2a, respectivamente. Para entender essa diferença cabe estudar um pouco sobre base numérica, outro tema básico do programador sólido. Practice makes perfect Nada é bem aprendido se não for apreendido. Algumas tarefas programáticas que podem fixar o conceito de tipo estão listadas abaixo:
  Usar **printf **especificando tipos diversos (%d, %s, %f, %p, ...) para a mesma variável, inclusive correndo o risco de gerar algumas exceções.
  Usar scanf especificando diversas variáveis para o mesmo tipo (%d, %s, %f, %p, ...), vendo o resultado da leitura da entrada do usuário na memória.
  Tentar copiar o conteúdo de uma variável para outra variável de tipo diferente. Sempre analise a memória para ver o resultado.
  Outros faz-de-conta bem famosos   Ordenação de extremidades: O problema Little Endian e Big Endian.
  UNICODE: Por um conjunto de letras universal.
  Base numérica: O que são binário e hexadecimal e como eles afetam nossa vida.
  </description>
</item>

     
        <item>
  <title>Básico do básico: ponteiros</title>
  <link>http://www.caloni.com.br/basico-do-basico-ponteiros/</link>
  <pubDate>2008-12-06</pubDate>
  
  <guid>http://www.caloni.com.br/basico-do-basico-ponteiros/</guid>
  <description>Nessas últimas semanas tenho gastado meu tempo junto da mais nova pupila da SCUA, aspirante a programadora em C e Install Shield Script. Minha tarefa? Explicar tudo, desde o mais simples, como variáveis, até as coisas não tão triviais, como símbolos de depuração.
Posso afirmar que tem sido muito compensador ativar algumas partes do meu cérebro que acreditava nem mais existirem. Rever velhos conceitos, apesar de manjados, nos dá a oportunidade de lembrar que as coisas mais complexas que construímos no dia-a-dia se baseiam em um punhado de preceitos básicos que é essencial ter na cabeça. E nunca esquecê-los.
Meu amigo costuma chamar esses preceitos básicos de fundamentais. Isso por um bom motivo lógico e semântico: tudo que aprendemos de básico sobre qualquer área de conhecimento serve-nos de base para suportar as outras coisas que virão a ser entendidas na mesma área de conhecimento. Ou seja: é a parte mais importante a ser aprendida. Sem ela, a base, não nos é possível construir nada sólido e duradouro. Sem ela, toda a estrutura construída a posteriori se rompe e vai abaixo.
Foi partindo desse princípio que me preocupei com esmero para explicar as peças mais fundamentais do conhecimento em jogo, formadoras da cabeça de um programador para sempre, seja em C como em qualquer outra linguagem. E como nada é bem explicado sem formar imagens na cabeça, aproveitei para desenhar alguns esboços no papel. O resultado desses esboços é esse artigo.
Ponteiro: o eterno vilão da história Não tenho a presunção de conseguir explicar 100% para alguém iniciante o que são ponteiros em C, como usá-los e como se proteger deles. Definitivamente ponteiro não é um conceito simples, apesar de básico, e posso dizer sem vergonha que demorei cerca de seis meses no meu aprendizado em C pra entender completamente tudo relacionado com ponteiros. Demorou, quebrei a cabeça, mas depois nunca mais esqueci.
De acordo com o meu amigo Rafael, a melhor definição que usei até hoje para explicar esse conceito envolvia um armário repleto de gavetas, todas numeradas em ordem de posição (1, 2, 3...). Cada gaveta podia guardar qualquer coisa, inclusive o número de outra gaveta em um pedaço de papel. Com isso, eu poderia guardar em uma gaveta aleatória o que eu precisava guardar e escrever o &amp;quot;endereço&amp;quot; dessa gaveta em um pedaço de papel e guardá-lo na gaveta número 1, por exemplo. Com isso poderia até esquecer a posição onde está o que eu guardei, pois bastava abrir a gaveta número 1 e ler a posição em que estava essa gaveta.
Deve ter ficado óbvio, mas se não ficou: o armário é a memória RAM, as gavetas são váriáveis e as gavetas onde guardamos pedaços de papel são ponteiros, que não deixam de ser variáveis, e apontam para outras gavetas que são... adivinha? Outras variáveis!

[ ](http://i.imgur.com/GcnMNxv.jpg)
Outros conceitos que costumo utilizar é relacionar a memória RAM com a memória do programa e contar a memória como se contam carneirinhos. Dessa forma fica fácil pelo menos entender dois conceitos fundamentais na arte dos ponteiros: memória e endereço.
Practice makes perfect O segundo passo, acredito eu, é entender como a memória é dimensionada através do programa, e como o tipo molda a representação dos bits e bytes através das ligações de silício, mas isso fica pra mais tarde. Temos que programar, e é isso que vai de fato fazer a diferença no aprendizado de uma linguagem como C. Nada como uma boa mistura de teoria e prática para gerar um concreto armado que irá suportar um Empire State de conhecimento.
Por isso, segue uma lista de tarefas interessantes para exercitar o conceito de ponteiros:
  Criar funções que modificam números passados como parâmetro.
  Criar funções que modificam texto passado como parâmetro.
  Alocar e desalocar memória dinamicamente.
  Tarefas mais específicas da minha área e que uso o tempo todo:
  Escrever e ler texto em arquivos.
  Escrever e ler no registro do Windows.
  Obter o endereço de uma função do Windows dinamicamente. E chamá-la.
Nota: Não use as classes superiores de C&#43;&#43; nem referências. Estou falando de estudar ponteiros nua e cruamente. Não seja preguiçoso. Algumas coisas devem ser feitas da maneira mais &amp;quot;primitiva&amp;quot; até se entender com o que se está lidando. Lembre-se que os melhores programadores possuem os alicerces mais fortes.
  Bônus Points: Fantoches! Este vídeo é o mais didático do universo sobre como funcionam ponteiros em C. Veja e mostre pros seus filhos:
</description>
</item>

     
        <item>
  <title>HouaissParaBabylon versão beta</title>
  <link>http://www.caloni.com.br/houaissparababylon-versao-beta/</link>
  <pubDate>2008-11-15</pubDate>
  
  <guid>http://www.caloni.com.br/houaissparababylon-versao-beta/</guid>
  <description>Depois de muitos fins-de-semana divididos em horas picadinhas de programação de lazer, está disponível em vosso saite a primeira versão para usuários do conversor do dicionário Houaiss para o aplicativo Babylon.
Foi uma longa jornada, sim, mas espero que valha a pena para quem esperou. Também espero poder receber inúmeras respostas com dúvidas, sugestões e até mesmo mais problemas que vierem a acontecer.
Segue um pequeno roteiro do funcionamento do programa, que é bem simples, aliás. Para que tudo dê certo, no entanto, é necessário que o computador onde será feita a conversão possua os três programas abaixo instalados e funcionamento corretamente:
 Dicionário Houaiss. Testado na versão 2, deve ser instalado com opção de cópia dos arquivos no disco rígido. Babylon. Testado nas versões 6 e 7. Pode ser registrado ou não. Babylon Builder. O construtor dos dicionários Babylon. Apesar de ser possível construir dicionários personalizados para o Babylon, é necessário que se use esse aplicativo conversor. O HouaissParaBabylon o usa, e por isso precisa que ele esteja instalado corretamente.  Tudo isso verificado, basta então clicar no botão de Iniciar Conversão, sentar e esperar. A primeira fase envolve três passos:
 Desencriptação do dicionário original. Isso é feito baseando-se em nossa análise de engenharia reversa. Montagem do projeto de dicionário Babylon. Para isso existe um processo de interpretação do formato Houaiss, agora desencriptado, e sucessivas traduções para um projeto que o Babylon Builder irá entender. Construção do dicionário Babylon. Essa parte é feita pelo Babylon Builder. Por ser o maior dicionário de português da atualidade, esse processo pode demorar bastante, e com certeza irá se tornar o maior dicionário já instalado na sua lista de dicionários do Babylon.  Na segunda fase, após toda essa movimentação de HD, existe apenas uma coisa a fazer: instalar o dicionário no Babylon.
Quem faz isso é o próprio Babylon, se devidamente instalado. Se tudo deu certo, o HouaissParaBabylon sai de fininho e deixa o usuário com o progresso da instalação do dicionário Houaiss-Babylon.
Se não for encontrado o dicionário Houaiss devidamente instalado no disco rígido, será exibida uma mensagem de erro pedindo que a instalação seja feita dessa maneira. Se, contudo, não for possível localizar a instalação do dicionário, será pedido ao usuário que diga onde ela se encontra, ou aponte para a pasta &amp;quot;Houaiss&amp;quot; em seu CD de instalação, uma dica suficiente para que a operação seja bem-sucedida.
Outros erros comuns, como o Babylon Builder não instalado, serão obviamente avisados ao usuário. Erros mais raros terão um tratamento mais genérico. No entanto, nem por isso ele está livre de solução. Ao sair de uma conversão mal-sucedida, o usuário tem a opção de exportar o log de operações que foram realizadas durante a malfadada operação. Dessa forma, ele próprio conseguirá diagnosticar o problema ou, em casos mais sérios, me enviar o resultado de suas tentativas.
E é isso. Para uma versão inicial, talvez esteja razoável. Quem confirmará serão os ansiosos usuário que, espero sinceramente, consigam seus objetivos há tempos aguardados.
</description>
</item>

     
        <item>
  <title>Como funciona o PsExec</title>
  <link>http://www.caloni.com.br/como-funciona-o-psexec/</link>
  <pubDate>2008-10-29</pubDate>
  
  <guid>http://www.caloni.com.br/como-funciona-o-psexec/</guid>
  <description>Semana passada precisei reproduzir o comportamento da ferramenta PsExec em um projeto, o que me fez sentir alguma nostalgia dos tempos em que eu fazia engenharia reversa todo dia. Este breve relato (espero) reproduz os passos que segui para descobrir o que esse programa tão útil quanto perigoso faz.
Dados conhecidos Sabe-se que o PsExec consegue executar um programa remotamente, ou seja, de uma máquina para outra, outra essa que chamaremos de máquina-alvo. O programa a ser executado geralmente deve estar disponível na própria máquina-alvo (condição ideal). Além da simples execução, para aplicativos console ele permite ainda a interação como se estivéssemos executando o programa remoto em nossa própria máquina local. Ele consegue isso redirecionando sua entrada e saída, o que o torna, como nos descreve o próprio autor, um &amp;quot;telnet light&amp;quot;:
psexec \\maquina-alvo [-u admin-na-maquina-alvo] cmd.exe Além desse comportamento já muito útil ainda existe um bônus que se trata de especificar um executável local que será copiado remotamente para a máquina-alvo e executado. Esse é o comportamento que espero imitar:
psexec \\maquina-alvo [-c c:\tests\myprogram.exe] [-u admin-na-maquina-alvo]PsExec v1.72 - Execute processes remotely Copyright (C) 2001-2006 Mark RussinovichSysinternals - www.sysinternals.comMicrosoft Windows XP [versão 5.1.2600](C) Copyright 1985-2001 Microsoft Corp. No teste acima o myprogram.exe é somente o cmd.exe renomeado. Um teste básico =)
Primeiro passo: reproduzir o comportamento analisado e coletar pistas Já fizemos isso logo acima. Se trata apenas de observar o programa funcionando. Ao mesmo tempo em que entendemos seu modus operandi coletamos pistas sobre suas entranhas. No caso do PsExec, que faz coisas além-mar, como redirecionar os pipes de entrada/saída de um programa console, iremos checar a existência de algum serviço novo na máquina-alvo e arquivos novos que foram copiados, além de opcionalmente dar uma olhada no registro. Ferramentas da própria SysInternals como Process Explorer e Process Monitor também são úteis nessa análise inicial.
Como podemos ver, um serviço com o nome de PsExec foi criado na máquina-alvo. Se procurarmos saber o caminho do arquivo que corresponde a esse serviço, tanto pelo Process Explorer ou o Service Manager, descobriremos que se trata de um arquivo no diretório do windows chamado psexecsvc.exe.
Se o arquivo existe nessa pasta, então é óbvio que alguém o copiou. Resta saber como.
Segundo passo: acompanhar o processo lentamente Nessa segunda fase, podemos refazer o comportamento esperado inúmeras vezes, coletando dados e pensando a partir dos dados obtidos. Para esse caso, como quase todos que analiso, vou usar o nosso amigo WinDbg. Para isso, como tenho sempre minhas ferramentas disponíveis no ambiente onde trabalho, basta digitar &amp;quot;windbg&amp;quot; antes do comando anterior e dar uma olhada em algumas APIs-chave, como a criação/abertura de arquivos e a criação de serviços. Note que é importante fazer isso em um escopo limitado para não perdermos horas de análise. Descobrir coisas como, por exemplo, que as ações do PsExec só começam a ser executadas após a digitação da senha do usuário, pode ajudar, pois daí só começo minha análise a partir desse ponto.
windbg psexec \\maquina-alvo -u admin cmd.exePsExec v1.72 - Execute processes remotelyCopyright (C) 2001-2006 Mark RussinovichSysinternals - www.sysinternals.comPassword:ntdll!DbgBreakPoint:7c90120e cc int 30:001&amp;gt; bp kernel32!CreateFileW0:001&amp;gt; bp advapi32!CreateServiceW0:001&amp;gt; gConnecting to maquina-alvo...Breakpoint 0 hiteax=40150000 ebx=0011ee90 ecx=00000000 edx=00005078 esi=7c80932e edi=0011eeb0eip=7c8107f0 esp=0011ee70 ebp=0011eed0 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206kernel32!CreateFileW:7c8107f0 8bff mov edi,edi0:000&amp;gt; du poi(@esp&#43;4)0011ee90 &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;&amp;quot;\\.\PIPE\wkssvc&amp;quot;&amp;lt;/font&amp;gt;0:000&amp;gt; k 50 // pilha muito grande!ChildEBP RetAddr0011ee6c 77dc4b92 kernel32!CreateFileW0011eed0 77dc4369 RPCRT4!NMP_Open&#43;0x17a0011ef1c 77dc48d3 RPCRT4!OSF_CCONNECTION::TransOpen&#43;0x5e0011ef70 77dc4a5d RPCRT4!OSF_CCONNECTION::OpenConnectionAndBind&#43;0xbc0011efb4 77dc49ac RPCRT4!OSF_CCALL::BindToServer&#43;0x1040011f018 77dbfdbc RPCRT4!OSF_BINDING_HANDLE::AllocateCCall&#43;0x2b60011f048 77db8a01 RPCRT4!OSF_BINDING_HANDLE::NegotiateTransferSyntax&#43;0x280011f060 77db8a38 RPCRT4!I_RpcGetBufferWithObject&#43;0x5b0011f070 77db906d RPCRT4!I_RpcGetBuffer&#43;0xf0011f080 77e3460b RPCRT4!NdrGetBuffer&#43;0x280011f460 5bcb9d7c RPCRT4!NdrClientCall2&#43;0x1950011f474 5bcb9d1e NETAPI32!NetrWkstaGetInfo&#43;0x1b0011f4bc 71c78cc2 NETAPI32!NetWkstaGetInfo&#43;0x380011f4e0 71c78a75 NETUI1!WKSTA_10::I_GetInfo&#43;0x210011f4e8 71be1843 NETUI1!NEW_LM_OBJ::GetInfo&#43;0x1c0011fadc 71be31aa ntlanman!CheckLMService&#43;0x3d00120464 71be3058 ntlanman!AddConnection3Help&#43;0x3e0012118c 71be2e29 ntlanman!AddConnectionWorker&#43;0x37c001211b0 71ae461a ntlanman!NPAddConnection3&#43;0x1f001211d8 71ae45ac MPR!CUseConnection::TestProviderWorker&#43;0x4700121aa8 71ae2445 MPR!CUseConnection::TestProvider&#43;0x6200121b08 71ae431d MPR!CRoutedOperation::GetResult&#43;0x10f00121da4 71ae2348 MPR!CUseConnection::GetResult&#43;0x18000121ddc 71ae22fd MPR!CMprOperation::Perform&#43;0x4d00121de8 71ae4505 MPR!CRoutedOperation::Perform&#43;0x2200121e98 71ae50f0 MPR!WNetUseConnectionW&#43;0x58*** WARNING: Unable to verify checksum for image00400000*** ERROR: Module load completed but symbols could not be loaded for image0040000000121ec0 00401796 &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;MPR!WNetAddConnection2W&amp;lt;/font&amp;gt;&#43;0x1cWARNING: Stack unwind information not available. Following frames may be wrong.001225d0 0032002e image00400000&#43;0x1796001225d4 0030002e 0x32002e001225d8 0034002e 0x30002e001225dc 00000000 0x34002e Uma rápida busca no Google nos informa que o _pipe _querendo ser aberto pertence à lista de _pipes _que estão sempre disponíveis nas máquinas para responder às requisições do sistema. São importantes para a comunicação entre processos (IRP, Inter Process Communication). No entanto, quem usa esse pipe é o sistema, e ele foi chamado, como pudemos ver, pela função WNetAddConnection2W.
Se analisarmos mais a fundo a pilha de chamadas conseguiremos dar um olhada nos parâmetros passados. Para isso existe a opção de mostrar os argumentos passados para as funções ao exibir a pilha:
0:000&amp;gt; kv 50ChildEBP RetAddr Args to Child0011ee6c 77dc4b92 0011ee90 c0000000 00000003 kernel32!CreateFileW (FPO:0011eed0 77dc4369 00147140 001463f8 005b4b46 RPCRT4!NMP_Open&#43;0x17a (FPO:...00121e98 71ae50f0 00000000 00121ee4 004182a0 MPR!WNetUseConnectionW&#43;0x58 (FPO: [Non-Fpo])*** WARNING: Unable to verify checksum for image00400000*** ERROR: Module load completed but symbols could not be loaded for image0040000000121ec0 00401796 &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;00121ee4 &amp;lt;/font&amp;gt;&amp;lt;font color=&amp;quot;#000000&amp;quot;&amp;gt;004182a0 004139e0&amp;lt;/font&amp;gt;&amp;lt;font color=&amp;quot;#000000&amp;quot;&amp;gt; &amp;lt;/font&amp;gt;MPR!WNetAddConnection2W&#43;0x1c (FPO: [Non-Fpo])WARNING: Stack unwind information not available. Following frames may be wrong.001225d0 0032002e 0030002e 0034002e 00000030 image00400000&#43;0x1796001225d4 0030002e 0034002e 00000030 00000000 0x32002e001225d8 0034002e 00000030 00000000 00000000 0x30002e001225dc 00000000 00000000 00000000 00000000 0x34002e0:000&amp;gt; db &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;00121ee4&amp;lt;/font&amp;gt;00121ee4 00 00 00 00 00 00 00 00-00 00 00 00 03 00 00 00 ................00121ef4 e2 1e 12 00 04 1f 12 00-00 00 00 00 00 00 00 00 ................00121f04 5c 00 5c 00 31 00 30 00-2e 00 32 00 2e 00 30 00 &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;\.\.1.0...2...0.&amp;lt;/font&amp;gt;00121f14 2e 00 34 00 30 00 5c 00-49 00 50 00 43 00 24 00 &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;..4.0.\.I.P.C.$.&amp;lt;/font&amp;gt;00121f24 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................00121f34 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................00121f44 cc da 90 7c c8 2d 91 7c-ec 07 00 00 88 1f 12 00 ...|.-.|........00121f54 88 1f 12 00 00 00 00 00-f2 20 12 00 e0 24 12 00 ......... ...$.. Ele tenta abrir uma conexão com a máquina-alvo em seu compartilhamento de IPC, que como já vimos serve para comunicação entre processos, até entre máquinas distintas. Dessa forma, descobrimos um dos pontos importantes no funcionamento do PsExec: ele usa o nome e senha fornecidos para abrir uma comunicação remota no compartilhamento IPC$.
Depois sugem várias paradas ao CreateFile, de maneira que a melhor forma de acompanhar isso é colocando um &amp;quot;dumpezinho&amp;quot; de memória na sua parada:
0:000&amp;gt; bp kernel32!CreateFileW &amp;quot;&amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;du poi(@esp&#43;4)&amp;lt;/font&amp;gt;&amp;quot;breakpoint 0 redefined0:000&amp;gt; g0011ee90 &amp;quot;\\.\PIPE\wkssvc&amp;quot;eax=40150000 ebx=0011ee90 ecx=00000000 edx=00005d6e esi=7c80932e edi=0011eeb0eip=7c8107f0 esp=0011ee70 ebp=0011eed0 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206kernel32!CreateFileW:7c8107f0 8bff mov edi,edi0:000&amp;gt; g0011f474 &amp;quot;\\.\PIPE\wkssvc&amp;quot;eax=40160000 ebx=0011f474 ecx=00000000 edx=00005d77 esi=7c80932e edi=0011f494eip=7c8107f0 esp=0011f454 ebp=0011f4b4 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206kernel32!CreateFileW:7c8107f0 8bff mov edi,edi0:000&amp;gt; g0011f210 &amp;quot;\\.\PIPE\wkssvc&amp;quot;eax=40160000 ebx=0011f210 ecx=00000000 edx=00005d7a esi=7c80932e edi=0011f230eip=7c8107f0 esp=0011f1f0 ebp=0011f250 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206kernel32!CreateFileW:7c8107f0 8bff mov edi,edi0:000&amp;gt; g0012213c &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;&amp;quot;\\10.2.0.40\ADMIN$\PSEXESVC.EXE&amp;quot;&amp;lt;/font&amp;gt;eax=00122090 ebx=00000003 ecx=00000000 edx=009300d0 esi=00000080 edi=ffffffffeip=7c8107f0 esp=00122064 ebp=001220ac iopl=0 nv up ei pl nz ac po cycs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000213kernel32!CreateFileW:7c8107f0 8bff mov edi,edi Muito bem! Chegamos a mais um ponto importante de nossa análise: o psexecsvc.exe é copiado através do compartilhamento ADMIN$ remotamente (diretório c:\windows). Esse compartilhamento se torna acessível, uma vez que uma conexão autenticada já foi aberta. Se listarmos as conexões existentes, veremos o compartilhamento IPC$ aberto:
&amp;gt;net useNovas conexões serão lembradas.Status Local Remoto Rede-------------------------------------------------------------------------------OK &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;\\10.2.0.40\IPC$&amp;lt;/font&amp;gt; Rede Microsoft WindowsComando concluído com êxito.&amp;gt; Também podemos notar que, enquanto estamos parados depurando o processo psexec.exe, temos acesso ao compartilhamento admin$:
A análise desses fatos demonstra como é importante fazer as coisas, pelo menos na fase &amp;quot;iniciante&amp;quot;, bem lentamente, e entender a mudança de estado durante o processo. Nem sempre isso é possível, é verdade, ainda mais quando estamos falando de análise de kernel. Mas, quando as condições permitem, vale a pena pensar antes de fazer.
Voltando à analise: temos direitos remotos nessa máquina. Dessa forma, fica fácil criar um serviço remotamente, que é o que faz o nosso amigo PsExec:
0:000&amp;gt; gBreakpoint 1 hiteax=00410870 ebx=00410870 ecx=00147a68 edx=00410844 esi=00410844 edi=00147a68eip=77fb7381 esp=001224e4 ebp=001228dc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246ADVAPI32!CreateServiceW:77fb7381 6a20 push 20h0:000&amp;gt; du poi(@esp&#43;8)00410870 &amp;quot;PSEXESVC&amp;quot;0:000&amp;gt; du poi(@esp&#43;8*4)001228dc &amp;quot;%SystemRoot%\PSEXESVC.EXE&amp;quot; Pronto. Isso era tudo que precisava para conseguir reproduzir seu comportamento. Agora posso fazer isso programando ou até manualmente:
C:\Tests&amp;gt;net use \\10.2.0.40\ipc$ /user:adminA senha ou o nome de usuário é inválido para \\10.2.0.40\ipc$.Digite a senha para que &#39;admin&#39; se conecte a &#39;10.2.0.40&#39;:Comando concluído com êxito.C:\Tests&amp;gt;net useNovas conexões serão lembradas.Status Local Remoto Rede-------------------------------------------------------------------------------OK \\10.2.0.40\ipc$ Rede Microsoft WindowsComando concluído com êxito.C:\Tests&amp;gt;copy myprogram.exe \\10.2.0.40\admin$1 arquivo(s) copiado(s).C:\Tests&amp;gt;sc \\10.2.0.40 create MyProgram binPath= %systemroot%\myprogram.exe[SC] CreateService SUCCESS O resto do comportamento, como o redirecionamento de entrada e saída e execução do processo na conta especificada, embora muito interessante, não me interessa de imediato. Quem sabe interesse a você, e não tenhamos uma continuação dessa análise em um outro blogue de &amp;quot;desmontagem&amp;quot; por aí =)
</description>
</item>

     
        <item>
  <title>Windows Jobs com Completion Port</title>
  <link>http://www.caloni.com.br/windows-jobs-com-completion-port/</link>
  <pubDate>2008-09-23</pubDate>
  
  <guid>http://www.caloni.com.br/windows-jobs-com-completion-port/</guid>
  <description>Ou &amp;quot;Como esperar o término de todos os processos-filho criados a partir de um conjunto de processos&amp;quot;.
Dessa vez confesso que esperava um pouco mais de documentação do MSDN, ou pelo menos um sistema de referências cruzadas eficiente. Outro dia demorei cerca de duas horas para conseguir criar um job, anexar o processo desejado e, a pior parte, esperar que todos os processos (o principal e seus filhos e netos) terminassem.
Além da pouca documentação, parece que não são muitas as pessoas que fazem isso e publicam na web, ou eu não sei procurar direito.
Mas, pra início de conversa, o que é um job mesmo?
Leve introdução sobre o conceito de jobs Um job é um objeto &amp;quot;novo&amp;quot; no kernel do Windows 2000 em diante, e se prontifica a suprir a carência que havia anteriormente de controle sobre o que os processos podem fazer e por quanto tempo.
A abstração mais coerente que eu consigo tirar de um job é como um trabalho a ser executada por um ou mais processos. O objeto job controla a criação, o término e as exceções que ocorrem dentro dele mesmo.

Entre as funções mais úteis de um job estão limitar o tempo de execução do conjunto de processos, o número de handles/arquivos/outros objetos abertos, limite de memória RAM ocupada e a possibilidade de terminar todos os processos de uma só vez.
Para informações básicas de como criar um job e anexar processos recomendo o ótimo artigo de Jeffrey Richter.
No final desse artigo ele chega a citar o controle mais refinado dos processos através de uma completion port, que permitirá receber eventos que ocorrem dentro de um job durante sua vida útil. Apesar de citar, não há código de exemplo que faça isso.
Bom, agora há:
#define _WIN32_WINNT 0x0500 // Jobs só existem do 2000 em diante#include &amp;lt;windows.h&amp;gt;/** @brief Função que cria um processo a partir de cmdLine* e coloca-o dentro de um job. A função aguarda o término* do processo e de qualquer subprocesso criado por este.*/DWORD CreateJobAndWait(LPSTR cmdLine){// primeiro, criamos um job sem nome HANDLE job = CreateJobObject(NULL, NULL);if( job ){STARTUPINFO si = { sizeof(si) };PROCESS_INFORMATION pi;// depois, criamos um processo suspenso (travado) if( CreateProcess(NULL, cmdLine, NULL, NULL, FALSE, CREATE_SUSPENDED | CREATE_NEW_CONSOLE, NULL, NULL, &amp;amp;si, &amp;amp;pi) ){// atribuímos esse processo ao nosso jobo AssignProcessToJobObject(job, pi.hProcess);// rodamos o processo ResumeThread(pi.hThread);// essa é uma completion i/o port genérica // (ou seja, não relacionada com nenhum arquivo // ou outra completion port) HANDLE port = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);if( port ){JOBOBJECT_ASSOCIATE_COMPLETION_PORT jobPort;jobPort.CompletionKey = 0; // ver variável key abaixo jobPort.CompletionPort = port; // nossa completion port vai aqui!// definimos a c.p. em nosso job if( SetInformationJobObject(job, JobObjectAssociateCompletionPortInformation, &amp;amp;jobPort, sizeof(jobPort)) ){ULONG_PTR key = 0; // ver membro CompletionKey acima LPOVERLAPPED overlap = 0;DWORD tranferred = 0;// nosso loop de mensagens com completion port while( GetQueuedCompletionStatus(port, &amp;amp;tranferred, &amp;amp;key, &amp;amp;overlap, INFINITE) ){// transferred especifica a mensagem DWORD msg = *(LPDWORD) &amp;amp;tranferred;// significa que não existem mais processos rodando if( msg == JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO )break; // saímos fora }}CloseHandle(port); // fecha tudo }CloseHandle(pi.hThread); // fecha tudo CloseHandle(pi.hProcess); // fecha tudo }CloseHandle(job); // fecha tudo }return 0;}int main(int argc, char* argv[]){if( argc == 2 )CreateJobAndWait(argv[1]);}O exemplo acima cria um processo baseado em uma linha de comando e espera pelo término do processo criado e de todos os subprocessos criados a partir do primeiro processo. Note que mesmo que o primeiro processo termine, a Completion Port só receberá o evento que todos os processos acabaram depois que o último subprocesso terminar.
Dessa forma, ao compilarmos o código:
C:\Tests\CreateJob&amp;gt;cl Createjob.cppMicrosoft (R) 32-bit C/C&#43;&#43; Optimizing Compiler Version 15.00.21022.08 for 80x86Copyright (C) Microsoft Corporation. All rights reserved.Createjob.cppMicrosoft (R) Incremental Linker Version 9.00.21022.08Copyright (C) Microsoft Corporation. All rights reserved./out:Createjob.exeCreatejob.obj E rodarmos mais um prompt de comando através de nosso programa (o texto em azul significa nossa nova janela de prompt):
C:\Tests\CreateJob&amp;gt;Createjob.exe cmd (travado) Microsoft Windows XP [versão 5.1.2600] (C) Copyright 1985-2001 Microsoft Corp. C:\Tests\CreateJob&amp;gt;notepad C:\Tests\CreateJob&amp;gt;exit
C:\Tests\CreateJob&amp;gt; (continua travado)(fechando notepad)C:\Tests\CreateJob&amp;gt; (deve destravar) Mesmo ao fecharmos o prompt criado, o programa só será finalizado ao fecharmos o Bloco de Notas iniciado pelo segundo prompt.
Além desse evento, que era o que eu estava procurando, esse método permite obter outros eventos bem interessantes:
  JOB_OBJECT_MSG_NEW_PROCESS. Um novo processo foi criado dentro do job.
  ** JOB_OBJECT_MSG_EXIT_PROCESS**. Um processo existente dentro do job foi terminado.
  JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT. O limite de memória de um processo já foi alcançado.
  JOB_OBJECT_MSG_END_OF_PROCESS_TIME. O limite de tempo de processamento de um processo já foi alcançado.
  Enfim, jobs não terminam por aí. Dê mais uma olhada no MSDN e veja se encontra mais alguma utilidade interessante para o nosso amigo job. Eu encontrei e fiquei feliz.
</description>
</item>

     
        <item>
  <title>Os processos-fantasma</title>
  <link>http://www.caloni.com.br/os-processos-fantasma/</link>
  <pubDate>2008-08-20</pubDate>
  
  <guid>http://www.caloni.com.br/os-processos-fantasma/</guid>
  <description>Estava eu outro belo dia tentando achar um problema em um driver que controla criação de processos quando, por acaso, listo os processos na máquina pelo depurador de kernel, após ter dado alguns logons e logoffs, quando me vem a seguinte lista de processos do Windows Explorer:
PROCESS &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;815f0da0&amp;lt;/font&amp;gt; SessionId: 0 Cid: 0694 Peb: 7ffd8000 ParentCid: 0100DirBase: 0d6e9000 ObjectTable: 00000000 HandleCount: 0.Image: explorer.exePROCESS 8164bda0 SessionId: 0 Cid: 03b0 Peb: 7ffdf000 ParentCid: 0100DirBase: 02673000 ObjectTable: 00000000 HandleCount: 0.Image: explorer.exePROCESS 815f7d50 SessionId: 0 Cid: 020c Peb: 7ffd9000 ParentCid: 0100DirBase: 0bc7f000 ObjectTable: 00000000 HandleCount: 0.Image: explorer.exePROCESS 8164c698 SessionId: 0 Cid: &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;0794 &amp;lt;/font&amp;gt;Peb: 7ffde000 ParentCid: 0100DirBase: 0cb08000 ObjectTable: e1a40f20 HandleCount: 279.Image: explorer.exe Analisando pelo Gerenciador de Tarefas, podemos detectar que o único processo de pé possui o PID (Process ID) do último elemento de nossa lista, curiosamente o único com um contador de handles diferente de zero.
Lembrando que 1940 em hexadecimal é 0x794, exatamente o valor deixado em destaque na lista acima, e reproduzido abaixo:
PROCESS 8164c698 SessionId: 0 Cid: &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;0794 &amp;lt;/font&amp;gt;Peb: 7ffde000 ParentCid: 0100DirBase: 0cb08000 ObjectTable: e1a40f20 HandleCount: 279.Image: explorer.exe Sendo ele o único processo a rodar, a única explicação válida para as outras instâncias do explorer.exe estarem de pé seria o fato de haver algum outro processo (inclusive o sistema operacional) com um handle aberto para ele. Felizmente isso pode ser facilmente verificado pelo uso do comando !object do WinDbg, no caso abaixo com o primeiro explorer.exe da lista, utilizando-se a sua estrutura EPROCESS (em vermelho na lista acima).
kd&amp;gt; !object 815f0da0Object: 815f0da0 Type: (817cce70) ProcessObjectHeader: 815f0d88 (old version)HandleCount: &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;2&amp;lt;/font&amp;gt; PointerCount: &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;3&amp;lt;/font&amp;gt; Muito bem. Temos dois handles e dois ponteiros ainda abertos para o objeto processo-fantasma explorer.exe. O fato de haver um handle aberto indica que é muito provável que se trate de um outro processo rodando em user mode, já que normalmente as referências para objetos dentro do kernel são feitas com o uso de ponteiros.
Para descobrirmos quem detém esse handle, existe o comando !handle, que pode exibir informações sobre todos os handles de um determinado tipo no processo atual. Como queremos procurar por todos os handles do tipo Process em todos os processos existentes, é necessário usá-lo em conjunto com o comando mais esperto !for_each_process, que pode fazer coisas incríveis para o programador de user/kernel:
kd&amp;gt; !for_each_process &amp;quot;!handle 0 1 @#Process Process&amp;quot;processor number 0, process 817cc830Searching for handles of type ProcessPROCESS 817cc830 SessionId: none Cid: 0004 Peb: 00000000 ParentCid: 0000DirBase: 00039000 ObjectTable: e1000cc0 HandleCount: 286.Image: SystemHandle table at e1002000 with 286 Entries in use0004: Object: 817cc830 GrantedAccess: 001f0fff0298: Object: 8169a958 GrantedAccess: 001f03ff0308: Object: 8156c880 GrantedAccess: 00000438067c: Object: 816744e8 GrantedAccess: 001f03ffprocessor number 0, process 81589020Searching for handles of type ProcessPROCESS 81589020 SessionId: none Cid: 016c Peb: 7ffd7000 ParentCid: 0004DirBase: 06978000 ObjectTable: e130d688 HandleCount: 21.Image: smss.exeHandle table at e12a5000 with 21 Entries in use0038: Object: 81561128 GrantedAccess: 001f0fff003c: Object: 81561128 GrantedAccess: 000004000050: Object: 815b2128 GrantedAccess: 001f0fff0054: Object: 81668020 GrantedAccess: 00000400processor number 0, process 81561128Searching for handles of type ProcessPROCESS 81561128 SessionId: 0 Cid: 0234 Peb: 7ffde000 ParentCid: 016cDirBase: 0742d000 ObjectTable: e13e0418 HandleCount: 342.Image: csrss.exeHandle table at e14f3000 with 342 Entries in use0014: Object: 815b2128 GrantedAccess: 001f0fff00ec: Object: 8154e880 GrantedAccess: 001f0fff0100: Object: 8156c880 GrantedAccess: 001f0fff0130: Object: 815dc798 GrantedAccess: 001f0fffprocessor number 0, process 815b2128Searching for handles of type ProcessPROCESS 815b2128 SessionId: 0 Cid: 024c Peb: 7ffde000 ParentCid: 016cDirBase: 075b2000 ObjectTable: e13d5790 HandleCount: 448.Image: winlogon.exeHandle table at e102b000 with 448 Entries in use018c: Object: 8154e880 GrantedAccess: 001f0fff019c: Object: 8156c880 GrantedAccess: 001f0fffprocessor number 0, process 8154e880Searching for handles of type ProcessPROCESS 8154e880 SessionId: 0 Cid: 0290 Peb: 7ffda000 ParentCid: 024cDirBase: 07908000 ObjectTable: e15fea78 HandleCount: 261.Image: services.exeHandle table at e15cf000 with 261 Entries in use029c: Object: 81668020 GrantedAccess: 001f0fff0330: Object: 815dc798 GrantedAccess: 001f0fff... continua por muuuuuuuito mais tempo Uma simples busca pelo EPROCESS do processo-fantasma nos retorna dois processos que o estão referenciando: um svchost.exe e um outro processo com um nome muito suspeito, provavelmente feito sob encomenda para a confecção desse artigo:
Handle table at e167b000 with 247 Entries in useprocessor number 0, process 8169a958Searching for handles of type ProcessPROCESS 8169a958 SessionId: 0 Cid: 03f4 Peb: 7ffdb000 ParentCid: 0290DirBase: 08437000 ObjectTable: e156bc38 HandleCount: 1302.Image: svchost.exeHandle table at e19fe000 with 1302 Entries in use0108: Object: 815b2128 GrantedAccess: 000004780128: Object: 815b2128 GrantedAccess: 00000478012c: Object: 815b2128 GrantedAccess: 00100000015c: Object: 815b2128 GrantedAccess: 0000047a01f4: Object: 81615928 GrantedAccess: 0000047802f0: Object: 815f7d50 GrantedAccess: 00100068035c: Object: 8169a958 GrantedAccess: 001f0fff0dbc: Object: 8156c880 GrantedAccess: 001000000f44: Object: 8169a958 GrantedAccess: 00000068&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;1020: Object: 815f0da0 GrantedAccess: 00100068&amp;lt;/font&amp;gt;10dc: Object: 8169a958 GrantedAccess: 001000001118: Object: 815f42f0 GrantedAccess: 00100068...processor number 0, process 8164c220Searching for handles of type ProcessPROCESS 8164c220 SessionId: 0 Cid: 044c Peb: 7ffdf000 ParentCid: 02a4DirBase: 0db16000 ObjectTable: e15c66b8 HandleCount: 12.Image: &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;ProcessLeaker.exe&amp;lt;/font&amp;gt;Handle table at e103a000 with 12 Entries in use&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;0010: Object: 815f0da0 GrantedAccess: 00100000&amp;lt;/font&amp;gt;001c: Object: &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;815f42f0 &amp;lt;/font&amp;gt;GrantedAccess: 001000000028: Object: &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;8164bda0 &amp;lt;/font&amp;gt;GrantedAccess: 00100000002c: Object: &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;815f7d50 &amp;lt;/font&amp;gt;GrantedAccess: 001000000030: Object: &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;8164c698 &amp;lt;/font&amp;gt;GrantedAccess: 00100000 Se lembrarmos o ponteiro dos outros processos, podemos notar que ele está bloqueando todas as outras instâncias dos antigos explorer.exe, executados em outras sessões do usuário:
PROCESS &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;815f0da0&amp;lt;/font&amp;gt; SessionId: 0 Cid: 0694 Peb: 7ffd8000 ParentCid: 0100DirBase: 0d6e9000 ObjectTable: 00000000 HandleCount: 0.Image: explorer.exePROCESS &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;8164bda0&amp;lt;/font&amp;gt; SessionId: 0 Cid: 03b0 Peb: 7ffdf000 ParentCid: 0100DirBase: 02673000 ObjectTable: 00000000 HandleCount: 0.Image: explorer.exePROCESS &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;815f7d50&amp;lt;/font&amp;gt; SessionId: 0 Cid: 020c Peb: 7ffd9000 ParentCid: 0100DirBase: 0bc7f000 ObjectTable: 00000000 HandleCount: 0.Image: explorer.exePROCESS &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;8164c698&amp;lt;/font&amp;gt; SessionId: 0 Cid: &amp;lt;font color=&amp;quot;#000000&amp;quot;&amp;gt;0794 &amp;lt;/font&amp;gt;Peb: 7ffde000 ParentCid: 0100DirBase: 0cb08000 ObjectTable: e1a40f20 HandleCount: 279.Image: explorer.exe Esse ProcessLeaker se tratava de um serviço do mesmo produto que contém de fato um leak de recurso: em um dado momento ele abre um handle para o processo explorer.exe, só que por alguns motivos obscuros ele não é fechado nunca, gerando uma lista interminável de processos-fantasma. E é lógico que ele originalmente não chama ProcessLeaker.exe =)
Essa análise mostra duas coisas: que com um pouco de conhecimento e atitude é possível encontrar bugs em outras partes do programa, mesmo quando resolvendo outros problemas e que, nem sempre o problema está onde parece estar, que seria no nosso querido driver de controle de processos do começo da história.
</description>
</item>

     
        <item>
  <title>Guia para iniciantes no DriverEntry</title>
  <link>http://www.caloni.com.br/guia-para-iniciantes-no-driverentry/</link>
  <pubDate>2008-08-11</pubDate>
  
  <guid>http://www.caloni.com.br/guia-para-iniciantes-no-driverentry/</guid>
  <description>A mensagem anterior deixou bem claro que tenho um roteiro de leituras bem hardcore a fazer nos próximos 20 anos. Pretendo, enquanto isso, programar alguma coisinha rodando em ring0, porque nem só de teoria vive o programador-escovador-de-bits. Pensando nisso, esse fim-de-semana comecei a me aventurar nos ótimos exemplos e explicações do DriverEntry.com.br, nossa referência kernel mode tupiniquim.
A exemplo do que Dmitry fez com os livros de drivers, acredito que a mesma coisa pode ser feita com os blogues. A maneira de esmiuçá-los vai depender, principalmente, da quantidade de material a ser estudado e das práticas necessárias para que o conhecimento entre na cabeça de uma vez por todas.
No momento, minha prática se resume a isso:
  Debug or not debug. Aqui resolvi dar uma olhada de perto nas macros e funções usadas para tracing no DDK, e descobri que, assim como a runtime do C, podemos ter mensagens formatadas no estilo do printf e vprintf, o que economiza uma porção de código repetitivo. Dessa forma pude usar minha estratégia de ter a macro LOG usada para mandar linhas de depuração na saída padrão. Ainda tenho que estudar, contudo, o uso da variável va_list em kernel.
  ExAllocatePool (WithoutTag). Precisei fazer alguns testes no Dependency Walker e anexar o fonte que faz a vez do GetProcAddress para drivers em meu miniprojeto do Bazaar para aprendizado de programação em kernel (linque para download no final do artigo).
  Getting Started. Esse foi o artigo mais interessante de todos, pois foi a base de todo o código que ando repetindo em meus exercícios. Além desse, é vital o uso do Visual Studio no processo de desenvolvimento, pois muitas (quase todas) das funções do DDK são alienígenas para mim, assim como os seus 497 parâmetros cada.
  Driver plus plus. Tive que perder algum tempo codificando uma segunda versão do Useless e baixando o framework da Hollis para testar as peculiaridades do C&#43;&#43; em kernel mode. Não que eu vá usar alguma coisa avançada nesse estágio, mas preciso conhecer algumas limitações e alguns macetes que farão uma grande diferença no futuro, quando as linhas de código ultrapassarem 10.000.
  Pulei alguns tópicos que pretendo explorar quando estiver mais à vontade com alguns conceitos básicos, como a explicação de como obter o processo dono de uma IRP, a explicação do que é uma IRP (apesar de eu ter baixado e brincado com o monitor da OSR) e a aparentemente simples explanação sobre como funcionam as listas ligadas do DDK. Tudo isso virá com o tempo, e algumas coisas estarão sempre martelando na cabeça. É só dar tempo ao tempo e codificar.
  Nós queremos exemplos. Esse foi o artigo que mais me deu trabalho, mas que mais valeu a pena. Codifiquei tudo do zero, olhando aos poucos no código do Fernando para pegar o jeito de usar funções com nomes enormes e auto-explicativas e parâmetros com os nomes a, b, c. Também dediquei um tempinho considerável com a aplicação de user mode, para (re)aprender a depurar dos dois lados da moeda.
  Próximos passos?
Pelo que eu vi, no geral, acredito que aos poucos irei voltar para os tópicos que pulei, além de olhar em outros artigos que chamaram minha atenção:
  Como criar um driver de boot
  Usando o DSF para interagir com dispositivos USB de mentirinha
  A continuação emocionante de nosso driver que recebe reads e writes
  Usar o que existe de bom e melhor para garantir a qualidade de um driver
  Mais alguns detalhes que começam a fazer sentido em nosso KernelEcho
  Criando e usando IOCTLs. Essa vai ser ótima!
  A necessidade inevitável de mexer com o registro do sistema
  Tudo isso aliado aos exemplos e à teoria latente do Windows 2000 Device Driver Book (minha primeira leitura) irá dar um upgrade forçado aos meus neurônios. Espero sobreviver para contar o final da história.
</description>
</item>

     
        <item>
  <title>Antidebugging during the process attach</title>
  <link>http://www.caloni.com.br/antidebugging-during-the-process-attach/</link>
  <pubDate>2008-08-05</pubDate>
  
  <guid>http://www.caloni.com.br/antidebugging-during-the-process-attach/</guid>
  <description>Today was a great day for reverse engineering and protection analysis. I&#39;ve found two great programs to to these things: a API call monitor and a COM call monitor. Besides that, in the first program site - from a enthusiastic of the good for all Win32 Assembly - I&#39;ve found the source code for one more antidebugging technique, what bring us back to our series of antidebugging techniques.
The antiattaching technique The purpose of this protection is to detect if some debugger tries to attach into our running process. The attach to process operation is pretty common in all known debugger, as WinDbg and Visual Studio. Different from the DebugPort protection, this solution avoids the attach action from the debuggee program. In this case the protection can make choices about what to do on the event of attach (terminate the process, send an e-mail, etc).
The code I&#39;ve found does nothing more than to make use of the attach process function that&#39;s always called: the ntdll!DbgUiRemoteBreakin. Being always called, we can just to put our code there, what is relatively easy to do:
#include &amp;lt;windows.h&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;assert.h&amp;gt;using namespace std;/** This function is triggered when a debugger try to attach into our process.*/void AntiAttachAbort(){// this is a test application, remember?	MessageBox(NULL, &amp;#34;Espertinho, hein?&amp;#34;, &amp;#34;AntiAttachDetector&amp;#34;, MB_OK | MB_ICONERROR);// this is the end	TerminateProcess(GetCurrentProcess(), -1);}/** This function installs a trigger that is activated when a debugger try to attach.@see AntiAttachAbort.*/void InstallAntiAttach(){PVOID attachBreak = GetProcAddress(GetModuleHandle(&amp;#34;ntdll&amp;#34;), // this dll is ALWAYS loaded	&amp;#34;DbgUiRemoteBreakin&amp;#34;); // this function is ALWAYS called on the attach eventassert(attachBreak); // attachBreak NEVER can be null// opcodes to run a jump to the function AntiAttachAbort	BYTE jmpToAntiAttachAbort[] ={ 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, // mov eax, 0xCCCCCCCC	0xFF, 0xE0 }; // jmp eax// we change 0xCCCCCCCC using a more useful address	*reinterpret_cast&amp;lt;PVOID*&amp;gt;(&amp;amp;jmpToAntiAttachAbort[1]) = AntiAttachAbort;DWORD oldProtect = 0;if( VirtualProtect(attachBreak, sizeof(jmpToAntiAttachAbort), PAGE_EXECUTE_READWRITE, &amp;amp;oldProtect) ){// if we can change the code page protection we put a jump to our code	CopyMemory(attachBreak, jmpToAntiAttachAbort, sizeof(jmpToAntiAttachAbort));// restore old protection	VirtualProtect(attachBreak, sizeof(jmpToAntiAttachAbort), oldProtect, &amp;amp;oldProtect);}}/** In the beginning, God said: &amp;#39;int main!&amp;#39;*/int main(){InstallAntiAttach();cout &amp;lt;&amp;lt; &amp;#34;Try to attach, if you can...&amp;#34;;cin.get();} To compile the code above, just call the compiler and linker normally. Obs.: We need the user32.lib in order to call MessageBox API:
cl /c antiattach.cpplink antiattach.obj user32.libantiattach.exeTry to attach, if you can... After the program has been running, every try to attach will show a detection message and program termination.
windbg -pn antiattach.exe&amp;lt;a href=&amp;quot;http://i.imgur.com/mdRqvjp.png&amp;quot; title=&amp;quot;Detecção de attach&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;http://www.caloni.com.br/blog/wp-content/uploads/antiattach.png&amp;quot; alt=&amp;quot;Detecção de attach&amp;quot;&amp;gt;&amp;lt;/img&amp;gt;&amp;lt;/a&amp;gt; Code peculiarities Yes, I know. Sometimes we have to use &amp;quot;brute force codding&amp;quot; and make obscure codes, like this:
// opcodes to run a jump to the function AntiAttachAbortBYTE jmpToAntiAttachAbort[] ={ 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, // mov eax, 0xCCCCCCCC0xFF, 0xE0 }; // jmp eax// we change 0xCCCCCCCC using a more useful address*reinterpret_cast&amp;lt;PVOID*&amp;gt;(&amp;amp;jmpToAntiAttachAbort[1]) = AntiAttachAbort; There are a lot of ways to do the same thing. The example above is what is normally called in the crackers community as a shellcode, what is a pretty name for &amp;quot;byte array that is really the assembly code that does interesting things&amp;quot;. Shellcode for short =).
Alternative ways to do this are:
  To declare a naked function in Visual Studio, to create an empty function just after, do some math to calculate the size of the function to be copied into another place (aware of Edit and Continue option).
  To create a structure whose members are masked opcodes. This way, is possible in the constructor to receive the values and use it as a &amp;quot;mobile function&amp;quot;.
  Both have pros and cons. The cons are related with the environment dependency. In the first alternative is necessary to configure the project to disable &amp;quot;Edit and Continue&amp;quot; option, whilst in the second one is necessary to align 1 byte the structure.
Anyway, given the implementation, the main advantage is to isolate the code in only two functions - AntiAttachAbort and InstallAntiAttach - an API local hook (in the same process) that should never be called in production code. Besides, there are C&#43;&#43; ways to do such thing like &amp;quot;live assembly&amp;quot;. But this is matter for other future and exciting articles.
</description>
</item>

     
        <item>
  <title>Antidebugging using the DebugPort</title>
  <link>http://www.caloni.com.br/antidebugging-using-the-debugport/</link>
  <pubDate>2008-08-01</pubDate>
  
  <guid>http://www.caloni.com.br/antidebugging-using-the-debugport/</guid>
  <description>When a debugger starts a process to be debugged or, the article case, connects to a already created process, the communication between these processes is made through an internal resource inside Windows called LPC (Local Procedure Call). The system creates a &amp;quot;magic&amp;quot; communication port for debugging and the debugging events pass throw it.
Among these events we can tell the most frequent:
  Activated breakpoints
  Thrown exceptions
  Threads creation/termination
  DLLs load/unload
  Process exit
  In the case of connecting into a existent process, the API DebugActiveProcess is called. Since this call, if successful, the caller program is free now to call the API DebugActiveProcess, looking for debugging events. The main loop for a debugger is, so, pretty simple:
void DebugLoop(){bool exitLoop = false;while( ! exitLoop ){DEBUG_EVENT debugEvt;// Wait for some debug event.	WaitForDebugEvent(&amp;amp;debugEvt, INFINITE);// Let us see what it is about.	switch( debugEvt.dwDebugEventCode ){// This one...// That one...// Process is going out. We get out the loop and go away.	case EXIT_PROCESS_DEBUG_EVENT:exitLoop = true;break;}// We need to unfreeze the thread who sent the debug event.	// Otherwise, it stays frozen forever!	ContinueDebugEvent(debugEvt.dwProcessId, debugEvt.dwThreadId, DBG_EXCEPTION_NOT_HANDLED);}} The interesting detail about this communication process is that a program can be debugged actively only for ONE debugger. In other words, while there&#39;s a process A debugging process B, no one besides A can debug and break B.Using this principle, we can imagine a debugging protection based on this exclusivity, creating a protector process that connects to the protected process and &amp;quot;debugs&amp;quot; it:
/** @brief Antidebug protection based on DebugPort aquisition.* @author Wanderley Caloni (wanderley@caloni.com.br)* @date 2007-08*/#include &amp;lt;windows.h&amp;gt;/* Every debugger needs a debugging loop. In this loop it catchesdebugging events sent by the operating system.*/DWORD DebugLoop(){DWORD ret = ERROR_SUCCESS;bool exitLoop = false;while( ! exitLoop ){DEBUG_EVENT debugEvt;WaitForDebugEvent(&amp;amp;debugEvt, INFINITE);switch( debugEvt.dwDebugEventCode ){// Process going out. We get out the loop and leave.	case EXIT_PROCESS_DEBUG_EVENT:exitLoop = true;break;}// Necessary, since the current thread is frozen.	ContinueDebugEvent(debugEvt.dwProcessId, debugEvt.dwThreadId, DBG_EXCEPTION_NOT_HANDLED);}return ret;}/* Attachs to the protected process againt debugging. Actually, we protect itagaint debugging being its debugger.*/DWORD AntiAttach(DWORD pid){DWORD ret = ERROR_SUCCESS;if( pid ){BOOL dbgActProc;dbgActProc = DebugActiveProcess(pid);if( dbgActProc )DebugLoop();elseret = GetLastError();}elseret = ERROR_INVALID_HANDLE;return ret;}/* In the beginning, God said: &amp;#39;int main!&amp;#39;*/int main(int argc, char* argv[]){DWORD ret = ERROR_SUCCESS;if( argc &amp;gt; 1 ){DWORD pid = atoi(argv[1]);ret = AntiAttach(pid);}return (int) ret;} The needed steps to test the code above are:
  Compile the code
  Run notepad (or another victim)
  Get its PID (Process ID)
  Run the protector process passing the notepad PID as the argument
  Try to attach to the notepad using a debugger (e.g. Visual C&#43;&#43;)
  After the attach process, the debug port is occupied, and the communication between the debugger and debuggee is made throug LPC. Bellow we can see a little illustration of how things work:

Basically the process stay receiving debugging events (through the LPC message queue) until the final event, the process exit. Notice that if someone try to terminate the protector process the debuggee process will be terminated, too.
Flawless? OK... The strength in this protection is that it doesn&#39;t affect the code understanding and readability. In fact the code that protects is in another process. The weakness, I would say, it is your visibility. Everyone that will try to attack the solution will se two processes being created, what gives him/her something to think about...
That&#39;s why thinking about the implementation is vital. Particularly the main point to be thought is the debugger/debuggee union. As much as better these two pieces were packed, harder to the attacker will be to separate them. An additional idea is to use the same technique in the opposite way, in other words, the debuggee process to attach into the debugger.
This time I&#39;m not going to say that there&#39;s a easy solution. Maybe because I haven&#39;t though enough about the problem. Ideas?
</description>
</item>

     
        <item>
  <title>Antidebugging using exceptions (part two)</title>
  <link>http://www.caloni.com.br/antidebugging-using-exceptions-part-two/</link>
  <pubDate>2008-07-30</pubDate>
  
  <guid>http://www.caloni.com.br/antidebugging-using-exceptions-part-two/</guid>
  <description>In the first article we saw how it&#39;s possible to spoof the debugger through exceptions and let the attacker lose some considerable time trying to unbind the program from the fake breakpoints. However, we saw also that this is a difficult solution to keep in the source code, besides its main weakness to be easily bypassed if discovered. Now it&#39;s time to put things easier to support and at the same time to guarantee tough times even if the attacker discover what is going on.
The upgrade showed here still uses the exception throwing intrinsically, but now it doesn&#39;t depends on the code division in minifunctions and minicalls. Instead, we just need to get code traces and put them inside a miraculous macro that will do everything we want. This, of course, after some &amp;quot;hammer work&amp;quot; that will be explained here.
// Go back to place pre-defined by the restoration point.void LongJmp(restorePoint){// Here we will generate an exception to make things difficult.	// @todo Make a breakpoint exception and catch it.// 3. We return to the if without using the stack, but from the restoration point.	GoBackToTheStartFunction(restorePoint);}// Here everything begins.int Start(){// Obs.: follow the agreement flow according to the numbers.// 1. First pass: we define a restoration point to the return of LongJmp.	// 4. Second pass: we go back from the LongJmp function, but this time we get into the else.	if( RestorePointDefined() == Defined ){// 2. We call the function that will return to the if.	LongJmp( if );}else{// 5. Call the real function, our true target.	CallTheUsefulFunction();}// 6. End of execution.	return 0;} The solution above is explained in pseudocode to make things clearer. Notice that exist some kind of invisible return, not stack based. To handle it, however, we can use the good for all C ANSI standard, using the setjmp (step one) and longjmp (step 3). To understand the implementation for theses functions running on the 8086 platform we need to get the basic vision of the function calls in a stack based environment (the C and Pascal way).
Registers, stack frame and call/ret Registers are reserved variables in the processor that can be used by the assembly code. Stack frame is the function calling hierarchy, the &amp;quot;who called who&amp;quot; in a given execution state. Call and ret are assembly instructions to call and return from a function, respectively. Both change the stack frame.
Imagine you have a function, CallFunc, and another function, Func, and one calls the other. In order to analyse just the function call, and just that, let&#39;s consider Func doesn&#39;t receive any argument and doesn&#39;t return any value. The C code, would be like bellow:
void Func(){return;}void CallFunc(){Func();} Simple, huh? Being simple, the generated assembly will be simple as well. In CallFunc it should have the function call, and inside Func the return from the call. The rest of the code is related with Debug version stuff.
Func:00411F73 prev_instruction ; ESP = 0012FD38 (four bytes stacked up)00411F74 ret ; *ESP = 00411FA3 (return address)CallFunc:00411F9C prev_instruction00411F9E call Func (411424h) ; ESP = 0012FD3C00411FA3 next_instruction From the assembly above we can conclude two things: 1. The stack grows down, since its value decremented four bytes (0012FD3C minus 0012FD38 equal four) and 2. The return value from the calling is the address of the very next instruction after the call instruction, in the case 00411FA3.
Well, in the same way we can follow this simple execution, the attacker will do as well. That&#39;s why in the middle of this call we will throw an exception and, in the return, we will not do the return in the conventional way, but using another technique that, instead using the ret instruction, sets manually the esp value (stack state) and jumps to the next instruction in CallFunc.
Func:00411F60 throw_exception00411F61 ...00411F73 catch_exception00411F74 mov ESP, 0012FD3C ; ESP = 0012FD3C, just like CallFunc00411F75 jmp 00411FA3 ; jumps to CallFunc::next_instruction Back to the Middle Earth All this assembly stuff doesn&#39;t need to be written in assembly level. It was just a way I found to illustrate the differences between the stack return and the jump return. As it was said, to the luck and well being for all, this same technique can be implemented using ANSI C functions:
jmp_buf env; // Contains the next instruction (stack state).void Func(){// 3. Return using the &amp;#34;nonconventional&amp;#34; way	longjmp(env, 1);}void CallFunc(){// 1. If we&amp;#39;re setting, returns 0.	// 2. If we&amp;#39;re returning, returns a value different from 0.	if( setjmp(env) == 0 )Func();int x = 10; // 4. Next instruction.} That was the new trick for the trowing of exceptions. The final code is clearer, now:
/** The only purpose of this function is to generate an exception.*/DWORD LongJmp(jmp_buf* env){__try{__asm int 3}__except( EXCEPTION_EXECUTE_HANDLER ){longjmp(*env, 1);}return ERROR_SUCCESS;}/** And God said: &amp;#39;int main!&amp;#39;*/int main(){DWORD ret = ERROR_SUCCESS;while( cin ){string line;cout &amp;lt;&amp;lt; &amp;#34;Type something\n&amp;#34;;getline(cin, line);jmp_buf env;if( setjmp(env) == 0 ){LongJmp(&amp;amp;env);}else{cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl;}}return (int) ret;} At first sight, it seems a waste the if being directly in the code (remember we gonna use the same conditional structure in several parts in the code). To turn things clearer, resume the protected call and allows the protection to be disabled in debug version code, let&#39;s create a macro:
/** Use this macro instead LongJmp*/#define ANTIDEBUG(code){jmp_buf env;if( setjmp(env) == 0 ){LongJmp(&amp;amp;env);}else{code;}}/** And God said: &amp;#39;int main!&amp;#39;*/int main(){DWORD ret = ERROR_SUCCESS;while( cin ){string line;cout &amp;lt;&amp;lt; &amp;#34;Type something\n&amp;#34;;getline(cin, line);ANTIDEBUG(( cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl ));}return (int) ret;} Now we allow the antidebugging selection by call, what turns things much easier than to choose the protected points inside the code.
</description>
</item>

     
        <item>
  <title>Antidebugging using exceptions (part one)</title>
  <link>http://www.caloni.com.br/antidebugging-using-exceptions-part-one/</link>
  <pubDate>2008-07-28</pubDate>
  
  <guid>http://www.caloni.com.br/antidebugging-using-exceptions-part-one/</guid>
  <description>A debugger puts breakpoints to stop for a moment the debuggee execution. In order to do this it makes use of a well known instruction: int 3. This instruction throws an exception - the breakpoint exception - that is caught by the operating system and bypassed to the handling code for this exception. For debuggee processes this code is inside the debugger. For free processes this code normally doesn&#39;t exist and the application simply crashs.
The main idea in this protection is to take care these exceptions during the application execution. Doing this, we can make use of this fact and, in the handling code, run the protected code. The solution here looks like a script interpreter. It consists basically of two threads: The first one read an instructions sequence and tells the second thread to run it step to step. In order to do this the second thread uses a small functions set with well defined code blocks. Here&#39;s the example in pseudocode:
// the well-defined functions are functional blocks of code and have// the same signature, allowing the creation of a pointer array to themvoid WellDefinedFunction1( args );void WellDefinedFunction2( args );void WellDefinedFunction3( args );//...void WellDefinedFunctionN( args );// this thread stays forever waiting execution commands from some// well-defined function. the parameter that it receives is the function numbervoid ExecutionThread(){// 2. ad aeternum	while( true ){// 5. it runs some well-defined function by number	ExecuteWellDefinedFunction( functionNumber );}}// the well-defined functions script is an integer array indicating // the number for the next function that is going to be calledint FunctionsToBeCalled[] = { 3, 4, 1, 2, 34, 66, 982, n };int Start(){// 1. we create the thread that is going to run commands	CreateThread( ExecutionThread );// 3. for each script item (each function number)	for( int i = 0; i &amp;lt; sizeof(FunctionsToBeCalled); &#43;&#43;i ){// 4. tells the thread to run the function number N	TellExecutionThreadToExecuteWellDefinedFunction( FunctionToBeCalled[i] );}// 6. end of execution.	return 0;} The protection isn&#39;t there yet. But it will as intrinsic part of the execution thread. All we need to do is to add a exception handling and to throw lots of int 3. The thrown exceptions are caught by a second function that runs the instruction before to returning:
// filter exceptions that were thrown by the thread belowDWORD ExceptionFilterButExecuteWellDefinedFunction(){// 5. run some well-defined function by number	ExecuteWellDefinedFunction( number );return EXCEPTION_EXECUTE_HANDLER; // goes to except code}// this thread stays forever waiting execution commands from a // well-defined function. its &amp;#34;parameter&amp;#34; is the function numbervoid ExecutionThread(){// 2. ad aeternum	while( true ){__try{__asm int 3 // breakpoint exception// it stops the debugger if we have an attached debugger in	// the process, or throws an exception if there is no one	}__except( ExceptionFilterButExecuteWellDefinedFunction() ){// it does nothing. here is NOT where is the code (obvious, huh?)	}Sleep( someTime ); // give some time	}} The execution thread algorithm is the same. Just the point where each instruction is executed depends to the exception throw system. Note that this exception has to be thrown in order to the next instruction run. This is fundamental, since this way nobody can just rip of the int 3 code to avoid the exception. If one does that, so no instruction will be executed at all.
In practice, if one tries to debug such a program one will have to deal with tons of exceptions until find out what&#39;s happening. Of course, as in every software protection, is&#39;s not definitive; it has as a purpose to make hard the reverse engineering understanding. That&#39;s not going to stop those who are really good doing that stuff.
Nothing is for free
The price paid for this protection stays on the source code visibility and understanding, compromised by the use of this technique. The programming is state machine based, and the functions are limited to some kind of behavior standard. So much smaller the code blocks inside the minifunctions, so much hard the code understanding will be.
The example bellow receives input through a command prompt and maps the first word typed to the function that must be called. The rest of the typed line is passed as arguments to the functions. The interpreter thread reads the user input and writes into a global string variable, at the same time the executor thread waits the string to be completed to starts the action. It was used the variable pool to let the code simpler, but the ideal would be some kind of synchronise, just like events, by example. You can download the source code here.
/** @brief Sample demonstrating how to implemente antidebug in a code exception based.@date jul-2007@author Wanderley Caloni*/#include &amp;lt;windows.h&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;sstream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;stdlib.h&amp;gt;using namespace std;// show available commandsbool Help(const string&amp;amp;){cout &amp;lt;&amp;lt; &amp;#34;AntiDebug Test Program\n&amp;#34;&amp;lt;&amp;lt; &amp;#34; Echo string to be printed\n&amp;#34;&amp;lt;&amp;lt; &amp;#34; System command [params]\n&amp;#34;&amp;lt;&amp;lt; &amp;#34; Quit\n\n&amp;#34;;return true;}// run system/shell commandbool System(const string&amp;amp; cmd){system(cmd.c_str());return true;}// print string to outputbool Echo(const string&amp;amp; str){cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl;return true;}// quit programbool Quit(const string&amp;amp;){exit(0);return false;}// minifunctions arraybool (* (g_miniFuncs[]) )(const string&amp;amp;) = { Help, System, Echo, Quit };// &amp;#34;minifunction -&amp;gt; index&amp;#34; mappingmap&amp;lt;string, int&amp;gt; g_miniFuncIdx;// start minifunctions mappingvoid InitializeMiniFuncIdx(){g_miniFuncIdx[&amp;#34;Help&amp;#34;] = 0;g_miniFuncIdx[&amp;#34;System&amp;#34;] = 1;g_miniFuncIdx[&amp;#34;Echo&amp;#34;] = 2;g_miniFuncIdx[&amp;#34;Quit&amp;#34;] = 3;}// last line read from inputstring g_currentLine;// how much time are we going to wait for the next line?const DWORD g_waitTime = 1000;// run minifunctionsDWORD FilterException(){DWORD ret = EXCEPTION_CONTINUE_EXECUTION;if( ! g_currentLine.empty() ){istringstream line(g_currentLine);g_currentLine.clear();string function;string params;line &amp;gt;&amp;gt; function;getline(line, params);// 5. run some well-defined function by number if( ! g_miniFuncs[g_miniFuncIdx[function] ](params) )ret = EXCEPTION_CONTINUE_SEARCH;}return ret;}DWORD WINAPI AntiDebugThread(PVOID){InitializeMiniFuncIdx(); // start minifunction mapping// 2. ad aeternum (or almost) while( true ){//FilterException();__try // the extern try waits for an exit command {__try // the intern try stays generating exceptions continuously {__asm int 3}// FilterException is the function who runs minifunctions __except( FilterException() ){// we can put some fake code here }}__except( EXCEPTION_EXECUTE_HANDLER ){break; // get out from ad aeternum (to the limbo?) }Sleep(g_waitTime);}return ERROR_SUCCESS;}/** and God said: &amp;#39;int main!&amp;#39;*/int main(){DWORD ret = ERROR_SUCCESS;DWORD tid = 0;HANDLE antiDebugThr;// 1. we create the thread that is going to run the commands antiDebugThr = CreateThread(NULL, 0, AntiDebugThread, NULL, 0, &amp;amp;tid);;if( antiDebugThr ){// 3. for each item in the script (function numbers) while( cin ){cout &amp;lt;&amp;lt; &amp;#34;Type something\n&amp;#34;;// 4. tells the thread to run the function number N getline(cin, g_currentLine);if( WaitForSingleObject(antiDebugThr, g_waitTime * 2) != WAIT_TIMEOUT )break;}GetExitCodeThread(antiDebugThr, &amp;amp;ret);CloseHandle(antiDebugThr), antiDebugThr = NULL;}// 6. end of execution. return (int) ret;} The strength in this protection is to confound the attacker easily in the first steps (days, months...). Its weakness is the simplicity for the solution, since the attacker eventually realize what is going on. It is so easy that I will let it as an exercise for my readers.
In the next part we will se an alternative to make the code clearer and easy to use in the every day by a security software developer.
</description>
</item>

     
        <item>
  <title>O conhecido unresolved external</title>
  <link>http://www.caloni.com.br/o-conhecido-unresolved-external/</link>
  <pubDate>2008-07-18</pubDate>
  
  <guid>http://www.caloni.com.br/o-conhecido-unresolved-external/</guid>
  <description>O artigo anterior mostrou que nem sempre as coisas são simples de resolver, mas que sempre existe um caminho a seguir e que, eventualmente, todos os problemas se solucionarão.
Porém, resolver um problema por si só não basta: é preciso rapidez. E como conseguimos rapidez para resolver problemas? Um jeito que eu, meu cérebro e o Dmitry Vostokov conhecem é montando padrões.
Um padrão nos ajuda a não pensar novamente em coisas que sabemos a resposta, de tantas vezes que já fizemos. Só precisamos saber o caminho para resolver determinado problema.
Mesmo assim, existem diversos caminhos a percorrer. Até mesmo para um singelo e batidíssimo &amp;quot;unresolved external&amp;quot;.
Primeiro passo: você está usando a LIB correta? O erro mais comum é usar uma LIB onde não está a função que estamos usando, ou usar uma versão diferente da mesma LIB que não contém a função, ou contém, mas com assinatura (parâmetros da função) diferentes. Isso pode ser verificado no código-fonte da LIB, se disponível, ou então pelo uso do dumpbin, como já vimos anteriormente.
Às vezes, porém, não estamos usando a função diretamente e não conhecemos quem a usaria. Para isso que hoje em dia os compiladores mais espertos nos dizem em que parte do código foi referenciado a tal função:
test.obj : error LNK2019: unresolved external symbol _func referenced in function _main É sábio primeiro inspecionar a função que referencia, para depois entender porque ela não foi encontrada. Mesmo parecendo diferente, essa operação faz parte do primeiro passo, que é identificar a origem.
Segundo passo: você digitou direito? Parece estúpido, mas às vezes é esse o caso. Essa é a segunda coisa a fazer porque não é tão comum quanto a primeira, visto que hoje em dia é rotina colocarmos as funções em um _header _e incluirmos esse cabeçalho em nosso código-fonte (em C&#43;&#43;, praticamente obrigatório). Se houvesse discrepância entre o nome da função chamada e o nome da função existente, provavelmente teríamos um erro de compilação (&amp;quot;função não encontrada&amp;quot;) antes do erro de linking.
Terceiro passo: tente incluir a função diretamente no seu código Se a LIB não está cooperando, e der pouco trabalho, experimente incluir a função inteira (ou o cpp) dentro do seu projeto, para linkar diretamente. Se funcionar, então existe alguma diferença de compilação entre os dois projetos (o seu e o da LIB) para que haja uma divergência no nome procurado. Procure nas opções de projeto.
Quarto passo: comece de novo! Sempre que nos deparamos com um problema que aos poucos vai consumindo o nosso tempo, tendemos a gastar mais tempo fazendo coisas inúteis que sabemos que não irá adiantar de nada. Às vezes fazer brute force pode dar certo. Outras vezes, seria melhor recomeçar a pesquisa e tentar entender de fato o que está acontecendo na compilação. Em outras palavras: gastar o seu tempo pensando pode ser mais produtivo do que agir instintivamente.
</description>
</item>

     
        <item>
  <title>O caso da função de Delay Load desaparecida</title>
  <link>http://www.caloni.com.br/o-caso-da-funcao-de-delay-load-desaparecida/</link>
  <pubDate>2008-07-16</pubDate>
  
  <guid>http://www.caloni.com.br/o-caso-da-funcao-de-delay-load-desaparecida/</guid>
  <description>Todos os projetos do Visual Studio 6 estavam compilando normalmente com a nova modificação do código-fonte, uma singela chamada a uma função da DLL iphlpapi.dll. No entanto, ainda restava a compilação para Windows 95, um legado que não era permitido esquecer devido ao parque antigo de máquinas e sistemas operacionais de nossos clientes.
Ora, acontece que a função em questão não existe em Windows 95! O que fazer?
Essa é uma situação comum e controlada, que chega a ser quase um padrão de projeto: funções novas demais. A saída? Não chamar a função quando o sistema não for novo o suficiente. Isso pode ser resolvido facilmente com uma chamada a GetVersion.
Porém, um outro problema decorrente dessa situação é que a função chamada estaticamente cria um link de importação da DLL para o executável. Ou seja, uma dependência estática. Dependências estáticas necessitam ser resolvidas antes que o programa execute, e o carregador (loader) de programas do sistema é responsável por essa verificação.
Para verificar a existência de todas as DLLs e funções necessárias para nosso programa podemos utilizar o mundialmente conhecido Dependency Walker:
depends meu_executa&amp;lt;strike&amp;gt;&amp;lt;/strike&amp;gt;vel.exe Se a função ou DLL não existe no sistema, o seguinte erro costuma ocorrer (isso depende da versão do Sistema Operacional):
Mas nem tudo está perdido!
Visual Studio Delay Load DLL Existe uma LIB no Visual Studio que serve para substituir a dependência estática de uma DLL pela verificação dinâmica da existência de suas funções quando, e se, for executada a função no programa.
Essa LIB contém algumas funções-chave que o Visual Studio utiliza ser for usado o seguinte parâmetro de compilação:
/delayload:iphlpapi.dll A função principal se chama &amp;quot;__delayLoadHelper@8&amp;quot;, ou seja, é uma função com convenção de chamada WINAPI (stdcall) que recebe dois parâmetros.
Isso costuma sempre funcionar, sendo que tive uma grande surpresa com os seguintes erros de compilação na versão do programa que deve ser executada em Windows 95:
--------------------Configuration: Project - Win32 Win95 Release--------------------Linking...iphlpapi.lib(iphlpapi.dll) : error LNK2001: unresolved external symbol ___delayLoadHelper@8release/meu_executavel.exe : fatal error LNK1120: 1 unresolved externalsError executing link.exe.meu_executavel.exe - 3 error(s), 0 warning(s) Isso, é claro, depois de ter checado e rechecado a existência da LIB de Delay Load na lista de LIBs a serem lincadas:
E agora, José? Acontece que eu conheço algumas ferramentas que podem sempre me ajudar em situações de compilação e linque: Process Monitor e dumpbin.
O Process Monitor pode ser usado para obter exatamente a localização da LIB que estamos tentando verificar:
Após localizar o local, podemos listar seus símbolos, mais precisamente a função &amp;quot;delayLoadHelper&amp;quot;:
C:\DDK\3790\lib\w2k\i386&amp;gt;dumpbin /symbols delayimp.lib | grep delayLoadHelper108 00000000 SECT3C notype () External | ___delayLoadHelper2@8 A análise mostra que a função possui um &amp;quot;2&amp;quot; no final de seu nome, causando o erro de linque.
Mudanças na função__delayLoadHelper Essa função, pelo visto, tem mudado de nome desde o Visual C&#43;&#43; 6, o que fez com que LIBs mais novas não funcionassem com essa versão do Visual Studio.
Para sanar o problema, existem duas coisas que podem ser feitas:
  Usar a delayimp.lib antiga. Isso não exige nenhuma mudança no código.
  Criar uma função delayLoadHelper como wrapper. Isso exige a escrita de código. O código-fonte dessa função está disponível no diretório Include do Visual Studio, e pode ser adaptada para versões antigas.
  Nessa sessão de depuração você aprendeu como usar o Process Monitor para rastrear arquivos usados na compilação e como listar símbolos de LIBs que são usadas para lincar o programa.
</description>
</item>

     
        <item>
  <title>Primeiros passos no VMware Workstation</title>
  <link>http://www.caloni.com.br/primeiros-passos-no-vmware-workstation/</link>
  <pubDate>2008-07-10</pubDate>
  
  <guid>http://www.caloni.com.br/primeiros-passos-no-vmware-workstation/</guid>
  <description>Como uma ferramenta essencial que uso todos os dias da minha vida de programador, sou obrigado a falar neste blogue sobre a VMware, ferramenta que tem me salvado algumas centenas de horas de depuração, testes e alguns cabelos brancos (a mais).
Para os que não sabem, o VMware é um software de virtualização que permite rodar diversos sistemas operacionais secundários (chamados de convidados, ou guests) em cima do sistema operacional primário (chamado de hospedeiro, ou host). Para isso ele utiliza uma técnica muito interessante conhecida como virtualização, onde o desempenho da máquina virtual chega bem próximo da máquina nativa em que estamos rodando, ainda mais se instalados os apetrechos de otimização (vide VMware Tools) dentro dos sistemas operacionais convidados.
O VMware, diferente de alguns outros programas de virtualização, não é gratuito. No entanto, o tempo despendido pela equipe da VMware em tornar esta a solução a de melhor qualidade (opinião pessoal de quem já mexeu com Virtual PC e pouco de VirtualBox) está bem cotado, sendo que seu preço é acessível pelo desenvolvedor médio. Pior que o preço da VMware com certeza será o dos sistemas operacionais convidados, se estes forem da Microsoft, que obriga cada instância do Windows, seja hospedeiro ou convidado, a possuir uma licença separada. Se rodar um Windows XP como hospedeiro e um Vista e 2000 como convidados vai desembolsar pelo menos o quíntuplo da licença da VMware.
No entanto, não entremos em mais detalhes financeiros. Os detalhes técnicos são mais interessantes.
A instalação é simples e indolor, sendo constituída de cinco ou seis botões de next. O resto, e mais importante, é a instalação de um sistema operacional dentro de sua primeira máquina virtual. Outro assistente existe nessa fase para guiá-lo através de suas escolhas que irão configurar sua futura máquina.
Um pouco sobre redes
Use bridged networking. É criada uma conexão real através de uma ponte feita em cima de uma placa de rede da máquina real. É usado um IP diferente da máquina real e se comporta como uma outra máquina qualquer na rede.
Use NAT. As conexões são criadas usando o IP do sistema operacional hospedeiro. Para isto acontecer é usado o conhecido esquema de NAT, onde um único IP externo pode representar n IPs internos de uma rede (nesse caso, a rede virtual formada pelas máquinas virtuais de uma mesma máquina real).
Use host-only networking. O IP usado nessa conexão é diferente da máquina real, mas só é enxergada por ela e por outras VMs localizadas na mesma máquina hospedeira. Muito útil para isolar um teste de vírus, quando se precisa de uma rede mas não podemos usar a rede da empresa inteira.
Imagine uma VM (Virtual Machine) como uma máquina de verdade, onde podemos dar boot, formatar HDs (virtuais ou reais), colocar e remover dispositivos. Tendo isso em mente, fica simples entender o que funciona por dentro de sua console, ou seja, a tela onde vemos a saída da virtualização.
Um pouco sobre discos virtuais
Os HDs que criamos para nossas VMs são arquivos lógicos localizados em nosso HD real. A mágica em que o sistema operacional virtual acessa o disco virtual como se fosse de verdade é feita pela VMware, inclusive a doce ilusão que ele cotém 80 GB, enquanto seu arquivo-repositório ocupa meros 5 GB no disco. Nas edições novas do software, é possível mapear um HD virtual e exibi-lo na máquina real.
Se você dispõe do CD de instalação de um sistema operacional, por exemplo, Windows XP, basta inseri-lo no CD virtual de sua VM. Ela aceita também imagens ISO, se for o caso. Lembre-se apenas que ele terá que ser &amp;quot;bootável&amp;quot;, do contrário é necessário um disquete de boot.
Um pouco sobre BIOS
A sua VM emula todo o comportamento de uma máquina real. Ela, portanto, contém uma BIOS, feita pela VMware. Essa BIOS possui as mesmas opções interessantes de ordem de boot (primeiro o disquete, depois o HD, etc) e escolha de dispositivo de boot (tecla ESC).
A instalação do sistema operacional segue os mesmos passos que a instalação do sistema operacional de qualquer máquina de verdade.
As teclas mágicas
Entrar o foco na VM. Digite Ctrl &#43; G. Todos seus movimentos de teclado e mouse só irão funcionar dentro da máquina virtual, exceto o Ctrl &#43; Alt &#43; Del, exclusividade do sistema de autenticação do Windows.
Tirar o foco da VM. Digite Ctrl &#43; Alt. Todos seus movimentos de teclado e mouse passam a ser do SO hospedeiro.
Ctrl &#43; Alt &#43; Del dentro da VM. Use Ctrl &#43; Alt &#43; Insert. Ele terá o mesmo efeito que um CAD, independente em que tela estiver em sua VM.
Após feita a instalação, você terá um sistema operacional rodando dentro de um sistema operacional. Isso não é legal?
Snapshots
A primeira coisa a fazer em sua VM com SO recém-instalado é criar um snapshot, ou seja, salvar o estado atual de sua máquina virtual. Ao fazer isso, se fizer alguma coisa dentro da VM que possa se arrepender depois, basta voltar para o estado que salvou anteriormente. A VMware permite criar quantos snapshots precisar (basta ter espaço em disco). Ela permite que você crie novas máquinas virtuais a partir de um estado de uma VM já criada, o que pode economizar todo o tempo de montar do zero outra VM ou copiar o disco virtual.
  Abrir os seus e-mails suspeitos. Não tenha mais medo de sujar seu computador com e-mails de conteúdo duvidoso. Crie um estado seguro em sua VM através de um snapshot (fotografia de estado da máquina virtual) e execute os anexos mais absurdos. Depois basta voltar para o estado seguro.
  Testes que costumam alterar o estado da máquina. Driver, GINA ou serviço novo? Que tal usar uma VM para fazer os testes iniciais e parar de reformatar o Windows?
  As VMs possibilitam um mundo de utilidades que o mundo ainda está descobrindo. Para nós, desenvolvedores, a maior vantagem de tudo isso é termos nossos ambientes de testes mais bizarros facilmente configurados no conforto de uma caixinha de areia.
</description>
</item>

     
        <item>
  <title>Pesquisas sobre a GINA</title>
  <link>http://www.caloni.com.br/pesquisas-sobre-a-gina/</link>
  <pubDate>2008-07-02</pubDate>
  
  <guid>http://www.caloni.com.br/pesquisas-sobre-a-gina/</guid>
  <description>Já sabemos o que é uma GINA. Afinal, todo mundo já viu uma antes. E sabemos que hoje em dia ela está morta.
No entanto, algumas pequenas mudanças foram feitas nela no Windows XP que ainda almaldiçoam o código de quem tenta reproduzir a famosa GINA da Microsoft. Nem todos chegam no final e morrem tentando.
Eu sou um deles.
Uma explicação sobre como funciona o processo de logon (local e remoto) e os componentes envolvidos está no artigo &amp;quot;How Interactive Logon Works&amp;quot; da Technet. Esse artigo irá abrir os olhos para mais detalhes que você gostaria de saber sobre nossa velha e querida amiga. Os desenhos explicativos estão ótimos!
Após essa leitura picante, podemos voltar ao feijão com arroz e começar de novo lendo a descrição de como funciona a GINA na Wikipedia, que nos remete a vários linques interessantes, entre os quais:
  A explicação documentada do MSDN de como funciona a interação entre Winlogon e GINA.
  Um ótimo artigo dividido em duas partes que explica como fazer sua própria customização de GINA. Foi nele que encontrei o retorno que precisava para emular a execução do Gerenciador de Tarefas baseado na digitação do Ctrl &#43; Alt &#43; Del. De brinde ainda vem uma GINA de exemplo para download.
  A partir de mais algumas buscas e execuções do Process Monitor podemos encontrar os valores no registro que habilitam o Fast User Switching e a Tela de Boas Vindas do Windows XP. O valor da Tela de Boas Vindas é que habilita e desabilita a execução do Gerenciador de Tarefas baseado em Ctrl &#43; Alt &#43; Del. Esses itens são essenciais para os que quiserem criar uma réplica perfeita da GINA da Microsoft no Windows XP. Isso finaliza a minha busca.
Sempre tem mais. Se a máquina estiver no domínio essa opção não funciona. Porém, o WinLogon verifica se existe um valor chamado ForceFriendlyUi, que descobri graças ao Process Monitor. Aliado ao LogonType, sendo igual a 1, a Tela de Boas-Vindas é habilitada, mesmo em um ambiente com servidor de domínio.
Por último, claro, salvo se não existir o valor GinaDll dentro da chave do WinLogon. Se esse for o caso, o ForceFriendlyUi também não funciona. E é exatamente aí que uma GINA é instalada.
E eis que surge uma nova GINA.
</description>
</item>

     
        <item>
  <title>Reflexão em C&#43;&#43;</title>
  <link>http://www.caloni.com.br/reflexao-em-c/</link>
  <pubDate>2008-06-30</pubDate>
  
  <guid>http://www.caloni.com.br/reflexao-em-c/</guid>
  <description>O termo e conceito de &amp;quot;reflection&amp;quot; (reflexão), muito usado em linguagens modernas, é a capacidade de um programa de observar e até de alterar sua própria estrutura. Bom, isso você pode ler na Wikipédia. O interessante é o que podemos usar desse conceito na linguagem C&#43;&#43;.
Infelizmente não muito.
O sistema de RTTI (Run Time Type Identification), a identificação de tipos em tempo de execução, seria o começo do _reflection _em C&#43;&#43;. Foi um começo que não teve meio nem fim, mas existe na linguagem. Dessa forma podemos tirar algum proveito disso.
Um leitor pediu para que eu falasse um pouco sobre essas coisas, especificamente como se faz para obter o nome da classe de onde estamos executando um determinado método. Para esse tipo de construção podemos usar o operado typeid, que retorna informações básicas sobre um tipo de acordo com um tipo, instância ou expressão:
#include &amp;lt;iostream&amp;gt;using namespace std;int main(){cout &amp;lt;&amp;lt; typeid( int ).name() &amp;lt;&amp;lt; endl;int x;cout &amp;lt;&amp;lt; typeid( x ).name() &amp;lt;&amp;lt; endl;cout &amp;lt;&amp;lt; typeid( 2 &#43; 2 ).name() &amp;lt;&amp;lt; endl;}C:\Tests&amp;gt;cl typeid.cppMicrosoft (R) 32-bit C/C&#43;&#43; Optimizing Compiler Version 15.00.21022.08 for 80x86Copyright (C) Microsoft Corporation. All rights reserved./out:typeid.exetypeid.objC:\Tests&amp;gt;typeid.exeint Dessa forma, podemos nos aproveitar do fato que todo método não-estático possui a variável implícita this, do tipo &amp;quot;ponteiro constante para T&amp;quot;, onde T é o tipo da classe que contém o método sendo chamado.
#include &amp;lt;iostream&amp;gt;using namespace std;class MyClass{public:void MyMethod(){cout &amp;lt;&amp;lt; typeid(*this).name() &amp;lt;&amp;lt; &amp;#34;::MyMethod&amp;#34; &amp;lt;&amp;lt; endl;}};int main(){MyClass myc;myc.MyMethod();}C:\Tests&amp;gt;cl typeid-class.cppMicrosoft (R) 32-bit C/C&#43;&#43; Optimizing Compiler Version 15.00.21022.08 for 80x86Copyright (C) Microsoft Corporation. All rights reserved./out:typeid-class.exetypeid-class.objC:\Tests&amp;gt;typeid-class.exe class MyClass::MyMethod
Com classes não-polimórficas a coisa parece não ter muita utilidade. No entanto, essa mesma técnica pode ser aplicada em classes derivadas, uma vez que o operador typeid pode trabalhar em tempo de execução:
#include &amp;lt;iostream&amp;gt;using namespace std;class MyClass{public:virtual void MyMethod(){cout &amp;lt;&amp;lt; typeid(*this).name() &amp;lt;&amp;lt; &amp;#34;::MyMethod&amp;#34; &amp;lt;&amp;lt; endl;}};class MyDerivatedClass1 : public MyClass { };class MyDerivatedClass2 : public MyClass { };int main(){MyClass* myc1 = new MyDerivatedClass1;MyClass* myc2 = new MyDerivatedClass2;myc1-&amp;gt;MyMethod();myc2-&amp;gt;MyMethod();}C:\Tests&amp;gt;cl typeid-class2.cppMicrosoft (R) 32-bit C/C&#43;&#43; Optimizing Compiler Version 15.00.21022.08 for 80x86Copyright (C) Microsoft Corporation. All rights reserved./out:typeid-class2.exetypeid-class2.objC:\Tests&amp;gt;typeid-class2.exe class MyDerivatedClass1::MyMethod class MyDerivatedClass2::MyMethod
Apenas se lembre de ter de fato uma classe polimórfica (eu consegui isso tornando MyMethod uma função virtual). Do contrário você pode ter problemas.
</description>
</item>

     
        <item>
  <title>É possível carregar duas DLLs gêmeas no mesmo processo?</title>
  <link>http://www.caloni.com.br/e-possivel-carregar-duas-dlls-gemeas-no-mesmo-processo/</link>
  <pubDate>2008-06-21</pubDate>
  
  <guid>http://www.caloni.com.br/e-possivel-carregar-duas-dlls-gemeas-no-mesmo-processo/</guid>
  <description>Um dos últimos artigos de Dmitry Vostokov, e tenho que falar assim porque o cara escreve muito em pouco tempo, fala sobre os perigos de termos uma mesma DLL carregada duas vezes em um único processo, muitas vezes em versões diferentes. Para os observadores atentos como Dmitry esse é um perigo que muitas vezes temos que estar preparados. Para os espertinhos de plantão, a resposta padrão seria: &amp;quot;não vou me preocupar, porque o contador de instâncias cuida disso&amp;quot;.
Será mesmo tão simples?
Regra número 1: o _loader _não sabe tudo que você sabe Vamos supor um caso bem simples e plausível, que é exatamente o mesmo do artigo do Crash Dump Analysis: um produto qualquer possui dois pontos em que ele carrega a mesma DLL. Contudo, no primeiro ponto é usado um caminho relativo, dentro da pasta DLL; na segunda chamada é usado o caminho atual. Se existir de fato duas DLLs, mesmo que idênticas, nesses lugares, então teremos duas instâncias da &amp;quot;mesma DLL&amp;quot; carregadas no processo.
O código do aplicativo apenas tenta carregar a DLL em dois lugares distintos e exibe o endereço para onde elas foram mapeadas em nosso processo de teste:
#include &amp;lt;windows.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;int main(){HMODULE dll1 = LoadLibrary(&amp;#34;.\\DLL\\DLL.dll&amp;#34;);HMODULE dll2 = LoadLibrary(&amp;#34;.\\DLL.dll&amp;#34;);printf(&amp;#34;First DLL: %p\nSecond DLL: %p&amp;#34;,dll1, dll2);return 0;}A DLL é uma DLL trivial:
#include &amp;lt;windows.h&amp;gt;BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, PVOID reserv){return TRUE;}Vamos aos testes.
DLL não existe Nesse caso, ambos os retornos serão nulos, que é o natural e esperado quando a DLL não pode ser encontrada nos lugares especificados pelo sistema e pelo aplicativo.
K:\Docs\Projects&amp;gt;cl app.cMicrosoft (R) 32-bit C/C&#43;&#43; Optimizing Compiler Version 14.00.50727.42 for 80x86Copyright (C) Microsoft Corporation. All rights reserved.app.cMicrosoft (R) Incremental Linker Version 8.00.50727.42Copyright (C) Microsoft Corporation. All rights reserved./out:app.exeapp.objK:\Docs\Projects&amp;gt;appFirst DLL: 00000000
Second DLL: 00000000
K:\Docs\Projects&amp;gt; DLL existe apenas no caminho do aplicativo No segundo caso, a DLL é carregada com sucesso se usado o caminho relativo, pois o caminho atual faz parte da lista de caminhos que o sistema percorre para encontrá-la. A primeira chamada deve falhar.
K:\Docs\Projects&amp;gt;cl /LD dll.cMicrosoft (R) 32-bit C/C&#43;&#43; Optimizing Compiler Version 14.00.50727.42 for 80x86Copyright (C) Microsoft Corporation. All rights reserved.dll.cMicrosoft (R) Incremental Linker Version 8.00.50727.42Copyright (C) Microsoft Corporation. All rights reserved./out:dll.dll/dll/implib:dll.libdll.objK:\Docs\Projects&amp;gt;appFirst DLL: 00000000Second DLL: 10000000
K:\Docs\Projects&amp;gt; DLL existe em ambos os lugares No caso problemático, a mesma DLL é carregada em dois endereços distintos da memória do mesmo processo, o que pode causar sérios problemas dependendo do código envolvido.
K:\Docs\Projects&amp;gt;mkdir DLLK:\Docs\Projects&amp;gt;copy dll.dll DLL1 arquivo(s) copiado(s).K:\Docs\Projects&amp;gt;appFirst DLL: 10000000
Second DLL: 00350000
K:\Docs\Projects&amp;gt; Apesar do mundo parecer injusto, temos uma segunda regra que podemos usar para aqueles casos onde a idiotisse já foi feita:
Regra número 2: você pode contar para o _loader _o que pretende fazer Vamos supor que estamos no meio de uma mudança bem radical no produto e queremos ter certeza que qualquer chamada à nossa DLL irá invocar unicamente a que estiver dentro do caminho do produto (caminho atual). Para esse caso o Windows permite uma saída muito interessante, que é o uso de um arquivo com o nome do aplicativo mais o sufixo &amp;quot;.local&amp;quot;. Se esse arquivo existir, de acordo com o MSDN, então qualquer chamada à DLL irá ter sempre a prioridade do caminho atual.
K:\Docs\Projects&amp;gt;copy con app.exe.local^Z1 arquivo(s) copiado(s).K:\Docs\Projects&amp;gt;appFirst DLL: 10000000
Second DLL: 10000000
K:\Docs\Projects&amp;gt; Moral da história Tente evitar a replicação do mesmo arquivo em diversos lugares. Quando eu digo &amp;quot;mesmo arquivo&amp;quot; me refiro ao mesmo nome de DLL, embora não necessariamente a mesma versão. Isso pode evitar algumas dores de cabeça futuras. E muitas, muitas horas de depuração.
</description>
</item>

     
        <item>
  <title>Alinhamento de Memória Portável</title>
  <link>http://www.caloni.com.br/alinhamento-de-memoria-portavel/</link>
  <pubDate>2008-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/alinhamento-de-memoria-portavel/</guid>
  <description>Como vimos durante o seminário CCPP, o alinhamento de memória pode ser problemático durante momentos críticos, como migração de plataforma (16 para 32 bits) e de ambiente (compilador novo). A forma como a memória é alinhada influi diretamente em algoritmos de criptografia ou de rede, para citar dois exemplos bem comuns, fazendo com que o que funcionava antes não funcione mais sem mexer uma única linha de código. Eu já vi isso. E isso não é bom.
A raiz do problema é que, dependendo do alinhamento usado pelo compilador, o sizeof de uma variável pode mudar de valor, mesmo que o tamanho útil não mude. Por exemplo, vamos supor que temos uma dada estrutura que iremos encriptar:
struct S{/* 4 bytes */int size;/* 31 bytes */char name[31];};/* 4 &#43; 31 = 35 bytes */ Se usarmos a construção &amp;quot;sizeof(struct S)&amp;quot;, podemos obter o valor 35 caso o alinhamento seja feito em 1 byte, ou podemos obter o valor 40 se o alinhamento estiver configurado em 8 bytes. E é aí que começa o problema.
Já pensando nesse problema, os projetistas de vários compiladores suportam uma extensão não-padrão que permite definir, para um dado conjunto de estruturas e variáveis, o alinhamento que deve ser seguido. Isso de cara já resolve o problema, se sua solução usar apenas compiladores que suportem essa idéia. No Visual C&#43;&#43; essa idéia é traduzida pela diretiva pragma, que é definida no padrão C (6.8.6) e C&#43;&#43; (16.6). Seu uso não torna um programa não-padrão. No entanto, o que vai depois da diretiva é dependente da implementação e não é garantido que irá funcionar.
Usando essas diretivas ao compilador nossa estrutura sempre terá 40 bytes ocupados na memória, pois o alinhamento foi forçado em 8 bytes. Existem aqueles compiladores que não suportam essa idéia da mesma forma, ou não suportam de jeito nenhum. Para esses casos, alguns desvios de comportamento são necessários. A grande pergunta é se isso é possível de ser feito de forma 100% padrão. E, pelo que eu pude constatar, é possível, sim:
#include &amp;lt;stdio.h&amp;gt;union Align{struct S{char buf[13];int x;}t;unsigned char align[sizeof(struct S) % 8 ?(sizeof(struct S) / 8 &#43; 1) * 8:(sizeof(struct S))];}; O código acima usa o conceito de união de estruturas (union) para fazer valer um alinhamento na marra (no caso, 8). Uma estrutura, como todos sabem, amontoa os seus membros um após o outro na memória. Dessa forma podemos tratar um bloco de memória com um leiaute que definimos com outros tipos. Em uma união, os membros não são amontoados um após o outro. Todos eles começam no mesmo ponto da memória. Eles se sobrescrevem. O tamanho da união sempre é o tamanho do seu maior membro, e não a soma de todos. É um tanto difícil de descrever esse leiaute, mas imagine que você tenha apenas uma posição na memória e queira chamá-la de vários nomes e tamanhos diferentes. Essa é a união.
Como deve ser fácil de imaginar, uma união não tem tanto uso quanto uma estrutura, mas ainda assim faz parte da linguagem. Ela possibilita enxergar a mesma região de memória sob vários ângulos. Podemos descobrir a organização de um inteiro na memória, por exemplo, byte a byte. Dependendo se a plataforma onde o programa acima é compilado, esse leiaute pode mudar. O motivo é que cada plataforma e compilador terá sua maneira de traduzir o código C na memória.
Agora que sabemos o que são uniões fica fácil entender o esquema da solução portável. A union acima simplesmente usa a segunda estrutura como uma auxiliar de alinhamento. Com ela do tamanho múltiplo do alinhamento desejado forçamos a união inteira a ter esse alinhamento, independente do tamanho da estrutura útil, a que iremos usar para armazenar os dados. Todo o resto é usado para alinhar na memória.
Tudo que temos que saber para fazer o alinhamento é o tamanho normal de nosso tipo útil (struct S). A partir desse valor deduzimos o próximo número que seja múltiplo de 8, através da seguinte construção:
sizeof(struct S) % 8 ?(sizeof(struct S) / 8 &#43; 1) * 8:(sizeof(struct S)) Ou seja, se S já for múltiplo de 8 é o próprio valor. Se não for, então dividimos por 8 e multiplicamos pelo mesmo valor adicionado de um, o que nos retorna o próximo múltiplo.
É lógico que, como se trata de uma construção onde temos completo domínio dos tipos e valores envolvidos, transformar isso em um template é &amp;quot;pedaço de torta&amp;quot;.
template&amp;lt;typename T, int A&amp;gt;union UAlign{T t;unsigned char align[sizeof(T) % A?(sizeof(T) / A &#43; 1) * A:(sizeof(T))];}; E essa é a melhor parte de descobrir um padrão em um tipo: o template nasce quase que naturalmente. A beleza da linguagem floresce.
</description>
</item>

     
        <item>
  <title>Guia básico de repositórios no Bazaar</title>
  <link>http://www.caloni.com.br/guia-basico-de-repositorios-no-bazaar/</link>
  <pubDate>2008-06-10</pubDate>
  
  <guid>http://www.caloni.com.br/guia-basico-de-repositorios-no-bazaar/</guid>
  <description>Alguns conceitos-chave antes de trabalhar com o Bazaar são:
  Revision (Revisão). Um snapshot dos arquivos que você está trabalhando.
  Working Tree (Árvore de Trabalho). Um diretório contendo seus arquivos controlados por versão e subdiretórios.
  Branch (Ramificação). Um grupo ordenado de revisões que descreve o histórico de um grupo de arquivos.
  Repository (Repositório). Um depósito de revisões.
  Agora vamos brincar um pouco com os conceitos.
Criando o primeiro projeto controlado O uso mais simples que existe no Bazaar é o controle de uma pasta sozinha, conhecida como uma Standalone Tree. Como toda Working Tree, ela possui um repositório relacionado, que no caso está dentro dela mesmo, na pasta oculta &amp;quot;.bzr&amp;quot;.
Pra criar uma Standalone Tree, tudo que precisamos é usar o comando init de dentro da pasta a ser controlada, quando é criado um repositório local. Adicionamos arquivos para o repositório com o comando add, e finalizamos nossa primeira versão com o comando commit.
C:\Tests&amp;gt;cd project1C:\Tests\project1&amp;gt;bzr initC:\Tests\project1&amp;gt;bzr addadded AUTHORSadded COPYINGadded COPYRIGHTadded ChangeLogadded ChangeLog.2added FAQ...added winboard/extends/infboard/main.cadded winboard/extends/infboard/msvc.makadded winboard/extends/infboard/support.cC:\Tests\project1&amp;gt;bzr commit -m &amp;quot;Comentario sobre a revisao&amp;quot;Committing to: C:/Tests/project1/added AUTHORSadded COPYINGadded COPYRIGHTadded ChangeLogadded ChangeLog.2added FAQ...added winboard/extends/infboard/main.cadded winboard/extends/infboard/msvc.makadded winboard/extends/infboard/support.cCommitted revision 1.C:\Tests\project1&amp;gt; Feito. A partir daí temos um repositório onde podemos realizar o comando commit sempre que quisermos marcar um _snapshot _em nosso código-fonte.
Criando um novo branch Se quisermos fazer uma alteração muito grande em nosso pequeno projeto seria melhor termos outro diretório onde trabalhar antes de realizar o commit na versão estável. Para isso podemos usar o comando branch, que cria uma nova pasta com todo o histórico da pasta inicial até esse ponto. Os históricos em um branch estão duplicados em ambas as pastas, e portanto são independentes. Você pode apagar a pasta original ou a secundária que terá o backup inteiro no novo branch.
C:\Tests\project1&amp;gt;cd ..C:\Tests&amp;gt;bzr branch project1 project1-changingBranched 1 revision(s).C:\Tests&amp;gt;cd project1-changingC:\Tests\project1-changing&amp;gt; Criando um repositório compartilhado Criar um novo branch totalmente duplicado pode se tornar um desperdício enorme de espaço em disco (e tempo). Para isso foi criado o conceito de Shared Repository, que basicamente é um diretório acima dos branchs que trata de organizar as revisões em apenas um só lugar, com a vantagem de otimizar o espaço. Nesse caso, antes de criar o projeto, poderíamos usar o comando init-repo na pasta mãe de nosso projeto, e depois continuar com o processo de init dentro da pasta do projeto.
C:\&amp;gt;bzr init-repo TestsC:\&amp;gt;cd TestsC:\Tests&amp;gt;bzr init project1C:\Tests&amp;gt;cd project1C:\Tests\project1&amp;gt;bzr addadded AUTHORSadded COPYINGadded COPYRIGHTadded ChangeLogadded ChangeLog.2added FAQ...added winboard/extends/infboard/main.cadded winboard/extends/infboard/msvc.makadded winboard/extends/infboard/support.cC:\Tests\project1&amp;gt;bzr commit -m &amp;quot;Comentario sobre a revisao&amp;quot;Committing to: C:/Tests/project1/added AUTHORSadded COPYINGadded COPYRIGHTadded ChangeLogadded ChangeLog.2added FAQ...added winboard/extends/infboard/main.cadded winboard/extends/infboard/msvc.makadded winboard/extends/infboard/support.cCommitted revision 1.C:\Tests\project1&amp;gt; Se compararmos o tamanho, veremos que o repositório compartilhado é que detém a maior parte dos arquivos, enquanto agora o &amp;quot;.bzr&amp;quot; que está na pasta do projeto possui apenas dados de controle. A mesma coisa irá acontecer com qualquer branch criado dentro da pasta de repositório compartilhado.
Mas já criamos nossos dois branches cheios de arquivos, certo? Certo. Como já fizemos isso, devemos criar uma nova pasta como repositório compartilhado e criar dois novos branches dentro dessa pasta, cópias dos dois branches gordinhos:
C:\Tests&amp;gt;bzr init-repo project1-repoC:\Tests&amp;gt;bzr branch project1 project1-repo\project1Branched 1 revision(s).C:\Tests&amp;gt;bzr branch project1-changing project1-repo\project-changingBranched 1 revision(s).C:\Tests&amp;gt; Isso irá recriar esses dois branches como os originais, mas com a metade do espaço em disco, pois seus históricos estarão compartilhados na pasta project1-repo.
E o tal do SubVersion? O SubVersion é um sistema de controle centralizado. O Bazaar consegue se comportar exatamente como o SubVersion, além de permitir carregar o histórico inteiro consigo. Quem decide como usá-lo é apenas você, pois cada usuário do sistema tem a liberdade de escolher a melhor maneira.
Os comandos para usar o Bazaar à SubVersion são os mesmos do SubVersion: checkout e commit. No entanto, um checkout irá fazer com que seu commit crie a nova revisão primeiro no seu servidor (branch principal) e depois localmente. Se você não deseja criar um histórico inteiro localmente, pode criar um checkout leve (parâmetro --lightweight), que apenas contém arquivos de controle. No entanto, se o servidor de fontes não estiver disponível, você não será capaz de ações que dependam dele, como ver o histórico ou fazer commits.
C:\Tests\client&amp;gt;bzr checkout ..\server\project1C:\Tests\client&amp;gt;cd project1C:\Tests\client\project1&amp;gt;echo &amp;quot;New changes&amp;quot; &amp;gt;&amp;gt; FAQC:\Tests\client\project1&amp;gt;bzr commit -m &amp;quot;New changes comment&amp;quot;Committing to: C:/Tests/server/project1/modified FAQCommitted revision 2.C:\Tests\client\project1&amp;gt;bzr log -l 1 ..\..\server\project1------------------------------------------------------------revno: 2committer: Wanderley Caloni &amp;lt;wanderley@caloni.com.br&amp;gt;branch nick: project1timestamp: Sun 2008-06-08 19:52:17 -0300message:New changes commentC:\Tests\client\project1&amp;gt; Na verdade, o Bazaar vai além, e permite que um branch/checkout específico seja conectado e desconectado em qualquer repositório válido. Para isso são usados os comandos bind e unbind. Um branch conectado faz commits remotos e locais, enquanto um branch unbinded faz commits apenas locais. É possível mudar esse comportamento com o parâmetro --local, e atualizar o branch local com o comando update.
Mais detalhes  Bazaar User Guide  Mais detalhes ainda  Bazaar User Reference  </description>
</item>

     
        <item>
  <title>Declaração x definição</title>
  <link>http://www.caloni.com.br/declaracao-x-definicao/</link>
  <pubDate>2008-06-06</pubDate>
  
  <guid>http://www.caloni.com.br/declaracao-x-definicao/</guid>
  <description>Uma diferença que eu considero crucial na linguagem C/C&#43;&#43; é a questão da declaração/definição (em inglês, declaration/definition). É a diferença entre esses dois conceitos que permite, por exemplo, que sejam criadas estruturas prontas para serem conectadas a listas ligadas:
struct Element{int x;int y;&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;Element* next;&amp;lt;/font&amp;gt; /* olha eu mesmo aqui! */}; Por outro lado, e mais importante ainda, é ela que permite que as funções sejam organizadas em unidades de tradução (cpps) distintas para depois se unirem durante o link, mesmo que entre elas exista uma relação de dependência indissociável:

Existem diversas formas de entender esses dois conceitos. Eu prefiro explicar pela mesma experiência que temos quando descobrimos a divisão hardware/software:
  Hardware é o que você chuta
  Software é o que você xinga
  Exatamente. _Hardware _é algo paupável, que você pode até chutar se quiser. Por exemplo, a sua memória RAM! No entanto, _software _é algo mais abstrato, que nós, seres humanos, não temos a capacidade de dar umas boas pauladas. Portanto, nos abstemos a somente xingar o maldito que fez o programa &amp;quot;buggento&amp;quot;.
Da mesma forma, uma declaração em C/C&#43;&#43; nos permite moldar como será alguma coisa na memória, sem no entanto ocupar nem um mísero byte no seu programa:
int func(int x, int y, int z); /* tamanho em memória: zero bytes */struct Teste{char bufao[0x100000]; /* tamanho em memória: zero bytes */int intao[0xffffff]; /* tamanho em memória: zero bytes */};extern int x; /* tamanho em memória: adivinha! */ Por outro lado, a definição, o _hardware _da história, sempre ocupará alguma coisa na memória RAM, o que, de certa forma, permite que você chute uma variável (embora muitas outras também irão para o saco).
int func(int x, int y, int z) /* tamanho em memória:{int ret = x &#43; y &#43; z; /* alguns _asm add &#43; */return ret; /* um _asm ret */}Teste tst; /* tamanho em memória: 0x100000 &#43; 0xffffff * 4 = 1048576 bytes */int x; /* tamanho em memória: sizeof(int) bytes */ Dessa comparação só existe uma pegadinha: uma definição também é uma declaração. Por exemplo, nos exemplos acima, além de definir func, tst e x, o código também informa ao compilador que existe uma função chamada func, que existe uma variável tst do tipo Teste e uma variável x do tipo int.
Informa ao compilador? Essa é uma outra ótima maneira de pensar a respeito de declarações: elas sempre estão conversando diretamente com o compilador. Por outro lado, nunca conversam diretamente com o _hardware, _pois ao executar seu código compilado, as declarações não mais existem. Foi apenas um interlúdio para que o compilador conseguisse alocar memória da maneira correta.
Complicado? Talvez seja, mesmo. Mas é algo que vale a pena fixar na mente. Isso, é claro, se você quiser ser um programador C/C&#43;&#43; mais esperto que os outros e resolver pequenos problemas de compilação que muitos perdem horas se perdendo.
Corolário Então por que diabos a separação declaração/definição consegue definir coisas como listas ligadas, como no código acima? A resposta é um pouco ambígua, mas representa regra essencial na sintaxe da linguagem: após a definição do nome e do tipo de declaração envolvida podemos referenciá-la como declaração, ou seja, não ferindo a limitação de que não sabemos o tamanho de uma variável do tipo declarado. Dessa forma, é perfeitamente legal definirmos um ponteiro para uma estrutura que ainda não se sabe muita coisa, além de que é uma estrutura:
struct Estrutura; /* atenção: declaração apenas! */Estrutura* st; /* ponteiro para declaração: não sabemos o tamanho ainda */ Dessa forma, o começo de uma definição de estrutura já declara o nome da estrutura antes de terminar a declaração do tipo inteiro. Bizarro, não? De qualquer forma, isso permite a construção clássica de lista ligada:
&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;struct Estrutura&amp;lt;/font&amp;gt; /* a partir daqui Estrutura já está visível */{&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;Estrutura* st;&amp;lt;/font&amp;gt; /* recursividade? é apenas um ponteiro! */}; Se vermos pelo lado prático, de qualquer forma seria impossível definir uma variável dentro dela mesma, pois isso geraria uma recursão infinita de definições, e, como sabemos, os recurso da máquina são finitos.
</description>
</item>

     
        <item>
  <title>Como criar uma LIB no Visual Studio</title>
  <link>http://www.caloni.com.br/como-criar-uma-lib-no-visual-studio/</link>
  <pubDate>2008-05-29</pubDate>
  
  <guid>http://www.caloni.com.br/como-criar-uma-lib-no-visual-studio/</guid>
  <description>Quando se está começando no ramo, alguns detalhes nunca vêm à tona para o programador novato. Ele simplesmente vai codando até se sentir satisfeito com o prazer que é proporcionado pela prática da arte dos deuses de silício.
Isso, em termos práticos, quer dizer que todo o fonte vai ser escrito no mesmo &amp;quot;.c&amp;quot;, que aliás talvez nem se dê ao luxo de possuir seu próprio &amp;quot;.h&amp;quot;: pra quê, se as funções são todas amigas de infância e todas se conhecem?
No começo não existe nenhum problema, mesmo. O fonte vai ser pequeno. A coisa só complica quando não dá mais pra se achar no meio de tantos gotos e ifs aninhados. Talvez nessa hora o programador já-não-tão-novato até tenha descoberto que é possível criar vários arquivos-fonte e reuni-los em um negócio chamado projeto, e que existem IDEs, como o Visual Studio, que organizam esses tais projetos.
A partir daí, para chegar em uma LIB, já é meio caminho andado.
Mas, afinal de contas, pra que eu preciso de uma LIB, mesmo? Boa pergunta. Uma LIB, ou biblioteca, nada mais é do que um punhado de &amp;quot;.obj&amp;quot; colocados todos no mesmo arquivo, geralmente um &amp;quot;.lib&amp;quot;. Esses &amp;quot;.obj&amp;quot; são o resultado da compilação de seus respectivos &amp;quot;.c&amp;quot; de origem.

Alguns acreditam ser esse negócio de LIB uma pura perda de tempo, pois existem trocentas configurações diferentes (e incompatíveis) e trocentas compilações diferentes para gerenciar. Outros acham que o problema está no tempo de compilação, enquanto outros defendem o uso dos &amp;quot;.obj&amp;quot; de maneira separada. Esse artigo não presume que nem um nem outro seja melhor. Apenas ensina o que você precisa saber para criar sua primeira LIB usando o Visual Studio Express.
Vamos lá?
Criando seu primeiro projeto de LIB Após abrir o VS, tudo que precisamos fazer é ir em New, Project, e escolher a configuração de &amp;quot;Win32 Project&amp;quot;:

A seguir, escolhemos nas opções do assistente criar uma &amp;quot;Static library&amp;quot;, e desmarcamos a opção de &amp;quot;Precompiled header&amp;quot; para evitar má sorte logo no primeiro projeto de LIB (má sorte significa horas procurando erros incríveis que você só irá fazer desaparecer se recompilar tudo com o uso do famigerado &amp;quot;Rebuild All&amp;quot;; espero que isso dê certo para você, para mim não tem funcionado).
E pronto! Temos um projeto de LIB completo, funcional e... um tanto inútil. Mas, calma lá. Ainda não terminamos.
Adicionando arquivos à sua LIB Conforme o programador consegue se livrar das maldições das mil dependências, aos poucos ele vai conseguindo novas funções genéricas e encaixáveis para colocar em sua coleção de objs. Essa com certeza não é uma tarefa fácil, mas ei, quem disse que esse trampo de programador seria fácil?
Vamos imaginar que você é muito do sem imaginação (típico de pessoas que mantêm blogues) e criou duas funções lindíssimas que somam e multiplicam dois números:
int sum(int a, int b){return a &#43; b;}int mult(int a, int b){return a * b;} Não são aquelas coisas, mas são genéricas e, até certo ponto, &amp;quot;úteis&amp;quot; para o nosso exemplo.
Agora, tudo que temos que fazer é criar dois arquivos: mymath.c e mymath.h. No mymath.c, colocamos as funções acima exatamente como estão. No mymath.h, colocamos apenas as declarações dessas duas funções, apenas para avisar outros &amp;quot;.c&amp;quot; que existem duas funções que fazem coisas incríveis nessa nossa LIB.
/* soma dois números */int sum(int a, int b);/* multiplica dois números */int mult(int a, int b); Adicionamos esses dois arquivos ao projeto (se já não estão), e voilà!
------ Build started: Project: MyFirstLib, Configuration: Debug Win32 ------Compiling...mymath.cCreating library...Build log was saved at &amp;quot;file://c:\Projects\temp\MyFirstLib\Debug\BuildLog.htm&amp;quot;MyFirstLib - 0 error(s), 0 warning(s)========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ========== Usando a LIB mais maravilhosa de todos os tempos Para usar uma LIB temos inúmeras maneiras de fazê-lo. A mais simples que eu conheço é criar um novo projeto no mesmo Solution de sua LIB. Um console, por exemplo:
Se você seguiu todos os passos direitinho, e eu estou assumindo que você já sabia como criar um projeto console, sua saída da compilação talvez seja mais ou menos essa:
------ Build started: Project: MyFirstCmd, Configuration: Debug Win32 ------Compiling...mycmd.cLinking...mycmd.obj : error LNK2019: unresolved external symbol _mult referenced in function _mainmycmd.obj : error LNK2019: unresolved external symbol _sum referenced in function _mainc:\Projects\temp\MyFirstLib\Debug\MyFirstCmd.exe : fatal error LNK1120: 2 unresolved externalsBuild log was saved at &amp;quot;file://c:\Projects\temp\MyFirstCmd\Debug\BuildLog.htm&amp;quot;MyFirstCmd - 3 error(s), 0 warning(s)========== Build: 0 succeeded, 1 failed, 1 up-to-date, 0 skipped ========== Dois erros! Ele não achou os símbolos _mult e _sum. Mas eles estão logo ali! E agora?
Nada a temer: tudo que temos que fazer é falar para o Solution que o projeto myfirstcmd depende do projeto myfirstlib:
------ Build started: Project: MyFirstCmd, Configuration: Debug Win32 ------Linking...Embedding manifest...Microsoft (R) Windows (R) Resource Compiler Version 6.0.5724.0Copyright (C) Microsoft Corporation. All rights reserved.Build log was saved at &amp;quot;file://c:\Projects\temp\MyFirstCmd\Debug\BuildLog.htm&amp;quot;MyFirstCmd - 0 error(s), 0 warning(s)========== Build: 1 succeeded, 0 failed, 1 up-to-date, 0 skipped ========== Isso resolve o problema de organização e compilação quando temos dezenas de &amp;quot;.c&amp;quot; espalhados pelo projeto. Existem melhores alternativas, mais bem organizadas e estruturadas, inclusive lingüisticamente falando. No entanto, tudo tem sua hora, e só se deve preocupar-se com isso quando sua solução tiver algumas dezenas de &amp;quot;.lib&amp;quot;. Até lá!
</description>
</item>

     
        <item>
  <title>Aprendendo rapidamente conceitos essenciais do WinDbg</title>
  <link>http://www.caloni.com.br/aprendendo-rapidamente-conceitos-essenciais-do-windbg/</link>
  <pubDate>2008-05-23</pubDate>
  
  <guid>http://www.caloni.com.br/aprendendo-rapidamente-conceitos-essenciais-do-windbg/</guid>
  <description>Todo o poder e flexibilidade do pacote Debugging Tools da Microsoft pode ser ofuscado pela sua complexidade e curva de aprendizagem. Afinal de contas, usar o depurador do Visual Studio é muito fácil, quando se começa a usar, mas mesmo assim conheço muitos programadores que relutam em depurar passo-a-passo, preferindo a depuração por meio de &amp;quot;MessageBoxes&amp;quot; ou saídas na tela. Imagine, então, a dificuldade que não é para quem conseguiu às duras penas aprender a tornar um hábito a primeira passada do código novo em folha através do F10 começar a fazer coisas como configurar símbolos e digitar comandos exdrúxulos em uma tela em modo texto. Para piorar a questão, existem aqueles que defendem o uso unificado de uma ferramenta que faça tudo, como um telefone celular. Eu discordo. Quando a vantagem competitiva de uma ferramenta sobre outra é notável, nada pior que ficar preso em um ambiente legalzinho que faz o mínimo para você, mas não resolve o seu problema de deadlock.
Foi pensando nessa dificuldade que foi escrita uma apresentação nota dez por Robert Kuster que explica todas as minúcias importantes para todo programador iniciante e experiente na arte de &amp;quot;WinDbgear&amp;quot;. &amp;quot;WinDbg. From A to Z!&amp;quot; é uma ferramenta tão útil quanto o próprio WinDbg, pois explica desde coisas simples que deve-se saber desde o início, como configurar símbolos, quanto assuntos mais avançados, como depuração remota. Até para quem já está no nível avançado vale a pena recapitular algumas coisas que já foram ditas no AWD.
Mesmo tentando ser sucinto, o assunto ocupou um conjunto de 111 transparências que demoram de uma a duas horas de leitura cuidadosa, se você não fizer testes durante o trajeto. Entre as coisas que eu li e reli, segue uma lista importante para nunca ser esquecida (entre parênteses o número das transparências que considero mais importantes):
  O que é são as bibliotecas de depuração do Windows e como elas podem te ajudar (6 e 9)
  O que são símbolos de depuração (11, 12, 14)
  Como funciona a manipulação de exceções e como depurar (18, 19, 85)
  Como configurar seu depurador para funcionar globalmente (20)
  Tipos de comandos no WinDbg (22)
  Configurando símbolos e fontes no WinDbg (24, 25)
  Interagindo com as janelas do WinDbg (33)
  Informações sobre processos, pilhas e memória (29, 41, 43, 45, 66)
  Informações sobre threads e locks (31, 55)
  Comandos úteis com _strings _e memórias (66)
  Avaliando expressões no WinDb: MASM e C&#43;&#43; (70, 71)
  Usando _breakpoints _no WinDbg (básico) (81)
  Usando _breakpoints _no WinDbg (complicado) (83, 84)
  Depuração remota (muito útil!) (87)
  Escolhendo a melhor ferramenta para o problema (fantástico!) (108)
  Além da enchurrada de informações, o autor ainda explica a teoria com comandos digitados no próprio WinDbg, dando um senso bem mais prático à ferramenta. Ou seja, é útil tanto para os que aprendem por definições abstratas e lista de comandos quanto os que preferem já colocar a mão na massa e massacrar o bom e velho notepad.exe.
No final, duas dicas importantíssimas do autor para quem deseja se aventurar nesse mundo: leia a documentação do WinDbg (que também é ótima, apesar de bem mais extensa) e aprenda assembly (simplesmente essencial para resolver muitos problemas).
Se você ainda não teve tempo de se dedicar à depuração avançada em Windows e pensa que nunca terá, dedique duas horinhas divididas em períodos de 15 minutos por dia para explorar esse fantástico tutorial, que com certeza, se bem aplicado, reduzirá exponencialmente seu tempo de resolução de problemas.
Eu recomendo.
Existe uma tradução para inglês desse texto no saite do próprio Robert Kuster, que usou-o como uma espécie de introdução.
</description>
</item>

     
        <item>
  <title>MouseTool: clique automático do seu rato</title>
  <link>http://www.caloni.com.br/mousetool-clique-automatico-do-seu-rato/</link>
  <pubDate>2008-05-21</pubDate>
  
  <guid>http://www.caloni.com.br/mousetool-clique-automatico-do-seu-rato/</guid>
  <description>Bem, como a maioria de você já sabe, eu realmente não gosto de mouses. Apesar disso respeito os usuário que usam-no e até gostam dele. Essa é a razão por que estou escrevendo mais uma vez sobre isso. Dessa vez, irei mostrar um programa que eu uso todos os dias: MouseTool, para os usuários que não usam o mouse, mas gostam dele [1].
O principal objetivo do programa é evitar de clicar no mouse, simulando um clique toda vez que o usuário pára de mover o ponteiro. E é só isso: simples, eficiente e mouseless =).
Existem algumas outras opções como arrastar-e-soltar e clique-duplo, ambas disponíveis pelo próprio programa através de atalhos do teclado ou mudança de estado, situação onde o usuário antes pousa o ponteiro sobre a ação desejada e depois pousa o ponteiro sobre o alvo, dessa forma alternando entre os três modos.
O MouseTool originalmente foi uma ferramente de fonte aberto. Isso significa que a última versão do código-fonte está disponível, certo? Errado. Na verdade, eu não consegui, por mais que tentasse achar, a versão para baixar do código.
Felizmente meu amigo Marcio Andrey já havia baixado o fonte algum tempo atrás e, assim como eu, ele gostaria de torná-lo disponível para todos que gostassem de usá-lo e alterá-lo. Por isso que estou publicando-o aqui. Ele é gratuito e aberto. Façam o que quiserem com ele =).
Vamos aproveitar o código-fonte e mostrar como explorar um código não escrito por nós. Normalmente as primeiras coisas a fazer são: baixar o arquivo compactado e descompactá-lo dentro de uma nova pasta. Dessa forma encontramos o arquivo de projeto (nesse caso, MouseTool.dsw) e tentamos abri-lo. Falhando de início miseravelmente porque acredito que ninguém mais utilize a versão do Visual Studio que abre isso.
Normalmente programadores de projetos de fonte aberto estão acostumados a obter os arquivos-fonte, modificá-los, publicá-los e assim por diante. Porém isso não é quase nunca verdade para programadores Windows de aplicativos estritamente comerciais. É necessário se reajustar à nova cultura para aproveitar os benefícios da política de fonte aberto.
Por exemplo, dados os arquivos-fonte, nós podemos explorar algumas partes interessantes de coisas que gostaríamos de fazer em nossos próprios programas. São trechos pequenos de código que fazem coisas úteis que gastaríamos algumas horas/dias para pesquisar na internet e achar a resposta procurada. Através de um projeto de fonte aberto, conseguimos usar um programa e ao mesmo tempo aprender seu funcionamento. E a principal parte é: nós temos o fonte, mas não os direitos autorais.
Subi um repo no GitHub para baixar o programa; faça bom uso dele.
PS: MouseTool agora tem uma versão Linux em um projeto no Source Forge! Seu nome é GMouseTool, projeto criado por Márcio de Oliveira.
</description>
</item>

     
        <item>
  <title>Aquele do-while engraçado</title>
  <link>http://www.caloni.com.br/aquele-do-while-engracado/</link>
  <pubDate>2008-05-15</pubDate>
  
  <guid>http://www.caloni.com.br/aquele-do-while-engracado/</guid>
  <description>Nesses últimos dias andei conversando com um amigo que está estudando sistemas operacionais na faculdade. Melhor ainda, vendo o código real de um sistema operacional em funcionamento. A conseqüência é que, além de aprender um bocado de como as coisas funcionam de verdade debaixo dos panos, acaba-se aprendendo alguns truquezinhos básicos e tradicionais da linguagem C.
Por exemplo, é um hábito conhecido o uso de construções do-while quando existe a necessidade de definir uma macro que possui mais de um comando em vez de usar a igualmente conhecida { construção de múltiplos comandos entre chaves }.
O que talvez não seja tão conhecido é o porquê das coisas serem assim.
Vamos imaginar uma macro de logue que é habilitada em compilações debug, mas é mantida em silêncio em compilações release:
#ifdef NDEBUG#define MYTRACE( message ) /* nothing */#else#define MYTRACE( message ) \	{ \char buffer[500]; \sprintf(buffer, \&amp;#34;MYTRACE: %s(%d) %s\n&amp;#34;, \__FILE__, \__LINE__, \message); \OutputDebugString(buffer); \}#endif /* NDEBUG */Nada de mais, e parece até funcionar. Porém, como veremos nas próximas linhas, esse é realmente um exemplo de código &amp;quot;buguento&amp;quot;, já que uma chamada dentro de uma construção if-else simplesmente não funciona.
if( exploded() )MYTRACE(&amp;#34;Oh, my God&amp;#34;);elseMYTRACE(&amp;#34;That&amp;#39;s right&amp;#34;); error C2181: illegal else without matching if Por que isso? Para responder a essa questão nós precisamos olhar um pouco mais de perto no resultado do preprocessador da linguagem, que apenas troca nossa macro pelo pedaço de código que ela representa:
if( exploded() ){char buffer[500];sprintf(buffer,&amp;#34;MYTRACE: %s(%d) %s\n&amp;#34;,__FILE__,__LINE__,&amp;#34;Oh, my God&amp;#34;);OutputDebugString(buffer);};else{char buffer[500];sprintf(buffer,&amp;#34;MYTRACE: %s(%d) %s\n&amp;#34;,__FILE__,__LINE__,&amp;#34;That&amp;#39;s right&amp;#34;);OutputDebugString(buffer);};Dessa forma, podemos ver o porquê. Quando chamamos a macro, geralmente usamos a sintaxe de chamada de função, colocando um sinal de ponto-e-vírgula logo após a chamada. Essa é a maneira correta de se chamar uma função, mas no caso de uma macro, dessa macro, é um desastre, porque ela cria dois comandos em vez de um só (um ponto-e-vírgula vazio, apesar de não fazer nada, é um comando válido). Então, isso é o que o compilador faz:
if( instruction ){/* um monte de comandos */} /* aqui eu esperaria um else ou uma instrução nova */ ; /* uma instrução nova! ok, sem else desa vez */
else /* espere ae! o que esse else está fazendo aqui sem um if?!?! */{/* mais comandos */} Pense sobre o comando vazio como se ele fosse um comando real, o que é a maneira mais fácil de entender o erro de compilação que recebemos ao compilar o código abaixo:
if( error() ){printf(&amp;quot;error&amp;quot;);} printf(&amp;quot;here we go&amp;quot;);
else /* llegal else without matching if! */{printf(&amp;quot;okay&amp;quot;);} Por essa razão, a maneira tradicional de escapar desse erro comum é usar uma construção válida que peça de fato um ponto-e-vírgula no final. Felizmente nós, programadores C/C&#43;&#43;, temos essa construção, e ela é... muito bem, o do-while!
do{/* múltiplos comandos aqui */}while( expression ) ;
 /* eu espero um ponto-e-vírgula aqui, parafinalizar minha instrução do-while */ Assim nós podemos reescrever nossa macro de logue da maneira certa (e todas as 549.797 macros já escritas em nossa vida de programador). E, apesar de ser uma construção um tanto bizarra, ela funciona melhor do que nossa tentativa inicial:
#ifdef NDEBUG#define MYTRACE( message ) /* nothing */#else#define MYTRACE( message ) \	do \{ \char buffer[500]; \sprintf(buffer, \&amp;#34;MYTRACE: %s(%d) %s\n&amp;#34;, \__FILE__, \__LINE__, \message); \printf(buffer); \} \while( 0 )#endif /* NDEBUG */Ao usar um do-while (com uma expressão que retorna falso dentro do teste, de maneira que o código seja executado apenas uma vez) a construção if-else consegue funcionar perfeitamente:
if( exploded() )do{char buffer[500];sprintf(buffer,&amp;#34;MYTRACE: %s(%d) %s\n&amp;#34;,__FILE__,__LINE__,&amp;#34;Oh, my God&amp;#34;);OutputDebugString(buffer);}while( 0 );elsedo{char buffer[500];sprintf(buffer,&amp;#34;MYTRACE: %s(%d) %s\n&amp;#34;,__FILE__,__LINE__,&amp;#34;That&amp;#39;s right&amp;#34;);OutputDebugString(buffer);}while( 0 );</description>
</item>

     
        <item>
  <title>Como tratar um merge no Bazaar</title>
  <link>http://www.caloni.com.br/como-tratar-um-merge-no-bazaar/</link>
  <pubDate>2008-05-09</pubDate>
  
  <guid>http://www.caloni.com.br/como-tratar-um-merge-no-bazaar/</guid>
  <description>Hoje fizemos um _merge _de duas versões que entraram em conflito em nosso projeto-piloto usando bzr. Isso geralmente ocorre quando alguma coisa mudou no mesmo arquivo em lugares muito próximos um do outro. Veremos um exemplo de código para ter uma idéia de quão fácil é o processo:
#include &amp;lt;stdio.h&amp;gt;void InitFunction(){printf(&amp;#34;InitFunction&amp;#34;);}void DoAnotherJob(){char buf[100] = &amp;#34;&amp;#34;;fgets(buf, sizeof(buf), stdin);printf(&amp;#34;New line: %s&amp;#34;, buf);}void TerminateFunction(){printf(&amp;#34;TerminateFunction&amp;#34;);}int main(){InitFunction();while( ! feof(stdin) ){DoAnotherJob();}TerminateFunction();}A execução do programa contém uma saída parecida com as linhas abaixo:
C:\Tests\bzrpilot&amp;gt;bzppilot.exeInitFunctionuma linhaNew line: uma linhaduas linhasNew line: duas linhastres linhasNew line: tres linhas^ZNew line: TerminateFunctionC:\Tests\bzrpilot&amp;gt; Parece que está faltando algumas quebras de linha. Além de que sabemos que nossos arquivos de entrada poderão conter até 200 caracteres por linha, o que pode gerar um desastre em nosso buffer de 100 bytes. Buffer overflow!
Para corrigir ambos os problemas foram criados dois branches, seguindo as melhores práticas de uso de um controle de fonte distribuído:
C:\Tests&amp;gt;bzr branch bzrpilot bzrpilot-linebreakBranched 1 revision(s).C:\Tests&amp;gt;bzr branch bzrpilot bzrpilot-bufferoverflowBranched 1 revision(s). Feitas as correções devidas, o _branch _linebreak fica com a seguinte cara:
void InitFunction(){ printf(&amp;quot;InitFunction\n&amp;quot;);
}void DoAnotherJob(){char buf[100] = &amp;quot;&amp;quot;;fgets(buf, sizeof(buf), stdin); printf(&amp;quot;New line: %s\n&amp;quot;, buf);
}void TerminateFunction(){ printf(&amp;quot;TerminateFunction\n&amp;quot;);
} Em vermelho podemos notar as linhas alteradas. Uma mudança diferente foi feita para o bug do buffer overflow, em seu _branch _correspondente:
void DoAnotherJob(){ char buf[200] = &amp;quot;&amp;quot;;
 fgets(buf, sizeof(buf), stdin);printf(&amp;quot;New line: %s&amp;quot;, buf);} Agora só temos que juntar ambas as mudanças no _branch _principal.
&amp;quot;Mas espere aí! Não é uma boa termos números mágicos no código!&amp;quot; Com toda razão, pensa o programador que está corrigindo o bug da quebra de linha, olhando sorrateiramente a função do meio, intocada, DoAnotherJob.
Então ele resolve fazer um pequeno fix &amp;quot;de brinde&amp;quot;, desconhecendo que mais alguém andou alterando essas linhas:
#define ENOUGH_BYTES 100
void InitFunction(){printf(&amp;quot;InitFunction\n&amp;quot;);}void DoAnotherJob(){ char buf[ENOUGH_BYTES] = &amp;quot;&amp;quot;;
 fgets(buf, sizeof(buf), stdin);printf(&amp;quot;New line: %s\n&amp;quot;, buf);} Pronto. Um fonte politicamente correto! E que vai causar um conflito ao juntar essa galera. Vamos ver na seqüência:
C:\Tests&amp;gt;bzr log bzrpilot-linebreak --short3 Wanderley Caloni 2008-05-08A little fix2 Wanderley Caloni 2008-05-08Corrected line breaks1 Wanderley Caloni 2008-05-08Our first versionC:\Tests&amp;gt;bzr log bzrpilot-bufferoverflow --short2 Wanderley Caloni 2008-05-08Corrigido buffer overflow1 Wanderley Caloni 2008-05-08Our first versionC:\Tests&amp;gt;bzr log bzrpilot --short1 Wanderley Caloni 2008-05-08Our first versionC:\Tests&amp;gt;cd bzrpilotC:\Tests\bzrpilot&amp;gt;bzr pull ..\bzrpilot-linebreakM bzppilot.cppAll changes applied successfully.Now on revision 3.C:\Tests\bzrpilot&amp;gt;bzr pull ..\bzrpilot-bufferoverflow bzr: ERROR: These branches have diverged. Use the merge command to reconcile them.
Ops. Algo deu errado no segundo pull. O Bazaar nos diz que os _branches _estão diferentes, e que termos que usar o comando _merge _no lugar.
C:\Tests\bzrpilot&amp;gt;bzr merge ..\bzrpilot-bufferoverflowM bzppilot.cpp Text conflict in bzppilot.cpp
1 conflicts encountered. Usamos _merge _no lugar do _pull _e ganhamos agora um conflito no arquivo bzppilot.cpp, nosso único arquivo. Vamos ver a bagunça que fizemos?
Como funcionam os merges no Bazaar A última coisa que um controle de fonte quer fazer é confundir ou chatear o usuário. Por isso mesmo, a maioria dos conflitos que o Bazaar encontrar nos fontes serão resolvidos usando o algoritmo &amp;quot;se só um mexeu, então coloca a mudança&amp;quot;. A tabela do guia do usuário ilustra esse algoritmo em possibilidades:
Ancestral Usuário1 Usuário2 Resultado Comentáriox x x x não mudax x y y usuário 2 ganhoux y x y usuário 1 ganhoux y z ? conflito!!!
O ancestral é a última modificação em comum dos dois _branches _que estamos fazendo merge. Do ancestral pra frente cada um seguiu seu caminho, podendo existir quantas modificações quisermos.
Como podemos ver, o conflito só ocorre se ambos os usuário mexerem na mesma parte do código ao mesmo tempo. Eu disse na mesma parte do código, e não apenas no mesmo arquivo. Isso porque se a mudança for feita no mesmo arquivo, porém em locais diferentes, o conflito é resolvido automaticamente.
Em todos os conflitos de texto desse tipo, o Bazaar cria três arquivos de suporte e modifica o arquivo em conflito. Isso para cada conflito.
arquivo.cpp Resultado de até onde o Bazaar conseguiu o mergearquivo.cpp.BASE Versão ancestral do arquivoarquivo.cpp.THIS Nosso arquivo original antes de tentar fazer mergearquivo.cpp.OTHER A versão que entrou em conflito com a nossa Podemos fazer o _merge _da maneira que quisermos. Se vamos usar nossa versão de qualquer jeito é só sobrescrever o arquivo.cpp pelo arquivo.cpp.THIS. Se vamos fazer troca-troca de alterações, abrimos os arquivos .THIS e .OTHER e igualamos suas diferenças, copiando-as para arquivo.cpp.
Recomendo primeiramente olhar o que o Bazaar já fez. Se houver dúvidas sobre a integridade das mudanças, comparar diretamente os arquivos THIS e OTHER.
Vamos dar uma olhada na versão criada pelo Bazaar:
#include &amp;lt;stdio.h&amp;gt;#define ENOUGH_BYTES 100void InitFunction(){printf(&amp;quot;InitFunction\n&amp;quot;);}void DoAnotherJob(){ &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; TREE
 char buf[ENOUGH_BYTES] = &amp;quot;&amp;quot;; =======
 char buf[200] = &amp;quot;&amp;quot;;        MERGE-SOURCE
        fgets(buf, sizeof(buf), stdin);printf(&amp;quot;New line: %s\n&amp;quot;, buf);}void TerminateFunction(){printf(&amp;quot;TerminateFunction\n&amp;quot;);}int main(){InitFunction();while( ! feof(stdin) ){DoAnotherJob();}TerminateFunction();} Ora, vemos que ele já fez boa parte do trabalho para nós: as quebras de linha já foram colocadas e o novo define já está lá. Tudo que temos que fazer é trocar o _define _por 200 e tirar os marcadores, que é a junção das duas mudanças feitas no mesmo local, e que só um ser humano (AFAIK) consegue juntar:
#define ENOUGH_BYTES 200
void InitFunction(){printf(&amp;quot;InitFunction\n&amp;quot;);}void DoAnotherJob(){ char buf[ENOUGH_BYTES] = &amp;quot;&amp;quot;;
 fgets(buf, sizeof(buf), stdin);printf(&amp;quot;New line: %s\n&amp;quot;, buf);} Resolvido o problema, simplesmente esquecemos das versões .BASE, .THIS e .OTHER e falamos pro Bazaar que está tudo certo.
C:\Tests\bzrpilot&amp;gt;bzr resolve bzppilot.cpp O controle de fonte apaga automaticamente os arquivos THIS, BASE e OTHER, mantendo o original como a mudança aceita.
Após as correções dos conflitos, temos que fazer um _commit _que irá ser o filho dos dois _branches _que estamos juntando.
C:\Tests\bzrpilot&amp;gt;bzr commit -m &amp;quot;Tudo certo&amp;quot;Committing to: C:/Tests/bzrpilot/modified bzppilot.cppCommitted revision 4.C:\Tests\bzrpilot&amp;gt;bzr log------------------------------------------------------------revno: 4committer: Wanderley Caloni &amp;lt;wanderley@caloni.com.br&amp;gt;branch nick: bzrpilottimestamp: Thu 2008-05-08 22:09:35 -0300message:Tudo certo------------------------------------------------------------revno: 1.1.1
 committer: Wanderley Caloni &amp;lt;wanderley@caloni.com.br&amp;gt;branch nick: bzrpilot-bufferoverflowtimestamp: Thu 2008-05-08 21:47:33 -0300message:Corrigido buffer overflow------------------------------------------------------------revno: 3committer: Wanderley Caloni &amp;lt;wanderley@caloni.com.br&amp;gt;branch nick: bzrpilot-linebreaktimestamp: Thu 2008-05-08 21:49:30 -0300message:A little fix------------------------------------------------------------revno: 2committer: Wanderley Caloni &amp;lt;wanderley@caloni.com.br&amp;gt;branch nick: bzrpilot-linebreaktimestamp: Thu 2008-05-08 21:44:23 -0300message:Corrected line breaks------------------------------------------------------------revno: 1
committer: Wanderley Caloni &amp;lt;wanderley@caloni.com.br&amp;gt;branch nick: bzrpilottimestamp: Thu 2008-05-08 21:33:53 -0300message:Our first version A versão do branch alternativo é 1.1.1, indicando que ele saiu da revisão número 1, é o primeiro alternativo e foi o único commit. Se houvessem mais modificações neste branch, elas seriam 1.1.2, 1.1.3 e assim por diante. Se mais alguém quisesse juntar alguma modificação da revisão 1 ela seria 1.2.1, 1.3.1, 1.4.1 e assim por diante.
Enfim, tudo que temos que lembrar durante um merge do Bazaar é ver os conflitos ainda não resolvidos direto no fonte e alterá-los de acordo com o problema. O resto é codificar.
</description>
</item>

     
        <item>
  <title>Acessando memória física no WinDbg</title>
  <link>http://www.caloni.com.br/acessando-memoria-fisica-no-windbg/</link>
  <pubDate>2008-05-01</pubDate>
  
  <guid>http://www.caloni.com.br/acessando-memoria-fisica-no-windbg/</guid>
  <description>Como muitos devem saber, acessar memória virtual no WinDbg é coisa de criança, assim como em todo depurador decente. Se estamos falando de kernel mode então, nem se fala! A memória virtual é parte integrante do sistema operacional. Podemos saber mais sobre isso na apresentação do Strauss sobre gerenciamento de memória no Windows.
Porém, existem situações, como a que passei essa semana, onde é preciso saber e alterar o conteúdo da memória de verdade, mesmo. Quando eu falo &amp;quot;de verdade mesmo&amp;quot; estou falando em acessar a memória através do seu endereçamento real, que conta do zero até o final da sua memória RAM, sem divisão de processos e sem proteções de acesso.
Para isso é que serve um depurador de verdade, mesmo.
No modo real, onde vivem sistemas como o MS-DOS e programas como o Turbo C, a memória é acessada através do par de coordenadas conhecido como segmento e offset. Entre outros motivos, isso acontece porque em um determinado momento da história o 8086 possuía 16 bits em seus registradores, mas conseguia endereçar até 640 quilobytes, o que resulta em 640 vezes 1024, ou seja, 655366 bytes, um número dez vezes maior do que 65536 mil, ou 2 elevado a 16, o maior número representado por 16 bits.
Dessa forma, foi necessário o uso de mais 4 bits para fazer a coisa funcionar, pois como podemos notar logo abaixo, a representação do último byte de 640 KB exige isso:
10 16 16 16 16 decA 0 0 0 0 hex1010 0000 0000 0000 0000 bin Para conseguir esses 4 bits adicionais foram usados dois registradores em conjunto, o segmento e o offset. Funciona assim: o segmento é multiplicado por 16 (ou deslocado 4 bits à esquerda) e logo depois é somado com o offset, resultando no endereçamento desejado:
segment: 0x 9022offset: 0x 15140x 90220x 1514 (&#43;)real addr: 0x 91734 Ou seja, para acessar o byte de número 595764, ou 0x91734 podemos usar o segmento 0x9022 com o offset 0x1514. A soma desses dois com o segmento deslocado irá resultado no endereço flag, ou seja, aquele que obtemos se contarmos a memória do zero até o final da RAM. Importante lembrar que na época a RAM não costumava ser de valores como 2GB ou até 4GB, mas em KB mesmo. Isso explica a limitação do 8086 em endereçar até 640 KB.
Se nós repararmos bem, veremos que esse método implica em conseguirmos acessar o mesmo byte com um conjunto de segmentos e offsets diferentes, já que a soma pode ser resultado de operandos diversos. Esse é o chamado efeito de overlapping da memória segmentada, onde os programadores em assembly daquela época tinham que tomar alguns cuidados básicos para não atravessar a memória dos outros. No nosso exemplo acima, por exemplo, seria bem mais fácil chamar nosso bytezinho de segmento 0x9000, offset 0x1734.
0x 90000x 1734 (&#43;)0x 91734 É verdade! Então, o WinDbg possui alguns comandos extendidos e formas de representar essa memória real, atualmente limitada não mais em 640 KB, mas até onde seus pentes de RAM agüentarem. Os mais comuns são os que imitam os nossos conhecidos dumps de memória: db, dc, dd... Temos daí as extensões !db, !dc, !dd... (note a exclamação do início).
windbg -kllkd&amp;gt; !db 91734# 91734 00 (...) .....# 91744 00 (...) .....# 91754 00 (...) .....# 91764 00 (...) .....# 91774 00 (...) .....# 91784 00 (...) .....# 91794 00 (...) ..... Simples, assim. O sinal de # no início do dump de memória denota memória real.
Infelizmente, o WinDbg não nos permite ler certas regiões da memória por conta do cacheamento feito pelo processador. Para permitir a leitura em todas as condições, existem três flags que podem ser utilizados:
 c lê da memória cacheada uc lê da memória não-cacheada wc lê da memória de escrita combinada  Nesse caso é possível, embora fique por sua conta e risco, ler qualquer memória não-cacheada usando-se a flag uc.
É possível fazer mais brincadeiras usando os comandos comuns do WinDbg e uma notação diferente da memória. No entanto, é preciso tomar alguns cuidados quando mexer com isso. É recomendado o uso de uma máquina-vítima para esses testes, e não depuração local como estou fazendo.
 descrição example------------ ----------% 32, 64 bits %6400000&amp;amp; real 8086 &amp;amp;9000:1734# real 8086 #4C É isso aí. Não espero que você use muitas vezes essa forma de acessar memória. Só que eu usei e... nunca se sabe =)
</description>
</item>

     
        <item>
  <title>Guia básico de controle de código (Mercurial)</title>
  <link>http://www.caloni.com.br/guia-basico-de-controle-de-codigo-mercurial/</link>
  <pubDate>2008-04-15</pubDate>
  
  <guid>http://www.caloni.com.br/guia-basico-de-controle-de-codigo-mercurial/</guid>
  <description>Houve um bom motivo para que, semana passada, eu estivesse caçando inúmeras versões de um projeto desenvolvido fora da empresa: falta de controle de código. Esse tipo de lapso pode consumir de horas a dias de tempo perdido, dependendo de em quantas cópias de máquinas virtuais ficou espalhado o código.
Já escrevi a respeito da importância de controlar e gerenciar o código-fonte para que a falta de um histórico exato das alterações não seja motivo de recorreções de problemas, binários no cliente sem contraparte para ajustes, além de uma série de dores de cabeça que costumam começar a ocorrer assim que nos damos conta que nosso software está uma bagunça que dói.
Na época, discursei brevemente sobre alguns exemplos de gerenciadores de fonte que utilizam modelo centralizado, e nos exemplos práticos usamos o famigerado Source Safe, velho amigo de quem já programa ou programou Windows por alguns anos. Além dele, temos os conhecidíssimos CVS e Subversion, ambos largamente utilizados no mundo todo.
No entanto, uma nova forma de controlar fontes está nascendo já há algum tempo, com relativo sucesso e crescentes esperanças: o modelo distribuído. Nesse tipo de gerenciamento, a liberdade aumenta exponencialmente, permitindo coisas que no modelo antigo seriam muito difíceis de serem implementadas. Não vou me delongar explicando a teoria por trás da idéia, sabendo que, além de existir um ótimo texto explicando as vantagens em cima do modelo centralizado disponível na web, o próprio sítio das implementações atuais explica a idéia de maneira muito convincente. E são elas:
  Git. Conhecido como o controlador de fontes do kernel do Linux. Escrita a versão inicial por Linux Torvalds em C e módulos de Perl pendurados, hoje em dia tem como principal desvantagem a falta de suporte nos ambientes Windows, impactando negativamente em projetos portáveis. Sua principal vantagem, no entanto, é a rapidez: é o controle de fonte mais rápido do oeste.
  Mercurial (ou hg). Sem dúvida o mais fácil de usar. Bem documentado e com comandos intuitivos para o usuário, vem ganhando mais adeptos a cada dia. Seu desempenho é comparável ao do Git, e seu sistema de arquivos é bem eficiente.
  Bazaar (ou bzr). O irmão mais próximo do Mercurial, com comandos bem parecidos. Um costuma lembrar os comandos do outro, com pequenas diferenças. Seu desempenho não chega a ser comparável aos dois acima, mas sua robustez compensa, pois é o único, de acordo com testes e estudos, que suporta o controle total de operações de renomeação de arquivos e pastas. Recentemente seu projeto tem evoluído muito.
  Distribuído x Centralizado Nos sistemas centralizados o repositório de fontes fica em um lugar definido, de onde as pessoas pegam a última versão e sobem modificações, ou não, caso não tenham direito para isso.
Nos sistemas distribuídos, o histórico e ramificações ficam todos locais. Como assim locais? Bom, locais do jeito que eu estou falando quer dizer: na própria pasta onde se está desenvolvendo.
É lógico que pode existir uma versão de ramificações no servidor, que no caso do controle distribuído é mais um membro da rede peer-to-peer de ramificações, já que cada colaborador possui seu próprio repositório local, capaz de trocar revisões entre colaboradores e subir revisões os servidores que interessarem.
Além disso, o conceito de ramificações (branches) e consolidação de versões (merging) é muito mais presente do que em sistemas como o Subversion, onde o commit (ato de enviar as revisões de um código para o repositório central) ocorre de forma controlada. Da maneira distribuída, é comum criar um branch para cada problema ou feature sendo desenvolvida, e ir juntando tudo isso imediatamente após terminado, gerando um histórico bem mais detalhado e livre de gargalos com modificações temporárias.
Porém, a maior vantagem em termos de desenvolvimento acaba sendo a liberdade dos usuários, que podem trocar modificações de código entre si, sem existir a figura centralizadora do branch oficial. Ela pode existir, mas não é mais uma condição sine qua non para modificações no fonte.
Caso de uso: Mercurial Comecei a usar em meus projetos pessoais o Mercurial por ter ouvido falar dele primeiro. Achei a idéia fantástica, pois já estava à procura de um substituto para meu velho Source Safe, meio baleado das tantas inovações de controle de fonte que surgiram nos projetos de fonte aberto. Outro motivo para desistir do Source Safe foi o fato de ser uma solução comercial que custa dinheiro e não chega a ser absurdamente mais fácil de usar a ponto de valer a pena usá-lo.
O princípio de uso de uma ferramenta distribuída é muito simples: se você tiver um diretório de projeto já criado, basta, dentro dessa pasta, iniciar o repositório de fontes.
&amp;gt; hg init Após isso, será criada uma pasta com o nome .hg. Dentro dela é armazenado todo o histórico dos fontes. Podemos inicialmente adicionar os arquivos do projeto existente e fazer o primeiro commit, que irá começar a controlar os arquivos adicionados dentro dessa pasta e subpastas:
&amp;gt; hg addadding Header.hadding Main.cppadding Project.cppadding Project.vcproj&amp;gt; hg commit -m &amp;quot;Primeira versao&amp;quot; Se o programa não disse nada ao efetuar o commit, é porque está tudo certo. Agora podemos controlar as mudanças de nosso código usando o comando status. Para vermos o histórico usamos o comando log.
&amp;gt; hg logchangeset: 0:e9246bcf2107tag: tipuser: Wanderley Caloni &amp;lt;wanderley@caloni.com.br&amp;gt;date: Tue Apr 15 09:05:27 2008 -0300summary: Primeira versao&amp;gt; echo bla bla bla &amp;gt;&amp;gt; Main.cpp&amp;gt; hg statusM Main.cpp&amp;gt; hg commit -m &amp;quot;Alterado algumas coisas&amp;quot;&amp;gt; hg logchangeset: 1:829b081df653tag: tipuser: Wanderley Caloni &amp;lt;wanderley@caloni.com.br&amp;gt;date: Tue Apr 15 09:06:29 2008 -0300summary: Alterado algumas coisaschangeset: 0:e9246bcf2107user: Wanderley Caloni &amp;lt;wanderley@caloni.com.br&amp;gt;date: Tue Apr 15 09:05:27 2008 -0300summary: Primeira versao Como vimos, ao alterar um arquivo controlado este é mostrado pelo comando status como alterado (o M na frente do Main.cpp). Também existem controles para cópia e exclusão de arquivos.
Esse é o básico que se precisa saber para usar o Mercurial. Simples, não? O resto também é simples: fazer branches e juntá-los é uma questão de costume, e está entre as boas práticas de uso. Eu recomendo fortemente a leitura do tutorial &amp;quot;Entendendo o Mercurial&amp;quot;, disponível no sítio do projeto, até para entender o que existe por trás da idéia do controle descentralizado de fontes. Existe uma tradução muito boa feita pelo meu amigo Márcio.
Como usuário de Windows, posso dizer que a versão funciona muito bem, e é possível fazer coisas como, por exemplo, usar o WinMerge para juntar branches ou comparar versões automaticamente, o que por si só já mata toda a necessidade que eu tinha do Source Safe.
Mercurial ou Bazaar? Testei o Mercurial por cerca de três meses desde que o conheci. Esse fim-de-semana conheci mais a fundo o Bazaar, e pretendo começar a testá-lo também para ter uma visão dos dois mundos e optar por um deles. Ambos são projetos relativamente novos que prometem muito. De uma forma ou de outra, os programadores solitários agora possuem um sistema de controle de fontes sem frescura e que funciona para todos.
Para começar começando   Leia o tutorial passo-a-passo do Mercurial
  Leia o tutorial passo-a-passo do Bazaar
  Comece a usá-los em projetos simples e pequenos
  Comece a comparar seu uso ao do Subversion; identifique prós e contras
  Trace um roteiro de migração e mão à massa
  </description>
</item>

     
        <item>
  <title>Aprendendo assembly com o depurador</title>
  <link>http://www.caloni.com.br/aprendendo-assembly-com-o-depurador/</link>
  <pubDate>2008-04-11</pubDate>
  
  <guid>http://www.caloni.com.br/aprendendo-assembly-com-o-depurador/</guid>
  <description>Além de servir para corrigir alguns bugs escabrosos, o nosso bom e fiel amigo depurador também possui uma utilidade inusitada: ensinar assembly! A pessoa interessada em aprender alguns conceitos básicos da arquitetura do 8086 pode se exercitar na frente de um depurador 16 ou 32 bits sem ter medo de ser feliz.
Vamos ver alguns exemplos?
A pilha é você quem manda Para quem está começando, recomendo usar um depurador simples, 16 bits e que existe em todo e qualquer Windows: o debug. Já usado para depurar a MBR no Caloni.com.br, poderá agora ser usado para ensinar alguns princípios da plataforma de uma maneira indolor. Basta iniciá-lo na linha de comando:
debug- Os comandos mais úteis são o r (ver ou alterar registradores), o t/p (executar passo-a-passo), o d (exibir memória), o u (desmontar assembly) e o a (montar assembly). Ah, não se esquecendo do ? (ajuda).
Outro ensinamento bem interessante diz respeito à pilha. Aprendemos sempre que a pilha cresce de cima pra baixo, ou seja, de endereços superiores para valores mais baixos. Também vimos que os registradores responsáveis por controlar a memória da pilha são o sp (stack pointer) e o ss (stack segment). Pois bem. Vamos fazer alguns testes para ver isso acontecer.
-rAX=0000 BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000DS=0CF9 ES=0CF9 SS=0CF9 CS=0CF9 IP=0100 NV UP EI PL NZ NA PO NC0CF9:0100 69 DB 69-r ssSS &amp;lt;font color=&amp;quot;#000000&amp;quot;&amp;gt;0CF9&amp;lt;/font&amp;gt;:&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;9000&amp;lt;/font&amp;gt;-r spSP FFEE:&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;ffff&amp;lt;/font&amp;gt;-rAX=0000 BX=0000 CX=0000 DX=0000 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;SP=FFFF&amp;lt;/font&amp;gt; BP=0000 SI=0000 DI=0000DS=0CF9 ES=0CF9 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;SS=9000&amp;lt;/font&amp;gt; CS=0CF9 IP=0100 NV UP EI PL NZ NA PO NC0CF9:0100 69 DB 69-a0CF9:0100 mov ax, 12340CF9:0103 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;push ax&amp;lt;/font&amp;gt;0CF9:0104 inc ax0CF9:0105 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;push ax&amp;lt;/font&amp;gt;0CF9:0106 inc ax0CF9:0107 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;push ax&amp;lt;/font&amp;gt;0CF9:0108-u0CF9:0100 B83412 MOV AX,12340CF9:0103 50 PUSH AX0CF9:0104 40 INC AX0CF9:0105 50 PUSH AX0CF9:0106 40 INC AX0CF9:0107 50 PUSH AX0CF9:0108 6C DB 6C...AX=1234 BX=0000 CX=0000 DX=0000 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;SP=FFFF&amp;lt;/font&amp;gt; BP=0000 SI=0000 DI=0000DS=0CF9 ES=0CF9 SS=9000 CS=0CF9 IP=0103 NV UP EI PL NZ NA PO NC0CF9:0103 50 PUSH AX-tAX=1234 BX=0000 CX=0000 DX=0000 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;SP=FFFD&amp;lt;/font&amp;gt; BP=0000 SI=0000 DI=0000DS=0CF9 ES=0CF9 SS=9000 CS=0CF9 IP=0104 NV UP EI PL NZ NA PO NC0CF9:0104 40 INC AX-tAX=1235 BX=0000 CX=0000 DX=0000 &amp;lt;font color=&amp;quot;#000000&amp;quot;&amp;gt;SP=FFFD&amp;lt;/font&amp;gt; BP=0000 SI=0000 DI=0000DS=0CF9 ES=0CF9 SS=9000 CS=0CF9 IP=0105 NV UP EI PL NZ NA PE NC0CF9:0105 50 PUSH AX-tAX=1235 BX=0000 CX=0000 DX=0000 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;SP=FFFB&amp;lt;/font&amp;gt; BP=0000 SI=0000 DI=0000DS=0CF9 ES=0CF9 SS=9000 CS=0CF9 IP=0106 NV UP EI PL NZ NA PE NC0CF9:0106 40 INC AX-tAX=1236 BX=0000 CX=0000 DX=0000 SP=FFFB BP=0000 SI=0000 DI=0000DS=0CF9 ES=0CF9 SS=9000 CS=0CF9 IP=0107 NV UP EI PL NZ NA PE NC0CF9:0107 50 PUSH AX-tAX=1236 BX=0000 CX=0000 DX=0000 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;SP=FFF9&amp;lt;/font&amp;gt; BP=0000 SI=0000 DI=0000DS=0CF9 ES=0CF9 SS=9000 CS=0CF9 IP=0108 NV UP EI PL NZ NA PE NC0CF9:0108 6C DB 6C-d 9000:fff99000:FFF0 &amp;lt;font color=&amp;quot;#ff9900&amp;quot;&amp;gt;36 12&amp;lt;/font&amp;gt; &amp;lt;font color=&amp;quot;#339966&amp;quot;&amp;gt;35 12&amp;lt;/font&amp;gt; &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;34 12&amp;lt;/font&amp;gt; 00 6.5.4..- Como vemos, ao empilhar coisas na pilha, o valor do registrador sp diminui. E ao fazermos um dump do valor de sp conseguimos ver os valores empilhados anteriormente. Isso é muito útil na hora de depurarmos chamadas de funções. Por exemplo, no velho teste do Windbg x Bloco de notas:
windbg notepad0:000&amp;gt; bp user32!&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;MessageBoxW&amp;lt;/font&amp;gt;0:000&amp;gt; gModLoad: 5cfd0000 5cff6000 C:\WINDOWS\system32\ShimEng.dllModLoad: 596f0000 598ba000 C:\WINDOWS\AppPatch\AcGenral.DLLModLoad: 76b20000 76b4e000 C:\WINDOWS\system32\WINMM.dllModLoad: 774c0000 775fd000 C:\WINDOWS\system32\ole32.dll...ModLoad: 10000000 10030000 C:\Arquivos de programas\Babylon\Babylon-Pro\CAPTLIB.DLLModLoad: 74c40000 74c6c000 C:\WINDOWS\system32\OLEACC.dllModLoad: 76050000 760b5000 C:\WINDOWS\system32\MSVCP60.dllBreakpoint 0 hiteax=00000001 ebx=00000000 ecx=000a7884 edx=00000000 esi=000b2850 edi=0000000aeip=7e3b630a esp=0007f6d8 ebp=0007f6f4 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202USER32!&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;MessageBoxW&amp;lt;/font&amp;gt;:7e3b630a 8bff mov edi,edi0:000&amp;gt; dd esp L50007f6d8 01001fc4 00010226 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;000b2850&amp;lt;/font&amp;gt; 000a7ac2 ; ret handle &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;message&amp;lt;/font&amp;gt; caption0007f6e8 00000033 ; mb_ok0:000&amp;gt; du &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;000b2850&amp;lt;/font&amp;gt;000b2850 &amp;quot;O texto do arquivo Sem título fo&amp;quot;000b2890 &amp;quot;i alterado...Deseja salvar as al&amp;quot;000b28d0 &amp;quot;terações?&amp;quot;0:000&amp;gt; ezu 000b2850 &amp;quot;Tem certeza que deseja salvar esse artigo de merda?&amp;quot;0:000&amp;gt; gModLoad: 75f50000 7604d000 C:\WINDOWS\system32\BROWSEUI.dll 
Aposto que você sabe em qual dos três botões eu cliquei =)
Outros linques para aprender a depurar seus programas (e os dos outros) Depurar é um processo que exige dedicação (experiência) tanto ou mais do que o próprio desenvolvimento. Por isso, fazer um esforço para descobrir algum problema em algum software pode ser vantajoso no futuro, pois você terá mais capacidade de entender o que está acontecendo à sua volta.
Básico a intermediário:
  Guia básico para programadores de primeiro breakpoint
  Brincando com o WinDbg
  Encontrando as respostas do Flash Pops
  Intermediário a avançado:
  Hook de API no WinDbg
  Hook de COM no WinDbg
  Detectando hooks globais no WinDbg
  Analisando dumps com WinDbg e IDA
  Blogues que eu acho superinteressantes sobre debugging (do mais essencial para o mais avançado):
  Debugging Toolbox
  Mark&#39;s Blog
  Advanced Windows Debugging
  Crash Dump Analysis
  </description>
</item>

     
        <item>
  <title>Conversor de Houaiss para Babylon - parte 2</title>
  <link>http://www.caloni.com.br/conversor-de-houaiss-para-babylon-parte-2/</link>
  <pubDate>2008-04-08</pubDate>
  
  <guid>http://www.caloni.com.br/conversor-de-houaiss-para-babylon-parte-2/</guid>
  <description>Após algumas semanas de suspense, chegamos finalmente à nossa segunda e última parte da saga do dicionário Houaiss.
Como devem estar lembrados, a primeira parte se dispôs a desmontar a ofuscação usada nos arquivos do dicionário para permitir nossa posterior análise, com o simples e justo objetivo de importá-lo para o Babylon, cujas funcionalidades de busca são bem superiores.
Feito isso, agora nos resta entender a estrutura interna do Houaiss para montar um conversor que irá ajudar o Babylon Builder a construir nosso Houaiss-Babylon. Simples, não?
A primeira parte de toda análise é a busca por padrões com um pouco de bom senso. O Houaiss armazena suas definições em um conjunto de arquivos de nome deahNNN.dhx (provavelmente deah de Dicionario Eletrônico Antônio Houaiss). Os NNN variam de 001 - o maior arquivo - até 065, com algumas poucas lacunas, em um total de 53 arquivos originais.
O nosso rústico importador fez o trabalho de desofuscar todos os 53 arquivos usando a mesma lógica encontrada pelo WinDbg: somar o valor 0x0B para cada byte do arquivo. Dessa forma foram gerados 53 arquivos novos no mesmo diretório, porém com a extensão TXT.
Partindo do bom senso, abriremos o arquivo maior, deah001.txt, e abriremos o próprio dicionário Houaiss, em busca de um padrão que faça sentido. Como poderemos ver na figura abaixo, o padrão inicial não é nem um pouco complicado.

As duas primeiras observações do formato do arquivo nos dizem que (1) o primeiro caractere de cada linha indica o conteúdo dessa linha, e que (2) a formatação dos caracteres é feita dentro de um par de chaves {}.
Dessa forma, podemos começar a construir nosso interpretador de arquivos do Houaiss em seu formato básico.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;int main(){char cmd; // comando da linha atualmente lida	string line; // linha atualmente lida	int count = 0; // contador de palavraswhile( getline(cin, line) ){cmd = line[0]; // guardamos o comando	line.erase(0, 1); // tiramos o comando da linha	format(line); // formatação da linha (explicações adiante)switch( cmd ) // que comando é esse?	{case &amp;#39;*&amp;#39;: // verbete	&#43;&#43;count;cout &amp;lt;&amp;lt; &amp;#39;\n&amp;#39; &amp;lt;&amp;lt; line &amp;lt;&amp;lt; &amp;#39;\n&amp;#39;;break;case &amp;#39;:&amp;#39;: // definição	cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; &amp;#34;&amp;lt;br&amp;gt;\n&amp;#34;;break;}}return 0;}Simples e funcional. Com esse código já é possível extrair o básico que precisamos de um dicionário: os vocábulos e suas definições.
Para conseguir mais, é necessário mais trabalho.
Formatação A formatação segue o estilo já identificado, de forma que podemos aos poucos montar um interpretador de formatação para HTML, que é o formato reconhecido pelo Babylon Builder. Podemos seguir o seguinte molde, chamado no exemplo de código anterior:
void format(string&amp;amp; str){string::size_type pos1 = 0;string::size_type pos2 = 0;while( (pos1 = str.find(&amp;#39;&amp;lt;&amp;#39;)) != string::npos )str.replace(pos1, 1, &amp;#34;&amp;lt;&amp;#34;);while( (pos1 = str.find(&amp;#39;&amp;gt;&amp;#39;)) != string::npos )str.replace(pos1, 1, &amp;#34;&amp;gt;&amp;#34;);while( (pos1 = str.find(&amp;#39;{&amp;#39;)) != string::npos ){if( pos1 &amp;amp;&amp;amp; str[pos1 - 1] == &amp;#39;\\&amp;#39; ) // caractere de escape	str.replace(pos1 - 1, 2, &amp;#34;{&amp;#34;);else{string subStr;pos2 = str.find(&amp;#39;}&amp;#39;, pos1);if( pos2 != string::npos )subStr = str.substr(pos1 &#43; 1, pos2 - pos1 - 1);elsesubStr = str.substr(pos1 &#43; 1);istringstream is(subStr);string fmt;string word;is &amp;gt;&amp;gt; fmt;getline(is, word);if( word[0] == &amp;#39; &amp;#39; )word.erase(0, 1);if( fmt.find(&amp;#34;\\i&amp;#34;) != string::npos )word = &amp;#34;&amp;lt;i&amp;gt;&amp;#34; &#43; word &#43; &amp;#34;&amp;lt;/i&amp;gt;&amp;#34;;if( fmt.find(&amp;#34;\\b&amp;#34;) != string::npos )word = &amp;#34;&amp;lt;b&amp;gt;&amp;#34; &#43; word &#43; &amp;#34;&amp;lt;/b&amp;gt;&amp;#34;;if( fmt.find(&amp;#34;\\f20&amp;#34;) != string::npos )word = &amp;#34;&amp;lt;font style=\&amp;#34;text-transform: uppercase;\&amp;#34;&amp;gt;&amp;#34; &#43; word &#43; &amp;#34;&amp;lt;/font&amp;gt;&amp;#34;;if( fmt.find(&amp;#34;\\super&amp;#34;) != string::npos )word = &amp;#34;&amp;lt;font style=\&amp;#34;vertical-align: super;\&amp;#34;&amp;gt;&amp;#34; &#43; word &#43; &amp;#34;&amp;lt;/font&amp;gt;&amp;#34;;if( pos2 != string::npos )str.replace(pos1, pos2 - pos1 &#43; 1, word);elsestr.replace(pos1, pos2, word);}}}Algumas partes ainda estão feias, eu sei. Mas, ei, isso é um código de ráquer, não é mesmo? Além do mais, se isso não é desculpa suficiente, estamos trabalhando em uma versão beta.
A partir dessas duas funções é possível dissecar o primeiro arquivo do dicionário, e assim, construirmos a primeira versão interessante do Houaiss no Babylon.
Como é normal a qualquer dicionário do Babylon, podemos instalá-lo simplesmente clicando duas vezes no arquivo (em uma máquina com Babylon previamente instalado).

O projeto atual está um tanto capenga, mas já desencripta os arquivos do Houaiss e gera o projeto do Babylon Builder sozinho. Em anexo já está um projeto do Babylon Builder. Basta copiar o arquivo Houaiss.txt para a pasta do projeto e gerar o projeto do Babylon.
Para os interessados em incrementar a versão atual, sintam-se à vontade.
</description>
</item>

     
        <item>
  <title>Try-catch flutuante</title>
  <link>http://www.caloni.com.br/try-catch-flutuante/</link>
  <pubDate>2008-04-03</pubDate>
  
  <guid>http://www.caloni.com.br/try-catch-flutuante/</guid>
  <description>Esse detalhe da linguagem quem me fez descobrir foi o Yorick, que costuma comentar no blogue e tive o prazer de conhecer no 4o. EPA-CCPP.
É possível, apesar de bizarro, colocar um bloco try-catch em torno da lista de inicialização de variáveis de um construtor. Essa característica da linguagem permite que possamos capturar alguma exceção lançada por algum construtor de algum membro da classe. A construção em código ficaria no estilo abaixo:
Class::Class() try : initialization-list{// Class constructor body}catch(...) // note: this IS right!{// do something about// just like &amp;quot;throw&amp;quot; over here} Apesar dessa capacidade, não conseguimos parar o lançamento da exceção. Após seu lançamento, caímos no bloco catch abaixo do corpo do construtor e a exceção é lançada novamente, como se houvesse uma intrução throw no final do catch.
O exemplo abaixo demonstra um código de uma classe que captura a exceção durante a inicialização dos membros. Na seguida o catch da função main é executada, provando que a exceção de fato não é &amp;quot;salva&amp;quot; no primeiro bloco.
#include &amp;lt;iostream&amp;gt;/* This class explodes */class Explode{public:Explode(int x) {m_x = x;throw x;}void print(){std::cout &amp;lt;&amp;lt; &amp;#34;The number: &amp;#34; &amp;lt;&amp;lt; m_x &amp;lt;&amp;lt; std::endl;}private:int m_x;};/* This class is going to be exploded */class Victim{public:Victim() try : m_explode(5){std::cout &amp;lt;&amp;lt; &amp;#34;You&amp;#39;re supposed to NOT seeing this...\n&amp;#34;;}catch(...) { std::cerr &amp;lt;&amp;lt; &amp;#34;Something BAD hapenned\n&amp;#34;;std::cerr &amp;lt;&amp;lt; &amp;#34;We&amp;#39;re going to blow up\n&amp;#34;;// just like &amp;#39;throw&amp;#39; over here	}void print(){m_explode.print();}private:Explode m_explode;};int main(){try{Victim vic;}catch(...){std::cerr &amp;lt;&amp;lt; &amp;#34;Something BAD BAD happenned...\n&amp;#34;;}}Testei esse código nos seguintes compiladores:
  Visual Studio 6. Falhou, demonstrando desconhecer a sintaxe.
  Borland C&#43;&#43; Builder 5. Falhou, demonstrando desconhecer a sintaxe.
  Borland Developer Studio 4. Falhou, com o mesmo erro.
  Visual Studio 2003. Comportamento esperado.
  Visual Studio 2005. Comportamento esperado.
  Visual Studio 2008. Comportamento esperado.
  G&#43;&#43; (no Cygwin). Comportamento esperado.
  A saída esperada é a seguinte:
Something BAD hapennedWe&#39;re going to blow upSomething BAD BAD happenned... </description>
</item>

     
        <item>
  <title>Depuração da MBR</title>
  <link>http://www.caloni.com.br/depuracao-da-mbr/</link>
  <pubDate>2008-03-24</pubDate>
  
  <guid>http://www.caloni.com.br/depuracao-da-mbr/</guid>
  <description>Dando continuidade a um artigo beeeem antigo sobre depuração da BIOS usando SoftIce, como já vimos, podemos igualmente depurar a MBR após a chamada da INT13. Porém, devo atentar para o fato que, em algumas VMs, e sob determinadas condições do tempo e quantidade de ectoplasma na atmosfera, é possível que a máquina trave após o hot boot iniciado pelo depurador. Isso provavelmente tem cura usando o espaço de endereçamento alto da memória com a ajuda de aplicativos como LH e UMB.
Porém, estou aqui para contar uma nova forma de depurar essa partezinha do código que pode se tornar um tormento se você só se basear em tracing na tela (ou na COM1): usando o aplicativo debug do DOS.
Debug.(exe|com) O debug é um programa extremamente antigo, criado antes mesmo do MS-DOS pertencer à Microsoft e do Windows Vista ter sido criado. Como todo sistema operacional, é essencial que exista um programa para verificar problemas em outros programas. Essa foi a &amp;quot;motivação&amp;quot; para a criação do Debug.
Com o passar do tempo e com a evolução dos depuradores modernos, o uso do debug foi diminuindo até a chegada dos 32 bits, quando daí ele parou de vez de ser usado. Com um conjunto limitado de instruções, a versão MS é incapaz de decodificar o assembly de 32 bits, mostrar os registradores extendidos e de depurar em modo protegido.
O FreeDOS é um projeto de fonte aberto que procura criar uma réplica do sistema MS-DOS, com todos seus aplicativos (e um pouco mais). Entre eles, podemos encontrar o Debug refeito e melhorado. A versão com código-fonte possui suporte às instruções &amp;quot;novas&amp;quot; dos processadores 32 e suporta acesso à memória extendida, modo protegido e melhorias na &amp;quot;interface com o usuário&amp;quot; (como repetição de comandos automática, mudança no valor dos registradores em uma linha, etc). Enfim, nada mau.
É por isso que comecei a utilizá-lo e é nele que me baseio o tutorial logo abaixo.
Como depurar a MBR (finalmente!) Para conseguirmos essa proeza é necessário reiniciarmos a máquina com algum sistema 16 bits, de preferência que caiba em um disquete. Junto com ele basta uma cópia do debug.com. Após reiniciarmos e aparecer o prompt de comando, podemos chamar o depurador e começar a diversão:
A MBR fica localizada no primeiro setor do HD ativo (master). A BIOS automaticamente procura esse HD e faz a leitura usando a INT13, função da própria BIOS para leitura de disquetes e derivados.
Lembre-se que nem sempre existirá um MS-DOS para usarmos a INT21, tradicionalmente reservada para este sistema operacional. Portanto, se acostume com as &amp;quot;limitações&amp;quot; das funções básicas da BIOS.
O debug.com inicialmente começa a execução em um espaço de memória baixa. Podemos escrever um assembly qualquer nessa memória e começar a executar. Isso é exatamente o que iremos fazer, e a instrução escolhida será a INT13, pois iremos ler o primeiro setor do HD para a memória e começar a executá-lo. Isso é a depuração da MBR.
Para fazer isso, algumas informações são necessárias, e tudo está disponível no sítio muito simpático e agradável de Ralf Brown, o cara que enumerou todas as interrupções conhecidas, além de diversas outras coisas.
Como queremos ler um setor do disco, a função da interrupção que devemos chamar é a AH=02:
DISK - READ SECTOR(S) INTO MEMORY AH = 02hAL = number of sectors to read (must be nonzero)CH = low eight bits of cylinder numberCL = sector number 1-63 (bits 0-5)high two bits of cylinder (bits 6-7, hard disk only)DH = head numberDL = drive number (bit 7 set for hard disk)ES:BX -&amp;gt; data buffer Muito bem. Tudo que temos a fazer é preencher os registradores com os valores corretos:
rax 0201 ; função e número de setores (1)rcx 0001 ; número do cilindro e do setor (cilindro = 0, setor = 1)rdx 0080 ; número da cabeça (0) e do drive (HD = 0, o bit 7 deve estar levantado)res 0000 ; segmento em que é executada a MBRrbx 7e00 ; offset em que é executada a MBR Por que a MBR deve ser executada em 000:7E00? Essa é a maneira em que as coisas são. Você certamente poderia usar outro endereço, mas estamos tentando deixar a emulação de um _boot _o mais próximo possível de um _boot _de verdade. E, tradicionalmente, o endereço de execução da MBR é em 0000:7E00. Para recordar disso, basta lembrar que o tamanho de um setor é de 0x200 bytes, e que dessa forma a MBR vai parar bem no final do endereçamento baixo (apenas offset).
Essa organização é diferente do endereço inicial da BIOS, que é por padrão 0xFFFF0.
Após definir corretamente os registradores, tudo que temos que fazer é escrever uma chamada à INT13 no endereço atual e executar. O conteúdo inicial do disco será escrito no endereço de memória 0000:7E00. Após isso trocamos o IP atual para esse endereço e começamos a depurar a MBR, como se estivéssemos logo após o boot da máquina.
Depurando a BIOS Além da MBR, muitas vezes é preciso depurar a própria BIOS para descobrir o que está acontecendo. Nesse caso, tudo que precisamos fazer é colocar o ponteiro de próxima instrução para a região de memória 0xFFFF0, que traduzido para segmento/offset fica f000:fff0 (mais explicações sobre isso talvez em um futuro artigo).
-rcs f000-rip fff0-t </description>
</item>

     
        <item>
  <title>O mistério das pilhas diferentes</title>
  <link>http://www.caloni.com.br/o-misterio-das-pilhas-diferentes/</link>
  <pubDate>2008-03-12</pubDate>
  
  <guid>http://www.caloni.com.br/o-misterio-das-pilhas-diferentes/</guid>
  <description>Mal comecei a leitura do meu mais novo &amp;quot;mother-fucker&amp;quot; livro e já encontrei a solução para nunca mais viver o terror que vivi quando tive que testar minha engenharia reversa do artigo sobre o Houaiss. Se trata de uma simples questão que não sei por que não sigo todas as vezes religiosamente: configure seus símbolos corretamente.
Esse é o primeiro ponto abordado pelo autor, por se tratar de algo que, caso não seja bem feito, pode dar dores de cabeça piores do que o próprio problema que originou a sessão de debugging. Por isso eu repito:
Configure Seus Símbolos Corretamente
Vamos acompanhar alguns momentos de tortura alheia?
Era uma vez Tudo aconteceu quando inesperadamente perdi metade do artigo que estava escrevendo para explicar o processo de engenharia reversa no dicionário Houaiss. Tive que refazer todos os meus testes que havia feito no laptop. Como a preguiça é a mãe de todas as descobertas, não estava com ele ligado no momento do &amp;quot;reteste&amp;quot; e por isso acabei usando a máquina desktop, mesmo.
A análise inicial consistia simplesmente em verificar as entradas e saídas da função ReadFile, na esperança de entender a formatação interna do dicionário. Repetindo a seqüência:
windbg -pn houaiss2.exe0:001&amp;gt; bp kernel32!ReadFile &amp;quot;dd @$csp L6&amp;quot; $$ Dando uma olhada nos parâmetrosg0012fa70 0040a7a9 00000200 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;08bbf1d0 00000200&amp;lt;/font&amp;gt;0012fa80 0012fa88 00000000eax=0012fa88 ebx=00000200 ecx=00000200 edx=08bbf1d0 esi=08bbf1d0 edi=00000200eip=7c80180e esp=0012fa70 ebp=0012facc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246kernel32!ReadFile:7c80180e 6a20 push 20h$$ O buffer de saída é &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;08bbf1d0 &amp;lt;/font&amp;gt;$$ O número de bytes lidos é &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;200&amp;lt;/font&amp;gt;0:000&amp;gt; db 08bbf1d0 L8008bbf1d0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf1e0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf1f0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf200 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf210 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf220 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf230 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf240 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................0:000&amp;gt; bp /1 @$ra &amp;quot;db 08bbf1d0 L80&amp;quot;0:000&amp;gt; g08bbf1d0 2a 70 72 6f 67 72 61 6d-61 2d 66 6f 6e 74 65 0d &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;*programa-fonte.&amp;lt;/font&amp;gt;08bbf1e0 0a 43 73 2e 6d 2e 0d 0a-64 7b 5c 69 20 73 58 58 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;.Cs.m...d{\i sXX&amp;lt;/font&amp;gt;08bbf1f0 7d 0d 0a 54 69 6e 66 0d-0a 3a 70 72 6f 67 72 61 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;}..Tinf..:progra&amp;lt;/font&amp;gt;08bbf200 6d 61 20 64 65 20 63 6f-6d 70 75 74 61 64 6f 72 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;ma de computador&amp;lt;/font&amp;gt;08bbf210 20 65 6d 20 73 75 61 20-66 6f 72 6d 61 20 6f 72 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt; em sua forma or&amp;lt;/font&amp;gt;08bbf220 69 67 69 6e 61 6c 2c 20-61 6e 6f 74 61 64 6f 20 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;iginal, anotado&amp;lt;/font&amp;gt;08bbf230 70 65 6c 6f 20 70 72 6f-67 72 61 6d 61 64 6f 72 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;pelo programador&amp;lt;/font&amp;gt;08bbf240 20 65 6d 20 75 6d 61 20-6c 69 6e 67 75 61 67 65 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt; em uma linguage&amp;lt;/font&amp;gt;0:000&amp;gt; $$0:000&amp;gt; $$ Tudo legível? Mas já? Ai, meu Deus, alguém chama uma benzedeira!0:000&amp;gt; $$ Se notarmos no artigo anterior, veremos que o conteúdo do arquivo lido não é em texto claro, sendo necessário passar por mais algumas instruções assembly para descobrir a função responsável por embaralhar o conteúdo na memória. Contudo, ao rodar esses comandos novamente, eis que a saída do ReadFile já vem toda legível, como se o dicionário não estivesse mais encriptado.
A leitura foi feita e o texto direto do arquivo veio em claro? O que está acontecendo? Quando abro pelo comando type ele aparece todo obscuro...

Sim, alguma coisa não-trivial acaba de acontecer. Testei esse procedimento no laptop e no desktop, sendo que esse problema aconteceu apenas no desktop. Dessa vez a curiosidade falou mais alto que a preguiça, e tive que abrir as duas máquinas e comparar os resultados.
Rastreando o problema do endereço de retorno diferente Depois de um pouco de cabeçadas rastreando o assembly executado, descobri que o ponto onde o breakpoint havia parado não era o retorno da chamada a ReadFile. Isso eu não vou demonstrar aqui pois se trata de raciocínio de passo-a-passo no assembly até descobrir a diferença. É enfadonho e sujeito a erros. Sugiro que tente um dia desses. Para mim, o resultado lógico de tudo isso é a saída que segue:
0012fa70 0040a7a9 00000200 &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;08bbf1d0 00000200&amp;lt;/font&amp;gt;0012fa80 0012fa88 00000000eax=0012fa88 ebx=00000200 ecx=00000200 edx=08bbf1d0 esi=08bbf1d0 edi=00000200eip=7c80180e esp=0012fa70 ebp=0012facc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246kernel32!ReadFile:7c80180e 6a20 push 20h0:000&amp;gt; ? &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;poi(esp)&amp;lt;/font&amp;gt;Evaluate expression: 4237225 = &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;0040a7a9&amp;lt;/font&amp;gt;0:000&amp;gt; ? &amp;lt;font color=&amp;quot;#ff6600&amp;quot;&amp;gt;@$ra&amp;lt;/font&amp;gt;Evaluate expression: 4959640 = &amp;lt;font color=&amp;quot;#ff6600&amp;quot;&amp;gt;004bad98&amp;lt;/font&amp;gt;0:000&amp;gt; ? &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;poi(@$csp)&amp;lt;/font&amp;gt;Evaluate expression: 4237225 = &amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;0040a7a9 &amp;lt;/font&amp;gt; Como podemos ver pelos comandos acima, o pseudo-registrador $ra não está mostrando o valor corretamente!
Primeiro passo lógico: o seu é o mesmo que o meu? A primeira coisa que se faz numa hora dessas é comparar as versões dos componentes do depurador de ambos os ambientes. Para isso usamos o comando version.
0:000&amp;gt; version &amp;lt;font color=&amp;quot;#ff6600&amp;quot;&amp;gt;$$ desktop&amp;lt;/font&amp;gt;Windows XP Version 2600 (Service Pack 2) UP Free x86 compatibleProduct: WinNt, suite: SingleUserTSkernel32.dll version:Debug session time: Tue Feb 26 19:51:58.295 2008 (GMT-3)System Uptime: 0 days 1:14:07.857Process Uptime: 0 days 0:31:52.840Kernel time: 0 days 0:00:01.482User time: 0 days 0:00:02.723Live user mode: &amp;lt;Local&amp;gt;command line: &#39;&amp;quot;C:\Tools\DbgTools\windbg.exe&amp;quot; -pn houaiss2.exe&#39; Debugger Process 0xEC4dbgeng: image &amp;lt;font color=&amp;quot;#ff6600&amp;quot;&amp;gt;6.6.0007.5&amp;lt;/font&amp;gt;, built Sat Jul 08 17:12:40 2006[path: C:\Tools\DbgTools\dbgeng.dll]dbghelp: image &amp;lt;font color=&amp;quot;#ff6600&amp;quot;&amp;gt;6.6.0007.5&amp;lt;/font&amp;gt;, built Sat Jul 08 17:11:32 2006[path: C:\Tools\DbgTools\dbghelp.dll]DIA version: 60516Extension DLL search Path:C:\Tools\DbgTools\winext;C:\Tools\DbgTools\winext\arcade;(...)Extension DLL chain:dbghelp: image 6.6.0007.5, API 6.0.6, built Sat Jul 08 17:11:32 2006[path: C:\Tools\DbgTools\dbghelp.dll]ext: image 6.6.0007.5, API 1.0.0, built Sat Jul 08 17:10:52 2006[path: C:\Tools\DbgTools\winext\ext.dll]exts: image 6.6.0007.5, API 1.0.0, built Sat Jul 08 17:10:48 2006[path: C:\Tools\DbgTools\WINXP\exts.dll]uext: image 6.6.0007.5, API 1.0.0, built Sat Jul 08 17:11:02 2006[path: C:\Tools\DbgTools\winext\uext.dll]ntsdexts: image 6.0.5457.0, API 1.0.0, built Sat Jul 08 17:29:38 2006[path: C:\Tools\DbgTools\WINXP\ntsdexts.dll]0:000&amp;gt; version &amp;lt;font color=&amp;quot;#ff6600&amp;quot;&amp;gt;$$ laptop&amp;lt;/font&amp;gt;Windows XP Version 2600 (Service Pack 2) UP Free x86 compatibleProduct: WinNt, suite: SingleUserTS Personalkernel32.dll version:Debug session time: Tue Feb 26 20:54:39.718 2008 (GMT-3)System Uptime: 9 days 10:26:39.289Process Uptime: 0 days 0:00:56.359Kernel time: 0 days 0:00:00.406User time: 0 days 0:00:01.078Live user mode: &amp;lt;Local&amp;gt;command line: &#39;&amp;quot;C:\Tools\DbgTools\windbg.exe&amp;quot; -pn houaiss2.exe&#39; Debugger Process 0x864dbgeng: image &amp;lt;font color=&amp;quot;#ff6600&amp;quot;&amp;gt;6.8.0004.0&amp;lt;/font&amp;gt;, built Thu Sep 27 18:28:09 2007[path: C:\Tools\DbgTools\dbgeng.dll]dbghelp: image &amp;lt;font color=&amp;quot;#ff6600&amp;quot;&amp;gt;6.8.0004.0&amp;lt;/font&amp;gt;, built Thu Sep 27 18:27:05 2007[path: C:\Tools\DbgTools\dbghelp.dll]DIA version: 20119Extension DLL search Path:C:\Tools\DbgTools\WINXP;C:\Tools\DbgTools\winext;C:\(...)Extension DLL chain:dbghelp: image 6.8.0004.0, API 7.0.6, built Thu Sep 27 18:27:05 2007[path: C:\Tools\DbgTools\dbghelp.dll]ext: image 6.8.0004.0, API 1.0.0, built Thu Sep 27 18:26:59 2007[path: C:\Tools\DbgTools\winext\ext.dll]exts: image 6.8.0004.0, API 1.0.0, built Thu Sep 27 18:26:28 2007[path: C:\Tools\DbgTools\WINXP\exts.dll]uext: image 6.8.0004.0, API 1.0.0, built Thu Sep 27 18:26:45 2007[path: C:\Tools\DbgTools\winext\uext.dll]ntsdexts: image 7.0.6440.1, API 1.0.0, built Thu Sep 27 18:45:23 2007[path: C:\Tools\DbgTools\WINXP\ntsdexts.dll] OK. A versão instalada no desktop é bem antiga. Pode ser um indício. Fiz então a atualização e comparei novamente a saída de version.
Tudo igual.
Segundo passo lógico: prove ou refute seu raciocínio Decidi então usar aquela lógica cética que é desenvolvida por quem costuma depurar coisas sinistras e esotéricas por anos e anos e não duvida de mais nada, mas também acredita piamente que tudo tem um motivo. Se não está aparente, basta descobri-lo. E foi o que eu fiz. Gerei dois _dumps _distintos, um no laptop e outro no desktop. Ambos estavam com os ponteiros de instrução apontados exatamente para a entrada da função ReadFile, início de todo esse problema. Copiei o dump do desktop para o laptop e vice-versa.

Abri o dump do desktop no laptop: tudo funcionando. Abri o dump do _laptop _no desktop: mesmo erro.
Conclusão óbvia: é algo relacionado com o WinDbg no desktop, uma vez que o estado da pilha que era mostrado corretamente no _laptop _em ambos os dumps falhava duplamente na máquina desktop.
Próxima tentativa intuitiva: verificar o _path _dos símbolos: .sympathSymbol search path is: &amp;lt;empty&amp;gt; Isso com certeza não cheira bem. Ainda mais porque do outro lado do hemisfério, meu laptop estava configurado com toda a rigidez que um laptop de WinDbgeiro deve ter:
0:000&amp;gt; .sympathSymbol search path is: SRV*C:\Symbols*http://msdl.microsoft.com/download/symbols E aí estava uma diferença plausível. Consertados os diretórios de símbolos, tudo voltou ao normal.
Moral da história Procure primeiro verificar as coisas mais simples. Depois você tenta consertar o universo. Mas, primeiro, antes de tudo, veja se o cabo de rede está conectado. Ou no nosso cado de debugueiro:
Configure Seus Símbolos Corretamente
</description>
</item>

     
        <item>
  <title>Quando o ponteiro nulo não é inválido</title>
  <link>http://www.caloni.com.br/quando-o-ponteiro-nulo-nao-e-invalido/</link>
  <pubDate>2008-02-29</pubDate>
  
  <guid>http://www.caloni.com.br/quando-o-ponteiro-nulo-nao-e-invalido/</guid>
  <description>Existe coisa mais prazerosa do que admitir um erro que foi cometido na mesma semana? Existe: quando você sabia que estava certo, mas resolveu usar o senso comum por falta de provas.
Pois bem. O mesmo amigo que me recomendou que escrevesse sobre o assunto do ponteiro nulo achou um livro sobre armadilhas em C com um exemplo que demonstra exatamente o contrário: dependendo da plataforma, ponteiros nulos são sim válidos.
Nesse caso, se tratava de um programa que iria rodar em um microprocessador, daqueles que o DQ costuma programar. Pois bem. Quando o dito cujo ligava era necessário chamar uma rotina que estava localizada exatamente no endereço 0. Para fazer isso, o código era o seguinte:
( * (void(*)()) 0 ) (); Nada mais simples: um _cast _do endereço 0 (apesar de normalmente inválido, 0 pode ser convertido para endereço) para ponteiro de função que não recebe parâmetros e não retorna nada, seguido de deferência (&amp;quot;o apontado de&amp;quot;) e chamada (a dupla final de parênteses).
&amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;(* &amp;lt;/font&amp;gt;&amp;lt;font color=&amp;quot;#008000&amp;quot;&amp;gt;(void(*)())&amp;lt;/font&amp;gt; 0 &amp;lt;font color=&amp;quot;#0000ff&amp;quot;&amp;gt;) &amp;lt;/font&amp;gt;&amp;lt;font color=&amp;quot;#ff0000&amp;quot;&amp;gt;()&amp;lt;/font&amp;gt;; É bem o que o autor diz depois de jogar esta expressão: &amp;quot;expressions like these strike terror into the hearts of C programmers&amp;quot;. É lógico que isso não é bem verdade para as pessoas que acompanham este blogue =)
</description>
</item>

     
        <item>
  <title>Conversor de Houaiss para Babylon - parte 1</title>
  <link>http://www.caloni.com.br/conversor-de-houaiss-para-babylon-parte-1/</link>
  <pubDate>2008-02-27</pubDate>
  
  <guid>http://www.caloni.com.br/conversor-de-houaiss-para-babylon-parte-1/</guid>
  <description>Este artigo é sobre desmontar e montar novamente. Iremos descobrir como as entradas do dicionário Houaiss eletrônico estão gravadas em um primeiro momento, para depois remontarmos essa informação de maneira que ela possa ser usada em outro dicionário de uso mais flexível, o Babylon. Ou seja, este não é um guia de vandalismo. Estava apenas querendo usar um dicionário de qualidade excelente em outro dicionário cuja interface é muito boa.
Sobre pirataria
Considero o Houaiss o melhor dicionário da atualidade, uso todo santo dia e tenho todo o respeito por ele. Possuo uma cópia legalizada exatamente por isso. Além, é óbvio, pelo escandaloso cinismo que seria se eu, desenvolvedor de software, pirateasse os que utilizo. Porém, acredito que tudo tenha um limite: respeito os direitos de quem desenvolve o programa se o programa se dá ao respeito de ser pago. Quer dizer, eu realmente uso muito esse dicionário, e ele é útil para mim. Logo, nada mais justo do que adquiri-lo como manda a lei.
Assim como adquiri o Houaiss, também comprei o Babylon, um programa-dicionário, cuja interface permite buscar o significado das palavras lidas no computador simplesmente clicando nelas. A qualidade de seu dicionário português embutido é medíocre, mas o que ele ganha mesmo é em sua interface fácil para acessar palavras. Exatamente por faltar um dicionário em português de peso no Babylon, e eu ter adquirido outro muito melhor, quis que ambos funcionassem juntos, ou seja, acesso o Babylon e tenho o resultado adicional desse meu dicionário tupiniquim.
O Babylon possui um mecanismo para criação de dicionários chamado Babylon Builder. É muito simples e fácil de usar (além de ser gratuito). Sabendo que possuo ambas as licenças desses dois programas me sinto mais aliviado em tentar desencriptar a base de dados do primeiro para construir um dicionário para o segundo, e assim realizar meu sonho de consumo: um Babylon com um dicionário de peso!

Instalação É necessário que, na hora da instalação, seja escolhida a opção de copiar os arquivos para o disco. Estarei utilizando o path padrão de um Windows em português, que é &amp;quot;C:\Arquivos de Programas\Houaiss&amp;quot;.

A estrutura de diretórios interna da instalação é bem simples:
  Raiz. Arquivos de ajuda, desinstalador, executável principal, etc.
  Quadros. Figuras com conhecimentos gerais, como calendários, signos, línguas mais faladas, etc.
  Dicionario. Provavelmente onde está todo o dicionário, cerca de 120 MB.
  Se analisarmos o conteúdo dos arquivos dentro da pasta Dicionario vamos descobrir que ele se parece com &amp;quot;garbage nonsense&amp;quot;, apesar de existir um certo padrão. O padrão revela que pode se tratar de uma criptografia muito simples, talvez até um simples XOR.
for %i in (*.*) do type %i | less 
Análise Sabendo que o conteúdo do dicionário está em arquivos localizados no disco, e que teoricamente o programa não deve copiar todo o conteúdo para a memória, iremos depurar o processo do dicionário de olho nas chamadas da função ReadFile quando clicarmos em uma definição de palavra.
windbg -pn houaiss2.exe0:001&amp;gt; bp kernel32!ReadFile &amp;quot;dd @$csp L6&amp;quot; $$ Dando uma olhada nos parâmetrosg Ao clicar na definição de &amp;quot;programa-fonte&amp;quot;, o breakpoint é ativado:
0012fa70 0040a7a9 00000200 &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;08bbf1d0 00000200 &amp;lt;/span&amp;gt;0012fa80 0012fa88 00000000eax=0012fa88 ebx=00000200 ecx=00000200 edx=08bbf1d0 esi=08bbf1d0 edi=00000200eip=7c80180e esp=0012fa70 ebp=0012facc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246kernel32!ReadFile:7c80180e 6a20 push 20h$$ O buffer de saída é &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;08bbf1d0 &amp;lt;/span&amp;gt;$$ O número de bytes lidos é &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;200&amp;lt;/span&amp;gt;0:000&amp;gt; db 08bbf1d0 L8008bbf1d0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf1e0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf1f0 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf200 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf210 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf220 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf230 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................08bbf240 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ................0:000&amp;gt; bp /1 @$ra &amp;quot;db 08bbf1d0 L80&amp;quot;0:000&amp;gt; g08bbf1d0 1f 65 67 64 5c 67 56 62-56 22 5b 64 63 69 5a 02 .egd\gVbV&amp;quot;[dciZ.08bbf1e0 ff 38 68 23 62 23 02 ff-59 70 51 5e 15 68 4d 4d .8h#b#..YpQ^.hMM08bbf1f0 72 02 ff 49 5e 63 5b 02-ff 2f 65 67 64 5c 67 56 r..I^c[../egd\gV08bbf200 62 56 15 59 5a 15 58 64-62 65 6a 69 56 59 64 67 bV.YZ.XdbejiVYdg08bbf210 15 5a 62 15 68 6a 56 15-5b 64 67 62 56 15 64 67 .Zb.hjV.[dgbV.dg08bbf220 5e 5c 5e 63 56 61 21 15-56 63 64 69 56 59 64 15 ^\^cVa!.VcdiVYd.08bbf230 65 5a 61 64 15 65 67 64-5c 67 56 62 56 59 64 67 eZad.egd\gVbVYdg08bbf240 15 5a 62 15 6a 62 56 15-61 5e 63 5c 6a 56 5c 5a .Zb.jbV.a^c\jV\Zeax=00000001 ebx=00000200 ecx=7c801898 edx=7c90eb94 esi=08bbf1d0 edi=00000200eip=0040a7a9 esp=0012fa88 ebp=0012facc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202Houaiss2&#43;0xa7a9:0040a7a9 85c0 test eax,eax Depois da leitura, não temos muitas alternativas a não ser fazer o tracking de chamadas até que o mesmo buffer esteja desencriptado. Esse é o caminho natural das coisas, mas poderia haver complicações secundárias, como uma cópia de buffer antes de seu uso. Estou usando passos simples porque realmente foi muito simples descobrir o segredo da ofuscação.
0:000&amp;gt; pHouaiss2&#43;0xa7ab:0040a7ab 7507 jne Houaiss2&#43;0xa7b4 (0040a7b4) [br=1]0:000&amp;gt; pHouaiss2&#43;0xa7b4:0040a7b4 8b0424 mov eax,dword ptr [esp] ss:0023:0012fa88=000002000:000&amp;gt; pHouaiss2&#43;0xa7b7:0040a7b7 5a pop edx0:000&amp;gt; pHouaiss2&#43;0xa7b8:0040a7b8 5f pop edi0:000&amp;gt; pHouaiss2&#43;0xa7b9:0040a7b9 5e pop esi0:000&amp;gt; pHouaiss2&#43;0xa7ba:0040a7ba 5b pop ebx0:000&amp;gt; pHouaiss2&#43;0xa7bb:0040a7bb c3 ret0:000&amp;gt; pHouaiss2&#43;0xb9062:004b9062 8945f8 mov dword ptr [ebp-8],eax ss:0023:0012fac4=000000000:000&amp;gt; pHouaiss2&#43;0xb9065:004b9065 0375f8 add esi,dword ptr [ebp-8] ss:0023:0012fac4=000002000:000&amp;gt; pHouaiss2&#43;0xb9068:004b9068 807b1900 cmp byte ptr [ebx&#43;19h],0 ds:0023:090cf1f9=010:000&amp;gt; pHouaiss2&#43;0xb906c:004b906c 7410 je Houaiss2&#43;0xb907e (004b907e) [br=0]0:000&amp;gt; pHouaiss2&#43;0xb906e:004b906e 8b4df8 mov ecx,dword ptr [ebp-8] ss:0023:0012fac4=000002000:000&amp;gt; pHouaiss2&#43;0xb9071:004b9071 8b933c200300 mov edx,dword ptr [ebx&#43;3203Ch] ds:0023:0910121c=000000000:000&amp;gt; pHouaiss2&#43;0xb9077:004b9077 8bc3 mov eax,ebx0:000&amp;gt; pHouaiss2&#43;0xb9079:004b9079 e8eef9ffff &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;call Houaiss2&#43;0xb8a6c (004b8a6c)&amp;lt;/span&amp;gt;0:000&amp;gt; pHouaiss2&#43;0xb90:000&amp;gt; db 08bbf1d0 L8008bbf1d0 2a 70 72 6f 67 72 61 6d-61 2d 66 6f 6e 74 65 0d *programa-fonte.08bbf1e0 0a 43 73 2e 6d 2e 0d 0a-64 7b 5c 69 20 73 58 58 .Cs.m...d{\i sXX08bbf1f0 7d 0d 0a 54 69 6e 66 0d-0a 3a 70 72 6f 67 72 61 }..Tinf..:progra08bbf200 6d 61 20 64 65 20 63 6f-6d 70 75 74 61 64 6f 72 ma de computador08bbf210 20 65 6d 20 73 75 61 20-66 6f 72 6d 61 20 6f 72 em sua forma or08bbf220 69 67 69 6e 61 6c 2c 20-61 6e 6f 74 61 64 6f 20 iginal, anotado08bbf230 70 65 6c 6f 20 70 72 6f-67 72 61 6d 61 64 6f 72 pelo programador08bbf240 20 65 6d 20 75 6d 61 20-6c 69 6e 67 75 61 67 65 em uma linguage Pois bem. Logo depois de chamar a função Houaiss2&#43;0xb8a6c magicamente o buffer incompreensível se transformou no início da definição da palavra &amp;quot;programa-fonte&amp;quot;. Como não temos o programa-fonte do Houaiss, teremos que descer mais um nível no &amp;quot;assemblão&amp;quot;, mesmo.
(Note que reexecutei os passos anteriores para cair na mesma condição)
Houaiss2&#43;0xb9079:004b9079 e8eef9ffff call Houaiss2&#43;0xb8a6c (004b8a6c)0:000&amp;gt; &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;t&amp;lt;/span&amp;gt;eax=08bbf1a0 ebx=08bbf1a0 ecx=00000200 edx=00000000 esi=00000200 edi=02fe8661eip=004b8a6c esp=0012fa98 ebp=0012facc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202Houaiss2&#43;0xb8a6c:004b8a6c 53 push ebx0:000&amp;gt; peax=08bbf1a0 ebx=08bbf1a0 ecx=00000200 edx=00000000 esi=00000200 edi=02fe8661eip=004b8a6d esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202Houaiss2&#43;0xb8a6d:004b8a6d 03ca add ecx,edx0:000&amp;gt; peax=08bbf1a0 ebx=08bbf1a0 ecx=00000200 edx=00000000 esi=00000200 edi=02fe8661eip=004b8a6f esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206Houaiss2&#43;0xb8a6f:004b8a6f 49 dec ecx0:000&amp;gt; peax=08bbf1a0 ebx=08bbf1a0 ecx=000001ff edx=00000000 esi=00000200 edi=02fe8661eip=004b8a70 esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz ac pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000216Houaiss2&#43;0xb8a70:004b8a70 2bca sub ecx,edx0:000&amp;gt; peax=08bbf1a0 ebx=08bbf1a0 ecx=000001ff edx=00000000 esi=00000200 edi=02fe8661eip=004b8a72 esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206Houaiss2&#43;0xb8a72:004b8a72 7c12 jl Houaiss2&#43;0xb8a86 (004b8a86) [br=0]0:000&amp;gt; peax=08bbf1a0 ebx=08bbf1a0 ecx=000001ff edx=00000000 esi=00000200 edi=02fe8661eip=004b8a74 esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206Houaiss2&#43;0xb8a74:004b8a74 41 inc ecx0:000&amp;gt; peax=08bbf1a0 ebx=08bbf1a0 ecx=00000200 edx=00000000 esi=00000200 edi=02fe8661eip=004b8a75 esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz ac pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000216&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;Houaiss2&#43;0xb8a75&amp;lt;/span&amp;gt;:004b8a75 33db xor ebx,ebx0:000&amp;gt; peax=08bbf1a0 ebx=00000000 ecx=00000200 edx=00000000 esi=00000200 edi=02fe8661eip=004b8a77 esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246Houaiss2&#43;0xb8a77:004b8a77 8a5c1030 mov &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;bl&amp;lt;/span&amp;gt;,byte ptr [eax&#43;&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;edx&amp;lt;/span&amp;gt;&#43;30h] ds:0023:&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;08bbf1d0&amp;lt;/span&amp;gt;=1f0:000&amp;gt; peax=08bbf1a0 ebx=0000001f ecx=00000200 edx=00000000 esi=00000200 edi=02fe8661eip=004b8a7b esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246Houaiss2&#43;0xb8a7b:004b8a7b 83c30b &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;add ebx,0Bh&amp;lt;/span&amp;gt;0:000&amp;gt; peax=08bbf1a0 ebx=0000002a ecx=00000200 edx=00000000 esi=00000200 edi=02fe8661eip=004b8a7e esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz ac po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000212Houaiss2&#43;0xb8a7e:004b8a7e 885c1030 mov byte ptr [eax&#43;&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;edx&amp;lt;/span&amp;gt;&#43;30h],&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;bl &amp;lt;/span&amp;gt;ds:0023:&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;08bbf1d0&amp;lt;/span&amp;gt;=1f0:000&amp;gt; peax=08bbf1a0 ebx=0000002a ecx=00000200 edx=00000000 esi=00000200 edi=02fe8661eip=004b8a82 esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz ac po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000212Houaiss2&#43;0xb8a82:004b8a82 42 &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;inc edx&amp;lt;/span&amp;gt;0:000&amp;gt; peax=08bbf1a0 ebx=0000002a ecx=00000200 edx=00000001 esi=00000200 edi=02fe8661eip=004b8a83 esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202Houaiss2&#43;0xb8a83:004b8a83 49 &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;dec ecx&amp;lt;/span&amp;gt;0:000&amp;gt; peax=08bbf1a0 ebx=0000002a ecx=&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;000001ff &amp;lt;/span&amp;gt;edx=&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;00000001 &amp;lt;/span&amp;gt;esi=00000200 edi=02fe8661eip=004b8a84 esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz ac pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000216Houaiss2&#43;0xb8a84:004b8a84 75ef jne&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;Houaiss2&#43;0xb8a75&amp;lt;/span&amp;gt; (004b8a75) [br=1]0:000&amp;gt; peax=08bbf1a0 ebx=0000002a ecx=000001ff edx=00000001 esi=00000200 edi=02fe8661eip=004b8a75 esp=0012fa94 ebp=0012facc iopl=0 nv up ei pl nz ac pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000216&amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;Houaiss2&#43;0xb8a75&amp;lt;/span&amp;gt;:004b8a75 33db xor ebx,ebx... Estamos diante de um loop, que, ao analisar o valor de ecx, sabemos que se repete 0x200 vezes, que é exatamente o número de bytes lidos pela função ReadFile. Coincidência? Seria, se não estivesse bem no meio do _loop _a referência ao próprio buffer usado na leitura (08bbf1d0).
Acredito que para todo profissional de engenharia reversa a parte mais emocionante é a descoberta do grande segredo por trás do desafio, o porquê das coisas estarem como estão e o que fazer para desfazer a mágica da segurança: a chave!
Houaiss2&#43;0xb8a7b:004b8a7b 83c30b &amp;lt;span style=&amp;quot;color: #ff0000;&amp;quot;&amp;gt;add ebx,0Bh&amp;lt;/span&amp;gt; Note que essa operação é realizada para cada byte lido do buffer usado na leitura do arquivo. Conseqüentemente, não é difício de imaginar que o valor 0x0B é a chave usada para ofuscar o dicionário em arquivo, subtraindo esse valor de cada byte. Para desfazer a ofuscação, portanto, basta adicionar novamente o mesmo valor, que é exatamente o que faz a instrução _assembly _acima, e o meu singelo código de desofuscação do dicionário Houaiss abaixo:
#define _CRT_SECURE_NO_DEPRECATE#include &amp;lt;windows.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;//#define HOUAISS_PATH &amp;#34;C:\\Projects\\Temp\\HouaissReader\\Houaiss\\&amp;#34;int WINAPI WinMain(HINSTANCE, HINSTANCE, PSTR cmdLine, int){CHAR HOUAISS_PATH[MAX_PATH] = { };sscanf(cmdLine, &amp;#34;-p \&amp;#34;%[^\&amp;#34;]s&amp;#34;, HOUAISS_PATH);if( HOUAISS_PATH[0] == 0 ){MessageBox(NULL, &amp;#34;How to use:\r\nHouCalc.exe -p \&amp;#34;C:\\HouaissPath\\\&amp;#34;&amp;#34;, &amp;#34;Houaiss Decipher v. alpha&amp;#34;, 0);return 0;}for( int fileIdx = 1; fileIdx &amp;lt; 64; &#43;&#43;fileIdx ){CHAR path1[MAX_PATH];CHAR path2[MAX_PATH];sprintf(path1, &amp;#34;%sdeah%03d.dhx&amp;#34;, HOUAISS_PATH, fileIdx);sprintf(path2, &amp;#34;%sdeah%03d.txt&amp;#34;, HOUAISS_PATH, fileIdx);HANDLE file1 = CreateFile(path1, GENERIC_READ, FILE_SHARE_READ,NULL, OPEN_EXISTING, 0, NULL);HANDLE file2 = CreateFile(path2, GENERIC_READ | GENERIC_WRITE, 0,NULL, CREATE_ALWAYS, 0, NULL);if( file1 != INVALID_HANDLE_VALUE &amp;amp;&amp;amp; file2 != INVALID_HANDLE_VALUE ){DWORD fileSize = GetFileSize(file1, NULL);if( SetFilePointer(file2, fileSize, NULL, FILE_BEGIN) ){SetEndOfFile(file2);HANDLE map1 = CreateFileMapping(file1, NULL, PAGE_READONLY, 0, 0, NULL);HANDLE map2 = CreateFileMapping(file2, NULL, PAGE_READWRITE, 0, 0, NULL);if( map1 &amp;amp;&amp;amp; map2 ){PBYTE view1 = (PBYTE) MapViewOfFile(map1, FILE_MAP_READ, 0, 0, 0);PBYTE view2 = (PBYTE) MapViewOfFile(map2, FILE_MAP_WRITE, 0, 0, 0);if( view1 &amp;amp;&amp;amp; view2 ){for( DWORD i = 0; i &amp;lt; fileSize; &#43;&#43;i ){view2[i] = view1[i] &#43; 0x0B;}}if( view1 )UnmapViewOfFile(view1);if( view2 )UnmapViewOfFile(view2);}if( map1 )CloseHandle(map1);if( map2 )CloseHandle(map2);}}if( file1 )CloseHandle(file1);if( file2 )CloseHandle(file2);}return 0;}Nos próximos capítulos Parte da mágica já foi feita, talvez a mais importante e divertida. Daqui pra lá deixaremos o WinDbg de lado e analisaremos o formato em que o texto do dicionário é armazenado, ignorando sua ofuscação básica, que não é mais um problema. Como o artigo já está extenso o suficiente, vou deixar a continuação dessa empreitada para uma futura publicação.
</description>
</item>

     
        <item>
  <title>Códigos de entrevista - o ponteiro nulo</title>
  <link>http://www.caloni.com.br/codigos-de-entrevista-o-ponteiro-nulo/</link>
  <pubDate>2008-02-25</pubDate>
  
  <guid>http://www.caloni.com.br/codigos-de-entrevista-o-ponteiro-nulo/</guid>
  <description>O código é o que veremos abaixo:
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;void func(){*(int *)0 = 0;return 0;}int main(int argc, char **argv){func();return 0;} Bem, para testar a compilação basta compilar. Porém, se estivermos em uma entrevista, geralmente não existe nenhum compilador em um raio de uma sala de reunião senão seu próprio cérebro.
E é nessas horas que os entrevistadores testam se você tem um bom cérebro ou um bom currículo.
Por isso, vamos analisar passo a passo cada bloco de código e entender o que pode estar errado. Se não encontrarmos, iremos supor que está tudo certo.
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; Dois includes padrões, ultranormal, nada de errado aqui.
void func(){*(int *)0 = 0;return 0;}Duas ressalvas aqui: a primeira quanto ao retorno da função é void, porém a função retorna um inteiro. Na linguagem C, isso funciona, no máximo um warning do compilador. Em C&#43;&#43;, isso é erro brabo de tipagem.
A segunda ressalva diz respeito à linha obscura, sintaticamente correta, mas cuja semântica iremos guardar para o final, já que ainda falta o main para analisar.a
int main(int argc, char **argv){func();return 0;} A clássica função inicial, nada de mais aqui. Retorna um int, e de fato retorn. Chama a função func, definida acima.
A linha obscura A linha que guardamos para analisar contém uma operação de casting, atribuição e deferência, sendo o _casting _executado primeiro, operador unário que é, seguido pelo segundo operador unário, a deferência. Como sempre, a atribuição é uma das últimas. Descomprimida a expressão dessa linha, ficamos com algo parecido com as duas linhas abaixo:
int* p = (int*) 0;*p = 0; Não tem nada de errado em atribuir o valor 0 a um ponteiro, que é equivalente ao define NULL da biblioteca C (e C&#43;&#43;). De acordo com a referência GNU, é recomendado o uso do define, mas nada impede utilizar o 0 &amp;quot;hardcoded&amp;quot;.
Porém, estamos escrevendo em um ponteiro nulo, o que com certeza é um comportamento não-definido de conseqüências provavelmente funestas. O ponteiro nulo é um ponteiro inválido que serve apenas para marcar um ponteiro como inválido. Se escrevermos em um endereço inválido, bem, não é preciso ler o padrão para saber o que vai acontecer =)
Atualização Em código. Isso pode:
 int* p = 0; // atribuindo nulo a um ponteiroint* p2 = p; // isso também pode  Isso não pode:
 *p = 15; // &amp;lt;strong&amp;gt;NUNCA&amp;lt;/strong&amp;gt; acessar ponteiros nulosint x = *p; // isso também &amp;lt;strong&amp;gt;não pode&amp;lt;/strong&amp;gt;, ler de um ponteiro nulo  Dito isso, me sinto melhor =)</description>
</item>

     
        <item>
  <title>Configurando seus projetos no Visual Studio</title>
  <link>http://www.caloni.com.br/configurando-seus-projetos-no-visual-studio/</link>
  <pubDate>2008-02-21</pubDate>
  
  <guid>http://www.caloni.com.br/configurando-seus-projetos-no-visual-studio/</guid>
  <description>Ao iniciar na arte da programação em C no Visual Studio, eventualmente o programador irá querer testar seus programas rodando em outra máquina que não seja a de desenvolvimento, mandar uma versão beta para amigos, pra namorada e pro seu cachorro. Geralmente, por padrão, existem algumas dependências do programa compilado com uma DLL de runtime da versão do ambiente em que foi compilado o dito cujo, dificultando um pouco a distribuição do seu motherfucker-program.
Porém, seus &amp;quot;poroberemas se acabaram-se&amp;quot;. Com o inovador configurador de projetos do Visual Studio, tudo o que você queria é possível, e ainda mais!
Nota do autor: isso não foi uma propaganda gratuita, apenas uma piada. Se fosse um verdadeiro anúncio das maravilhas do Visual Studio, eu agora estaria falando daquele tal código gerenciado e o tal do C&#43;&#43; CLI.
Inicialmente, se compilarmos um programa em Debug no Visual Studio 2005 teremos as seguintes dependências:
A DLL kernel32 é nativa e sempre estará presente no Windows. Porém, a msvcr80d não. Ela veio junto com o pacote do Visual Studio, e se não for distribuída em outras máquinas, você não conseguirá rodar seu programa, pois isso gerará o seguinte erro:
Bem, para resolver isso, a partir da IDE, temos que ir em Project, Properties, Configuration Properties, C/C&#43;&#43;, Code Generation, Runtime Library.
Existem atualmente quatro tipos de runtime que você pode escolher:
 Multi-threaded (/MT). Versão Release que não depende de DLL. Multi-threaded Debug (/MTd). Versão Debug que não depende de DLL. Multi-threaded DLL (/MD). Versão Release que depende de DLL. Multi-threaded Debug DLL (/MDd). Versão Debug que depende de DLL.  Essas runtimes são chamada de multi-threaded porque antigamente existiam versões single-threaded dessas mesmas runtimes. Contudo, versões mais novas do Visual Studio só vêm com esse sabor mesmo.
Note que, por padrão, existem dois tipos de configuração em seu projeto: Debug (para testes) e Release (para distribuição). Convém não misturar configurações Debug com DLLs Release e vice-versa, a não ser que você tenha certeza do que está fazendo.
Pois bem. Para tirar a dependência da maldita DLL, tudo que temos que fazer é alterar a configuração, nesse caso Debug, de /MDd para /MTd. E recompilar.
E testar.
Além da dependência de DLLs, alguns casos especiais vão chiar por causa dos dados do manifesto embutidos no programa compilado. Por algum motivo que eu desconheço, o programa necessita que as DLLs estejam instaladas mesmo que no Dependency Walker não mostre nada. Nesses casos, uma arrancada do manifesto na versão Debug não fará mal algum.
Acho que esses são os únicos empecilhos iniciais para testar seu programa em outras máquinas. Sempre que ver o erro exibido no começo desse artigo, desconfie de alguma dependência que não está presente na máquina. Nessas horas, ter um Dependency Walker na mão vale ouro.
</description>
</item>

     
        <item>
  <title>Os diferentes erros na linguagem C</title>
  <link>http://www.caloni.com.br/os-diferentes-erros-na-linguagem-c/</link>
  <pubDate>2008-02-15</pubDate>
  
  <guid>http://www.caloni.com.br/os-diferentes-erros-na-linguagem-c/</guid>
  <description>Uma coisa que me espanta de vez em quando é o total desconhecimento por programadores mais ou menos experientes dos níveis de erros que podem ocorrer em um fonte escrito em C ou C&#43;&#43;. Desconheço o motivo, mas desconfio que o fato de outras linguagens não terem essa divisão de processos pode causar alguma nivelação entre as linguagens e fazer pensar que o processo de compilação em C é como em qualquer outra linguagem.
Porém, para começar, só de falarmos em compilação já estamos pegando apenas um pedaço do todo, que é a geração de um programa executável em C. Tradicionalmente, dividimos esse processo em três passos:
 Preprocessamento Compilação Linkedição  Vamos dar uma olhada mais de perto em cada um deles e descobrir erros típicos de cada processo.
O preprocessamento é especificado pelos padrões C e C&#43;&#43;, mas, tecnicamente, não faz parte da linguagem. Ou seja, antes que qualquer regra de sintaxe seja verificada no código-fonte, o preprocessamento já terá terminado.
Essa parte do processo lida com substituição de texto e diretivas baseadas em arquivos e símbolos. Por exemplo, a diretiva de preprocessamento mais conhecida
#include &amp;lt;stdio.h&amp;gt; faz com que todo o conteúdo do arquivo especificado seja incluído exatamente no ponto onde for colocada essa diretiva. Isso quer dizer que, antes sequer do código-fonte ser compilado, todo o conteúdo desse header padrão estará no corpo do arquivo C.
Para evitar que o mesmo header seja incluído inúmeras vezes dentro da mesma unidade em C, causando assim erros de redefinição, existe outra diretiva muito usada para cercar esses arquivos públicos:
#ifndef __MEUHEADER__ // se já estiver definido, caio fora até endif#define __MEUHEADER__// conteúdo do header#endif // __MEUHEADER__ Esse conjunto de duas diretivas, por si só, é capaz de gerar os mais criativos e bizarros erros de compilação em C. E estamos falando de erros que ocorrem antes que sequer seja iniciado o processo de compilação propriamente dito. Obviamente que os erros serão capturados durante a compilação, mas o motivo deles terem ocorrido foi um erro decorrente do processo de preprocessamento. Por exemplo, vamos supor que um determinado fonte necessita de uma declaração de função contida em meuheader.h:
#include &amp;quot;header-do-mal.h&amp;quot;#include &amp;quot;meuheader.h&amp;quot;int func(){meuheaderFunc();} Porém, num daqueles acasos da natureza, o header-do-mal.h define justamente o que não poderia definir jamais (obs.: e isso pode muito bem acontecer na vida real, se usamos definições muito comuns):
#ifndef __HEADERDOMAL__#define __HEADERDOMAL__// tirei header da jogada, huahuahua (risos maléficos)#define __MEUHEADER__#endif // __HEADERDOMAL__ Na hora do preprocessamento, o preprocessador não irá mais incluir o conteúdo dentro de header.h:
#ifndef __MEUHEADER__ // se já estiver definido, caio fora até endif#define __MEUHEADER__int meuheaderFunc(); // talvez alguém precise disso#endif // __MEUHEADER__ Conseqüentemente, durante a compilação do código-fonte já preprocessado, sem a declaração da função meuheaderFunc, irá ocorrer o seguinte erro:
error C3861: &#39;meuheaderFunc&#39;: identifier not found Isso em fontes pequenos é facilmente identificável. Em fontes maiores, é preciso ter um pouco mais de cuidado.
Após o processo de preprocessamento, de todos os arquivos indicados terem sido incluídos, de todas as macros terem sido substituídas, todas as constantes colocadas literalmente no código-fonte, temos o que é chamado unidade de compilação, que será entregue ao compilador, que, por sua vez, irá começar a análise sintática de fato, descobrindo novos erros que podem ou não (como vimos) ter a ver com a fase anterior. A figura abaixo ilustra esse processo, com algumas trocas conhecidas:
Se você conseguir passar ileso para a fase de compilação, pode se considerar um mestre do preprocessamento. Por experiência própria, posso afirmar que a maior parte do tempo gasto corrigindo erros de compilação, por ironia do destino, não terá origem na compilação em si, mas no preprocessamento e linkedição. Isso porque o preprocessamento confunde muito o que vimos no nosso editor preferido, e a linkedição ocorre em uma fase onde não importa mais o que está dentro das funções, mas sim o escopo de nomes, um assunto um pouco mais vago do que a linguagem C.
Na compilação você irá encontrar geralmente erros bem comportados, como conversão entre tipos, else sem if e esquecimento de pontuação ou parênteses.
int cannotConvertError(const char* message){int ret = message[0];return ret;}int ret = cannotConvertError(3);error C2664: &#39;cannotConvertError&#39; : cannot convert parameter 1 from &#39;int&#39; to &#39;const char *&#39;if( test() )something;something-else;elseelse-something;error C2181: illegal else without matching ifwhile( (x &amp;lt; z) &amp;amp;&amp;amp; func(x, func2(y) != 2 ){something;}error C2143: syntax error : missing &#39;)&#39; before &#39;{&#39; Claro, não estamos falando de erros relacionados a templates, que são um pesadelo à parte.
Chegando na linkedição, onde a esperança reside, tudo pode vir por água abaixo. Isso porque você já espera confiante que tudo dê certo, quando, na verdade, um erro bem colocado pode fazer você desistir pra sempre desse negócio de programar em C.
As características mais desejadas para corrigir erros nessa fase são:
 Total conhecimento da fase do preprocessamento Total conhecimento da fase da compilação Total conhecimento de níveis de escopo e assinatura de funções  Os dois primeiros itens são uma maldição previsível que deve-se carregar para todo o sempre. Se você não consegue entender o que aconteceu nas duas primeiras fases, dificilmente irá conseguir seguir adiante com essa empreitada. O terceiro item significa que deve-se levar em conta as bibliotecas que estamos usando, headers externos (com dependências externas), conflitos entre nomes, etc.
Alguns erros mais encontrados aqui são as funções não encontradas por falta da LIB certa ou por LIBs desatualizadas que não se encaixam mais com o projeto, fruto de muitas dores de cabeça de manutenção de código. Essa é a parte em que mais vale a pena saber organizar e definir uma interface clara entre os componentes de um projeto.
Do ponto de vista técnico, é a fase onde o linker junta todos os arquivos-objeto especificados, encontra as funções, métodos e classes necessárias e monta uma unidade executável, como ilustrado pela figura abaixo.
É óbvio que, por ter passado pelas três fases de transformação de um código-fonte em um programa executável, não quer dizer que este programa está livre de erros. Os famigerados erros de lógica podem se disfarçar até o último momento da compilação e só se mostrarem quando o código estiver rodando (de preferência, no cliente).
Entre esses erros, os mais comuns costumam se aproveitar de macros, como max, que usa mais de uma vez o parâmetro, que pode ser uma chamada com uma função. A função será chamada duas vezes, mesmo que aparentemente no código a chamada seja feita uma única vez:
#define max(a, b) ( a &amp;gt; b ? a : b )int z = max( func(10), 30 ); Um outro erro que já encontrei algumas vezes é quando a definição de uma classe tem um sizeof diferente do compilado em sua LIB, pela exclusão ou adição de novos membros. Isso pode (vai) fazer com que, durante a execução, a pilha seja corrompida, membros diferentes sejam acessados, entre outras traquinagens. Esses erros costumam acusar a falta de sincronismo entre os headers usados e suas reais implementações.
Enfim, na vida real, é impossível catalogar todos os erros que podem ocorrer em um fonte em C. Se isso fosse possível, ou não existiriam bugs, ou pelo menos existiria uma ferramenta para automaticamente procurar por esses erros e corrigi-los. Bom, existe o Lint.
Criei um projeto com alguns erros básicos, alguns demonstrados aqui, outros não, mas enfim, completamente configuráveis e divididos nessas três fases. É possível habilitar e desabilitar erros através do header cpperrors.h. Espero que gostem.
</description>
</item>

     
        <item>
  <title>Funky do-while</title>
  <link>http://www.caloni.com.br/funky-do-while/</link>
  <pubDate>2008-02-13</pubDate>
  
  <guid>http://www.caloni.com.br/funky-do-while/</guid>
  <description>It&#39;s a known habit to use do-while constructions when there&#39;s a need to define a macro that has more than one command instead of using the { simple multicommand brackets }. What was never clear is why this is so.
Let&#39;s imagine a trace macro that&#39;s enabled in debug mode, whilst kept in silence in release builds:
#ifdef NDEBUG#define MYTRACE( message ) /* nothing */#else#define MYTRACE( message ) \{ \char buffer[500]; \sprintf(buffer, \&amp;quot;MYTRACE: %s(%d) %s\n&amp;quot;, \__FILE__, \__LINE__, \message); \OutputDebugString(buffer); \}#endif /* NDEBUG */  Nothing much, but it seems to work. But, as we going to see in the following lines, it is really a buggy piece of code, since a call inside an if-else construction simply doesn&#39;t work.
if( exploded() )MYTRACE(&amp;quot;Oh, my God&amp;quot;);elseMYTRACE(&amp;quot;That&#39;s right&amp;quot;); error C2181: illegal else without matching if Why&#39;s that? In order to answer this question, we need to look closer into the result code from the preprocessor, just replacing the macro for its piece of code:
if( exploded() ){char buffer[500];sprintf(buffer,&amp;quot;MYTRACE: %s(%d) %s\n&amp;quot;,__FILE__,__LINE__,&amp;quot;Oh, my God&amp;quot;);OutputDebugString(buffer);};else{char buffer[500];sprintf(buffer,&amp;quot;MYTRACE: %s(%d) %s\n&amp;quot;,__FILE__,__LINE__,&amp;quot;That&#39;s right&amp;quot;);OutputDebugString(buffer);}; So, that&#39;s why. When we call a macro, generally we use the funcion-call syntax, putting a semicolon in the end. This is the right way to call a function, but in the macro case, it&#39;s a disaster, because it creates two commands instead of one (an empty semicolon, despite doing nothing, it&#39;s a valid command). So that&#39;s what the compiler does:
if( instruction ){/* a lot of comands */} /* here I would expect an else or new instruction */; /* a new command! okay, no else this time */else /* wait! what this else is doing here without an if?!?! */{/* more commands */} Think about the empty command as if it was a real command, what is the easier way to realize the compiler error:
if( error() ){printf(&amp;quot;error&amp;quot;);}printf(&amp;quot;here we go&amp;quot;);else /* llegal else without matching if! */{printf(&amp;quot;okay&amp;quot;);} For this reason, the tradicional way to skip this common error is to use a valid construction who asks for a semicolon in the end. Fortunately, language C has such construction, and it is... right, the do-while!
do{/* multiple commands here */}while( expression );/* I expect a semicolon here, in orderto end the do-while instruction */ So we can rewrite our trace macro the right way, even being a funcky one:
#ifdef NDEBUG#define MYTRACE( message ) /* nothing */#else#define MYTRACE( message ) \do \{ \char buffer[500]; \sprintf(buffer, \&amp;quot;MYTRACE: %s(%d) %s\n&amp;quot;, \__FILE__, \__LINE__, \message); \printf(buffer); \} \while( 0 )#endif /* NDEBUG */  Using a do-while (with a false expression inside the test to execute the block just once) the if-else construction is allowed and working properly:
if( exploded() )do{char buffer[500];sprintf(buffer,&amp;quot;MYTRACE: %s(%d) %s\n&amp;quot;,__FILE__,__LINE__,&amp;quot;Oh, my God&amp;quot;);OutputDebugString(buffer);}while( 0 );elsedo{char buffer[500];sprintf(buffer,&amp;quot;MYTRACE: %s(%d) %s\n&amp;quot;,__FILE__,__LINE__,&amp;quot;That&#39;s right&amp;quot;);OutputDebugString(buffer);}while( 0 ); </description>
</item>

     
        <item>
  <title>Desconstruindo IOCCC</title>
  <link>http://www.caloni.com.br/desconstruindo-ioccc/</link>
  <pubDate>2008-02-11</pubDate>
  
  <guid>http://www.caloni.com.br/desconstruindo-ioccc/</guid>
  <description>Como alguns devem saber, e outros não (ou não deveriam), existe uma competição internacional para escolher quem escreve o código em C mais ofuscado. Isso mesmo. O evento se chama The International Obfuscated C Code Contest (IOCCC resumidamente) e costuma premiar anualmente os melhores &amp;quot;do ramo&amp;quot; com a chamada &amp;quot;menção desonrosa&amp;quot;.
Acredito que a real valia de um campeonato desse porte é fazer as pessoas pensarem mais a fundo sobre as regras da linguagem. Isso faz com que erros mais obscuros que encontramos no dia-a-dia se tornem mais fáceis. Claro que ninguém deveria programar como os caras desse torneio, mas a título de aprendizagem, é uma grande aula sobre C.
Publico aqui a interpretação do primeiro programa a ganhar a tal menção desonrosa, em 1984. Se trata do batidíssimo &amp;quot;Hello World&amp;quot;, só que um pouco compactado e confuso. Vejamos o fonte original:
int i;main(){for(;i[&amp;quot;]&amp;lt;i;&#43;&#43;i){--i;}&amp;quot;];read(&#39;-&#39;-&#39;-&#39;,i&#43;&#43;&#43;&amp;quot;hell\o, world!\n&amp;quot;,&#39;/&#39;/&#39;/&#39;));}read(j,i,p){write(j/p&#43;p,i---j,i/i);} Aparentemente o fonte é bem confuso, apesar de podermos já ver a famosa string escondida no meio do código. Depois de aplicar uma formatação mais adequada para nossa tarefa de desfazer o feito, o resultado é bem mais legível:
int i;main(){for( ; i[&amp;quot;] &amp;lt; i; &#43;&#43;i ){--i;}&amp;quot;]; read(&#39;-&#39; - &#39;-&#39;, i&#43;&#43; &#43; &amp;quot;hello, world!\n&amp;quot;, &#39;/&#39; / &#39;/&#39;) );}read(j, i, p){write(j / p &#43; p, i-- - j, i / i);} Algumas construções são óbvias. Vamos então partir para as não-tão-óbvias.
int i; Como toda variável global inteira, é inicializada com zero. Logo, a linha acima é equivalente a &amp;quot;int i =0&amp;quot;.
main() { }read() { } Aos programadores C&#43;&#43; desavisados de plantão, em C o valor de retorno padrão é int, e, caso não seja retornado nada, isso não constitui um erro, porém o comportamento é não-definido. Nada de mal, porém, pode ocorrer, a não ser o retorno de lixo da pilha.
for( ; &amp;lt;censurado&amp;gt;; &amp;lt;censurado&amp;gt; ); Outra coisa óbvia, mas não tanto, é um laço for sem corpo. Ele possui apenas um ponto-e-vírgula, que identifica uma instrução nula. Não faz nada no corpo, mas pode fazer coisas interessantes no cabeçalho, ou seja, na inicialização, no teste e no incremento. Como podemos ver, a inicialização também está vazia, contendo esse laço apenas o teste e o incremento. No teste temos a seguinte comparação:
i[&amp;quot;] &amp;lt; i; &#43;&#43;i ){--i;}&amp;quot;] Ora, sabendo que a variável &amp;quot;i&amp;quot; inicialmente tem o valor zero, o que estamos vendo aqui é a mesma coisa que
0[&amp;quot;] &amp;lt; i; &#43;&#43;i ){--i;}&amp;quot;] E uma vez que aprendemos algumas peculiaridades sobre o operador de subscrito em C, sabemos que a linha acima é equivalente a essa linha abaixo:
&amp;quot;] &amp;lt; i; &#43;&#43;i ){--i;}&amp;quot;[0] Agora ficou mais fácil de entender. Se trocarmos a nossa string literal por uma variável (forma mais usual), temos um acesso típico a um dos caracteres de uma string:
char* str = &amp;quot;] &amp;lt; i; &#43;&#43;i ){--i;}&amp;quot;;str[0]; Só precisamos lembrar que a variável i é que define a posição, e por ser uma variável, pode mudar durante a execução:
int i = 0;char* str = &amp;quot;] &amp;lt; i; &#43;&#43;i ){--i;}&amp;quot;;str[i]; Pois bem. Agora sabemos que o laço irá ser testado pelo menos uma vez, o que quer dizer que a parte do incremento vai executar pelo menos uma vez. E essa parte é a seguinte:
read(&#39;-&#39; - &#39;-&#39;, i&#43;&#43; &#43; &amp;quot;hello, world!\n&amp;quot;, &#39;/&#39; / &#39;/&#39;) Uma chamada de função. Nada mais simples. Podemos anular algumas coisas por aqui. Por exemplo, se subtraímos um número dele mesmo encontramos zero, e se dividirmos um número por ele mesmo o resultado é um:
&#39;-&#39; - &#39;-&#39; == 0&#39;/&#39; / &#39;/&#39; == 1 Lembre-se de que um caractere em C é um tipo inteiro, e portanto, pode fazer parte de cálculos matemáticos. Depois dessa simplificação, temos
read(0, i&#43;&#43; &#43; &amp;quot;hello, world!\n&amp;quot;, 1) Agora você deveria estar se perguntando (se ainda não encontrou a resposta) do porquê de eu ter dividido os três sinais de &#43; dessa forma. Existem duas opções para a divisão:
i&#43;&#43; &#43; &amp;quot;hello, world!\n&amp;quot; /* ou */i&#43; &#43;&#43;&amp;quot;hello, world&amp;quot;\n&amp;quot; /* ?? */ A primeira forma é a resposta correta devido à regra de precedência (deferida pela gramática). Antes os operadores unários, depois os binários. Dessa forma, um &amp;quot;i&#43;&amp;quot; não quer dizer nada, mas &amp;quot;i&#43;&#43;&amp;quot; é um operando com um operador unário.
Voltando à expressão, imagino que a essa altura você já deva ter decifrado que i&#43;&#43; &#43; &amp;quot;hello, world!\n&amp;quot; é o mesmo que:
char* str = &amp;quot;hello, world&amp;quot;\n&amp;quot;;&amp;amp;str[i&#43;&#43;]; Ou seja, obtemos o endereço do primeiro caractere da string e incrementamos nossa variável &amp;quot;i&amp;quot; que, como sabemos, é usada no teste do laço for. Na primeira vez, testamos se o primeiro caractere de &amp;quot;] &amp;lt; i; &#43;&#43;i ){--i;}&amp;quot; é diferente de zero. Na segunda iteração, portanto, iremos testar se o segundo caractere será zero. Sabendo disso, podemos deduzir que o laço irá correr por todos os caracteres da string de teste, até encontrar o zero finalizador de string. Ao mesmo tempo, iremos enviar para a função read sempre o endereço do i&#39;ésimo caractere da string &amp;quot;hello, world!\n&amp;quot;, pois essa string também é indexada pela variável &amp;quot;i&amp;quot;.
Isso quer dizer que nosso laço irá terminar exatamente no final de ambas as strings! (Note, que para comparar as strings, usamos as strings originais do programa, sem melhorar a formatação).
&amp;quot;] &amp;lt; i ; &#43; &#43; i ) { - - i ; }&amp;quot;1 2 3 4 5 6 7 8 9 0 1 2 3 4&amp;quot;h e l l o , w o r l d ! \n&amp;quot; Também devemos lembrar que o caractere de controle &#39;\n&#39; é representado apenas por um byte, apesar de no fonte parecer dois.
Em um passado bem longínquo, o padrão ANSI C não existia, e outras funções dominavam o ambiente UNIX. Muitas dessas funções foram adaptadas, e outras completamente copiadas para a formação do padrão. No entanto, ainda que o padrão não tenha colocado algumas funções clássicas, elas continuaram sendo usadas e suportadas. Um bom exemplo disso são as funções read e write, que, apesar de não estarem no padrão, estão no livro de K&amp;amp;R, no capítulo sobre fluxos (streams) em UNIX, provando que são bem populares.
Dentro desse mundo paralelo, existem identificadores de fluxos padrões para a entrada e a saída padrão. Melhor ainda, esses identificadores são inteiros que estão especificados da seguinte maneira (tirado da referência GNU da linguagem C, meu grifo):
 There are also symbolic constants defined in unistd.h for the file descriptors belonging to the standard streams stdin, stdout, and stderr; see Standard Streams.
STDIN_FILENO This macro has value 0, which is the file descriptor for standard input.
STDOUT_FILENO This macro has value 1, which is the file descriptor for standard output.
STDERR_FILENO This macro has value 2, which is the file descriptor for standard error output.
 Agora podemos voltar ao fonte. Vejamos como é implementada a função read, chamada dentro do laço for. Como todos sabem, se uma função já é definida em sua própria unidade, não haverá uma busca por referências externas, o que quer dizer que a implementação padrão de read não atrapalha a implementação local.
read(j, i, p){write(j / p &#43; p, i-- - j, i / i);} Ótimo. A função read chama a função (essa sim, padrão) write. Sabemos que tanto o primeiro quanto o último parâmetro da função será sempre constante no laço for:
read(0, i&#43;&#43; &#43; &amp;quot;hello, world!\n&amp;quot;, 1) O que quer dizer que o primeiro argumento passado para write será sempre o mesmo:
j == 0;p == 1;j / p &#43; p == 1; Além da constante óbvia passada no último argumento:
i / i = 1; /* independente de i */ Isso quer dizer que a chamada para write pode ser resumida para:
write(1, i-- - j, 1); O decremento da variável &amp;quot;i&amp;quot; (dentro de read) nunca é usado, uma vez que é uma variável local. E subtrair &amp;quot;j&amp;quot; é inócuo, uma vez que o valor de &amp;quot;j&amp;quot; será sempre zero. Logo, o argumento do meio é sempre o parâmetro do meio, por mais idiota que isso possa parecer =)
write(1, i, 1); Pronto, já temos condições de interpretar o significado dessa chamada à write. Como já vimos, o número 1 identifica a saída padrão, o que quer dizer que estamos escrevendo algo na saída padrão. Esse algo é o parâmetro &amp;quot;i&amp;quot; que, como vimos, é o endereço do i&#39;ésimo caractere da string &amp;quot;hello, word!\n&amp;quot;. O último argumento é o número de bytes a serem escritos, que será sempre um. O que quer dizer que o laço em for chamada a função read strlen(&amp;quot;hello, world!\n&amp;quot;) vezes passando o endereço do próximo caractere de cada vez. A função read, por sua vez, escreve este caractere na saída padrão. O resultado, como todos que compilarem o fonte e rodarem poderão comprovar, é a impressão da mensagem mais famosa do mundo da computação:
hello, world! E voilà =)
Abaixo um código-fonte equivalente, devidamente desencriptado:
int i = 0;main(){char* indexString = &amp;quot;]&amp;lt;i;&#43;&#43;i){--i;}&amp;quot;;char* outputString = &amp;quot;hello, world!\n&amp;quot;;for( ; indexString[i] != 0; read(&amp;amp;outputString[i&#43;&#43;]) );}read(outStr){write(1, outStr, 1);} </description>
</item>

     
        <item>
  <title>Silly regex trick: finding the project who failed inside a big VS solution</title>
  <link>http://www.caloni.com.br/silly-regex-trick-finding-the-project-who-failed-inside-a-vs-big-solution/</link>
  <pubDate>2008-02-07</pubDate>
  
  <guid>http://www.caloni.com.br/silly-regex-trick-finding-the-project-who-failed-inside-a-vs-big-solution/</guid>
  <description>I know what you going to think about this one: &amp;quot;silly trick&amp;quot;. That&#39;s why I just put it in the title. Anyway, that is something I use everyday, so I thought it might be useful to who cares about productivity.
Let&#39;s say you have to manage a big solution in Visual Studio made of more than 30 projects, and needs to rebuild all them. Suddenly, something goes wrong. The question is: how to discover, in a heartbeat, what project has failed?
Note that you need to enable &amp;quot;Regular Expressions&amp;quot; option in the Find Dialog (not shown here).
What I&#39;m saying inside this regex is &amp;quot;find the first number different from zero followed by a space and the letters err&amp;quot;. This lead us to the first project who has at least one error:
------ Build started: Project: FailedProj, Configuration: Release Win32 ------Compiling...stdafx.cppCompiling...FailedProj.cppFailedProj.cpp(2477) : error C2039: &#39;Blablabla&#39; : is not a member of &#39;IBlabla&#39;Build log was saved at &amp;quot;file://c:Projects...ReleaseBuildLog.htm&amp;quot;FailedProj - 2 error(s), 0 warning(s) If you think &amp;quot;what about when a project generates more than 9 errors? the regex wouldn&#39;t be able to catch this case&amp;quot;, well, you&#39;re right. Anyway, that&#39;s the quicker form to search for the unsuccessful project inside a big solution. A more complex yet complete regex would be:
[1-9][0-9]* err For me, the first version is enough. It is faster to type, simpler to catch and solves my problem. I hope it can solve yours =)
</description>
</item>

     
        <item>
  <title>Process Monitor e o monopólio malcriado</title>
  <link>http://www.caloni.com.br/process-monitor-e-o-monopolio-malcriado/</link>
  <pubDate>2008-02-05</pubDate>
  
  <guid>http://www.caloni.com.br/process-monitor-e-o-monopolio-malcriado/</guid>
  <description>Uma das primeiras regras que aprendemos para manter a integridade do Windows é utilizá-lo somente com a conta de usuários restritos, o que evitaria, por exemplo, que um programa mal-intencionado instale um serviço ou driver, que teriam acesso às partes íntimas do sistema operacional.
Essa é uma regra básica, mas não é fácil de cumpri-la. Só quem já tentou fazer isso sabe do que estou falando. Inúmeros programas mal-escritos vão tentar, de uma hora pra outra, acessar áreas do sistema de arquivos e registro que não possuem acesso, pois agora estão rodando em uma conta mais restrita. E não são programas de administração ou manutenção do sistema. Estou falando de programas de escritório e jogos. Aqui vai um singelo exemplo que tive que lidar esse fim-de-semana.
Primeiramente, quero deixar bem claro que jogamos Monopoly por mais ou menos dois meses sem ter qualquer tipo de problema, em três computadores diferentes. Até que resolvemos usar uma conta mais restrita. Foi o bastante para o programinha inocente começar a chiar.
Mau garoto. Bons tempos em que quando um jogo travava o máximo que tínhamos que fazer era apertar um botão.
Para encontrar problemas desse tipo, sempre uso o Process Monitor, que tem virado minha ferramenta básica para muitas coisas. Para os que não conhecem, o Process Monitor é uma ferramenta de auditoria de operações no sistema operacional, ou seja, tudo que alguém ler e escrever em arquivos e no registro será logado.
Sua função é mostrar tudo, absolutamente tudo que o sistema está fazendo em um determinado espaço no tempo. Isso pode ser ruim por um lado, já que será bem difícil encontrar alguma informação útil no meio de tanto lixo que pode ser gerado em um log de poucos momentos. Para ter uma idéia do que eu estou falando, tente abrir o Procmon sem qualquer filtro e deixá-lo rodando por 30 segundos sem fazer nada. No meu sistema isso deu aproximadamente 20 mil linhas de eventos de log. Nada mau para um sistema ocioso.
É por isso que ele vem &amp;quot;de fábrica&amp;quot; já com uma série de filtros, que evitam lotar o log de eventos com informação sempre gerada pelo sistema, mas quase sempre inútil. Além dos filtros-padrão, podemos inserir nossos próprios filtros. É isso que faremos aqui para pegar o monopólio malcriado (sem trocadilhos).
Como podemos ver, iremos mostrar em nosso log todos os eventos cujo nome do processo seja monopolyclassic.exe (o nosso amigo faltoso) e iremos excluir do log qualquer evento cujo resultado tenha sido sucesso (se deu certo, provavelmente não é um erro).
Executamos novamente o jogo, dessa vez com o Process Monitor capturando todos seus movimentos.
Agora, uma pequena ressalva: eu estou cansado de ver isso, mas para quem nunca viu, pode não ser tão óbvio. Como eu disse no início do artigo, programas mal-escritos costumam tentar acessar áreas do sistema que não são acessíveis para usuários comuns. Isso quer dizer que, se o problema que está acontecendo com o jogo tem a ver com essa peculiaridade, a primeira coisa a procurar é por erros de acesso negado.
A primeira busca retorna uma chave no registro referente às propriedades de joystick. Como não estou usando joysticks, podemos ignorar este erro por enquanto e passar adiante.
MonopolyClassic.exe CreateFile	C:\Documents and ...\TikGames\Monopoly NAME COLLISIONMonopolyClassic.exe CreateFile	C:\Arquivos de programas\GameHouse\Monopoly Classic\Monopoly.log ACCESS DENIEDMonopolyClassic.exe QueryOpen	C:\Arquivos de programas\GameHouse\Monopoly Classic\DBGHELP.DLL NAME NOT FOUNDMonopolyClassic.exe RegOpenKey	HKLM\Software\Microsoft\...\DBGHELP.DLL NAME NOT FOUND O próximo erro diz respeito a uma tentativa de acesso ao arquivo Monopoly.log localizado no diretório de instalação do jogo, o que já é mais sugestivo. Podemos fazer um pequeno teste alterando o acesso desse arquivo.
C:\Arquivos de programas\GameHouse\Monopoly Classic&amp;gt;cacls Monopoly.logC:\Arquivos de programas\GameHouse\Monopoly Classic\Monopoly.log BUILTIN\Usuários:RBUILTIN\Administradores:FAUTORIDADE NT\SYSTEM:FMITY\Caloni:FC:\Arquivos de programas\GameHouse\Monopoly Classic&amp;gt; Como podemos ver, o que é muito natural, um arquivo dentro da pasta de instalação de programas permite acesso de somente leitura para usuários comuns a seus arquivos, inclusive o Monopoly.log. Para fazer o teste, podemos simplesmente adicionar controle total a apenas esse arquivo, e rodar novamente o jogo.
&amp;gt;cacls Monopoly.log /E /G Usuários:Farquivo processado: C:\Arquivos de programas\GameHouse\Monopoly Classic\Monopoly.logC:\Arquivos de programas\GameHouse\Monopoly Classic&amp;gt;cacls Monopoly.logC:\Arquivos de programas\GameHouse\Monopoly Classic\Monopoly.log BUILTIN\Usuários:FBUILTIN\Administradores:FAUTORIDADE NT\SYSTEM:FMITY\Caloni:FC:\Arquivos de programas\GameHouse\Monopoly Classic&amp;gt;start monopolyclassic.exe Ora essa, estou conseguindo rodar o jogo! Isso quer dizer que nosso único problema, o acesso a esse arquivo, foi resolvido. Sabendo que um arquivo de log provavelmente não será executado por nenhuma conta privilegiada, podemos deixá-lo com acesso irrestrito para todos.
Para ter certeza que isso resolveu o problema, uma segunda auditoria de execução executada pelo Process Monitor pode nos revelar mais detalhes.
MonopolyClassic.exe QueryStandardInformationFile C:\Documents ...\Monopoly\save.gcf SUCCESSMonopolyClassic.exe ReadFile C:\Documents ...\Monopoly\save.gcf SUCCESSMonopolyClassic.exe CloseFile C:\Documents ...\Monopoly\save.gcf SUCCESSMonopolyClassic.exe CreateFile C:\Arquivos de programas\GameHouse\Monopoly Classic\Monopoly.log SUCCESSMonopolyClassic.exe CreateFile C:\Arquivos de programas\GameHouse\Monopoly Classic SUCCESSMonopolyClassic.exe CloseFile C:\Arquivos de programas\GameHouse\Monopoly Classic SUCCESSMonopolyClassic.exe WriteFile C:\Arquivos de programas\GameHouse\Monopoly Classic\Monopoly.log SUCCESS Moral da história: se algum dia você vier a escrever um programa inocente, deixe que pessoas inocentes consigam utilizá-lo.
</description>
</item>

     
        <item>
  <title>Compartilhando variáveis com o mundo v2</title>
  <link>http://www.caloni.com.br/compartilhando-variaveis-com-o-mundo-v2/</link>
  <pubDate>2008-02-01</pubDate>
  
  <guid>http://www.caloni.com.br/compartilhando-variaveis-com-o-mundo-v2/</guid>
  <description>Nota de desempenho: esse artigo finaliza (finalmente) a republicação de todos os artigos do antigo blogue. Isso quer dizer que a partir de agora eu sou obrigado a trabalhar, e, se quiser manter meu ritmo atual, vou ter que fazer mais do que cinco cliques do mouse.
Como todas as coisas que fazemos e pensamos depois, descobrimos que sempre existe uma outra maneira de fazer a mesma coisa. Se é melhor ou não, pode ser uma questão de gosto, estética, objetivos de vida, etc. Com a implementação das variáveis mapeadas globais não foi diferente. Bem, é isso que se espera fazer com código experimental: experimentos. E deu no que deu: SharedVar versão 2.0 alpha Enterprise Edition.
Quando comentei no final do artigo anterior que existem pessoas que só conseguem gerar código dentro de uma classe, não estava brincando. Existem linguagens, inclusive, que suportam apenas o paradigma de orientação a objetos, e levam isso muito a sério. C&#43;&#43; com certeza não é uma dessas linguagens, o que quer dizer que você tem a liberdade e a responsabilidade de tomar o melhor caminho para determinado problema.
Nessa segunda solução do nosso programa alocador de variáveis globais, pra variar, vamos utilizar uma classe. E pra entrar de vez no mundo POO vamos utilizar de quebra tratamento de erro orientado a exceções. Como vamos notar, aplicadas adequadamente, essas duas características da linguagem conseguirão um código mais simples de entender, embora não se possa dizer o mesmo da implementação &amp;quot;under the hood&amp;quot;.
/** Classe helper para as nossas funções de alocação de variáveiscompartilhadas com o mundo. */template&amp;lt;typename T&amp;gt;class SharedVar{public:// se conseguir, parabéns; senão, retorna BUM!SharedVar(PCTSTR varName){m_memPointer = 0;m_memHandle = AllocSharedVariable(&amp;amp;m_memPointer, varName);if( ! m_memHandle || ! m_memPointer )throw GetLastError();}// libera recursos alocados para a variável~SharedVar(){FreeSharedVariable(m_memHandle, m_memPointer);}T&amp;amp; operator * (){return *m_memPointer;}private:// não vamos nos preocupar com isso agoraSharedVar(const SharedVar&amp;amp; obj);SharedVar&amp;amp; operator = (const SharedVar&amp;amp; obj);T* m_memPointer;HANDLE m_memHandle;};  Como podemos notar, em programação &amp;quot;nada se cria, tudo se reutiliza&amp;quot;. Reutilização é boa quando podemos acrescentar características adicionais ao código sem deturpar seu objetivo original. E isso é bom.
Note que nossa classe tenta fazer as coisas logo no construtor, já que seu único objetivo é representar uma variável da memória cachê. Se ela não for bem-sucedida em sua missão, ela explode, porque não há nada que ela possa fazer para garantir a integridade do objeto sendo criado e ela não tem como saber qual o melhor tratamento de erro para o usuário da classe. Geralmente o melhor - ou pelo menos o mais adequado - é o tratamento que o usuário dá ao seu código, porque o usuário da classe é que deve saber o contexto de execução do seu código.
Bem, como o código agora está em uma classe e o erro é baseado em exceção, o código cliente muda um pouco:
/** Exemplo de como usar as funções de alocação de memória compartilhadaAllocSharedVariable, OpenSharedVariable e FreeSharedVariable.*/int _tmain(int argc, PTSTR argv[]){try{// passou algum parâmetro: lê a variável compartilhada e exibeif( argc &amp;gt; 1 ){system(&amp;quot;pause&amp;quot;);// array de 100 TCHARsSharedVar&amp;lt;TCHAR [100]&amp;gt; sharedVar(_T(SHARED_VAR));_tprintf(_T(&amp;quot;Frase secreta: \&#39;%s\&#39;\n&amp;quot;), *sharedVar);_tprintf(_T(&amp;quot;Pressione &amp;lt;enter&amp;gt; para retornar...&amp;quot;));getchar();}else // não passou parâmetro: escreve na variável // compartilhada e chama nova instância{// array de 100 TCHARsSharedVar&amp;lt;TCHAR [100]&amp;gt; sharedVar(_T(SHARED_VAR));PTSTR cmd = new TCHAR[ _tcslen(argv[0]) &#43; 10 ];_tcscpy(cmd, _T(&amp;quot;\&amp;quot;&amp;quot;));_tcscat(cmd, argv[0]);_tcscat(cmd, _T(&amp;quot;\&amp;quot; 2&amp;quot;));_tcscpy(*sharedVar,_T(&amp;quot;Vassora de sa, vassora de su, vassora de tuturuturutu!&amp;quot;));_tsystem(cmd);delete [] cmd;}}catch(DWORD err){_tprintf(_T(&amp;quot;Erro %08X.\n&amp;quot;), err);}return 0;}  Existem duas mudanças significativas: 1. a variável sozinha já representa a memória compartilhada; 2. o tratamento de erro agora é centralizado em apenas um ponto. Se pra melhor ou pior, eu não sei. Tratamento de exceções e classes são duas &amp;quot;modernisses&amp;quot; que podem ou não se encaixar em um projeto de desenvolvimento. Tudo vai depender de tudo. Por isso a melhor saída depende de como será a entrada.
</description>
</item>

     
        <item>
  <title>Compartilhando variáveis com o mundo</title>
  <link>http://www.caloni.com.br/compartilhando-variaveis-com-o-mundo/</link>
  <pubDate>2008-01-30</pubDate>
  
  <guid>http://www.caloni.com.br/compartilhando-variaveis-com-o-mundo/</guid>
  <description>Desde que comecei a programar, para compartilhar variáveis entre processo é meio que consenso usar-se a milenar técnica do crie uma seção compartilhada no seu executável/DLL. Isso funciona desde a época em que o Windows era em preto e branco. Mas, como tudo em programação, existem mil maneiras de assar o pato. Esse artigo explica uma delas, a não-tão-milenar técnica do use memória mapeada nomeada misturada com templates.
Era comum (talvez ainda seja) fazer um código assim:
// aqui definimos uma nova seção (note o &#39;shared&#39; usado como atributo)#pragma section(&amp;quot;shared&amp;quot;, read, write, shared)// um conjunto de variáveis agrupadas para facilitar o compartilhamentostruct EstruturaDoCoracao{int meuIntPreferido;char meuCharAmigo;double meuNumeroDePontoFlutuanteCamarada;};// uma instância da struct acima para podermos usar nos processo amigos__declspec(allocate(&amp;quot;shared&amp;quot;)) EstruturaDoCoracao g_coracao;int main(){g_coracao.meuCharAmigo = &#39;C&#39;;g_coracao.meuIntPreferido = 42;g_coracao.meuNumeroDePontoFlutuanteCamarada = 3.14159265358979323846264338;}  Aquele pragma do começo garante que qualquer instância do mesmo executável, mas processos distintos, irão compartilhar qualquer variável definida dentro da seção &amp;quot;shared&amp;quot;. O nome na verdade não importa muito - é apenas usado para clareza - , mas o atributo do final, sim.
Algumas desvantagens dessa técnica são:
 Não permite compartilhamento entre executáveis diferentes, salvo se tratar-se de uma DLL carregada por ambos. É um compartilhamento estático, que permanece do início do primeiro processo ao fim do último. Não possui proteção, ou seja, se for uma DLL, qualquer executável que a carregar tem acesso à área de memória.  Muitas vezes essa abordagem é suficiente, como em hooks globais, que precisam apenas de uma ou duas variáveis compartilhadas. Também pode ser útil como contador de instâncias, do mesmo jeito que usamos as variáveis estáticas de uma classe em C&#43;&#43; (vide shared_ptr do boost, ou a CString do ATL, que usa o mesmo princípio).
Houve uma vez em que tive que fazer hooks direcionados a threads específicas no sistema, onde eu não sabia nem qual o processo host nem quantos hooks seriam feitos. Essa é uma situação onde fica muito difícil usar a técnica milenar.
Foi daí que eu fiz um conjunto de funções alfa-beta de compartilhamento de variáveis baseado em template e memória mapeada:
#pragma once#include &amp;lt;windows.h&amp;gt;#include &amp;lt;tchar.h&amp;gt;/** Aloca uma variável em memória mapeada, permitindo a qualquer processocom direitos enxergá-la e alterá-la.*/template&amp;lt;typename T&amp;gt;HANDLE AllocSharedVariable(T** pVar, PCTSTR varName){DWORD varSize = sizeof(T);HANDLE ret = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,0, varSize, varName);if( ret ){*pVar = (T*) MapViewOfFile(ret, FILE_MAP_ALL_ACCESS, 0, 0, 0);if( ! *pVar ){DWORD err = GetLastError();CloseHandle(ret);SetLastError(err);}}else*pVar = NULL;return ret;}/** Abre uma variável que foi criada em memória mapeada, permitindo aoprocesso atual enxergar e alterar uma variável criada por outro processo.*/template&amp;lt;typename T&amp;gt;HANDLE OpenSharedVariable(T** pVar, PCTSTR varName){DWORD varSize = sizeof(T);HANDLE ret = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, varName);if( ret ){*pVar = (T*) MapViewOfFile(ret, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, varSize);if( ! *pVar ){DWORD err = GetLastError();CloseHandle(ret);ret = NULL;SetLastError(err);}}else*pVar = NULL;return ret;}/** Libera visualização de uma variável em memória mapeada. Quando o último processoliberar a última visualização, a variável é eliminada da memória.*/template&amp;lt;typename T&amp;gt;VOID FreeSharedVariable(HANDLE varH, T* pVar){if( pVar )UnmapViewOfFile(pVar);if( varH )CloseHandle(varH);}  Como pode-se ver, o seu funcionamento é muito simples: uma função-template que recebe uma referência para um ponteiro de ponteiro do tipo da variável desejada, o seu nome global e retorna uma variável alocada na memória de cachê do sistema. Como contraparte existe uma função que abre essa memória baseada em seu nome e faz o cast (coversão de tipo) necessário. Ambas as chamadas devem chamar uma terceira função para liberar o recurso.
O segredo para entender mais detalhes dessa técnica é pesquisar as funções envolvidas: CreateFileMapping, OpenFileMapping, MapViewOfFile e UnmapViewOfFile. Bem, o CloseHandle também ;)
Ah, é mesmo! Fiz especialmente para o artigo:
#define _CRT_SECURE_NO_DEPRECATE#include &amp;quot;ShareVar.h&amp;quot;#include &amp;lt;windows.h&amp;gt;#include &amp;lt;tchar.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#define SHARED_VAR &amp;quot;FraseSecreta&amp;quot;/** Exemplo de como usar as funções de alocação de memória compartilhadaAllocSharedVariable, OpenSharedVariable e FreeSharedVariable.*/int _tmain(int argc, PTSTR argv[]){// passou algum parâmetro: lê a variável compartilhada e exibeif( argc &amp;gt; 1 ){system(&amp;quot;pause&amp;quot;);TCHAR (*sharedVar)[100] = 0; // ponteiro para array de 100 TCHARsHANDLE varH = AllocSharedVariable(&amp;amp;sharedVar, _T(SHARED_VAR));if( varH &amp;amp;&amp;amp; sharedVar ){_tprintf(_T(&amp;quot;Frase secreta: &#39;%s&#39;n&amp;quot;), *sharedVar);_tprintf(_T(&amp;quot;Pressione &amp;lt;enter&amp;gt; para retornar...&amp;quot;));getchar();}}else // não passou parâmetro: escreve na variável // compartilhada e chama nova instância{TCHAR (*sharedVar)[100] = 0; // ponteiro para array de 100 TCHARsHANDLE varH = AllocSharedVariable(&amp;amp;sharedVar, _T(SHARED_VAR));if( varH &amp;amp;&amp;amp; sharedVar ){PTSTR cmd = new TCHAR[ _tcslen(argv[0]) &#43; 10 ];_tcscpy(cmd, _T(&amp;quot;\&amp;quot;&amp;quot;));_tcscat(cmd, argv[0]);_tcscat(cmd, _T(&amp;quot;\&amp;quot; 2&amp;quot;));_tcscpy(*sharedVar, _T(&amp;quot;Tuintuintuclaim&amp;quot;));_tsystem(cmd);delete [] cmd;}}return 0;}  Preciso lembrar que essa é uma versão inicial ainda, mas que pode muito bem ser melhorada. Duas idéias interessantes são: parametrizar a proteção da variável (através do SECURITY_ATTRIBUTES) e transformá-la em classe. Uma classe parece ser uma idéia bem popular. Afinal, tem tanta gente que só se consegue programar se o código estiver dentro de uma.
</description>
</item>

     
        <item>
  <title>RmThread: rode código em processo vizinho</title>
  <link>http://www.caloni.com.br/rmthread-rode-codigo-em-processo-vizinho/</link>
  <pubDate>2008-01-28</pubDate>
  
  <guid>http://www.caloni.com.br/rmthread-rode-codigo-em-processo-vizinho/</guid>
  <description>Aproveitando que utilizei a mesma técnica semana passada para desenvolver um vírus para Ethical Hacking, republico aqui este artigo que já está mofando no Code Projet, mas que espero que sirva de ajuda pra muita gente que gosta de fuçar nos internals do sistema. Boa leitura!
RmThread é um projeto que fiz baseado em uma das três idéias do artigo de Robert Kuster em &amp;quot;Three Ways to Inject Your Code into Another Process&amp;quot;. No entanto, não utilizei código algum. Queria aprender sobre isso, pesquisei pela internet, e me influenciei pela técnica CreateRemoteThread com LoadLibrary. O resto foi uma mistura de &amp;quot;chamada de funções certas&amp;quot; e MSDN.
O projeto que fiz é útil para quem precisa rodar algum código em um processo vizinho, mas não quer se preocupar em desenvolver a técnica para fazer isso. Quer apenas escrever o código que vai ser executado remotamente. O projeto de demonstração, RmThread.exe, funciona exatamente como a técnica citada anteriormente. Você diz qual o processo a ser executado e a DLL a ser carregada, e ele inicia o processo e carrega a DLL em seu contexto. O resto fica por conta do código que está na DLL.
Para fazer a DLL, existe um projeto de demonstração que se utiliza de uma técnica que descobri para fazer rodar algum código a partir da execução de DllMain sem ficar escravo de suas limitações (você só pode chamar com segurança funções localizadas na kernel32.dll).
Existem três funções que poderão ser utilizadas pelo seu programa:
/** Run process and get rights for running remote threads. */HANDLE CreateAndGetProcessGodHandle(LPCTSTR lpApplicationName, LPTSTR lpCommandLine);/** Load DLL in another process. */HMODULE RemoteLoadLibrary(HANDLE hProcess, LPCTSTR lpFileName);/** Free DLL in another process. */BOOL RemoteFreeLibrary(HANDLE hProcess, HMODULE hModule);  Eis a rotina principal simplificada demonstrando como é simples a utilização das funções:
//...// Start process and get handle with powers.hProc = CreateAndGetProcessGodHandle(tzProgPath, tzProgArgs);if( hProc != NULL ){// Load DLL in the create process context.HMODULE hDll = RemoteLoadLibrary(hProc, tzDllPath);if( hDll != NULL )RemoteFreeLibrary(hProc, hDll);CloseHandle(hProc);}//...  A parte mais complicada talvez seja o que fazer quando a sua DLL é carregada. Considerando que ao ser chamada em seu ponto de entrada, o código da DLL possui algumas limitações (uma já citada; para mais, vide a ajuda de DllMain no MSDN), fiz uma &amp;quot;execução alternativa&amp;quot;, criando uma thread na função DllMain:
BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){switch( ul_reason_for_call ){case DLL_PROCESS_ATTACH:{DWORD dwThrId;// Fill global variable with handle copy of this thread.BOOL bRes =DuplicateHandle(GetCurrentProcess(),GetCurrentThread(),GetCurrentProcess(),g_hThrDllMain,0,FALSE,0);if( bRes == FALSE )break;// Call function that do the useful stuff with its DLL handle.CloseHandle(CreateThread(NULL,0,RmThread,(LPVOID) LoadLibrary(g_tzModuleName),0,dwThrId));}break;//...  A função da thread, por sua vez, é esperar pela finalização da thread DllMain (temos o handle dessa thread armazenado em g_hThrDllMain), fazer o que tem que fazer, e retornar, liberando ao mesmo tempo o handle da DLL criado para si:
/*** Sample function, called remotely for RmThread.exe.*/DWORD WINAPI RmThread(LPVOID lpParameter){HMODULE hDll = (HMODULE) lpParameter;LPCTSTR ptzMsg = _T(&amp;quot;Congratulations! You called RmThread.dll successfully!&amp;quot;);// Wait DllMain termination.WaitForSingleObject(g_hThrDllMain, INFINITE);//TODO: Put your remote code here.MessageBox(NULL,ptzMsg,g_tzModuleName,MB_OK : MB_ICONINFORMATION);// Do what the function name says.FreeLibraryAndExitThread(hDll, 0);}  A marca TODO é aonde seu código deve ser colocado (você pode tirar o MessageBox, se quiser). Como DllMain já foi previamente executada, essa parte do código está livre para fazer o que quiser no contexto do processo vizinho.
Um detalhe interessante é que é necessária a chamada de FreeLibraryAndExitThread. Do contrário, após chamar FreeLibrary, o código a ser executado depois (um simples return) estaria em um endereço de memória inválido, já que a DLL não está mais carregada. O resultado não seria muito agradável.
Um problema chato (que você poderá encontrar) é que, se a DLL não for carregada com sucesso, não há uma maneira trivial de obter o código de erro da chamada de LoadLibrary. Uma vez que a thread inicia e termina nessa função API, o LastError se perde. Alguma idéia?
</description>
</item>

     
        <item>
  <title>Keychanger de criança</title>
  <link>http://www.caloni.com.br/keychanger-de-crianca/</link>
  <pubDate>2008-01-24</pubDate>
  
  <guid>http://www.caloni.com.br/keychanger-de-crianca/</guid>
  <description>Às vezes na vida a vontade de fazer alguma coisa besta acaba sendo mais forte do que o senso de ridículo. Então, resolvi ressuscitar o quase apodrecido RusKey, um programa que fiz para trocar letras digitadas no teclado. A idéia é muito simples: o sujeito digita &#39;i&#39; e sai um &#39;c&#39;, digita um &#39;f&#39; e sai um &#39;u&#39;, e assim por diante. Se estiver programando e for criar um if, por exemplo, no lugar da palavra if vai aparecer... bom, não é exatamente um if que vai aparecer na tela =).
Mas se analisarmos dessa maneira pode parecer até coisa de &amp;quot;ráquer&amp;quot;, o que certamente não é. Na verdade, se trata de um programa didático que visa ensinar a digitação em leiautes de teclados diferentes do normal em idiomas latinos. Pelo menos essa foi a intenção original.
Na época eu estava às voltas com o leiaute do famoso teclado russo (percebeu a origem do nome do programa?). Eu havia estudado cirílico e estava na hora de pôr em prática no computador. Mas, como quase nunca treinava, quando tentava procurar uma palavra no Babylon ou arriscar uma expressão nas conversas com minha amiga de Moscou me perdia completamente para encontrar as letras. A necessidade é a mãe da invenção e foi aí que começou o desenvolvimento.
Um alfabeto é uma das muitas maneiras de representar as palavras de uma língua por escrito. Uma palavra escrita é um conjunto de letras que representa os sons que usamos para falar essa palavra. Cada som usado é chamado de fonema.
Assim sendo, embora o alfabeto russo seja diferente do alfabeto latino muitos fonemas são compartilhados. Isso quer dizer que podemos pegar algumas letras do cirílico e traduzir diretamente para algumas letras do nosso alfabeto, e outras letras não. Exemplos de letras que podemos fazer isso:
Б == BВ == VГ == GД == D... Porém, após a tradução de uma letra no teclado, a posição dela geralmente não é a mesma posição do nosso teclado. Daí temos uma letra de nosso alfabeto em outro lugar. Se for feita uma tradução aproximada entre os dois alfabetos, nossas letras em um teclado russo ficariam dispostas assim:
Bem diferente do QWERT ASDFG que estamos acostumados, não?
Ao digitar usando esse pseudo-leiaute o treino do leiaute do teclado russo estaria sendo feito mesmo escrevendo com o alfabeto latino. Legal, não? Poderia programar com as letras todas trocadas, porque a saída final é a mesma. Basta treinar os dedos para acertarem as mesmas letras nos novos lugares. Assim, quando precisasse escrever no alfabeto cirílico saberia melhor onde cada letra fica.
A idéia é simples, e o código também não é nada complexo. Só preciso de um EXE e uma DLL. No EXE chamo uma função exportada pela DLL que por sua vez instala um hook de mensagens:
g_hHook = SetWindowsHookEx(WH_GETMESSAGE, HookProc, GetModuleHandle(MODULE_NAME), 0); Nas chamadas da função de callback da DLL, manipulo a mensagem WM_CHAR, que corresponde à digitação de caracteres, para trocar os caracteres originais do teclado pelos caracteres que deveriam existir no recém-inventado formato latino-russo, totalmente fora dos padrões e normas de segurança existentes:
switch( pMsg-&amp;gt;message ){case WM_CHAR:{LPTSTR ptzChar =_tcschr(g_tzRussAlphabet, (TCHAR) pMsg-&amp;gt;wParam);if( ptzChar ){size_t offset = ptzChar - g_tzRussAlphabet;pMsg-&amp;gt;wParam = (WPARAM) g_tzPortAlphabet[offset];}}}  Simples assim. E temos um keylogger que troca caracteres! É impressionante como as coisas mais simples podem se transformar nos momentos mais divertidos de um programador em um feriado.
</description>
</item>

     
        <item>
  <title>Otimização em funções recursivas</title>
  <link>http://www.caloni.com.br/otimizacao-em-funcoes-recursivas/</link>
  <pubDate>2008-01-18</pubDate>
  
  <guid>http://www.caloni.com.br/otimizacao-em-funcoes-recursivas/</guid>
  <description>O livro que estou lendo, Dominando Algoritmo com C, como o próprio nome diz, fala sobre algoritmos em C. Os primeiros capítulos são praticamente uma revisão para quem já programou em C, pois tratam de coisas que programadores com mais de cinco anos de casa devem ter na memória cachê (listas, pilhas, recursão, etc). Porém, tive uma agradável surpresa de achar um truque muito sabido que não conhecia, chamado de tail recursion. Fiz questão de testar nos dois compiladores mais conhecidos e eis o resultado.
Imagine uma função recursiva que calcula o fatorial de um número. Apenas para lembrar, o fatorial de um número n é igual a n * n-1 * n-2 * n-3 até o número 1. Existem implementações iterativas (com um laço for, por exeplo) e recursivas, que no caso chamam a mesma função n vezes.
int factorial(int n){if (n &amp;gt; 1)return factorial(n - 1) * n;elsereturn 1;}int main(){return factorial(1000);} Para ver o overhead de uma função dessas, compilamos com a opção de debug e depuramos no CDB.
&amp;gt;cl /Zi recursive-factorial1.c&amp;gt;cdb recursive-factorial1.exeMicrosoft (R) Windows Debugger Version 6.8.0004.0 X86Copyright (c) Microsoft Corporation. All rights reserved.CommandLine: recursive-factorial1.exeSymbol search path is: SRV*C:\Symbols*\\symbolserver\OSSYMBOLSExecutable search path is:ModLoad: 00400000 0041e000 recursive-factorial1.exeModLoad: 7c900000 7c9b0000 ntdll.dllModLoad: 7c800000 7c8f5000 C:\WINDOWS\system32\kernel32.dll(594.700): Break instruction exception - code 80000003 (first chance)eax=00241eb4 ebx=7ffdb000 ecx=00000000 edx=00000001 esi=00241f48 edi=00241eb4eip=7c901230 esp=0012fb20 ebp=0012fc94 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202ntdll!DbgBreakPoint:7c901230 cc int 30:000&amp;gt; bp factorial*** WARNING: Unable to verify checksum for recursive-factorial1.exe0:000&amp;gt; l&#43;*WARNING: Line information loading disabledSource options are ffffffff:1/t - Step/trace by source line2/l - List source line at prompt4/s - List source code at prompt8/o - Only show source code at prompt0:000&amp;gt; gBreakpoint 0 hit&amp;gt; 2: {0:000&amp;gt; p&amp;gt; 3: if (n &amp;gt; 1)0:000&amp;gt;&amp;gt; 4: return factorial(n - 1) * n;0:000&amp;gt;Breakpoint 0 hit&amp;gt; 2: {0:000&amp;gt;&amp;gt; 3: if (n &amp;gt; 1)0:000&amp;gt;&amp;gt; 4: return factorial(n - 1) * n;0:000&amp;gt;Breakpoint 0 hit&amp;gt; 2: {0:000&amp;gt;&amp;gt; 3: if (n &amp;gt; 1)0:000&amp;gt;&amp;gt; 4: return factorial(n - 1) * n;0:000&amp;gt;Breakpoint 0 hit&amp;gt; 2: {0:000&amp;gt;&amp;gt; 3: if (n &amp;gt; 1)0:000&amp;gt;&amp;gt; 4: return factorial(n - 1) * n;0:000&amp;gt;Breakpoint 0 hit&amp;gt; 2: {0:000&amp;gt;&amp;gt; 3: if (n &amp;gt; 1)0:000&amp;gt;&amp;gt; 4: return factorial(n - 1) * n;0:000&amp;gt;Breakpoint 0 hit&amp;gt; 2: {0:000&amp;gt;&amp;gt; 3: if (n &amp;gt; 1)0:000&amp;gt; kChildEBP RetAddr0012ff28 00401035 recursive_factorial1!factorial&#43;0x30012ff34 00401035 recursive_factorial1!factorial&#43;0x150012ff40 00401035 recursive_factorial1!factorial&#43;0x150012ff4c 00401035 recursive_factorial1!factorial&#43;0x150012ff58 00401035 recursive_factorial1!factorial&#43;0x150012ff64 0040105d recursive_factorial1!factorial&#43;0x150012ff70 00401268 recursive_factorial1!main&#43;0xd0012ffc0 7c816fd7 recursive_factorial1!__tmainCRTStartup&#43;0x15f0012fff0 00000000 kernel32!BaseProcessStart&#43;0x230:000&amp;gt; Ou seja, conforme chamamos a função recursivamente, a pilha tende a crescer. Agora imagine todo o overhead da execução, que precisa, a cada chamada, gerar um stack frame.
A mesma coisa podemos notar se compilarmos o mesmo fonte no GCC e depurarmos pelo GDB. Aliás, a primeira participação especial do GDB nesse blogue =)
$ gcc -g recursive-factorial1.c$ gdb a.exeGNU gdb 6.5.50.20060706-cvs (cygwin-special)Copyright (C) 2006 Free Software Foundation, Inc.GDB is free software, covered by the GNU General Public License, and you arewelcome to change it and/or distribute copies of it under certain conditions.Type &amp;quot;show copying&amp;quot; to see the conditions.There is absolutely no warranty for GDB. Type &amp;quot;show warranty&amp;quot; for details.This GDB was configured as &amp;quot;i686-pc-cygwin&amp;quot;...(gdb) break factorialBreakpoint 1 at 0x401056: file recursive-factorial1.c, line 3.(gdb) runStarting program: /cygdrive/c/temp/a.exeLoaded symbols for /cygdrive/c/WINDOWS/system32/ntdll.dllLoaded symbols for /cygdrive/c/WINDOWS/system32/kernel32.dllLoaded symbols for /usr/bin/cygwin1.dllLoaded symbols for /cygdrive/c/WINDOWS/system32/advapi32.dllLoaded symbols for /cygdrive/c/WINDOWS/system32/rpcrt4.dllBreakpoint 1, factorial (n=1000) at recursive-factorial1.c:33 if (n &amp;gt; 1)(gdb) step4 return factorial(n - 1) * n;(gdb)Breakpoint 1, factorial (n=999) at recursive-factorial1.c:33 if (n &amp;gt; 1)(gdb)4 return factorial(n - 1) * n;(gdb)Breakpoint 1, factorial (n=998) at recursive-factorial1.c:33 if (n &amp;gt; 1)(gdb)4 return factorial(n - 1) * n;(gdb)Breakpoint 1, factorial (n=997) at recursive-factorial1.c:33 if (n &amp;gt; 1)(gdb)4 return factorial(n - 1) * n;(gdb)Breakpoint 1, factorial (n=996) at recursive-factorial1.c:33 if (n &amp;gt; 1)(gdb)4 return factorial(n - 1) * n;(gdb)Breakpoint 1, factorial (n=995) at recursive-factorial1.c:33 if (n &amp;gt; 1)(gdb)4 return factorial(n - 1) * n;(gdb)Breakpoint 1, factorial (n=994) at recursive-factorial1.c:33 if (n &amp;gt; 1)(gdb)4 return factorial(n - 1) * n;(gdb)Breakpoint 1, factorial (n=993) at recursive-factorial1.c:33 if (n &amp;gt; 1)(gdb)4 return factorial(n - 1) * n;(gdb) backtrace#0 factorial (n=993) at recursive-factorial1.c:4#1 0x00401068 in factorial (n=994) at recursive-factorial1.c:4#2 0x00401068 in factorial (n=995) at recursive-factorial1.c:4#3 0x00401068 in factorial (n=996) at recursive-factorial1.c:4#4 0x00401068 in factorial (n=997) at recursive-factorial1.c:4#5 0x00401068 in factorial (n=998) at recursive-factorial1.c:4#6 0x00401068 in factorial (n=999) at recursive-factorial1.c:4#7 0x00401068 in factorial (n=1000) at recursive-factorial1.c:4#8 0x004010b3 in main () at recursive-factorial1.c:11(gdb) Isso acontece porque o compilador é obrigado a montar um novo stack frame para cada chamada da mesma função, já que os valores locais precisam manter-se intactos até o retorno recursivo da função. Porém, existe uma otimização chamada de tail recursion, que ocorre se, e somente se (de acordo com meu livro):
 A chamada recursiva é a última instrução que será executada no corpo da função. O valor de retorno da chamada não é parte de uma expressão.  Note que ser a última instrução não implica em ser a última linha da função, o importante é que seja a última linha executada. No nosso exemplo, isso já é fato, só que usamos o retorno em uma expressão.
return factorial(n - 1) * n;// o retorno da chamada recursiva // é parte de uma expressão Por isso é necessário desenvolver uma segunda versão do código, que utiliza dois parâmetros para que aconteça a situação de tail recursion.
int factorial(int n, int a){if (n &amp;lt; 0)return 0;else if (n == 0)return 1;else if (n == 1)return a;elsereturn factorial(n - 1, n * a);}int main(){return factorial(1000, 1);} Nessa segunda versão, a chamada da função recursiva não mais é parte de uma expressão, e continua sendo a última instrução executada. Agora só temos que compilar com a opção de otimização certa em ambos os compiladores e testar.
Para o Visual Studio, podemos usar a flag /Og (otimização global).
&amp;gt;cl /Zi /Og recursive-factorial2.c&amp;gt;cdb recursive-factorial2.exe...bp factorialg...Breakpoint 0 hiteax=003235f0 ebx=7c80abc1 ecx=00000001 edx=0041c560 esi=00000002 edi=00000a28eip=00401020 esp=0012ff68 ebp=0012ffc0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246recursive_factorial2!factorial:00401020 55 push ebp0:000&amp;gt; l&#43;*WARNING: Line information loading disabledSource options are ffffffff:1/t - Step/trace by source line2/l - List source line at prompt4/s - List source code at prompt8/o - Only show source code at prompt0:000&amp;gt; p&amp;gt; 3: if (n &amp;lt; 0)0:000&amp;gt;&amp;gt; 5: else if (n == 0)0:000&amp;gt;&amp;gt; 7: else if (n == 1)0:000&amp;gt;&amp;gt; 10: return factorial(n - 1, n * a);0:000&amp;gt;&amp;gt; 5: else if (n == 0)0:000&amp;gt;&amp;gt; 7: else if (n == 1)0:000&amp;gt;&amp;gt; 10: return factorial(n - 1, n * a);0:000&amp;gt;&amp;gt; 5: else if (n == 0)0:000&amp;gt;&amp;gt; 7: else if (n == 1)0:000&amp;gt;&amp;gt; 10: return factorial(n - 1, n * a);0:000&amp;gt;&amp;gt; 5: else if (n == 0)0:000&amp;gt;&amp;gt; 7: else if (n == 1)0:000&amp;gt;&amp;gt; 10: return factorial(n - 1, n * a);0:000&amp;gt;&amp;gt; 5: else if (n == 0)0:000&amp;gt;&amp;gt; 7: else if (n == 1)0:000&amp;gt;&amp;gt; 10: return factorial(n - 1, n * a);0:000&amp;gt;&amp;gt; 5: else if (n == 0)0:000&amp;gt;&amp;gt; 7: else if (n == 1)0:000&amp;gt;&amp;gt; 10: return factorial(n - 1, n * a);0:000&amp;gt;&amp;gt; 5: else if (n == 0)0:000&amp;gt;&amp;gt; 7: else if (n == 1)0:000&amp;gt;&amp;gt; 10: return factorial(n - 1, n * a);0:000&amp;gt;&amp;gt; 5: else if (n == 0)0:000&amp;gt;&amp;gt; 7: else if (n == 1)0:000&amp;gt;&amp;gt; 10: return factorial(n - 1, n * a);0:000&amp;gt;&amp;gt; 5: else if (n == 0)0:000&amp;gt;&amp;gt; 7: else if (n == 1)0:000&amp;gt;&amp;gt; 10: return factorial(n - 1, n * a);0:000&amp;gt;&amp;gt; 5: else if (n == 0)0:000&amp;gt; kChildEBP RetAddr0012ff64 0040105c recursive_factorial2!factorial&#43;0x100012ff70 00401266 recursive_factorial2!main&#43;0xc0012ffc0 7c816fd7 recursive_factorial2!__tmainCRTStartup&#43;0x15f0012fff0 00000000 kernel32!BaseProcessStart&#43;0x230:000&amp;gt; Como podemos ver, após n chamadas, a pilha continua apenas com uma chamada a factorial.
Para o GCC, a opção é mais explítica, e funciona da mesma forma.
$ gcc -g -foptimize-sibling-calls recursive-factorial2.c$ gdb a.exe...(gdb) break factorial...(gdb) run...Breakpoint 1, factorial (n=1000, a=0) at recursive-factorial2.c:33 if (n &amp;lt; 0)(gdb) step5 else if (n == 0)(gdb)7 else if (n == 1)(gdb)10 return factorial(n - 1, n * a);(gdb)11 }(gdb)factorial (n=1, a=6695656) at recursive-factorial2.c:1010 return factorial(n - 1, n * a);(gdb)factorial (n=999, a=0) at recursive-factorial2.c:22 {(gdb)Breakpoint 1, factorial (n=999, a=0) at recursive-factorial2.c:33 if (n &amp;lt; 0)(gdb)5 else if (n == 0)(gdb)7 else if (n == 1)(gdb)10 return factorial(n - 1, n * a);(gdb)11 }(gdb)factorial (n=1, a=6695656) at recursive-factorial2.c:1010 return factorial(n - 1, n * a);(gdb)factorial (n=998, a=0) at recursive-factorial2.c:22 {(gdb)Breakpoint 1, factorial (n=998, a=0) at recursive-factorial2.c:33 if (n &amp;lt; 0)(gdb)5 else if (n == 0)(gdb)7 else if (n == 1)(gdb)10 return factorial(n - 1, n * a);(gdb)11 }(gdb)factorial (n=1, a=6695656) at recursive-factorial2.c:1010 return factorial(n - 1, n * a);(gdb)factorial (n=997, a=0) at recursive-factorial2.c:22 {(gdb)Breakpoint 1, factorial (n=997, a=0) at recursive-factorial2.c:33 if (n &amp;lt; 0)(gdb)5 else if (n == 0)(gdb)7 else if (n == 1)(gdb)10 return factorial(n - 1, n * a);(gdb)11 }(gdb)factorial (n=1, a=6695656) at recursive-factorial2.c:1010 return factorial(n - 1, n * a);(gdb)factorial (n=996, a=0) at recursive-factorial2.c:22 {(gdb)Breakpoint 1, factorial (n=996, a=0) at recursive-factorial2.c:33 if (n &amp;lt; 0)(gdb)5 else if (n == 0)(gdb)7 else if (n == 1)(gdb)10 return factorial(n - 1, n * a);(gdb)11 }(gdb)factorial (n=1, a=6695656) at recursive-factorial2.c:1010 return factorial(n - 1, n * a);(gdb) backtrace#0 factorial (n=1, a=6695656) at recursive-factorial2.c:10#1 0x61006198 in dll_crt0_1 () from /usr/bin/cygwin1.dll#2 0x61004416 in _cygtls::call2 () from /usr/bin/cygwin1.dll#3 0x00000000 in ?? ()(gdb) Voilà!
PS: De brinde uma versão que permite passar o número via linha de comando para facilitar os testes (e você vai reparar que há um problema em calcular o fatorial de 1000: ele é estupidamente grande! Resolver isso fica como exercício =).
#include &amp;lt;stdio.h&amp;gt;int factorial(int n, int a){if (n &amp;lt; 0)return 0;else if (n == 0)return 1;else if (n == 1)return a;elsereturn factorial(n - 1, n * a);}int main(int argc, char* argv[]){if( argc == 2 ){int num = atoi(argv[1]);int ret = factorial(num, 1);printf(&amp;quot;factorial %d = %d\n&amp;quot;, num, ret);return ret;}else{printf(&amp;quot;how to use: %s &amp;lt;number&amp;gt;\n&amp;quot;, argv[0]);return 1;}} </description>
</item>

     
        <item>
  <title>Encontrando as respostas do Flash Pops</title>
  <link>http://www.caloni.com.br/encontrando-as-respostas-do-flash-pops/</link>
  <pubDate>2008-01-16</pubDate>
  
  <guid>http://www.caloni.com.br/encontrando-as-respostas-do-flash-pops/</guid>
  <description>Existia uma série de jogos no sítio da UOL chamado Flash Pops onde você deve acertar o nome de filmes, programas de televisão, entre outros, que vão da década de 40 até a atualidade. É divertido e viciante fazer pesquisa na internet para encontrar os resultados, ainda mais quando já se é viciado em cinema. Ficamos jogando, eu e minha namorada, por semanas a fio. Quase chegamos a preencher tudo, e por um bom tempo ficamos travados para terminar. Então começamos a apelar para o Google e o IMDB até os limites do razoável. Nesse fim de semana, por exemplo, chegamos a assistir um filme de madrugada onde tocou rapidamente um trecho de uma das músicas que faltava no jogo sobre televisão. No dia seguinte procuramos a trilha sonora do filme, ouvimos faixa a faixa e procuramos o nome da música no Google, para finalmente encontrar o resultado.
Essa foi a última resposta &amp;quot;honesta&amp;quot;. Depois resolvi apelar para o WinDbg =)
A primeira coisa que pensei a respeito desse jogo foi que ele não seria tão ingênuo a ponto de colocar as respostas em texto aberto, do contrário, qual seria a graça, certo? Errado! Bom, no final das contas, um passo-a-passo bem simples me levou a encontrar a lista de respostas.
A primeira coisa a fazer é carregar o jogo na memória do navegador. Em seguida, seguindo meu raciocínio inicial, digitei a primeira resposta do jogo.
A partir daí, podemos &amp;quot;atachar&amp;quot; o WinDbg no processo do navegador e rastrear a memória do processo.
windbg -pn firefox.exe Então, como eu dizia, não faça isso em casa enquanto estiver digitando um artigo de seu blogue dentro do navegador. Ele vai travar!
windbg %programfiles%\Mozilla Firefox\firefox.exe OK. A primeira coisa é procurar pela string digitada, na esperança de achar a estrutura que escreve as respostas de acordo com a digitação. Isso pode ser feito facilmente graças ao WinDbg e ao artigo de Volker von Einem que ensina como procurar strings por toda a memória de um processo (mais tarde iremos também usar o comando-bônus do comentário de Roberto Farah).
0:017&amp;gt; s -a 0 0fffffff &amp;quot;caca fantasmas&amp;quot;0575f458 63 61 63 61 20 66 61 6e-74 61 73 6d 61 73 00 63 caca fantasmas.c057fb950 63 61 63 61 20 66 61 6e-74 61 73 6d 61 73 00 00 caca fantasmas.. Interessante. Dois resultados. Olhando o primeiro deles, vemos que encontramos o que queríamos sem nem mesmo tentar quebrar alguma chave de criptografia.
0:017&amp;gt; db 0575f4580575f458 63 61 63 61 20 66 61 6e-74 61 73 6d 61 73 00 63 caca fantasmas.c0575f468 61 63 61 2d 66 61 6e 74-61 73 6d 61 73 00 63 61 aca-fantasmas.ca0575f478 c3 a7 61 20 66 61 6e 74-61 73 6d 61 73 00 63 61 ..a fantasmas.ca0575f488 c3 a7 61 2d 66 61 6e 74-61 73 6d 61 73 00 67 68 ..a-fantasmas.gh0575f498 6f 73 74 62 75 73 74 65-72 73 00 41 72 72 61 79 ostbusters.Array0575f4a8 00 6d 75 73 31 00 6a 61-6d 65 73 20 62 6f 6e 64 .mus1.james bond0575f4b8 00 30 30 37 00 6d 75 73-32 00 6d 69 73 73 69 6f .007.mus2.missio0575f4c8 6e 20 69 6d 70 6f 73 73-69 62 6c 65 00 6d 69 73 n impossible.mis O segundo, porém, não parece uma lista de respostas, mas sim a resposta que acabamos de digitar no navegador.
0:017&amp;gt; db 057fb950057fb950 63 61 63 61 20 66 61 6e-74 61 73 6d 61 73 00 00 caca fantasmas..057fb960 5f 6c 65 76 65 6c 30 2f-6d 75 73 36 32 3a 6d 00 _level0/mus62:m.057fb970 00 00 00 00 24 44 82 05-20 40 82 05 32 3a 6d 00 ....$D.. @..2:m.057fb980 00 00 00 00 6c 49 82 05-68 45 82 05 00 00 00 00 ....lI..hE......057fb990 00 00 00 00 b4 4e 82 05-b0 4a 82 05 00 00 00 00 .....N...J......057fb9a0 00 00 00 00 24 74 85 05-20 70 85 05 00 00 00 00 ....$t.. p......057fb9b0 00 00 00 00 6c 79 85 05-68 75 85 05 00 00 00 00 ....ly..hu......057fb9c0 70 6f 72 63 65 6e 74 6f-00 63 65 72 74 61 73 00 porcento.certas. Para se certificar, rodamos novamente o navegador, apagamos a resposta e refazemos a busca.
0:017&amp;gt; g(864.dc0): Break instruction exception - code 80000003 (first chance)eax=7ffda000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005eip=7c901230 esp=03c3ffcc ebp=03c3fff4 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=0038 gs=0000 efl=00000246ntdll!DbgBreakPoint:7c901230 cc int 30:017&amp;gt; s -a 0 0fffffff &amp;quot;caca fantasmas&amp;quot;0575f458 63 61 63 61 20 66 61 6e-74 61 73 6d 61 73 00 63 caca fantasmas.c De fato, a lista de respostas é tudo que encontramos.
Assim como no artigo sobre carregamento de DLLs arbitrárias, vamos usar o muito útil comando .foreach, que caminha em uma lista de resultados de um comando para executar uma lista secundária de comandos. Apenas para relembrar, a sintaxe do foreach é a seguinte:
.foreach [Options] ( Variable { InCommands } ) { OutCommands }  Variable. Um nome que usamos no OutCommands. Representa cada token do resultado de InCommands. InCommands. Um ou mais comandos que executamos para gerar uma saída na tela. Essa saída será usada em OutCommands, onde Variable é substituído por cada token da saída. OutCommands. Um ou mais comandos executados usando a saída na tela de InCommands.  Para o .foreach, um token é uma string separada por espaço(s). A saída dos comandos do WinDbg nem sempre vai gerar algo que podemos usar diretamente, como no caso da busca que fizemos inicialmente. Apenas para demonstração, vamos imprimir todos os tokens da saída de nosso comando.
.foreach ( answerList { s -a 0 0fffffff &amp;quot;caca fantasmas&amp;quot; } ) { .echo answerList }0575f458636163612066616e-7461736d61730063cacafantasmas.c Isso acontece porque ele utilizada cada palavra separada por espaços da saída da busca.
0575f458 63 61 63 61 20 66 61 6e-74 61 73 6d 61 73 00 63 caca fantasmas.c Por isso usamos a flag -[1], que faz com que o comando imprima apenas o endereço onde ele encontrou a string.
0:017&amp;gt; s -[1]a 0 0fffffff &amp;quot;caca fantasmas&amp;quot;0x0575f458 Enfim, vamos ao que interessa. Para imprimir todas as strings que representam as respostas, podemos simplesmente, no OutCommands, fazer uma nova busca por string, só que dessa vez genérica, dentro de uma faixa razoável (digamos, 4KB).
0:006&amp;gt; .foreach ( answerList { s -[1]a 0 0fffffff &amp;quot;caca fantasmas&amp;quot; } ) { s -sa answerList L1000 }059ff458 &amp;quot;caca fantasmas&amp;quot;059ff467 &amp;quot;caca-fantasmas&amp;quot;059ff47a &amp;quot;a fantasmas&amp;quot;059ff48a &amp;quot;a-fantasmas&amp;quot;059ff496 &amp;quot;ghostbusters&amp;quot;059ff4a3 &amp;quot;Array&amp;quot;059ff4a9 &amp;quot;mus1&amp;quot;059ff4ae &amp;quot;james bond&amp;quot;059ff4b9 &amp;quot;007&amp;quot;059ff4bd &amp;quot;mus2&amp;quot;059ff4c2 &amp;quot;mission impossible&amp;quot;059ff4d5 &amp;quot;missao impossivel&amp;quot;059ff4e7 &amp;quot;miss&amp;quot;059ff4ed &amp;quot;o impossivel&amp;quot;059ff4fa &amp;quot;missao imposs&amp;quot;059ff509 &amp;quot;vel&amp;quot;059ff50d &amp;quot;miss&amp;quot;059ff513 &amp;quot;o imposs&amp;quot;059ff51d &amp;quot;vel&amp;quot;059ff521 &amp;quot;mus3&amp;quot;059ff526 &amp;quot;carruagens de fogo&amp;quot;059ff539 &amp;quot;charriots of fire&amp;quot;059ff54b &amp;quot;chariots of fire&amp;quot;... Bom, vou parar o dump por aqui, já que, entre os leitores, pode haver quem queria se divertir primeiro do jeito certo =)
Vimos que o jogo é facilmente quebrável porque armazena as respostas em texto claro. Uma solução alternativa seria utilizar um hash com colisão próxima de zero. Com isso bastaria trocar as respostas possíveis por hashs possíveis e armazená-los no lugar. Quando o usuário digitasse, tudo que o programa precisaria mudar era gerar um hash a partir da resposta do usuário e comparar com o hashs das respostas válidas.
Por uma incrível coincidência, esse truquezinho eu aprendi com meu amigo Thiago há poucos dias, que está lendo o livro Reversing. Simples, porém funcional.
</description>
</item>

     
        <item>
  <title>Analisando Dumps com WinDbg e IDA</title>
  <link>http://www.caloni.com.br/analisando-dumps-com-windbg-e-ida/</link>
  <pubDate>2008-01-10</pubDate>
  
  <guid>http://www.caloni.com.br/analisando-dumps-com-windbg-e-ida/</guid>
  <description>Apesar de ser recomendado que 100% dos componentes de um software esteja configurado corretamente para gerar símbolos na versão release, possibilitando assim a visualização do nome das funções internas através de um arquivo de dump (despejo) gerado na ocorrência de um crash, essa verdade só ocorre em 80% das vezes. Quis Murphy que dessa vez a única parte não &amp;quot;simbolizada&amp;quot; fosse a que gerou a tela azul em um Intel Quad Core que estou analisando esses dias.
Para incluir um programa novo em nosso leque de opções, vamos usar dessa vez uma ferramenta chamada IDA, um disassembler estático cujo nome é uma clara homenagem à nossa primeira programadora da história. E, é lógico, o WinDbg não poderá ficar de fora, já que ele será nosso analisador de dumps.
Tecnicamente falando, um dump nada mais é do que o conjunto de informações relevantes de um sistema em um determinado momento da execução, geralmente logo após um crash, onde tudo pára e morre. No caso do Windows, o crash é chamado de BSOD, Blue Screen Of Death, ou Tela Azul da Morte (bem macabro, não?). Do ponto de vista do usuário, é aquela simpática tela azul que aparece logo após o travamento da máquina.
Em algumas máquinas, essa tela nem mais é vista, pois o Windows XP é configurado automaticamente para exibir um simpático reboot que joga todos os seus dados não-salvos naquele momento para o limbo (ou, como diria meu amigo Thiago, para o &amp;quot;céu dos dados não-salvos antes de uma tela azul&amp;quot;).
Dumps podem ser abertos por um depurador que entenda o tipo de dump gerado (Visual Studio, WinDbg, OllyDbg, IDA, sd, etc). Se estamos falando de aplicativos que travaram, o Visual Studio pode dar conta do recado. Se é realmente uma tela azul, o WinDbg é o mais indicado. Para abrir um dump no WinDbg, tudo que temos que fazer é usar o item do menu &amp;quot;File, Open Crash Dump&amp;quot; ou digitar direto da linha de comando: windbg -z meu-crash-dump-do-coracao.dmp.
Após alguns segundos, o WinDbg irá imprimir uma saída cheia de detalhes parecendo o terminal de um filme de raquerismo. Não se preocupe, com o tempo cada detalhe fará mais sentido (ou não). Geralmente a melhor idéia depois de abrir o dump é seguir o conselho do próprio WinDbg e usar o comando !analyze -v, e mais um monte de informações será plotada na tela. Se o arquivo aberto for um minidump ele irá conter apenas a pilha de chamada que causou a tela azul, o estados dos registradores e algumas informações sobre módulos carregados no kernel. A partir daí podemos extrair algumas informações úteis:
 O código do Bug Check. Esse é talvez o mais importante, pois pode resolver rapidamente o nosso problema. Procurando na ajuda do WinDbg pelo código do erro (obs: execute o link pelo explorer) conseguimos ter algumas dicas de como evitar esse erro: &amp;quot;The MAXIMUMWAITOBJECTSEXCEEDED bug check has a value of 0x0000000C. This indicates that the current thread exceeded the permitted number of wait objects&amp;quot;. Mais sobre isso pra depois. Os dados da pilha. Pela pilha de chamadas, podemos não apenas saber se nosso driver está no meio com cara de culpado, como, através dos offsets, descobrir em que função ele se enfiou para dar no que deu. A última chamada do kernel antes do nosso driver pode indicar-nos que evento foi o responsável por iniciar todo o processo de cabum. Nesse caso, IopLoadDriver nos dá uma ótima dica: foi na hora de carregar o nosso driver.  Com isso em mãos, mesmo sem símbolos e nomes de funções no código, conseguiríamos achar o código responsável pelo BSOD. Porém, vamos imaginar por um momento que não foi tão fácil assim e fazer entrar em cena outra ferramenta indispensável nessas horas: o Interactive Disassembler.
No site do IDA podemos encontrar o download para uma versão gratuita do IDA, isso se usado com objetivos não-comerciais. Ou seja, para você que está lendo esse blogue por aprendizado, não terá nenhum problema você baixar essa versão e fazer alguns testes com seu driver favorito.
O funcionamento básico do IDA é bem básico, mesmo. Simplesmente escolhemos um executável para ele destrinchar e nos mostrar um assembly bem amigável, com todos os nomes de funções que ele puder deduzir. Como não temos os símbolos do próprio executável, as funções internas ganham &amp;quot;apelidos&amp;quot;, como sub6669, loc13F35 e por aí vai. Isso não importa, já que temos nomes amigáveis de APIs para pesquisar no código-fonte e tentar encontrar as funções originais em C.
Pois bem. Como manda o figurino, o primeiro ponto do assembly que temos que procurar é o ponto em que uma função interna é chamada logo após IopLoadDriver, mydriver&#43;0x4058. Por coincidência (ou não, já que essa é a função do IopLoadDriver), se trata da função inicial do executável, ou seja, provavelmente a função DriverEntry no código-fonte (obs: estamos analisando um driver feito para plataforma NT).
No dump que analisei o ponto de retorno é logo após uma chamada à função sub113F0, que não sei qual é. No entanto, o que eu sei é que logo no início é chamada a função IoIsWdmVersionAvailable, o que já nos permite fazer uma correlação com o código-fonte original. Após a chamada à IoIsWdmVersionAvailable, a próxima e última chamada de uma função é o que procuramos. Dessa forma, podemos ir caminhando até o ponto onde o driver chama o sistema operacional.
mydriver&#43;offset:call ds:KeInitializeDpcmov edx, dword_13000...push 1call sub_11BE0push eaxcall sub_117D0.text:000114D7add esi, 0D9Chpush esi...mydriver&#43;offset:push 0...push ebxpush edicall ds:KeWaitForMultipleObjectsmov eax, [esp&#43;30h&#43;var_14]mov edi, ds:ExFreePoolWithTag...mov ecx, [esp&#43;20h]push 0 Por sorte o caminho não foi tão longo e cheguei rapidamente no ponto onde é chamada a função KeWaitForMultipleObject que, de acordo com o WinDbg e com a OSR, pode gerar uma tela azul se esperarmos por mais de três objetos e não especificarmos um buffer no parâmetro WaitBlockArray. Agora podemos olhar no fonte e ver por quantos objetos esperamos e tirar nossa própria conclusão do que está acontecendo.
//...count = 0; // processorsmask = KeQueryActiveProcessors();maskAux = mask;while( maskAux ){if( maskAux &amp;amp; 1 )count&#43;&#43;;maskAux &amp;gt;&amp;gt;= 1;}//...KeWaitForMultipleObjects(count,waitObjects, WaitAll, UserRequest,KernelMode,TRUE,NULL,NULL);ExFreePool(...);ExFreePool(...);ExFreePool(...);//...  Ora, ora. O número de processadores influencia no número de objetos que estaremos esperando na função de espera. Esse seria um bom motivo para gerar um MAXIMUMWAITOBJECTSEXCEEDED em máquinas onde existe mais de 3 processadores ativos, não? Talvez seja uma boa hora para atualizar esse código e torná-lo compatível com os novos Quad Core.
É importante, durantes os testes de desenvolvimento, sempre manter em dia uma versão debug (para o mundo kernel mode, versões checked) para que os primeiros problemas, geralmente os mais bestinhas, sejam pegos de forma rápida e eficiente. No entanto, um bom desenvolvedor não se limita a depurar com código-fonte. Ele deve estar sempre preparado para enfrentar problemas de falta da versão certa, informação pela metade, situação não-reproduzível. Para isso que servem as ferramentas maravilhosas que podemos usar no dia-a-dia. O IDA é mais uma das que deve estar sempre no cinto de utilidades do bom &amp;quot;debugador&amp;quot;.
</description>
</item>

     
        <item>
  <title>Gambi do dia: swap com apenas duas variáveis</title>
  <link>http://www.caloni.com.br/gambi-do-dia-swap-com-apenas-duas-variaveis/</link>
  <pubDate>2007-12-31</pubDate>
  
  <guid>http://www.caloni.com.br/gambi-do-dia-swap-com-apenas-duas-variaveis/</guid>
  <description>Este artigo é uma reedição de meu blogue antigo, guardado para ser republicado durante minhas miniférias. Esteja à vontade para sugerir outros temas obscuros sobre a linguagem C ou C&#43;&#43; de sua preferência. Boa leitura!
Essa interessantíssima questão veio do meu amigo Kabloc: como trocar o valor entre duas variáveis do tipo int sem utilizar uma variável intermediária? O algoritmo ordinário para um swap entre tipos inteiros é:
void normalSwap(int &amp;amp;first, int&amp;amp; second){int third = first;first = second;second = third;}int main(){int first = 13;int second = 42;cout &amp;lt;&amp;lt; &amp;quot;first: &amp;quot; &amp;lt;&amp;lt; first &amp;lt;&amp;lt; &amp;quot;, second: &amp;quot; &amp;lt;&amp;lt; second &amp;lt;&amp;lt; endl;normalSwap(first, second);cout &amp;lt;&amp;lt; &amp;quot;first: &amp;quot; &amp;lt;&amp;lt; first &amp;lt;&amp;lt; &amp;quot;, second: &amp;quot; &amp;lt;&amp;lt; second &amp;lt;&amp;lt; endl;} Saída:first: 13, second: 42first: 42, second: 13 Uma das soluções que eu conheço é utilizar o operador de ou exclusivo, o conhecido XOR. Esse operador binário tem a não pouco bizarra habilidade de armazenar dois padrões de bits dentro de um mesmo espaço de armazenamento. Se você tiver um dos dois padrões, conseguirá o segundo. Relembremos sua tabela verdade:
void xorTable(){cout &amp;lt;&amp;lt; &amp;quot;-----------\n&amp;quot;&amp;lt;&amp;lt; &amp;quot; XOR Table\n&amp;quot;&amp;lt;&amp;lt; &amp;quot;-----------\n&amp;quot;&amp;lt;&amp;lt; &amp;quot;0 XOR 0 = &amp;quot; &amp;lt;&amp;lt; ( 0 ^ 0 ) &amp;lt;&amp;lt; &#39;\n&#39;&amp;lt;&amp;lt; &amp;quot;1 XOR 0 = &amp;quot; &amp;lt;&amp;lt; ( 1 ^ 0 ) &amp;lt;&amp;lt; &#39;\n&#39;&amp;lt;&amp;lt; &amp;quot;0 XOR 1 = &amp;quot; &amp;lt;&amp;lt; ( 0 ^ 1 ) &amp;lt;&amp;lt; &#39;\n&#39;&amp;lt;&amp;lt; &amp;quot;1 XOR 1 = &amp;quot; &amp;lt;&amp;lt; ( 1 ^ 1 ) &amp;lt;&amp;lt; &#39;\n&#39;;} -----------XOR Table-----------0 XOR 0 = 01 XOR 0 = 10 XOR 1 = 11 XOR 1 = 0 Ou seja, imagine que temos o valor 1 e o valor 0. Armazenando os dois juntos com XOR obtemos 1, já que:
1 (primeiro padrão) XOR 0 (segundo padrão) = 1 (padrões juntos) Mais tarde, se quisermos obter o primeiro padrão, usamos o segundo:
1 (padrões juntos) XOR 0 (segundo padrão) = 1 (primeiro padrão) Para obter o segundo padrão é só utilizar o primeiro obtido:
1 (padrões juntos) XOR 1 (primeiro padrão) = 0 (segundo padrão) Calcule a mesma operação com as quatro combinações possíveis e verá que podemos sempre reaver os dados partindo de um dos padrões. Como o cálculo independe do número de bits, já que operadores bit a bit operam um bit de cada vez, podemos usar a mesma técnica para juntar dois inteiros, duas strings, dois &amp;quot;qualquer coisa armazenada numa seqüência de zeros e uns&amp;quot;:
template&amp;lt;typename T1, typename T2, typename T3&amp;gt;void universalXor(const T1&amp;amp; first, const T2&amp;amp; second, T3&amp;amp; result){typedef unsigned char byte;const byte* pFirst = reinterpret_cast&amp;lt;const byte*&amp;gt;(&amp;amp;first);const byte* pSecond = reinterpret_cast&amp;lt;const byte*&amp;gt;(&amp;amp;second);byte* pResult = reinterpret_cast&amp;lt;byte*&amp;gt;(&amp;amp;result);for( size_t i = 0; i &amp;lt; sizeof(first) &amp;amp;&amp;amp; i &amp;lt; sizeof(second);&#43;&#43;i ){pResult[i] = pFirst[i] ^ pSecond[i];}}int main(){int x = 13, y = 42;cout &amp;lt;&amp;lt; &amp;quot;x: &amp;quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot;, y: &amp;quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &#39;\n&#39;;universalXor(x, y, x);universalXor(x, y, y);universalXor(x, y, x);cout &amp;lt;&amp;lt; &amp;quot;x: &amp;quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot;, y: &amp;quot; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &amp;quot;\n\n&amp;quot;;char str1[50] = &amp;quot;teste de xor&amp;quot;;char str2[50] = &amp;quot;aceita strings!&amp;quot;;cout &amp;lt;&amp;lt; &amp;quot;str1: &amp;quot; &amp;lt;&amp;lt; str1 &amp;lt;&amp;lt; &amp;quot;, str2: &amp;quot; &amp;lt;&amp;lt; str2 &amp;lt;&amp;lt; &#39;\n&#39;;universalXor(str1, str2, str1);universalXor(str1, str2, str2);universalXor(str1, str2, str1);cout &amp;lt;&amp;lt; &amp;quot;str1: &amp;quot; &amp;lt;&amp;lt; str1 &amp;lt;&amp;lt; &amp;quot;, str2: &amp;quot; &amp;lt;&amp;lt; str2 &amp;lt;&amp;lt; &#39;\n&#39;;return 0;} Saída:x: 13, y: 42x: 42, y: 13str1: teste de xor, str2: aceita strings!str1: aceita strings!, str2: teste de xor Essa técnica é uma das mais básicas -- se não for a mais -- de criptografia simétrica. O primeiro padrão faz o papel de texto aberto, o segundo banca a senha e o terceiro será o texto encriptado. Para &amp;quot;desencriptar&amp;quot; o texto é necessária a senha (e se você souber qual o texto original, saberá a senha).
Mas, voltando ao nosso problema original, podemos trocar duas variáveis inteiras usando a técnica do XOR. Em claro:
#include &amp;lt;iostream&amp;gt;using namespace std;void anormalSwap(int &amp;amp;first, int&amp;amp; second){first = first ^ second;second = first ^ second;first = first ^ second;}int main(){int first = 13;int second = 42;cout &amp;lt;&amp;lt; &amp;quot;first: &amp;quot; &amp;lt;&amp;lt; first &amp;lt;&amp;lt; &amp;quot;, second: &amp;quot; &amp;lt;&amp;lt; second &amp;lt;&amp;lt; endl;anormalSwap(first, second);cout &amp;lt;&amp;lt; &amp;quot;first: &amp;quot; &amp;lt;&amp;lt; first &amp;lt;&amp;lt; &amp;quot;, second: &amp;quot; &amp;lt;&amp;lt; second &amp;lt;&amp;lt; endl;} Saída:first: 13, second: 42first: 42, second: 13 Bom, preciso dizer que isso é uma gambi das grossas? Preciso dizer que não uso isso no meu dia a dia, até porque swap é uma função já consagrada da STL chamada std::swap? Não? Então sem Postscript dessa vez. E sem bois-cornetas =).
</description>
</item>

     
        <item>
  <title>Curiosidades inúteis: o operador de subscrito em C&#43;&#43;</title>
  <link>http://www.caloni.com.br/curiosidades-inuteis-o-operador-de-subscrito-em-c/</link>
  <pubDate>2007-12-27</pubDate>
  
  <guid>http://www.caloni.com.br/curiosidades-inuteis-o-operador-de-subscrito-em-c/</guid>
  <description>Este artigo é uma reedição de meu blogue antigo, guardado para ser republicado durante minhas miniférias. Esteja à vontade para sugerir outros temas obscuros sobre a linguagem C ou C&#43;&#43; de sua preferência. Boa leitura!
Em C e C&#43;&#43; as regras de sintaxe são extremamente flexíveis. Essa liberdade toda se manteve no decorrer dos tempos porque se trata de uma das idéias fundamentais da linguagem C, motivo de sua criação. Me lembro certa vez que, bitolado em C Standard 89, usei uma sintaxe não lá muito usual para acessar um elemento de um array. Foi apenas um experimento de estudante, coisa que nunca vi em código algum e queria comprovar.
As regras de acesso a elementos de um array (subscrito) são definidas não em termos do array, mas em termos de um ponteiro e de um índice. &amp;quot;Me dê um ponteiro para T e um inteiro e te retorno um lvalue do tipo T&amp;quot;. Essa é a idéia geral. A mesma idéia, com pequenas alterações, se manteve em C&#43;&#43;. Eis parte do parágrafo que fala sobre isso:
 A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type &amp;quot;pointer to T&amp;quot; and the other shall have enumeration or integral type. The result is an lvalue of type &amp;quot;T&amp;quot;. (...) The expression E1 [ E2 ] is identical (by definition) to *( (E1) &#43; (E2) ).
C&#43;&#43;: International Standard ISO/IEC 14882 First Edition 1998-09-01
 Isso traduzido em miúdos quer dizer que com duas expressões formando a construção E1 [ E2 ], sendo uma delas do tipo ponteiro para um tipo e a outra do tipo integral, o resultado é equivalente a *( (E1) &#43; (E2) ). Como no código abaixo:
#include &amp;lt;iostream&amp;gt;int main(){char ditado[] = &amp;quot;Diga-me com que programas e eu te direi quem és.&amp;quot;;int indice = 8;std::cout &amp;lt;&amp;lt; &amp;quot;E a linguagem é: &amp;quot; &amp;lt;&amp;lt; ditado[indice] &amp;lt;&amp;lt; std::endl;}  A teoria comprovada na prática: temos duas expressões no formato E1 [ E2 ] sendo uma do tipo ponteiro para char e a outra do tipo int, exatamente como a regra define. O detalhe obscuro que permaneceu durante a evolução dessas duas linguagens é que a regra de acesso a elementos não define a ordem das expressões. Assim sendo, me aproveito dessa flexibilidade e inverto os elementos do subscrito:
std::cout &amp;lt;&amp;lt; &amp;quot;E a linguagem é: &amp;quot; &amp;lt;&amp;lt; indice[ditado] &amp;lt;&amp;lt; std::endl; Isso também compila e tem o mesmo resultado, pois também é equivalente a *( (E1) &#43; (E2) ). No final dá na mesma. E do jeito que está a inversão nem dá tanto susto assim, pois estamos lidando com duas variáveis. A coisa começa a ficar mais IOCCC se colocarmos em vez de uma delas uma constante:
std::cout &amp;lt;&amp;lt; &amp;quot;E a linguagem é: &amp;quot; &amp;lt;&amp;lt; 8[ditado] &amp;lt;&amp;lt; std::endl; Isso ainda é válido, certo? Os tipos das expressões estão de acordo com a regra. Fica simples de visualizar se sempre pensarmos no &amp;quot;equivalente universal&amp;quot; *( (E1) &#43; (E2) ). Até coisas bizarras como essa acabam ficando simples:
std::cout &amp;lt;&amp;lt; 5[&amp;quot;Isso Compila?&amp;quot;] &amp;lt;&amp;lt; std::endl; Nota do autor: esse tipo de &amp;quot;recurso obscuro&amp;quot; dificilmente passará por uma revisão de código, e com razão, dado que não é um método útil e muito menos conhecido. Sábio é saber evitar. Não acredito, porém, que o conhecimento de certos detalhes da linguagem em que se programa sejam completamente inúteis. Conhecimento nunca é demais, pois quanto mais se conhece maior é o número de ferramentas conceituais que se dispõe para resolver um certo problema. Em muitas vezes o &amp;quot;conhecimento inútil&amp;quot; de hoje se torna um guia sábio quando se precisa de bons conceitos sobre a coisa toda. No entanto, que não venha um boi-corneta me dizer que esse código fere as boas práticas de programação. Tenho dito.
</description>
</item>

     
        <item>
  <title>O que acontece quando o contador estoura</title>
  <link>http://www.caloni.com.br/o-que-acontece-quando-o-contador-estoura/</link>
  <pubDate>2007-12-25</pubDate>
  
  <guid>http://www.caloni.com.br/o-que-acontece-quando-o-contador-estoura/</guid>
  <description>Dois conceitos de programação relacionados a limites computacionais são bem conhecidos do programador: o famigerado overflow e o não-tão-famoso underflow (embora seja fácil imaginar que ele é o oposto do primeiro). O primeiro ocorre quando somamos a uma variável inteira não-nula um valor cujo resultado não consegue ser representado pelo tamanho de memória usado para armazenar esse tipo inteiro (que pode ser um caractere, um inteiro curto, inteiro longo e por aí vai). O underflow, por outro lado (outro lado mesmo), é o resultado de uma subtração que não pode ser representado pelo número de bits do seu tipo inteiro.
Nada melhor que um código para ilustrar melhor esses dois ilustres acontecimentos:
#include &amp;lt;limits.h&amp;gt;#include &amp;lt;iostream&amp;gt;int main(){int x = INT_MAX;std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;x = x &#43; 1;std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; std::endl;} Saída:2147483647-2147483648 O indicador de que algo está errado é simples: como diabos foi um número positivo virar negativo, já que eu somei ao invés de subtrair? No entanto, computacionalmente parece extremamente correto: o próximo número após o maior valor positivo possível é o menor número negativo possível.
Nos computadores atuais tudo no final acaba sendo representado por zeros e uns, até o sinal de negativo dos números menores que zero. Por isso mesmo, para que consigamos usar números menores que zero, precisamos gastar um bit para indicar que este número é negativo. Existem muitas representações interessantes, dentre as quais a mais popular acabou sendo a de complemento de dois. A regra é simples:
 Toda representação binária que tiver o bit mais significativo ligado (o bit mais à esquerda) significa um número negativo cujo valor absoluto se obtém invertendo-se o resto dos bits e adicionando um.
 Quando o bit mais à esquerda não está ligado o valor absoluto é ele mesmo; ou seja, é um número positivo, incluindo o zero. Como vamos ver, isso facilita em muito os cálculos para o computador. Para nós, a coisa não fica lá muito difícil. Só precisamos lembrar que, em hexadecimal, todos os valores que tiverem o byte mais significativo igual ou maior que 8 (que é 1000 em binário) é negativo e temos que aplicar o método de complemento de dois para obter seu valor absoluto. Vejamos o valor -8, por exemplo:
 Primeiro temos a representação real (em um byte): 1111 1000. O bit mais significativo está ligado: é um número negativo. Descartamos o sinal, fica 111 1000. Devemos agora inverter todos os bits: 111 1000 se torna 000 0111. Por fim, somamos um: 000 0111 &#43; 1 = 000 1000. Como vimos no parágrafo anterior, 000 1000, ou simplesmente 1000, é 8. Na verdade, -8!  O que significa, na notação complemento de dois, a representação onde estão todos os bits ligados, independente do número de bytes?
Se alterarmos o código acima para imprimir na saída os números hexadecimais, obteremos a seguinte saída:
7fffffff80000000 E o mais legal é que agora sabemos que o primeiro número é o maior valor positivo possível nesse tamanho de int, pois possui todos os bits ligados exceto o bit de sinal. Já o segundo número, o primeiro incrementado de 1, possui todos os bits desligados exceto o bit de sinal: é o menor número negativo possível!
Consegue imaginar como os cálculos são feitos pelo computador? Curioso? Então dê uma olhada na Wikipedia sobre complemento de dois.
</description>
</item>

     
        <item>
  <title>Banco de dados no C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/banco-de-dados-no-c-builder/</link>
  <pubDate>2007-12-21</pubDate>
  
  <guid>http://www.caloni.com.br/banco-de-dados-no-c-builder/</guid>
  <description>Um banco de dados é qualquer lugar onde podemos ler e escrever informação geralmente persistente. Pode ser um arquivo INI, uma estrutura binária ou uma plantação de servidores para fazer busca na internet. O uso de banco de dados em programação é mais que essencial, pois permite que armazenemos os resultados de um processamento e utilizemos esses mesmos resultados em futuras execuções.
Visando preencher algumas lacunas na internet sobre esse tema iremos agora nos aventurar na configuração e uso de um banco de dados no C&#43;&#43; Builder.
 Obs. de camarada: banco de dados pode ser uma coisa bem chata. Contudo, a vida não é completa sem as partes chatas. O conhecimento dessa área é vital para a sobrevivência de muito desenvolvedores de software. Além do mais, pode se tornar bem mais interessante em algumas situações, como o estudo sobre normalização.
 Quase como um prêmio de consolação por participarmos de um sorteio que sabemos que não iremos ganhar nunca, a Caixa Econômica Federal generosamente oferece a opção de baixarmos todos os resultados da Mega Sena desde seu início. Iremos utilizar esse banco de dados para criar uma interface de visualização de resultados no C&#43;&#43; Builder.
Um problema inicial está no fato que o arquivo está no formato HTML, um formato mais difícil de usarmos no C&#43;&#43; Builder. Portanto, irei converter este formato em algo mais maleável, como um arquivo do Microsoft Access, o famoso MDB, ou um CSV.
Para a conversão, nada mais que algumas expressões regulares e macros de edição não resolvam em 5 minutos, sem contar a opção de importação do próprio Access. Para evitar perder estes 5 minutos deixei disponível o banco de dados gerado no repositório do projeto junto com o projeto que criaremos para demonstrar a visualização.
Neste tutorial vamos usar aquilo que é o configurador oficial de banco de dados no C&#43;&#43; Builder: o BDE. Se você ainda não observou, após a instalação do C&#43;&#43; Builder um novo item surgiu no Painel de Controle, o BDE Administrator. Vamos usá-lo para configurar uma base de dados baseada no nosso arquivo MDB recém-gerado.
Criado o MDB, podemos clicar no BDE Administrator do Painel de Controle. A única coisa que precisamos fazer é criar uma nova base de dados, e especificar seus poucos parâmetros, como o tipo de base (MSACCESS) e o path de onde está o arquivo MDB.
Ah, sim, claro, também é importante colocar um nome apropriado para a base de dados: MegaSena.
A partir daí clicando no botão Apply tudo deve fluir. Como em informática tudo quer dizer nada, eu deixo por conta do leitor a resolução de quaisquer problemas que acontecerem durante a configuração.
Criado o banco e testado (experimente conectar pelo próprio BDE) podemos agora criar um novo projeto VCL e colocar alguns componentes interessantes feitos especialmente para banco de dados. São eles:
 TDatabase: representa a própria base da dados, onde especificamos o nome da base de dados que vamos utilizar. TTable: representa uma tabela de uma base de dados. TDataSource: a origem dos dados que serão usados para popular seja lá o que quisermos popular.  Abaixo segue a configuração de cada um deles, ou seja, as propriedades que você deve mudar para que tudo funcione.
object Database1: TDatabaseAliasName = &#39;MegaSena&#39;Connected = TrueDatabaseName = &#39;MegaSena&#39;LoginPrompt = Falseendobject Table1: TTableActive = TrueDatabaseName = &#39;MegaSena&#39;TableName = &#39;Resultados&#39;endobject DataSource1: TDataSourceDataSet = Table1end Após todos esses componentes não-visuais terem sido inseridos no form, nada como colocar alguma coisa que o usuário veja: um TDBGrid.
object DBGrid1: TDBGridDataSource = DataSource1end Com isso, nossa janela já exibe o conteúdo da tabela em tempo de design:
E é isso! Se chegamos até aqui, já sabemos o arroz com feijão de usar banco de dados com o C&#43;&#43; Builder. Mais para a frente podemos nos aventurar em tópicos um pouco mais avançados, como fazer buscas, navegar item a item e essas coisas que as pessoas costumam fazer com um MDB.
 2021-03-27. Durante a revisão deste post eu tentei rodar a aplicação sem sucesso. Existem erros na abertura e configuração do arquivo mdb que não perdi mais tempo tentando resolver.  </description>
</item>

     
        <item>
  <title>Drag and drop no C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/drag-and-drop-no-c-builder/</link>
  <pubDate>2007-12-19</pubDate>
  
  <guid>http://www.caloni.com.br/drag-and-drop-no-c-builder/</guid>
  <description>O sistema de drag and drop do C&#43;&#43; Builder é muito fácil de usar, integrado que está com o sistema de classes e objetos do framework. Tanto para o objeto de drag quanto para o objeto de drop tudo que temos que fazer é definirmos a propriedade DragMode para dmAutomatic como mostra a figura. Isso fará com que toda a troca de mensagens seja manipulada automaticamente pela VCL.
A parte (ridídula) do código fica por conta da manipulação do evento de drop. Para aceitar um objeto, devemos tratar o evento OnDragOver. Basta isso para que a variável Accept tenha seu valor default definido para true. Podemos, entretanto, escolher se iremos ou não tratar um possível drop de um objeto. Verificando seu tipo, por exemplo:
void __fastcall TMain::FormDragOver(TObject *Sender, TObject *Source,int X, int Y, TDragState State, bool &amp;amp;Accept){Accept = true;}void __fastcall TMain::ListBoxDragOver(TObject *Sender, TObject *Source,int X, int Y, TDragState State, bool &amp;amp;Accept){Accept = dynamic_cast&amp;lt;TWinControl*&amp;gt;( Source ) ? true : false;}  A parte mais interessante do código fica por conta da hora que o objeto é &amp;quot;jogado&amp;quot;, no evento OnDragDrop. Nela recebemos o ponteiro para o Sender (como sempre), que é o target object, e um Source. Geralmente para manipular o source object é necessário antes realizar um cast para um tipo mais conhecido.
void __fastcall TMain::ListBoxDragDrop(TObject *Sender, TObject *Source, int X, int Y){if( TListBox* listBox = dynamic_cast&amp;lt;TListBox*&amp;gt;(Sender) ){TWinControl* winCtrl = static_cast&amp;lt;TWinControl*&amp;gt;(Source);if( listBox != winCtrl ){listBox-&amp;gt;Items-&amp;gt;Add(winCtrl-&amp;gt;Name);winCtrl-&amp;gt;Visible = false;}}}void __fastcall TMain::FormDragDrop(TObject *Sender, TObject *Source,int X, int Y){if( TForm* form = dynamic_cast&amp;lt;TForm*&amp;gt;(Sender) ){TControl* ctrl = 0;if( TListBox* listBox = dynamic_cast&amp;lt;TListBox*&amp;gt;( Source ) ){for( int i = 0; i &amp;lt; listBox-&amp;gt;Count; &#43;&#43;i ){if( listBox-&amp;gt;Selected[i] ){ctrl = this-&amp;gt;FindChildControl(listBox-&amp;gt;Items-&amp;gt;Strings[i]);listBox-&amp;gt;Items-&amp;gt;Delete(i);break;}}}elsectrl = dynamic_cast&amp;lt;TControl*&amp;gt;(Source);if( ctrl ){ctrl-&amp;gt;Top = Y;ctrl-&amp;gt;Left = X;ctrl-&amp;gt;Visible = true;}}}  E mais uma vez voilà! Pouquíssimas linhas de código e um movimentador e empilhador de controles. Dois detalhes merecem ser destacados:
 O uso de dynamic_cast em cima dos ponteiros da VCL é uma maneira saudável de checar a integridade dos tipos recebidos - particularmente do Sender. O uso do primeiro parâmetro dos tratadores de eventos também torna o código menos preso à componentes específicos do formulário; O método FindChildControl é deveras útil quando não temos certeza da existência de um controle. Geralmente é uma boa idéia confiar no sistema de gerenciamento de componentes da VCL. Não é à toa que existe um framework por baixo do ambiente RAD.  </description>
</item>

     
        <item>
  <title>Sizeof (de novo)</title>
  <link>http://www.caloni.com.br/sizeof-de-novo/</link>
  <pubDate>2007-12-17</pubDate>
  
  <guid>http://www.caloni.com.br/sizeof-de-novo/</guid>
  <description>Algumas coisas em C parecem tão simples na programação do dia-a-dia que em alguns momentos podem existir situações confusas e misteriosas. O uso obscuro do operador sizeof, por exemplo, pode dar margem a interpretações erradas a respeito do que está acontecendo por debaixo dos panos. Apesar do padrão ter sido elaborado para tentar tornar a linguagem uma coisa intuitiva e de fácil dedução, isso não acontece todas as vezes.
Vamos tomar, por exemplo, o seguinte minicódigo:
size_t len = sizeof(&amp;quot;A simple string&amp;quot;);memcpy(buf, &amp;quot;A simple string&amp;quot;, len); A pergunta ingênua: quantos bytes são copiados para buf?
A resposta ingênua: er... o tamanho de &amp;quot;A simple string&amp;quot;?
Agora vamos supor que você é um pouco mais esperto e começa a pensar: &amp;quot;mas, peraí, estou passando na realidade um ponteiro para sizeof, o que quer dizer que, se meus cálculos estiverem corretos, e estivermos em uma plataforma de 32 bits, sizeof deve retornar 4, o que quer dizer que acabei de achar um bug escabroso, uhuu!&amp;quot;.
Muito bem, o raciocínio é perfeito. Afinal de contas, &amp;quot;A simple string&amp;quot; é um ponteiro para um array de caracteres terminados em zero, certo?
Estou quase certo disso. Porém, isso quer dizer que já deixei vários bugs escabrosos há uns 4 anos atrás em trechos de código parecidos com esse. Será que eu estava errado e não me dei conta, ou sabia de algo que esqueci faz muito tempo?
Eu e meu amigo demos uma olhada no padrão da linguagem C de 89 (revisão de 90), que diz duas coisas muito importantes nesse momento: o que é um sizeof e o que é uma string constante (chamada no padrão de string literal):
 Sizeof (6.3.3.4) The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. The size is determined from the type of the operand, which is not itself evaluated. The result is an integer constant.
String literal (6.1.4) A character string literal is a sequence of zero or more multibyte characters enclosed in double-quotes, as in &amp;quot;xyz&amp;quot;. A wide string literal is the same, except prefixed by the letter L. (...) The multibyte character sequence is then used to initialize an array of static storage duration and lenght just sufficient to contain the sequence.
 Em C&#43;&#43; (padrão ISO de 98) o texto é muito parecido, apenas abragendo também o conceito de type-id (desnecessário explicar para o contexto deste artigo):
 Sizeof (5.3.3) The sizeof operator yields the number of bytes in the object representation of its operand. The operand is either an expression, which is not evaluated, or a parenthesized type-id.
String literal (2.13.4) A string literal is a sequence of characters (as defined in 2.13.2) surrounded by double quotes, optionally beginning with the letter L, as in &amp;quot;...&amp;quot; or L&amp;quot;...&amp;quot;. (...) An ordinary string literal has type &amp;quot;array of n const char&amp;quot; and static storage duration (...).
 Esses textos do padrão demonstram que o operador sizeof irá retornar o número de bytes baseado no tipo do operando, e que o tipo de uma string literal é de array de caracteres com o tamanho justo para caber a string.
Bem, todos sabemos o resultado das linhas abaixo:
char charArray[100];size_t len = sizeof(charArray); Nesse caso é simples de observar que o operador sizeof irá retornar 100, que é o número em bytes para abrigar o tipo do operando, que é de &amp;quot;array de 100 caracteres&amp;quot;. Podemos, então, imaginar que a nossa idiomática expressão do início é no fundo um resumo das linhas que se seguem.
...static char aSimpleString[] = &amp;quot;A simple string&amp;quot;;...size_t len = sizeof(aSimpleString);memcpy(buf, aSimpleString, len); Ou seja, o tipo de nossa string é na verdade de array estático de caracteres, como se uma variável tivesse sido definida anteriormente com o conteúdo da string, que deve estar em algum lugar da memória do programa. Visto dessa forma fica bem mais simples de entender o que acontece na versão resumida.
O mais encorajador desse problema do sizeof é que a resposta ingênua estava certa, ou seja, pelo menos dessa vez, o padrão conseguiu através de suas regras seguir a intuição do programador.
</description>
</item>

     
        <item>
  <title>Debug remoto no C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/debug-remoto-no-c-builder/</link>
  <pubDate>2007-12-13</pubDate>
  
  <guid>http://www.caloni.com.br/debug-remoto-no-c-builder/</guid>
  <description>Esse é um detalhe que pode passar despercebido da maioria da população Borland, mas o Builder, assim como o Visual Studio, possui sua suíte para depuração remota. E tudo o que você precisa fazer é instalar um pacote no cliente.
 No CD de instalação, existe uma pasta chamada RDEBUG. Na máquina cliente, execute o arquivo setup.exe contido nesta pasta. De preferência, não instale como um serviço (a menos que tenha um motivo). Crie uma aplicação tosca de teste (ou use uma aplicação tosca existente). Lembre-se que as DLLs do Builder não estarão disponíveis na máquina remota. Para não depender delas desabilite as opções &amp;quot;Use dynamic RTL&amp;quot; (aba Link) e &amp;quot;Build with runtime packages&amp;quot; (aba Packages) do seu projeto. Copie a aplicação para a máquina remota ou torne-a acessível através de mapeamento. Em Run, Parameters, habilite na aba Remote a opção &amp;quot;Debug project on remote machine&amp;quot; Em Remote Path especifique o path de sua aplicação visto da máquina remota. Em Remote Host especifique o nome ou o IP da máquina remota. Execute o aplicativo através do Builder (certifique-se que o cliente do Builder está rodando na máquina remota). Bom proveito!  Infelizmente essa opção não está disponível nas versões Standard do produto, assim como não está o debugging remoto no Visual Studio Express. Porém, a nova versão do Builder, renomeada para Borland Turbo C&#43;&#43;, é gratuita a possui essa feature embutida. O único porém é que a instalação não é automatizada, e os arquivos devem ser copiados &amp;quot;na mão&amp;quot;, seguindo um dos tópicos da ajuda. Melhor que nada.
Para os que utilizam o Visual Studio Express, realmente ainda não achei solução a não ser usar o bom, velho e fiel companheiro WinDbg. Não saia de casa sem ele.
</description>
</item>

     
        <item>
  <title>Gerenciamento de janelas em C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/gerenciamento-de-janelas-em-c-builder/</link>
  <pubDate>2007-12-11</pubDate>
  
  <guid>http://www.caloni.com.br/gerenciamento-de-janelas-em-c-builder/</guid>
  <description>As janelas criadas no C&#43;&#43; Builder são equivalentes às janelas criadas pela API, com o detalhe que a VCL gerencia tudo automaticamente. Isso não quer dizer que não podemos tomar controle de tudo. Quer dizer que não precisamos.
Abra o Builder. Um projeto padrão é criado. Agora no menu File, vá em New, Form. Isso adicionará um novo formulário ao projeto padrão. Pronto! Temos dois formulários. Agora se formos dar uma passeada no WinMain, vemos que o código para iniciar a VCL se alterou conforme a música:
try{Application-&amp;gt;Initialize();Application-&amp;gt;CreateForm(__classid(TForm1), &amp;amp;Form1);Application-&amp;gt;CreateForm(__classid(TForm2), &amp;amp;Form2);Application-&amp;gt;Run();} Porém, se rodarmos a aplicação nesse momento, podemos notar que o programa exibe apenas a janela correspondente ao primeiro formulário. De fato, ao chamar o método Application-&amp;gt;Run(), apenas o primeiro form criado é exibido. Isso não significa, é claro, que o segundo form não tenha sido criado. Para demonstrar como ele está lá, coloque o seguinte evento no clique de um botão do Form1:
#include &amp;quot;Unit2.h&amp;quot; // extern PACKAGE TForm2 *Form2;void __fastcall TForm1::Button1Click(TObject *Sender){Form2-&amp;gt;Show();}  Agora ao clicar do botão a janela correspondente ao formulário número 2 também aparece. Podemos fechá-la e abri-la quantas vezes quisermos que o aplicativo continua rodando. Apenas ao fechar a janela no. 1 o aplicativo realmente encerra. Esse comportamento segue o mesmo padrão da função main() na forma clássica das linguagens C/C&#43;&#43;:
ShowMessage(&amp;quot;O MainForm de Application&amp;quot;&amp;quot; é o primeiro TForm criado.&amp;quot;&amp;quot; É o princípio e o fim,&amp;quot;&amp;quot; o Alfa e o Ômega.&amp;quot;&amp;quot; Nele tudo começa&amp;quot;&amp;quot; e tudo termina&amp;quot;); Podemos, também como em C/C&#43;&#43; padrão, finalizar explicitamente a aplicação chamando o método Application-&amp;gt;Terminate. O MainForm em tempo de execução é uma propriedade de somente leitura de Application. Em tempo de design, ele pode ser alterado pela ordem de criação dos formulários no código ou pela IDE em Project, Options, Forms. Lá você também escolhe quais forms serão criados automaticamente.
Esse funcionamento e automação na criação de janelas da VCL foi feita para facilitar a vida do programador. Contudo, nunca estamos presos a somente isso. As maneiras das coisas funcionarem apenas refletem o uso mais comum no ambiente e não tem como função limitar a criatividade do desenvolvedor.
Para exemplificar, vamos inverter as coisas. Coloque um botão no segundo formulário que finalize o programa de maneira explítica:
void __fastcall TForm2::Button1Click(TObject *Sender){Application-&amp;gt;Terminate();}  Agora, no evento de OnClose (acho que você conhece o Object Inspector, não? Bom, se não conhece, talvez isso mereça um artigo à parte) do TForm1 insira o seguinte código:
void __fastcall TForm1::FormClose(TObject *Sender, TCloseAction &amp;amp;Action){Action = caNone;}  Pronto! Agora você decide onde termina e onde acaba sua aplicação.
Se dermos uma olhada bem de perto no que acontece por dentro de um aplicativo que usa a VCL descobriremos que o método Run de Application nada mais é que o loop de mensagens que já conhecemos.
Para analisarmos melhor o que ocorre nos internals da coisa, criei um projeto simplista que possui dois forms, ambos com quatro botões: 1) mostrar o outro form, 2) esconder a si mesmo, 3) fechar a si mesmo e 4) terminar aplicação. Os dois formulários são tão parecidos que desconfio que sejam gêmeos.
Além disso, iremos precisar do nosso velho e fiel amigo WinDbg, o que o trás de volta à cena do crime depois de alguns artigos de jejum. Para saber mais sobre o WinDbg e dar suas &amp;quot;WinDbgzadas&amp;quot;, faça uma busca no blogue.
A primeira coisa que um loop de mensagens deveria fazer seria chamar a função GetMessage, que obtém a primeira mensagem em espera na fila de mensagens da thread chamadora. Portanto, vamos dar uma olhada nas chamadas dessa função:
windbg Project1.exe0:001&amp;gt; gModLoad: addr module1.dllModLoad: addr module2.DLLModLoad: addr module3.dll...Ctrl&#43;Break0:001&amp;gt; bm /a user32!GetMessage?1: 7e4191c6 @!&amp;quot;USER32!GetMessageW&amp;quot;2: 7e42e002 @!&amp;quot;USER32!GetMessageA&amp;quot;0:001&amp;gt; g E o resultado é... nada! Mesmo mexendo com a janela e apertando seus botões não há uma única ocorrência do GetMessage. Bruxaria? Programação oculta?
Nem tanto. Uma alternativa ao GetMessage, que captura a primeira mensagem da fila de mensagens e a retira, é o PeekMessage, que captura a primeira mensagem da fila, mas mantém a mensagem na fila. Por algum motivo, os programadores da Borland fizeram seu loop de mensagens usando PeekMessage.
0:001&amp;gt; bc*0:001&amp;gt; bm /a user32!PeekMessage?1: 7e41929b @!&amp;quot;USER32!PeekMessageW&amp;quot;2: 7e41c96c @!&amp;quot;USER32!PeekMessageA&amp;quot;0:001&amp;gt; gBreakpoint 2 hiteax=00b1c6b0 ebx=00000000 ecx=0012ff44 edx=0012fef8 esi=00b1c6b0 edi=0012fef8eip=7e41c96c esp=0012fec8 ebp=0012ff44 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246USER32!PeekMessageA:7e41c96c 8bff mov edi,edi Agora, sim!
Analisando os parâmetros da função PeekMessage podemos obter algumas informações interessantes sobre uma mensagem, como seu código e a janela destino:
0:000&amp;gt; dd @$csp L20019fe9c 4005aa1c 0019fec80:000&amp;gt; dd poi(@$csp&#43;4) L60019fec8 00160708 00000113 00000001 000000000019fed8 0869c6e1 00000244 Podemos bater essas informações com as do aplicativo Spy&#43;&#43;, que captura janelas e suas mensagens:
0:000&amp;gt; bd *0:000&amp;gt; g Normalmente esses dois rodando juntos podem causar alguns conflitos internos. Por isso, quando for usar o Spy&#43;&#43;, procure desabilitar seus breakpoints. Após mexer no Spy&#43;&#43;, feche-o antes de continuar depurando.
Como podemos ver, nesse caso a janela encontrada foi justamente a que não aparece: TApplication! Sim, a classe principal da VCL é representada em runtime por uma janela escondida, que controla algumas mensagens específicas da aplicação.
Tem tudo a ver! Mais do que simplesmente programar interfaces, esses conhecimentos permitem fazer a análise de qualquer aplicativo que possua um loop de mensagens. O importante descoberto aqui é que o C&#43;&#43; Builder, assim como o .NET, o Java e o &amp;quot;próximo framework gerenciado&amp;quot;, não pode escapar da fatal realidade de que, para exibir janelas, o aplicativo deverá dançar a música da API Win32.
0:001&amp;gt; bc*0:001&amp;gt; bp user32!PeekMessageA &amp;quot;.echo PeekMessage; g&amp;quot;0:001&amp;gt; bp user32!DispatchMessageA &amp;quot;.echo DispatchMessage; g&amp;quot;0:001&amp;gt; gPeekMessageDispatchMessagePeekMessageDispatchMessagePeekMessage...DispatchMessagePeekMessageeax=77c3f88a ebx=00000000 ecx=77c3e9f9 edx=77c61a70 esi=7c90e88e edi=00000000eip=7c90eb94 esp=0012fe64 ebp=0012ff60 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246ntdll!KiFastSystemCallRet:7c90eb94 c3 ret </description>
</item>

     
        <item>
  <title>Interação entre controles no C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/interacao-entre-controles-no-c-builder/</link>
  <pubDate>2007-12-05</pubDate>
  
  <guid>http://www.caloni.com.br/interacao-entre-controles-no-c-builder/</guid>
  <description>Como próxima lição da nossa jornada Borland, vamos aprender a fazer os controles de um form interagirem entre si com a força do pensamento.
Para essa proeza precisaremos de:
 Dois TButtons Um TEdit Um TListBox  Bom, sabemos já como colocar esses caras no form principal. Apenas espalhe-os de maneira que eles não fiquem uns em cima dos outros (essa técnica de espalhamento chama-se design).
Agora no evento default do Button1 (duplo-clique nele) colocaremos o seguinte código:
void __fastcall TForm1::Button1Click(TObject *Sender){if( !Edit1-&amp;gt;Text.IsEmpty() ){ListBox1-&amp;gt;AddItem(Edit1-&amp;gt;Text, 0);Edit1-&amp;gt;Text = &amp;quot;&amp;quot;;}}  Percebeu? Não? Então rode e note o que acontece quando você aperta o botão.
Agora iremos fazer algo mais interessante ainda com o segundo botão. Coloque no evento default o seguinte código:
void __fastcall TForm1::Button1Click(TObject *Sender){if( !Edit1-&amp;gt;Text.IsEmpty() ){ListBox1-&amp;gt;AddItem(Edit1-&amp;gt;Text, 0);Edit1-&amp;gt;Text = &amp;quot;&amp;quot;;}}  Mais simples, impossível. E com um pouco de imaginação, o mais besta dos aplicativos pode se tornar uma utilidade do dia a dia. Até sua mãe vai adorar.
</description>
</item>

     
        <item>
  <title>Conceitos básicos na programação com C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/conceitos-basicos-na-programacao-com-c-builder/</link>
  <pubDate>2007-12-03</pubDate>
  
  <guid>http://www.caloni.com.br/conceitos-basicos-na-programacao-com-c-builder/</guid>
  <description>No projeto que é criado quando iniciamos a IDE três arquivos-fonte são gerados: Project1.cpp, Unit1.cpp e Unit1.h. Desses três, vamos analisar o primeiro:
#include &amp;lt;vcl.h&amp;gt;WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int){try{Application-&amp;gt;Initialize();Application-&amp;gt;CreateForm(__classid(TForm1), &amp;amp;Form1);Application-&amp;gt;Run();}//...return 0;}  Sim, existe um WinMain e ele não está escondido! Nele você pode fazer o que quiser. A IDE apenas auxilia você a gerenciar seus forms. Note que também existe a inclusão de um cabeçalho chamado vcl.h (obrigatório), o que nos leva diretamente para a base de toda a programação Delphi/Builder.
A VCL é o framework usado tanto no Builder quanto no Delphi para a programação RAD nesses ambientes. Considere como a MFC geração C&#43;&#43; da Borland (antes era o OWL). Todos os controles que você vê na paleta da IDE - Button, Label, CheckBox, Timer - são criados e gerenciados através da VCL. Com os mesmos nomes acrescidos do prefixo T (TButton, TCheckBox...) você tem as classes que representam em código o que você vê no ambiente RAD. Através da VCL pode-se criar novos componentes estendidos dos originais, e eles serão gerenciados pela IDE, que aliás é feita usando VCL.
Voltando ao código: o Application é um objeto visível em todo os módulos do processo e representa a aplicação em execução. Através dele você cria e destrói forms e inicia a execução da VCL. Ah, sim, é bom lembrar que todos os objetos VCL devem ser criados no heap (usando o operador new ou algum método de um objeto VCL já criado, como o CreateForm do Application). Essa e mais algumas restrições foram impostas na criação de classes VCL para que seu comportamento fosse similar/compatível com tecnologias como COM e CORBA (além das vantagens do polimorfismo e gerenciamento automático de objetos).
Olhando para o outro fonte, Unit1.h, podemos ver a definição da classe que representa o form principal:
class TForm1 : public TForm{__published: // IDE-managed Componentsprivate: // User declarationspublic: // User declarations__fastcall TForm1(TComponent* Owner);};extern PACKAGE TForm1 *Form1;  A classe deriva de TForm, que é uma classe da VCL que representa uma janela padrão do Windows. Como se nota, um objeto da classe é criado automaticamente, exatamente o utilizado no WinMain para a criação da janela principal.
Na classe existe um escopo estendido chamado published. Nele são colocados os membros da classe que podem ser gerenciados pela IDE. Considere como um public dinâmico. Coloque um TButton no form e note que um novo membro é criado na classe, dentro do escopo gerenciado pela IDE:
__published: // IDE-managed ComponentsTButton *Button1; Esses membros são iniciados automaticamente pela VCL. Contudo, você ainda pode criar objetos em tempo de execução e entregar o gerenciamento de seu tempo de vida para a VCL (o que significa chamar new e nunca um delete). Para essa proeza, todos os construtores de componentes devem receber um ponteiro para o seu Owner, que será o responsável por destruir o objeto. Veja como é ridículo criar um controle novo e definir algumas propriedades:
void __fastcall TForm1::Button1Click(TObject *Sender){TButton* btn2 = new TButton(this); // this é o meu formbtn2-&amp;gt;Parent = this; // será o owner e o parent do novo botãobtn2-&amp;gt;SetBounds(10, 10, 150, 25); // definindo as fronteiras dentro do formbtn2-&amp;gt;Caption = &amp;quot;Prazer! Sou dinâmico!&amp;quot;;btn2-&amp;gt;Visible = true;}  O Parent é o component que abriga a representação visual do objeto dentro de si. Parent e Owner são dois conceitos distintos. Pra frente veremos como as janelas são gerenciadas pela VCL e pela IDE.
É claro! O Borlando C&#43;&#43; Builder é coisa do passado, assim como Delphi e VB como os conhecemos. A versão nova do C&#43;&#43; Buider chama-se Turbo C&#43;&#43; (até semana passada, pelo menos). Nele as coisas são iguais mas diferentes. Ou seja, os conceitos aqui apresentados ainda valem. Só estão com uma cara diferente.
</description>
</item>

     
        <item>
  <title>Desenhando em C&#43;&#43; Builder</title>
  <link>http://www.caloni.com.br/desenhando-em-c-builder/</link>
  <pubDate>2007-11-29</pubDate>
  
  <guid>http://www.caloni.com.br/desenhando-em-c-builder/</guid>
  <description>Uma das partes mais fáceis e divertidas de se mexer no C&#43;&#43; Builder é a que lida com gráficos. A abstração da VCL toma conta da alocação e liberação dos objetos gráficos da GDI e nos fornece uma interface para desenhar linhas e figuras geométricas, mexer com bitmaps, usar fontes etc. Concomitantemente, temos acesso ao handles &amp;quot;crus&amp;quot; da Win32 API para que possamos chamar alguma função esotérica necessária para o seu programa, o que nos garante flexibilidade suficiente.
Vamos fazer da área da janela principal uma tela onde possamos desenhar. Para isso, só precisamos fazer duas coisas em nosso programa: saber quando o mouse está com algum botão pressionado e desenhar quando ele estiver sendo &amp;quot;arrastado&amp;quot;.
Saber o estado dos botões é trivial, podemos capturar isso nos eventos OnMouseDown e OnMouseUp e guardar em alguma variável.
//...private:bool mouseDown; // essa variável guarda o estado do mouse...//...__fastcall TForm1::TForm1(TComponent* Owner): TForm(Owner){mouseDown = false; // ... e é importante iniciá-la}void __fastcall TForm1::FormMouseUp(TObject *Sender, TMouseButton Button,TShiftState Shift, int X, int Y){mouseDown = false;}void __fastcall TForm1::FormMouseDown(TObject *Sender, TMouseButton Button,TShiftState Shift, int X, int Y){Canvas-&amp;gt;PenPos = TPoint(X, Y); // mais tarde veremos o porquê dissomouseDown = true;}  Saber quando o mouse está sendo arrastado também é um passo trivial, uma vez que temos esse evento (OnMove) para tratar no controle da janela.
Para desenhar, todo formulário e mais alguns controles gráficos possuem um objeto chamado Canvas, do tipo TCanvas (duh). Essa classe representa uma superfície de desenho que você pode acessar a partir de seus métodos. Isso é a abstração do conhecido device context da GDI, tornando a programação mais fácil. O desenho de uma linha, por exemplo, é feito literalmente em uma linha de código.
void __fastcall TForm1::FormMouseMove(TObject *Sender, TShiftState Shift,int X, int Y){if( mouseDown ){Canvas-&amp;gt;LineTo(X, Y);}}  O método LineTo() desenha uma linha do ponto onde está atualmente a caneta de desenho até a coordenada especificada. Esse é o motivo pelo qual no evento OnMouseDown alteramos a propriedade PenPos do Canvas para o ponto onde o usuário pressiona o botão do mouse.
Voila! Temos o nosso Personal PaintBrush, com toda a tosquisse que menos de 10 linhas de código podem fazer. OK, ele não é perfeito, admito, mas pode ser melhorado. Temos o código-fonte =).
Um dos problemas nele reflete o comportamento de gráficos em janelas no Windows. Seja o que for que tenhamos desenhado sobre uma janela, seu conteúdo é perdido ao ser sobrescrito por outra janela. Isso porque a memória de vídeo da área de trabalho é compartilhada entre todas as janelas do sistema (isso muda com o advento do &amp;quot;Avalon&amp;quot;). Precisamos, então, sempre repintar o que é feito durante a execução do programa.
Se precisamos repintar, logo precisamos saber tudo o que o usuário fez até então. Uma das técnicas mais baratas no quesito memória para salvar o estado gráfico de uma janela é guardar um histórico das operações realizadas sobre sua superfície e executá-las novamente ao repintar a janela. A GDI é rápida o bastante para que o custo de processamento não seja sentido na maioria dos casos. Para o nosso Paint, apenas um array de coordenadas origem-destino já dá conta do recado:
//...private:bool mouseDown; // essa variavel guarda o estado do mousestd::vector&amp;lt;TRect&amp;gt; mouseHistory; // um TRect guarda duas posicoes XY//...// ...{if( mouseDown ){// guardando a pincelada para reproduzi-la depoismouseHistory.push_back( TRect(Canvas-&amp;gt;PenPos, TPoint(X, Y)) );Canvas-&amp;gt;LineTo(X, Y);}}//...  </description>
</item>

     
        <item>
  <title>Carregando DLLs arbitrárias pelo WinDbg ou como escrever script para WinDbg</title>
  <link>http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg-parte-2/</link>
  <pubDate>2007-11-27</pubDate>
  
  <guid>http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg-parte-2/</guid>
  <description>Como pudemos ver no artigo anterior o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Além de desatualizado (com comandos de assembly 32 bits). Por esse motivo, e para tornar as coisas mais divertidas, resolvi transformar tudo aquilo em um simples script que pode ser executado digitando apenas uma linha. Tenha em mente que este artigo continua desatualizado usando assembly 32 bits e hoje é uma mera curiosidade para aprendizado do passado. E se trata do meu primeiro script grande para o WinDbg, por isso, peço que tenham dó de mim =).
Um script no WinDbg nada mais é que uma execução em batch: um arquivo texto cheio de comandos que poderíamos digitar manualmente, mas que preferimos guardar para poupar nossos dedos. Existem quatro maneiras diferentes de chamar um script no WinDbg, todas muito parecidas, variando apenas se são permitidos espaços antes do nome do arquivo e se os comandos são condensados, isto é, as quebras de linhas substituídas por ponto-e-vírgula para executar tudo em uma linha só.
 $&amp;lt;nome-do-arquivo - não permite espaços e condensa comandos. $&amp;gt;&amp;lt;nome-do-arquivo - não permite espaços e não condensa comandos. $$&amp;lt;nome-do-arquivo - permite espaços e condensa comandos. $$&amp;gt;&amp;lt;nome-do-arquivo - permite espaços e não condensa comandos. $$&amp;gt;a&amp;lt;nome-do-arquivo - igual ao anterior, e ainda permite passar argumentos.  A ajuda do WinDbg descreve as diferenças dos comandos acima de forma adversa, afirmando que os comandos &#39;&amp;lt;&#39; não condensam as linhas e os &#39;&amp;gt;&amp;lt;&#39; o fazem, quando na realidade é o contrário. Não se deixe enganar por esse detalhe. No caso do script desse artigo, utilizaremos a última forma, pois precisamos de um argumento para funcionar: o nome da DLL. Caso você não digite esse argumento, a ajuda do script será impressa:
How to use:$$&amp;gt;a&amp;lt;path\LoadLibrary.txt mydll.dll$$&amp;gt;a&amp;lt;path\LoadLibrary.txt c:\\path\\mydll.dll$$&amp;gt;a&amp;lt;path\LoadLibrary.txt &amp;quot;c:\\path with space\\mydll.dll&amp;quot; Não há qualquer dificuldade. Tudo que você tem que fazer é baixar o script que carrega DLLs e salvá-lo em um lugar de sua preferência. Depois é só digitar o comando que carrega scripts, o path de nosso script e o nome da DLL a ser carregada em uma das três formas exibidas. Eu costumo criar uma pasta chamada &amp;quot;scripts&amp;quot; dentro do diretório de instalação do Debugging Tools, o que quer dizer que posso simplesmente chamar todos meus scripts (ou seja, 1) dessa maneira:
$$&amp;gt;a&amp;lt;scripts\LoadLibrary.txt mydll.dll Abaixo um pequeno teste que fiz carregando a DLL do Direct Draw (ddraw.dll) na nossa vítima de plantão:
windbg notepad.exeMicrosoft (R) Windows Debugger Version 6.8.0004.0 X86Copyright (c) Microsoft Corporation. All rights reserved.CommandLine: notepad.exeSymbol search path is: SRV*C:\Symbols*http://msdl.microsoft.com/downloads/symbolsExecutable search path is:ModLoad: 01000000 01014000 notepad.exeModLoad: 7c900000 7c9b0000 ntdll.dllModLoad: 7c800000 7c8f5000 C:\WINDOWS\system32\kernel32.dll...ModLoad: 73000000 73026000 C:\WINDOWS\system32\WINSPOOL.DRV(8e8.214): Break instruction exception - code 80000003 (first chance)eax=001a1eb4 ebx=7ffdf000 ecx=00000000 edx=00000001 esi=001a1f48 edi=001a1eb4eip=7c901230 esp=0007fb20 ebp=0007fc94 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202ntdll!DbgBreakPoint:7c901230 cc int 30:000&amp;gt; $$&amp;gt;addraw.dllModLoad: 73bc0000 73bc6000 C:\WINDOWS\system32\DCIMAN32.dllModLoad: 76390000 763ad000 C:\WINDOWS\system32\IMM32.DLLModLoad: 629c0000 629c9000 C:\WINDOWS\system32\LPK.DLLModLoad: 74d90000 74dfb000 C:\WINDOWS\system32\USP10.dllFreed 0 bytes starting at 00280000eax=001a1eb4 ebx=7ffdf000 ecx=00000000 edx=00000001 esi=001a1f48 edi=001a1eb4eip=7c901230 esp=0007fb20 ebp=0007fc94 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202ntdll!DbgBreakPoint:7c901230 cc int 3 Simples e indolor. Vamos agora dar uma olhada no script completo e dissecar as linhas pausadamente. Dessa forma entenderemos como a função inteira funciona e como usar os comandos isoladamente para criar novos scripts.
$$$$ @brief Loads a module inside the debuggee process.$$ @author Wanderley Caloni &amp;lt;wanderley@caloni.com.br&amp;gt;$$ @date 2007-11$$.if( ${/d:$arg1} ){r $t2 = @$ip.foreach /pS 5 ( addr { .dvalloc 0x1000 } ) { r$t0 = addr }r $t1 = @$t0 &#43; 0x100eza @$t0 &amp;quot;${$arg1}&amp;quot;.echo Trying to load the following module:da @$t0$$ push $ipeb @$t1 0x68ed @$t1 &#43; 0x01 @$t2$$ pushfdeb @$t1 &#43; 0x05 0x9c$$ pushadeb @$t1 &#43; 0x06 0x60$$ push $t0eb @$t1 &#43; 0x07 0x68ed @$t1 &#43; 0x08 @$t0$$ call LoadLibraryeb @$t1 &#43; 0x0c 0xe8ed @$t1 &#43; 0x0d ( kernel32!LoadLibraryA - @$t1 - 0x11 )$$ popadeb @$t1 &#43; 0x11 0x61$$ popfdeb @$t1 &#43; 0x12 0x9d$$ reteb @$t1 &#43; 0x13 0xc3r $ip = @$t1bp /1 @$t2 &amp;quot;.dvfree @$t0 0&amp;quot;g}.else{.echo How to use:.echo $$&amp;gt;a&amp;lt;path\LoadLibrary.txt mydll.dll.echo $$&amp;gt;a&amp;lt;path\LoadLibrary.txt c:\\path\\mydll.dll.echo $$&amp;gt;a&amp;lt;path\LoadLibrary.txt &amp;quot;c:\\path with space\\mydll.dll&amp;quot;} Como podemos ver, ele é um pouco grandinho. Por isso mesmo que ele é um script, já que não precisamos, sempre que formos usar este comando, ficar olhando para o fonte. Por falar em olhar, uma primeira olhada revela a seguinte estrutura:
.if( ${/d:$arg1} ){...}.else{...} Qualquer semelhança com as instruções em C não é mera coincidência. Essa estrutura de fato verifica se o resultado dentro do .if é verdadeiro. No caso o script verifica se o primeiro parâmetro foi passado, já que os argumentos são acessíveis através dos alias (apelidos) $arg1 - $argn. Essa maneira de usar os argumentos passados no WinDbg ainda não foi documentada, mas encontrei essa dica em um artigo do Roberto Farah, um grande escritor de scripts para o WinDbg.
Da mesma forma, o que não deve ser nenhuma surpresa, o WinDbg suporta comentários. Todas as linhas que contêm &#39;$$&#39; isoladamente são comentários, e seu conteúdo da direita é ignorado, salvo se for encontrado um ponto-e-vírgula. A primeira coisa que fazemos para carregar a DLL é salvar o estado do registrador IP, que indica onde está a próxima instrução:
 r $t2 = @$ip Feito isso, usamos um comando não tão comum, mas que pode ser muito útil nos casos em que precisamos capturar algum dado da saída de um comando do WinDbg e usá-lo em outro comando. A estrutura do .foreach deixa o usuário especificar dois grupos de comandos: o primeiro grupo irá gerar uma saída que pode ser aproveitada no segundo grupo.
.foreach /pS 5 $$pula; ( addr $$alias; { .dvalloc 0x1000 $$saída; } ) { r$t0 = addr } A opção &amp;quot;/pS 5&amp;quot; diz ao comando para pular 5 posições antes de capturar o token que será usado no próximo comando. Os tokens são divididos por espaço. Sendo a saída de &amp;quot;.dvalloc 0x1000&amp;quot; o &amp;quot;Allocated 1000 bytes starting at 00280000&amp;quot;. Pulando 5 posições iremos capturar o endereço onde a memória foi alocada. E é isso mesmo que queremos!
1 2 3 4 5 6Allocated 1000 bytes starting at 00280000 O sinônimo do endereço (alias) se torna &amp;quot;addr&amp;quot;, apelido que usamos ao executar o segundo comando, que armazena o endereço no registrador temporário $t0:
r$t0 = addr Após alocada a memória, gravamos o parâmetro de LoadLibrary, o path da DLL a ser carregada, em seu início.
eza @$t0 &amp;quot;${$arg1}&amp;quot; O código assembly que irá chamar fica um ponto à frente, mas na mesma memória alocada.
r $t1 = @$t0 &#43; 0x100 Conforme as técnicas vão cada vez ficando mais &amp;quot;não-usuais&amp;quot;, mais difícil fica achar um nome para a coisa. Essa técnica de escrever o assembly de um código através de escritas em hexadecimal dentro de um script do WinDbg eu chamei de &amp;quot;script assembly&amp;quot;. Se tiver um nome melhor, não se acanhe em usá-lo. E me deixe saber =).
$$ push $ipeb @$t1 0x68ed @$t1 &#43; 0x01 @$t2$$ pushfdeb @$t1 &#43; 0x05 0x9c$$ pushadeb @$t1 &#43; 0x06 0x60$$ push $t0eb @$t1 &#43; 0x07 0x68ed @$t1 &#43; 0x08 @$t0$$ call LoadLibraryeb @$t1 &#43; 0x0c 0xe8ed @$t1 &#43; 0x0d ( kernel32!LoadLibraryA - @$t1 - 0x11 )$$ popadeb @$t1 &#43; 0x11 0x61$$ popfdeb @$t1 &#43; 0x12 0x9d$$ reteb @$t1 &#43; 0x13 0xc3 Cada comentário de uma instrução em assembly é seguido pela escrita dessa instrução usando o comando e. Se trata de um código bem trivial, fora alguns detalhes que merecem mais atenção.
Os comandos acima servem para salvar e restaurar o estado dos registradores e das flags de execução. Isso permite que possamos executar o código virtualmente em qualquer posição que pararmos no código depurado, já que retornamos tudo como estava ao final da execução do LoadLibrary. É claro que isso não garante que o código estará 100% estável em todas as condições, mas já ajuda um bocado.
Uma chamada através do opcode call (código em hexa 0xe80c) é bem comum e se trata de uma chamada relativa, baseada no estado do Instruction Pointer atual mais o valor especificado. Por isso mesmo que fazemos o cálculo usando o endereço de onde será escrita a próxima instrução, que é o valor que teremos em IP quando este call for executado:
( kernel32!LoadLibraryA - @$t1 - 0x11 ) Quando o código estiver completamente escrito na memória alocada, um disassembly dele retornará algo parecido com o código abaixo:
push offset ntdll!DbgBreakPoint (7c901230) ; empilhamos o IP atual (endereço de retorno)pushfd ; salva estado das flags atualpushad ; salva estado dos registradores atualpush 8F0000h ; empilha endereço do path da dll a ser carregadacall kernel32!LoadLibraryA (7c801d77) ; chamamos LoadLibraryApopad ; restaura estado dos registradorespopfd ; restaura estado das flagsret ; retorna para o ponto onde o depurador parou (no caso, 7c901230) Você pode ver com seus próprio olhos se editar o script comentando o último comando (g), executando o script e executando o disassembly do IP.
u @$ip Somos um script bem comportado (na medida do possível) e por isso colocamos um breakpoint temporário no final para, quando retornarmos para o código atual, desalocarmos a memória usada para a escrita e execução das instruções.
bp /1 @$t2 &amp;quot;.dvfree @$t0 0&amp;quot; Eu não me responsabilizo por qualquer (mau) uso do script aqui disponibilizado, assim como as eventuais perdas de código-fonte, trilhas de HD e placas de memória RAM pela sua execução. Assim sendo, bom divertimento.
O criador do DriverEntry me questionou se não seria mais fácil, em vez de escrever todos os opcodes em hexa, usar o comando a, que permite entrar o código assembly diretamente a partir de um endereço especificado. Essa realmente é uma ótima idéia, e de fato eu tentei isso no começo de meus testes. Porém, infelizmente para scripts isso não funciona bem. A partir do comando a o prompt fica esperando uma entrada do usuário, não lendo o assembly que estaria no próprio script. Pior ainda, a escrita do assembly não permite usar os registradores temporários, como $t0 ou $t1, o que nos força a escrever um código dependende de valores constantes. Por esses motivos, tive que apelar para o comando e, que é a forma mais confusa de escrever e entender assembly. Nesse tipo de edição é vital comentar bem cada linha que se escreve.
</description>
</item>

     
        <item>
  <title>Carregando DLLs arbitrárias pelo WinDbg</title>
  <link>http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg/</link>
  <pubDate>2007-11-23</pubDate>
  
  <guid>http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg/</guid>
  <description>Durante meus testes para a correção de um bug me deparei com a necessidade de carregar uma DLL desenvolvida por mim no processo depurado. O detalhe é que o processo depurado é de terceiros e não possuo o fonte. Portanto, as opções para mim mais simples são:
 Usar o projeto RmThread para injetar a DLL (nesse caso iniciando o processo através dele). Fazer um módulo wrapper para uma DLL qualquer e ser carregado de brinde. Usar o WinDbg e brincar um pouco.  Por um motivo desconhecido a terceira opção me pareceu mais interessante =).
A seqüência mais simples para carregar uma DLL através do WinDbg na época que escrevi este post era chamar kernel32!LoadLibrary através de um código digitado na hora, o que podemos chamar de live assembly (algo como &amp;quot;assembly ao vivo&amp;quot;). Porém, essa simples seqüência que contém um pouco mais que uma dúzia de passos hoje teria que ser feito em assembly 64 bits e é um pouco mais complicado. Para quem ainda quer se divertir dessa forma por esse caminho irei deixar as instruções para 32 bits.
Devemos parar a execução, voltar para um ponto seguro do código com o comando gu (que volta para a função chamadora e evita perda de estado dos registradores) e armazenar o local seguro em um registrador temporário (o WinDbg tem 20 deles, $t0 até $t19).
gur$t0 = @$ip Note que usamos dois pseudo-registradores ($t0, o primeiro registrador temporário do WinDbg, e $ip, o registrador que aponta para a próxima instrução que será executada), mas só um deles possue o prefixo &#39;@&#39;. Esse prefixo diz ao WinDbg que o que segue é um registrador. Como o comando r já é usado com registradores, é desnecessário usá-lo para $t0. Se usarmos sintaxe C&#43;&#43; esse prefixo é obrigatório, enquanto na sintaxe MASM não. Porém, se não usarmos esse prefixo em registradores não-comuns (como é o caso para $ip) o WinDbg primeiro tentará interpretar o texto como um número hexadecimal. Ao falhar, tentará interpretar como um símbolo. Ao falhar novamente, ele finalmente irá tratá-lo como um registrador. A diferença na velocidade faz valer a pena digitar um caractere a mais. Faça a prova!
Parada a execução em um local seguro e armazenado o IP, em seguida podemos alocar memória para entrar o código em assembly da chamada, além do seu parâmetro, no caso o path da DLL a ser carregada. Para a alocação usamos o comando .dvalloc, para a escrita de uma string o comando eza (ANSI) ou ezu (UNICODE). Em seguida usamos o comando a para escrever o código assembly da chamada à função kernel32!LoadLibrary e uma interrupção 3 (breakpoint) para termos uma maneira conveniente de parada.
.dvalloc 0x1000Allocated 1000 bytes starting at 000001d9`abd20000eza 000001d9`abd20000 &amp;quot;c:\\tools\\tioclient.dll&amp;quot;0:000&amp;gt; a 000001d9`abd20000&#43;0x100000001d9`abd20100 call KERNEL32!LoadLibraryA000001d9`abd20105 int 3000001d9`abd20106 Note que estamos usando a versão ANSI do LoadLibrary, aquela que termina com A. Sendo assim, escrevemos uma string ANSI como parâmetro usando o comando eza.
O último passo seria chamar a função previamente &amp;quot;editada&amp;quot;. Para isso basta mudarmos o endereço da próxima instrução para o começo de nosso código, definir os parâmetros nos registradores (no caso apenas um, a string em rcx) e mandar executar, pois ele irá parar automaticamente no breakpoint que definimos &amp;quot;na mão&amp;quot;, o int 3 digitado. Após a execução devemos voltar o ponteiro usando nosso backup no registrador $t0.
0:000&amp;gt; r$ip = 0x00280000&#43;0x1000:000&amp;gt; gModLoad: 10000000 10045000 c:\\tools\\tioclient.dll(398.d90): Break instruction exception - code 80000003 (first chance)eax=10000000 ebx=7ffdd000 ecx=7c801bf6 edx=000a0608 esi=001a1f48 edi=001a1eb4eip=0028010a esp=0007fb24 ebp=0007fc94 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=000002460028010a cc int 30:000&amp;gt; r$ip = $t0*** WARNING: Unable to verify checksum for C:tempMinhaDllInvasora.dll0:000&amp;gt; gModLoad: 5cb70000 5cb96000 C:\WINDOWS\system32\ShimEng.dllModLoad: 6f880000 6fa4a000 C:WINDOWS\AppPatch\AcGenral.DLLModLoad: 76b40000 76b6d000 C:WINDOWS\system32\WINMM.dllModLoad: 774e0000 7761d000 C:WINDOWS\system32\ole32.dll... Como pudemos ver pela saída, a DLL foi carregada e agora temos a possibilidade de chamar qualquer código que lá esteja. Como fazer isso? Provavelmente usando o mesmo método aqui aplicado. Live-assembly é o que manda 8).
</description>
</item>

     
        <item>
  <title>Usando a libc nativa do Windows</title>
  <link>http://www.caloni.com.br/usando-a-libc-nativa-do-windows/</link>
  <pubDate>2007-11-21</pubDate>
  
  <guid>http://www.caloni.com.br/usando-a-libc-nativa-do-windows/</guid>
  <description>Por padrão, todo projeto no Visual Studio depende da libc. Isso quer dizer que, mesmo que você não use nem um mísero printf em todos os projetos criados, está atrelado a essa dependência. Em tempos onde fazer um &amp;quot;Hello World&amp;quot; pode custar 56 KB em Release - Visual Studio 2005, configuração padrão sem &amp;quot;buffer security check&amp;quot; - vale a pena economizar alguns KBytes que não se vão usar. Principalmente se essa possibilidade existe desde o cavernoso Windows 95.
Crie um novo projeto console Win32 vazio (File, New, Project, blá blá blá) e coloque um código de Hello, World nele. Configure para ele usar uma runtime estática e veja o tamanho do executável gerado. Aqui após configurar um projeto ordinário que compila um executável console ordinário que não depende de runtimes novas (exceto a kernel32.dll) meu arquivo está com 96 KB.
#include &amp;lt;stdio.h&amp;gt;int main(){puts(&amp;quot;oi, mundo!\n&amp;quot;);}  Desde o Windows 95, existe uma DLL na pasta de sistema chamada msvcrt.dll com a maioria das funções da libc disponíveis para link dinâmico. Só que, com o uso padrão do Visual C&#43;&#43;, é usada sempre a biblioteca que vem junto com o ambiente, com suas trocentas funções (e consequentes bytes enche-linguiça). Porém, é possível utilizar diretamente a msvcrt.dll distribuída no diretório do sistema se criarmos uma LIB de importação para ela.
Tudo que você precisa fazer é gerar um msvcrt.def com as funções exportadas por essa dll usando o comando dumpbin.exe /exports msvcrt.dll e gerar uma lib de importação com o comando lib.exe passando no parâmetro /DEF o arquivo gerado. Abaixo um exemplo de como deve estar esse arquivo antes do comando lib /def:msvcrt.def:
LIBRARY msvcrtEXPORTS_CrtCheckMemory_CrtDbgBreak...wprintf_swscanfwscanf_s Depois desse último passo geramos a LIB que precisávamos e agora só falta integrar com o projeto. Copie o msvcrt.lib para o diretório do projeto e configure no projeto esse arquivo na lista de LIBs a serem incluídas (Properties, Linker, Input, Additional Dependencies). Lembre-se de ignorar todas as LIBs padrão (Linker, Input, Ignore All Default Libraries). Para evitar unresolved external em frescuras de segurança ignore as firulas de checagem (C/C&#43;&#43;, Code Generation, Buffer Security Check, e Basic Runtime Checks em Debug). Antes de mais nada deixe explícito o nome da função de entrada de seu programa para main, pois do contrário ele irá usar um bootstrap que inicia a libc (Linker, Advanced, Entry Point), compile e linke. E voilà!
E agora o tamanho final de nosso executável passou para espantosos 3 KB! Isso a princípio parece ótimo e dá vontade de usar em todos os projetos, mas existe um porém ainda não resolvido: as limitações da falta de um runtime. Essa é uma solução bem bobinha que não tem nada a ver com uma solução profissional 100% garantida e com suporte técnico 24 horas. Algumas coisas não vão funcionar, como inicialização de variáveis estáticas, exceções, redirecionamento de entrada/saída, etc. Contudo, para projetos simples e pequenos, isso não deverá ser um problema. No entanto, eu não garanto qualquer coisa que advier de compilações inspiradas neste artigo.
</description>
</item>

     
        <item>
  <title>História do Windows - parte 5.1</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-51/</link>
  <pubDate>2007-11-19</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-51/</guid>
  <description>Chega às lojas no dia 25 de outubro de 2001 a unificação entre as plataformas de uso doméstico e corporativo do sistema. O Windows XP, de Windows eXPerience, usa o kernel de 32 bits de seus antecessores Windows NT e Windows 2000. É vendido em duas edições: Home e Professional Edition. O design do sistema foi totalmente remodulado para suportar ao mesmo tempo a facilidade de uso do usuário doméstico e a robustez e confiabilidade dos clientes corporativos. Essa é minha versão favorita da História do Windows e junto do Windows 7 uma das edições mais robustas já feitas.
Oriundo do Projeto Luna um dos grandes trunfos nessa versão do Windows foi (mais uma vez) a &amp;quot;revolução gráfica&amp;quot;, baseada em um redesenho do velho conceito de desktop dos sistemas operacionais da Microsoft, em destaque o uso de temas e a total compatibilidade com a grande maioria das placas 3D. Sim, esse Windows foi feito pra jogar. Do ponto de vista da arquitetura, pouca coisa mudou, e essa versão mudou internamente de 5.0 (Windows 2000) para 5.1 (Windows XP). Ou seja, praticamente um patch de correção glorificado pelo departamento de marketing.
Agora, além do sistema 32 bits que todos já conheciam, é lançada a primeira versão 64 bits do Windows, o Windows XP 64-bit Edition. Na época a Intel se preparava para o fracasso de mercado que foi o Intel Itanium (IA-64) e esse Windows suportava essa nova arquitetura. Na verdade, o projeto foi além das expectativas e aplicou sua primeira versão do Windows-on-Windows 64-bit (WOW64), que permitia a execução de aplicativos 32 bits (x86) em cima da nova plataforma. Isso era feito pela tradução literal do código do assembly antigo para o assembly novo, além de outras técnicas auxiliares. (Atualmente essa versão do Windows não é mais suportada.)
Como se tornou uma prática desde os tempos do Windows NT, a versão para servidores é sempre lançada algum tempo depois da versão para estações de trabalho. Assim foi com o Windows NT Server, o Windows 2000 Server e agora com o Windows XP, rebatizado em sua versão servidores para Windows 2003 Server, cujo código é uma evolução do XP original.
Da mesma forma, com o lançamento da versão 64 para a plataforma x86, uma nova versão do Windows foi criada: a Windows XP Professional x64 Edition. Baseada no código do Windows 2003 Server SP1, essa nova versão se aproveitava da compatibilidade do x86-64 com a velha plataforma e otimizava a interação e execução dos velhos aplicativos 32, usando uma versão melhorada do WOW64, que se aproveitava da possibilidade de ficar trocando entre os modos 32 e 64 durante a execução dos aplicativos.
No decorrer dessa história avançamos uns bons 20 anos até agora. Muita coisa que deveria ter sido falada não foi, e muita coisa que não merecia ser mencionada, foi. Após esta versão outras foram criadas, mas o grande merge foi de fato o Windows XP, que lançou a plataforma NT pura para os usuários caseiros finais.
Não falarei mais aqui sobre a &amp;quot;outra ramificação&amp;quot; do Windows, aquela constituída por Windows 95, 98 e ME. Não falarei do processo antitruste contra a Microsoft por conta da venda do sistema operacional com o Internet Explorer e Media Player embutidos; não discursarei sobre os protestos dos consumidores quando a Microsoft cobrou pela versão de atualização do Windows 98, o Second Edition; muito menos esbravejarei sobre a raiva dos usuários pelo superaquecimento do processador por conta do Windows ME e sua duvidável interface revolucionária.
Pelo contrário. Acho que é uma boa hora para adentrar mais ainda nas entranhas da arquitetura NT e entender algumas coisas até então inexploradas.
Na eterna briga entre sistemas operacionais, uma categoria bem abastada (principalmente as discussões Tanenbaum x Torvalds diz respeito aos sistemas monolíticos e aos baseados em microkernel. Basicamente os sistemas monolíticos possuem todo o seu código executando em modo privilegiado, inclusive os device drivers. Nos sistemas baseados em microkernel, no entanto, existe apenas uma fina camada de interface rodando em modo privilegiado, que serve de interação entre todos os serviços, driver e aplicativos e o hardware.
O problema em si não é a organização dos componentes do sistema operacional em torno de um ou de outro design, mas o que isso implica em termos de eficiência. Se o Windows fosse desenvolvido com kernel monolítico todos seus componentes internos acessariam tudo disponível no modo kernel, o que tem o potencial de ser mais rápido. Já um sistema microkernel abstrai mais a comunicação entre os diferentes componentes do sistema.
Ao ser projetado o objetivo do Windows nunca foi ser um sistema operacional de microkernel, embora umas boas almas tenham clamado o contrário. No entanto, sua organização monolítica foi feita de tal forma que uma visão lógica do sistema operacional nos diria que a tentativa original foi dividir os serviços em camadas e componentes (servidores), de forma que as camadas superiores pudessem confiar nos serviços das camadas inferiores, tal como é em uma pilha TCP/IP.
Porém, as coisas não são tão simples assim. O SO inteiro não é feito dessa forma. Foram usados diversos modelos para a organização do sistema, e é fácil perceber isso se enxergamos o todo através de várias visões. Quando isso acontece se enxerga o caos, que é o que temos quando só pensamos em módulos acessando módulos e código arbitrário rodando em kernel mode. Contudo, podemos analisar o resultado lógico da divisão em camadas em um kernel monolítico.
Dessa forma é possível existir uma organização no mesmo código, mesmo esteja toda em código privilegiado. Basta que os pontos de comunicação entre os módulos esteja bem definido e documentado. O problema dessa abordagem é o acesso, que não é protegido de fato, e eventuamente vão existir existir diversos atalhos (documentados ou não) para alcançar as coisas de maneira mais rápida, para o bem da velocidade.
Uma última e terceira visão, baseada em componentes, divide o código em gerenciadores e provedores de serviços. Conceitualmente essa divisão permitiria a migração de todo o código não-crítico para user mode, embora não seja o que ocorre. Essa divisão foi feita inicialmente e mantida apenas para serviços não-críticos que pudessem rodar em código não-privilegiado e a manutenção dos subsistemas: Win32, POSIX, MS-DOS. Nessa última visão conseguimos ainda visualizar um microkernel, mas é importante notar que não estamos falando aqui do conceito puro e formal que definimos no início da explicação.
O esboço final, dessa forma, ficou sendo um sistema operacional dividido em componentes, com a maioria rodando em modo privilegiado (kernel mode), cuja divisão lógica primária tende a ser em camadas. É muito importante ter essa visão da coisa conforme nos aprofundamos nos mistérios do ring0, ou kernel mode, que controla tudo isso.
Agora esqueça essa viagem teórica de arquitetura. Para a organização dos recursos do sistema foi adotado um outro modelo, semelhante (embora não seja) ao conceito de orientação a objetos. Nesse modelo, os recursos são organizados em entidades identificáveis em sua maioria por um ponteiro opaco (kernel) ou um identificador, chamado de handle (user mode). Todos os recursos recebem o mesmo tratamento, embora se refiram a coisas extremamente diferentes, como um arquivo, uma porta de rede, um pedaço de memória, um processo e uma janela.
Essa organização foi adotada principalmente pela sua grande vantagem de minimizar mudanças, uma vez que as informações sobre os recursos são armazenadas em estruturas opacas, isto é, elas existem, porém não são acessíveis a todos. Isso permite que elas sofram mudanças internas no decorrer do tempo sem impactar para seus usuários. Essa é a abordagem pragmática que tem feito com que mesmo contando já décadas, o projeto Windows consiga avançar rapidamente junto com a tecnologia disponível para que o sistema operacional não fique parado no tempo. O que o futuro nos reserva depende apenas dos fatores externos.
</description>
</item>

     
        <item>
  <title>Detectando hooks globais no WinDbg (SetWindowsHookEx)</title>
  <link>http://www.caloni.com.br/detectando-hooks-globais-no-windbg/</link>
  <pubDate>2007-11-09</pubDate>
  
  <guid>http://www.caloni.com.br/detectando-hooks-globais-no-windbg/</guid>
  <description>Nada como um comando prático para aprender rapidamente uma técnica. Nesse caso, tive que usar o seguinte comando para localizar o momento em que um executável instala um hook global: bp user32!SetWindowsHookExA &amp;quot;j poi(esp&#43;4*4) &#39;g&#39; ; &#39;.echo *** GLOBAL HOOK ***; g&#39;&amp;quot;.
Vamos analisar cada um desses subcomandos um a um.
No WinDbg é possível definir um ou mais comandos que são executados quando um breakpoint é acionado. Esses comandos ficam entre aspas duplas e podem conter as mesmas coisas que digitamos na linha de comando. Alguns comandos, porém, são mais úteis que outros nesse contexto. Por exemplo, o comando &amp;quot;.echo&amp;quot;. Podemos digitar .echo na linha de comando do WinDbg. O que acontece?
0:000&amp;gt; .echo O que acontece?O que acontece? Exatamente o que o comando se dispõe a fazer: imprimir seus argumentos na tela. E qual a vantagem nisso? Nenhuma, se estamos na linha de comando, mas muita se estivermos colocando um breakpoint onde queremos contar o número de vezes que passamos por lá, o comando tem serventia:
0:000&amp;gt; bp $exentry &amp;quot;.echo Passou pelo main; g&amp;quot;0:000&amp;gt; gModLoad: 5cb70000 5cb96000 ShimEng.dllModLoad: 774e0000 7761d000 ole32.dll...ModLoad: 5ad70000 5ada8000 UxTheme.dllPassou pelo mainModLoad: 74720000 7476b000 MSCTF.dll... Se essa mensagem fosse exibida mais de uma vez, poderíamos supor que é possível existir algum tipo de infecção na execução do aplicativo, como quando o código inicial carrega o original e volta a executar o mesmo ponto.
O objetivo aqui é &amp;quot;preparar o terreno&amp;quot; (ficar residente) antes que o código original seja executado. Com um simples breakpoint e um simples .echo conseguimos visualizar esse tipo de ataque. Outra possibilidade é que se trata daqueles executáveis &amp;quot;empacotados&amp;quot; por meio de algum encriptador de códigos como UPX, que desempacota o código e reexecuta o ponto de entrada do executável. Claro que esse é apenas um uso que podemos fazer desses comandos.
Aprendi o comando j antes do .if, por isso acabo usando mais o primeiro, mas ambos possuem similaridades. O formato desse comando é exatamente como um &amp;quot;if-else&amp;quot;:
j Expression Command1 ; Command2j Expression &#39;Command1&#39; ; &#39;Command2&#39; Se Expression for verdadeiro, Command1 será executado; do contrário, Command2 será. Se você não precisa do else basta usar um comando vazio &#39; &#39;. A escolha é sua em usar aspas simples ou nada. Se usar aspas simples, é possível colocar mais de um comando, que foi o que eu fiz no else: &#39;.echo *** GLOBAL HOOK ***; g&#39;&amp;quot;.
Tudo depende do uso que você fizer desde comando. Algumas peculiaridades existem com relação ao uso de aspas duplas, simples, sem aspas, com ponto-e-vírgula, etc, mas são coisas que, como diz meu amigo Thiago, &amp;quot;só se aprende na dor&amp;quot;.
Lembram-se de nossa peregrinação pela pilha de chamadas quando fizemos um hook na função MessageBox pelo WinDbg? Aqui é a mesma coisa, pois estou analisando um parâmetro passado na pilha (esp): o ID da thread para onde vai o hook.
HHOOK SetWindowsHookEx(int idHook,HOOKPROC lpfn,HINSTANCE hMod,DWORD dwThreadId); Relembrando nosso passeio pela pilha, ao entrar em uma função stdcall, os primeiros 4 bytes são o endereço de retorno, os próximos o primeiro parâmetro e assim por diante. O que quer dizer que poi ( esp &#43; (4 * 4) ). É o apontado do quarto parâmetro (44) que está sendo verificado. Concluindo, se o parâmetro dwThreadId for igual a zero, estamos diante de um hook global, e é o momento em que meu .echo vai exibir na tela &amp;quot;** GLOBAL HOOK ***&amp;quot;. Do contrário, a execução vai continuar silenciosamente.
</description>
</item>

     
        <item>
  <title>Ponteiro de método: qual this é usado?</title>
  <link>http://www.caloni.com.br/ponteiro-de-metodo-qual-this-e-usado/</link>
  <pubDate>2007-11-07</pubDate>
  
  <guid>http://www.caloni.com.br/ponteiro-de-metodo-qual-this-e-usado/</guid>
  <description>Depois de publicado o artigo anterior sobre ponteiros de métodos surgiu uma dúvida muito pertinente do autor do blogue CodeBehind, um escovador de bits disfarçado de programador .NET: qual objeto que vale na hora de chamar um método pelo ponteiro?
Isso me estimulou a desdobrar um pouco mais os mistérios por trás dos ponteiro de métodos e de membros, e descobrir os detalhes mais ocultos desse lado esotérico da linguagem.
Para entender por inteiro o que acontece quando uma chamada ou acesso utilizando ponteiros dependentes de escopo, algumas pequenas mudanças foram feitas na nossa pequena classe Rand.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;time.h&amp;gt;class Rand;typedef void (Rand::*FP)();typedef int Rand::*MP;class Rand{public:Rand(){m_num = rand() % 100;}int m_num;void Print(){std::cout &amp;lt;&amp;lt; &amp;quot;this: &amp;quot; &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; this &amp;lt;&amp;lt; &amp;quot;, member: &amp;quot; &amp;lt;&amp;lt; std::dec &amp;lt;&amp;lt; m_num&amp;lt;&amp;lt; std::endl;}};/** No princípio Deus disse: &#39;int main!&#39;*/int main(){srand(time(NULL));Rand r1, r2, r3;FP fp = &amp;amp;Rand::Print;MP mp = &amp;amp;Rand::m_num;(r1.*fp)();(r2.*fp)();(r3.*fp)();std::cout &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &amp;quot;this: &amp;quot; &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; &amp;amp;r1 &amp;lt;&amp;lt; &amp;quot;, member: &amp;quot; &amp;lt;&amp;lt; std::dec &amp;lt;&amp;lt; r1.*mp &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &amp;quot;this: &amp;quot; &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; &amp;amp;r2 &amp;lt;&amp;lt; &amp;quot;, member: &amp;quot; &amp;lt;&amp;lt; std::dec &amp;lt;&amp;lt; r2.*mp &amp;lt;&amp;lt; std::endl;std::cout &amp;lt;&amp;lt; &amp;quot;this: &amp;quot; &amp;lt;&amp;lt; std::hex &amp;lt;&amp;lt; &amp;amp;r3 &amp;lt;&amp;lt; &amp;quot;, member: &amp;quot; &amp;lt;&amp;lt; std::dec &amp;lt;&amp;lt; r3.*mp &amp;lt;&amp;lt; std::endl;}  O novo código chama através do mesmo ponteiro o mesmo método (duh), mas através de três objetos diferentes. Se observarmos a saída veremos que cada instância da classe guardou um inteiro aleatório diferente para si:
this: 0012FF6C, member: 97this: 0012FF5C, member: 5this: 0012FF60, member: 44this: 0012FF6C, member: 97this: 0012FF5C, member: 5this: 0012FF60, member: 44 Cada compilador e plataforma tem a liberdade de implementar o padrão C&#43;&#43; da maneira que quiser, mas o conceito no final acaba ficando quase a mesma coisa. No caso de ponteiros de métodos, o ponteiro guarda realmente o endereço da função que pertence à classe. Porém, como todo método não-estático em C&#43;&#43;, para chamá-lo é necessário possuir um this, ou seja, o ponteiro para a instância:
Em assembly teremos algo assim:
; FP fp = &amp;amp;Rand::Print;lea rax,[Rand::Print] mov qword ptr [fp],rax; (r1.*fp)();lea rcx,[r1] call qword ptr [fp] ; (r2.*fp)();lea rcx,[r2] call qword ptr [fp] ; (r3.*fp)();lea rcx,[r3] call qword ptr [fp]  Além do ponteiro de métodos, também é possível no C&#43;&#43; apontar para membros de um dado objeto como foi feito no exemplo acima. Para tanto, como vimos no código, basta declarar um tipo de ponteiro de membro de acordo com o tipo desejado com o escopo da classe: typedef int Rand::*MP. Nesse caso, a técnica de usar o próprio enderenço não funciona, já que cada objeto possui um membro próprio em um lugar de memória próprio. Porém, assim como os ponteiros de métodos, os ponteiros de membros exigem um objeto para serem acessados, o que já nos dá a dica de onde o objeto começa. Sabendo onde ele começa, fica fácil saber onde fica o membro através do seu offset, ou seja, a distância dele a partir do início da memória do objeto. O código abaixo simplifica a obtenção de um objeto dentro da classe usando ponteiro para membros:
MP mp = &amp;amp;Rand::m_num;int i1 = r1.*mp;int i2 = r2.*mp;int i3 = r3.*mp; Note no assembly gerado que para isso funcionar o código precisa do offset armazenado em algum lugar. E, nada mais óbvio, o &amp;quot;ponteiro&amp;quot; de um membro de uma classe nada mais é que o offset deste membro dentro desta classe.
; MP mp = &amp;amp;Rand::m_num;mov dword ptr [mp],0; int i1 = r1.*mp;movsxd rax,dword ptr [mp] mov eax,dword ptr r1[rax] mov dword ptr [i1],eax ; int i2 = r2.*mp;movsxd rax,dword ptr [mp] mov eax,dword ptr r2[rax] mov dword ptr [i2],eax ; int i3 = r3.*mp;movsxd rax,dword ptr [mp] mov eax,dword ptr r3[rax] mov dword ptr [i3],eax Como podemos ver, não é nenhuma magia negra a responsável por fazer os ponteiros de métodos e de membros funcionarem em C&#43;&#43;. Porém, eles não são ponteiros ordinário que costumamos misturar a torto e a direito. Essa distinção na linguagem é importante para manter o código &amp;quot;minimamente sadio&amp;quot;.
</description>
</item>

     
        <item>
  <title>Ponteiros de método: conceito fundamental</title>
  <link>http://www.caloni.com.br/ponteiros-de-metodo-conceito-fundamental/</link>
  <pubDate>2007-11-05</pubDate>
  
  <guid>http://www.caloni.com.br/ponteiros-de-metodo-conceito-fundamental/</guid>
  <description>Diferente de ponteiros de função globais ou estáticas, que são a grosso modo ponteiros como qualquer um, os ponteiros de método possuem uma semântica toda especial que costuma intimidar até quem está acostumado com a aritmética de ponteiros avançada. Não é pra menos: é praticamente uma definição à parte, com algumas limitações e que deixa a desejar os quase sempre criativos programadores da linguagem, que vira e mexe estão pedindo mudanças no C&#43;&#43;0x.
Três regras iniciais que devem ser consideradas para usarmos ponteiros para métodos são:
 A semântica para lidar com ponteiros de método é totalmente diferente de ponteiros de função. Ponteiros de método de classes distintas nunca se misturam. Para chamarmos um ponteiro de método precisamos sempre de um objeto da classe para a qual ele aponta.  Visto isso, passemos a um exemplo simples, um chamador de métodos aleatórios, que ilustra o princípio básico de utilização:
#include &amp;lt;iostream&amp;gt;#include &amp;lt;time.h&amp;gt;class Rand;typedef void (Rand::*FP)();class Rand{public:Rand(){srand(time(NULL));}FP GiveMeFunc(){return m_funcs[rand() % 3];}private:void FuncOne() { std::cout &amp;lt;&amp;lt; &amp;quot;One!\n&amp;quot;; }void FuncTwo() { std::cout &amp;lt;&amp;lt; &amp;quot;Two!\n&amp;quot;; }void FuncThree() { std::cout &amp;lt;&amp;lt; &amp;quot;Three!\n&amp;quot;; }static FP m_funcs[3];};FP Rand::m_funcs[3] = { &amp;amp;FuncOne, &amp;amp;FuncTwo, &amp;amp;FuncThree };void passThrough(FP fp){Rand r;( r.*fp )(); // &amp;lt;&amp;lt;-- this}/** No princípio Deus disse:&#39;int main!&#39;*/int main(){Rand r;FP fp;fp = r.GiveMeFunc();passThrough(fp);} Como podemos ver, para o typedef de ponteiros de método é necessário especificar o escopo da classe. Com isso o compilador já sabe que só poderá aceitar endereços de métodos pertencentes à mesma classe com o mesmo protótipo. Na hora de atribuir, usamos o operador de endereço e o nome do método (com escopo, se estivermos fora da classe). É importante notar que, diferente de ponteiros de função, o operador de endereço é obrigatório. Do contrário:
error C4867: &#39;Rand::FuncOne&#39;: function call missing argument list; use &#39;&amp;amp;Rand::FuncOne&#39; to create a pointer to member E, por fim, a chamada. Como é a chamada de um método, é quase intuitiva a necessidade de um objeto para chamá-la. Do contrário não teríamos um this para alterar o objeto em qualquer método não-estático, certo? Daí a necessidade do padrão C&#43;&#43; especificar dois operadores especialistas para esse fim, construídos a partir da combinação de operadores já existentes em C:
Rand r;Rand* pr = &amp;amp;r;// [obj] .* [method ptr]( r.*pMethod )();// [obj ptr] -&amp;gt;* [method ptr] ( pr-&amp;gt;*pMethod )(); Esses operadores obrigam o programador a sempre ter um objeto e um ponteiro. Daí não tem como errar. Infelizmente, devido à ordem de precedência, temos que colocar os parênteses em torno da expressão para chamar o método. Pelo menos fica equivalente ao que precisávamos fazer antes da padronização da linguagem C.
</description>
</item>

     
        <item>
  <title>Brincando com o WinDbg (alterando mensagem de erro no Bloco de Notas / Notepad)</title>
  <link>http://www.caloni.com.br/brincando-com-o-windbg/</link>
  <pubDate>2007-10-30</pubDate>
  
  <guid>http://www.caloni.com.br/brincando-com-o-windbg/</guid>
  <description>No primeiro artigo sobre o WinDbg usamos o aplicativo Logger para verificar as funções APIs que são chamadas por um determinado programa. Agora iremos dar um passo adiante e depurar de fato um aplicativo qualquer, com o detalhe que não teremos o código-fonte.
Existem duas maneiras de depurar um programa localmente usando o WinDbg: iniciá-lo pelo próprio WinDbg ou conectar o depurador (attach) em um programa já em execução. Podemos especificar o que faremos direto na linha de comando ou pela sua interface. Pela linha de comando podemos usar os comandos windbg notepad.exe, windbg -pn notepad.exe e windbg -p pid. Pela interface são os conhecidos itens do menu File: Open Executable e Attach to a Process.
Para variar, iremos depurar o Bloco de Notas, o maravilhoso editor de textos da Microsoft e plataforma de testes para serviços, GINAs e drivers. Para começar, poderemos usar quaisquer das opções anteriores, o que nos levará para uma saída poluída como a seguinte:
Microsoft (R) Windows Debugger Version 6.7.0005.1Copyright (c) Microsoft Corporation. All rights reserved.CommandLine: notepad.exeSymbol search path is: SRV*C:Symbols*http://msdl.microsoft.com/downloads/symbolsExecutable search path is:ModLoad: 01000000 01014000 notepad.exeModLoad: 7c900000 7c9b0000 ntdll.dllModLoad: 7c800000 7c8f5000 C:\WINDOWS\system32\kernel32.dllModLoad: 763b0000 763f9000 C:\WINDOWS\system32\comdlg32.dllModLoad: 77f60000 77fd6000 C:\WINDOWS\system32\SHLWAPI.dllModLoad: 77dd0000 77e6b000 C:\WINDOWS\system32\ADVAPI32.dllModLoad: 77e70000 77f01000 C:\WINDOWS\system32\RPCRT4.dllModLoad: 77f10000 77f57000 C:\WINDOWS\system32\GDI32.dllModLoad: 7e410000 7e4a0000 C:\WINDOWS\system32\USER32.dllModLoad: 77c10000 77c68000 C:\WINDOWS\system32\msvcrt.dllModLoad: 773d0000 774d3000 C:WINDOWS\WinSxSx86_Microsoft.Windows.Common-Controls_SbrublesModLoad: 7c9c0000 7d1d5000 C:\WINDOWS\system32\SHELL32.dllModLoad: 73000000 73026000 C:\WINDOWS\system32\WINSPOOL.DRV(df8.e28): Break instruction exception - code 80000003 (first chance)eax=001a1eb4 ebx=7ffd5000 ecx=00000000 edx=00000001 esi=001a1f48 edi=001a1eb4eip=7c901230 esp=0007fb20 ebp=0007fc94 iopl=0 nv up ei pl nz na po nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000202ntdll!DbgBreakPoint:7c901230 cc int 3 Não se preocupe, nada aconteceu de errado. Essa é apenas a maneira do WinDbg de dizer &amp;quot;oi, estou aqui, positivo e operando&amp;quot;. Vamos destrinchar as informações iniciais para evitar confusão:
 Version: versão que está sendo executada do WinDbg (duh). CommandLine: linha de comando que foi usada ao executar o depurador. ModLoad: sempre que um módulo é carregado no processo (DLLs ou o próprio executável) o WinDbg informa os endereços inicial e final de carregamente e o nome do módulo. Para rever a lista de módulos carregados usa-se o comando lm. (.): Break instruction exception - code 8000003 (first chance). Qualquer informação específica de uma thread é informada dessa maneira no WinDbg. No caso, foi a exceção de breakpoint (parada na execução) acionada no começo da depuração (e é por isso que o notepad ainda não está aparecendo).  Explicado o começo o resto é fácil. Para continuar a execução do bloco de notas basta usarmos o comando g (Go), ou pressionar F5, ou ir no menu &amp;quot;Debug, Go&amp;quot;, ou ainda apertar um dos botões de fluxo do depurador listado no seu toolbar:
Nos depuradores mais comums você terá todas essas opções ao seu dispor e nos comandos mais incomuns tudo o que você terá será o prompt de comando do WinDbg e a ajuda, acionada por F1 ou pelo comando .hh &amp;lt;tópico&amp;gt;. Geralmente os comandos do WinDbg possuem milhares de parâmetros e é considerada atitude sábia olhar de vez em quando o que alguns desses parâmetros significam para que, aos poucos, aprenda-se alguns truques até a chegada da iluminação completa, onde seu espírito irá fluir livremente pela memória de todos os processos do sistema.
Por enquanto, basta apertar g seguido de ENTER.
A tempo: após executar g mais um monte daquelas mensagens cheias de caracteres irão aparecer. Não se preocupe. Elas realmente não são importantes no momento, mas é importante saber o básico, que é &amp;quot;o WinDbg está avisando você de tudo o que ocorre&amp;quot;. No momento certo saberemos usar as informações na tela quando houver necessidade.
Vamos fazer algo não tão esperto para ver como o bloco de notas reage. Tente abrir um arquivo com um nome inexistente:
Como podemos ver o Bloco de Notas exibe uma mensagem de erro indicando que o arquivo cujo nome você digitou não existe, pede para você verificar a orografia e tudo o mais. O importante aqui não é que você não sabe digitar nomes de arquivos, mas sim qual a função que o notepad usa para exibir sua mensagem de erro. Na versão original deste post esta função era a MessageBox, e eu seguia explicando o protótipo da função e seus argumentos. Hoje, 2021-03-07, no Windows 10, descubro que o MessageBox não é mais usado, dando lugar ao ShellMessageBoxW. Como eu descobri isso? Bom, eu segui os mesmos passos do post original e coloquei um breakpoint em MessageBox e executei novamente a abertura de um arquivo inválido e... o breakpoint não disparou. Nesse caso eu dei uma olhada na pilha de chamada de todas as threads para encontrar alguma thread que chamou funções de janela. Para isso você pode usar o comando ~*kvn (para todas as threads exiba a pilha de chamadas no modo verbose).
Na saída abaixo você pode encontrar essa chamada na primeira thread, a 2b14.30f8, no stack frame 0x0e.
0:003&amp;gt; ~* kvn0 Id: 2b14.30f8 Suspend: 1 Teb: 000000b7`5be5b000 Unfrozen# Child-SP RetAddr : Args to Child : Call Site00 000000b7`5bdbd6f8 00007ff9`c74e078e : 00000000`ffffffff 00007ff9`ae84cd4c 000000b7`00000000 00000000`00000001 : win32u!NtUserMsgWaitForMultipleObjectsEx&#43;0x1401 000000b7`5bdbd700 00007ff9`ae85352b : 00000211`41e83718 00007ff9`c87d0454 00000000`00000001 00000000`000000e5 : USER32!RealMsgWaitForMultipleObjectsEx&#43;0x1e02 000000b7`5bdbd740 00007ff9`ae853422 : 00000000`ffffffff 00000000`00000000 00000000`008f06b6 00000000`00000410 : DUser!CoreSC::WaitMessage&#43;0xeb03 000000b7`5bdbd7b0 00007ff9`c74edbe1 : 00000000`00000000 00000000`00000001 00000000`00000121 00007ff9`c74cde1b : DUser!MphWaitMessageEx&#43;0x6204 000000b7`5bdbd7e0 00007ff9`c87d0454 : 00000000`00000001 00000002`00000001 00000000`0000412a 00000000`00000000 : USER32!_ClientWaitMessageExMPH&#43;0x21...0a 000000b7`5bdbd9e0 00007ff9`b14545e7 : 00000000`00000000 00000000`00000000 00000000`00000000 00000000`00000187 : USER32!DialogBoxIndirectParamW&#43;0x180b 000000b7`5bdbda20 00007ff9`b145456e : 15e684dc`00000800 00000000`00000000 00000000`00000000 000000b7`5bdbdb20 : COMCTL32!SHFusionDialogBoxIndirectParam&#43;0x570c 000000b7`5bdbda60 00007ff9`c748cf3e : 00000211`479c00a0 00000000`00000000 000000b7`5bdbdbf0 000000b7`5bdbdb20 : COMCTL32!CTaskDialog::Show&#43;0x1220d 000000b7`5bdbdab0 00007ff9`c747959e : 00000000`00000000 00000000`00220a9c 00000000`00000000 00000000`00220a9c : shlwapi!TaskDialogIndirect&#43;0x560e 000000b7`5bdbdaf0 00007ff9`c68f92cd : 00000000`00000000 00000211`47a57dd0 00000211`41e69208 00007ff9`c74cde1b : shlwapi!ShellMessageBoxW&#43;0x18e0f 000000b7`5bdbdcc0 00007ff9`c68bf17c : 00000000`80070002 000000b7`5bdbdda9 00000000`00000000 00000000`00000000 : comdlg32!_DisplayErrorMessage&#43;0x291...24 000000b7`5bdbeb30 00007ff9`c68b609a : 00000000`00000000 000000b7`00000000 00000211`00000004 000000b7`5bdbed68 : USER32!DialogBoxIndirectParamW&#43;0x1825 000000b7`5bdbeb70 00007ff9`c6893084 : 00000211`41e69090 00000211`00000000 00000211`41e69098 00000003`00000003 : comdlg32!&amp;lt;lambda_3a7baec315efe719b0d1bc9a8eafe6df&amp;gt;::operator()&#43;0xee26 000000b7`5bdbebc0 00007ff6`2c3987ae : 00000000`00000000 00000000`008e07ea 00000000`00000000 000000b7`5bdbf0a8 : comdlg32!CFileOpenSave::Show&#43;0xa3427 000000b7`5bdbef80 00007ff6`2c398aff : 00000000`00000000 00000000`00001808 00000000`008e07ea 00000000`00000000 : notepad!ShowOpenSaveDialog&#43;0xfe... Essa é uma função equivalente à antiga MessageBox, cujo protótipo é int ShellMessageBoxW(HINSTANCE hAppInst, HWND hWnd, LPCWSTR lpcText, LPCWSTR lpcTitle, UINT fuStyle, ...), ou seja, uma função que recebe cinco ou mais parâmetros: o handle da instância caso a string passada esteja em um resource, o handle da janela pai, o texto da mensagem, o título e flags de exibição. As reticências ao final do protótipo indicam que ele pode conter mais argumentos.
Sabendo que o notepad não usa mais MessageBox, vamos colocar um singelo breakpoint nessa outra função API. Para parar a execução do notepad, podemos digitar &amp;quot;Ctrl &#43; Break&amp;quot; ou ir no menu &amp;quot;Debug, break&amp;quot; ou ainda... bem, você pegou o espírito da coisa. Na linha de comando após o break digite bp shlwapi!ShellMessageBoxW seguido de g e ENTER novamente.
Note que utilizei o prefixo shlwapi! para especificar que a função está no módulo shlwapi.dll, mas não seria necessário já que o WinDbg procura por qualquer função digitada na sua lista de funções exportadas e símbolos atuais. Contudo, fazer isso torna as coisas mais rápidas e evita perder tempo à toa.
Agora podemos efetuar a mesma operação de abrir um arquivo inexistente no bloco de notas que a execução irá parar no início da função ShellMessageBoxW da API:
Breakpoint 0 hitshlwapi!ShellMessageBoxW:00007ff9`c7479410 4055 push rbp0:000&amp;gt; rrax=00007ff9c6933000 rbx=0000000000000187 rcx=00007ff9c6880000rdx=0000000000220a9c rsi=0000000000000001 rdi=00000211479d6030rip=00007ff9c7479410 rsp=000000b75bdbd728 rbp=00000211479ba190r8=0000000000000187 r9=0000000000000000 r10=0000021148ed1ae0r11=000000b75bdbd2c8 r12=0000000000000000 r13=0000000000000000r14=0000000000220a9c r15=0000000000000000iopl=0 nv up ei pl zr na po nccs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246shlwapi!ShellMessageBoxW:00007ff9`c7479410 4055 push rbp Analisando pela convenção de chamada x64 sabemos que o terceiro parâmetro, lpcText, está em r8 e é um ID do resource. O que valida essa análise é também o primeiro parâmetro, a instância do módulo que contém os resources que serão usados para carregar a mensagem, que fica em rcx e não está zerado (ele aponta para o módulo commdlg32.dll). Dessa forma nossa tarefa se torna particularmente mais difícil, pois para encontrar a string usada na mensagem de erro seria necessário buscar no meio dos resources dessa DLL.
No entanto, vou realizar aqui brincadeira semelhante ao post original, que é alterar a mensagem de erro. Para isso precisamos alocar alguma memória para escrever uma string UNICODE e alterar o registrador r8 para o endereço dessa memória. A alocação de memória pelo WinDbg pode ser feita usando o comando .dvalloc e a edição de uma string UNICODE terminada em zero pelo comando ezu (edit zero terminated unicode string). Após isso alteramos o valor do registrador com o comando r.
0:000&amp;gt; .dvalloc 10Allocated 1000 bytes starting at 00000211`43d600000:000&amp;gt; ezu 00000211`43d60000 &amp;quot;Obrigado por utilizar o maravilhoso Bloco de Notas!&amp;quot;0:000&amp;gt; rr8 = 00000211`43d600000:000&amp;gt; g Note que se estivéssemos tentando exibir uma string Ansi iríamos usar o comando eza (edit zero terminated ansi string). O WinDbg possui inúmeros comandos parecidos que começam com e, cuja lista pode ser consultada pelo comando .hh e. O equivalente para leitura é o comando d (de dump).
Repare que colocamos esse breakpoint diretamente na função API, ou seja, qualquer outro ponto do notepad em que ele tiver vontade de chamar a mesma API irá ativar o mesmo breakpoint e exibir a mesma mensagem, o que pode ser um pouco importuno da parte dele. Um bom exercício pós-leitura seria tratar as condições em que a mensagem será trocada, talvez se baseando na mensagem recebida. Mas isso já é lição de casa, e paramos por aqui.
</description>
</item>

     
        <item>
  <title>Proteção dos membros protected</title>
  <link>http://www.caloni.com.br/protecao-dos-membros-protected/</link>
  <pubDate>2007-10-26</pubDate>
  
  <guid>http://www.caloni.com.br/protecao-dos-membros-protected/</guid>
  <description>Quando queremos que um membro de nossa classe seja visível apenas dentro dos métodos da classe e dentro dos métodos das classes derivadas dessa classe usamos o nível de proteção protected. Isso, é claro, não quer dizer que uma classe derivada vá ter acesso aos membros protegidos de outra:
#include &amp;lt;iostream&amp;gt;using namespace std;class Base{protected:int m_protected;};class Derived : public Base{public:int GetProtected();int GetAnotherProtected();};class AnotherDerived : public Base{};int Derived::GetProtected(){return m_protected;}int Derived::GetAnotherProtected(){AnotherDerived anotherDeriv;return anotherDeriv.m_protected;}int main(){Derived deriv;deriv.GetProtected();deriv.GetAnotherProtected();}&amp;gt;./programerror C2248: &#39;Base::m_protected&#39; : cannot access protected member declared in class &#39;Base&#39;see declaration of &#39;Base::m_protected&#39;see declaration of &#39;Base&#39; Esse é o motivo fundamental do porquê não podermos fazer isso:
int Derived::GetAnotherProtected(){Base base;return base.m_protected;}  Ao acessar membros protegidos é importante o tipo da expressão que está do lado esquerdo do &amp;quot;.&amp;quot; ou &amp;quot;-&amp;gt;&amp;quot;. Afinal, o nível de proteção se baseia no escopo, e as classes são um escopo. É por isso que consigo acessar os membros protegidos de um outro objeto de minha classe, mesmo sendo outro objeto:
int Derived::GetAnotherProtected(){Derived deriv; // typeid(deriv) == typeid(*this).return deriv.m_protected; // OK}  A definição do escopo é tudo o que o compilador dispõe para saber se acessa ou não acessa um membro. Podemos ter acesso a m_protected enquanto somos do tipo Derived, mas não quando o mesmo objeto é usado como Base:
int Derived::GetAnotherProtected(){Base&amp;amp; base = *this; // typeid(deriv) != typeid(*this).return base.m_protected; // ERROR}  Essa proteção parece desnecessária e até mesmo incoerente quando lidamos com o mesmo objeto que acessa. Afinal, somos nós mesmos! Só que o compilador não sabe disso, e ele deve desconfiar de tudo e de todos para evitar esse tipo de &amp;quot;ataque&amp;quot;:
int Derived::GetAnotherProtected(){AnotherDerived anotherDeriv;Base&amp;amp; base = anotherDeriv; // typeid(deriv) != typeid(*this)return base.m_protected; // ERROR}  Agora a proteção do compilador faz sentido. Parece um detalhe frívolo, mas depois que vi alguns programadores de respeito se debatendo pela &amp;quot;burrice&amp;quot; do compilador, imaginei que talvez houvesse mais pessoas com a mesma dúvida de se existe ou não um &amp;quot;bug na linguagem&amp;quot;.
</description>
</item>

     
        <item>
  <title>Typeid e os perigos do não-polimorfismo</title>
  <link>http://www.caloni.com.br/typeid-e-os-perigos-do-nao-polimorfismo/</link>
  <pubDate>2007-10-24</pubDate>
  
  <guid>http://www.caloni.com.br/typeid-e-os-perigos-do-nao-polimorfismo/</guid>
  <description>Quando usamos o operador typeid geralmente desejamos conhecer informações sobre o tipo exato do objeto que temos em mãos, independente da hierarquia de herança a qual seu tipo pertença. Só que por ignorar, assim como o sizeof, que esse operador possui duas caras, às vezes damos com os burros n&#39;água e compramos gato por lebre. Não é pra menos. Uma sutil diferença entre classes polimórficas e estáticas pode dar aquele susto que só C&#43;&#43; pode proporcionar.
Eis um exemplo singelo, sem dramatização (com dramatização == &amp;quot;500 linhas de código de produção além do código abaixo&amp;quot;).
#include &amp;lt;iostream&amp;gt;#include &amp;lt;typeinfo&amp;gt;using namespace std;class Base{public:Base(){cout &amp;lt;&amp;lt; &amp;quot;Base()\n&amp;quot;;m_x = 0;}~Base(){cout &amp;lt;&amp;lt; &amp;quot;~Base()\n&amp;quot;;}int m_x;};class Deriv : public Base{public:Deriv(){cout &amp;lt;&amp;lt; &amp;quot;Deriv()\n&amp;quot;;m_x = 1;m_y = 0;}virtual ~Deriv(){cout &amp;lt;&amp;lt; &amp;quot;~Deriv()\n&amp;quot;;}int m_y;};void func(Base* b){cout &amp;lt;&amp;lt; typeid(*b).name() &amp;lt;&amp;lt; &#39;\n&#39;;}int main(){Base* b = new Deriv();func(b);}  O typeid usado nesse exemplo será o estático, no estilo typeid(type), porque o tipo do objeto para a função é de &amp;quot;ponteiro para objeto de classe não-polimórfica&amp;quot;, ou seja, sem nenhuma função virtual. É importante lembrar que o polimorfismo em C&#43;&#43; só é aplicado se houver razão para tal, pois na linguagem a regra é que &amp;quot;não existe sobrecarga de execução sem que o programador queira&amp;quot;:
&amp;gt;./programBase()Deriv()class Base Se o esperado pelo programador fosse um class Deriv na última linha da saída, ou seja, que o typeid utilizado fosse a versão dinâmica, então a nossa classe Base tem que ser polimórfica:
virtual ~Base(){cout &amp;lt;&amp;lt; &amp;quot;~Base()\n&amp;quot;;}  Esse é um erro equivalente ao chamar o operador delete usando o ponteiro recebido em func. Se isso fosse feito, seria chamado apenas o destrutor da classe Base. Por falar nisso, temos nesse exemplo um leak de memória (percebeu pela saída que os destrutores não são chamados?). Mas esse é um erro bem menos sutil que o visto pelo nosso amigo typeid amigo-da-onça ;).
&amp;gt;./programBase()Deriv()class Deriv </description>
</item>

     
        <item>
  <title>Guia básico para programadores de primeiro breakpoint</title>
  <link>http://www.caloni.com.br/guia-basico-para-programadores-de-primeiro-breakpoint/</link>
  <pubDate>2007-10-22</pubDate>
  
  <guid>http://www.caloni.com.br/guia-basico-para-programadores-de-primeiro-breakpoint/</guid>
  <description>Aproveitando um dos últimos artigos que fala sobre conceitos básicos de programação, lembro que, tão importante quanto programar é possuir habilidades básicas de depuração, uma arte por muitos programadores ignorada.
É interessante notar como muitos ignoram a utilidade e conveniência das tradicionais e poderosas ferramentas de depuração passo-a-passo. O motivo pode ser puro desdém ou ignorância (no sentido de desconhecimento). Se for pelo segundo, aí vão algumas dicas para dar uma passada geral no seu programa e, quem sabe, encontrar um ou outro bug pelo caminho.
Os comandos mais comuns de debug são: Start/Continue, Break, Stop, Restart, Show Next Statement, Step Into, Step Over e Step Out.
Run ou Debug é o comando primário. Simplesmente inicia uma nova execução de seu programa. Geralmente você deve utilizar esse comando quando já tiver definido seus breakpoints (mais sobre isso abaixo). Do contrário o programa vai iniciar, executar e sair, sem sequer você notar.
O comando Step Over avança uma linha de código-fonte, parando na seguinte, de uma maneira iterativa. É a chamada execução passo-a-passo. Com ele você consegue, com a ajuda das janelas de watch e variáveis locais, analisar passo-a-passo a execução do fluxo de seu programa variando de acordo com as condições do sistema.
Stop Into é um parente bem próximo do Step Over, com a importante diferença de entrar dentro das funções que são chamadas em cada linha de execução. Geralmente é usado quando você pretende revisar todo o fluxo de execução porque escreveu código novo ou porque ainda não chegou na situação que pretende simular ou ainda porque usou o Step Over antes e descobriu que existe algum problema na função X que você passou direto.
Já o Step Out é o complemento dos dois Steps acima. Ele vai sair executar todo o resto da função onde você está e parar exatamente uma linha após a chamada dessa função. Em suma: você já viu o que queria ver dentro da função atual e quer continuar a execução um ou mais níveis acima na pilha de chamadas.
Você não precisa passar por todo o seu código e todos os seus loops/laços de 500 iterações até chegar ao ponto que quer analisar. O breakpoint é um comando nativo do sistema que é dos mais úteis para o programador, capaz de parar o fluxo de execução em um ponto específico do código. O depurador torna disponível para você esse comando que pode ser engatilhado em qualquer linha, geralmente em uma quantidade razoável. Para controlar todos os breakpoints definidos existe uma janela com essa lista que indica, entre outras coisas, se estão habilitados ou não, se possuem alguma condição de quebra, quantas vezes devem parar, etc. Costuma existir um ótimo controle sobre breakpoints nos depuradores, pois esse é um comando muito usado em programação (e dos mais antigos).
Praticamente qualquer ferramenta de debug possui um mecanismo para que você consiga ver o que está dentro das variáveis de seu programa. Basicamente temos uma janela ou comando de watch, ou inspection, onde podemos inserir as variáveis que queremos espiar. Em um nível mais sofisticado, temos as janelas de locals e autos (o nome pode variar), onde podemos ver, respectivamente, as variáveis dentro da função e as variáveis mais próximas do ponto onde o código está parado (as que foram usadas na última linha e as que serão usadas na próxima, por exemplo). Claro que cada ambiente te fornece o que melhor ajudar durante a depuração, assim como o Delphi e o C&#43;&#43; Builder possuem o magnífico Object Inspector, uma janela com todas as propriedades de um objeto qualquer do sistema (uma janela, um botão, uma classe, etc).
Seguindo as janelas e comandos úteis de debug, a pilha de chamadas ou stack trace mostra a pilha da thread atual sendo depurada. Com ela você consegue ver o nome da função que chamou a função que chamou a função que chamou... até a função inicial (por exemplo, o nosso conhecido main, a primeira função de um programa &amp;quot;normal&amp;quot; em C/C&#43;&#43;).
No caso de seu programa ser multithreading, ou seja, possuir várias linhas de execução, fluxos distintos de código rodando, existirá uma janela ou comando onde você pode ver qual a thread atual (a que está sendo depurada e destrinchada nas outras janelas) e quais as outras threads. Muitos ambientes permitem que com essa janela seja feito um switch de threads, que é a troca da thread atual, o que irá alterar a janela de pilha de chamadas, de variáveis locais, e muito provavelmente a janela do código-fonte atualmente em execução.
Depurar esteve sempre ligado à programação desde os primórdios da humanidade. Por isso hoje em dia os depuradores estão muito evoluídos, geralmente integrados em um ambiente de desenvolvimento (exs: Visual Studio, KDE Develop) e possuem comandos e mais comandos e mais comandos. Existem comandos, por exemplo, para pular fluxo sem executar, definir um breakpoint temporário, visualizar registradores da máquina, visualizar páginas de memória, controle de exceções, misturar assembly com código-fonte, etc. Enfim, cada comando deve ser usado conforme a necessidade e conveniência. Não adianta querer usar tudo e entender tudo de uma vez. Os comandos acima já são um ótimo começo para uma depuração poderosa o suficiente para pegar alguns bugs.
</description>
</item>

     
        <item>
  <title>Por que minha DLL travou?</title>
  <link>http://www.caloni.com.br/por-que-minha-dll-travou/</link>
  <pubDate>2007-10-18</pubDate>
  
  <guid>http://www.caloni.com.br/por-que-minha-dll-travou/</guid>
  <description>O resumo da ópera é que o código do Windows chamador do DllMain das DLLs carregadas/descarregadas utiliza um objeto de acesso exclusivo (leia &amp;quot;mutex&amp;quot;) para sincronizar as chamadas. O resultado é que, em um processo, apenas um DllMain é chamado em um dado momento. Esse objeto é chamado de loader lock na documentação da Microsoft.
Escrevi um código besta para exemplificar, mas representa o que já vi em muito código-fonte, e muitas vezes não consegui perceber o que estava acontecendo (tanto porque desconhecia a existência desse loader lock quanto o código estava obscuro demais pra entender mesmo).
Uma simples vítima disso pode ser um pobre executável usando uma pobremente escrita DLL, assim como no código abaixo:
int main(){printf(&amp;quot;load dll&amp;quot;);HMODULE lockDll = LoadLibrary(_T(&amp;quot;dll_lock.dll&amp;quot;));if( lockDll ){Sleep(2000);printf(&amp;quot;free dll&amp;quot;);FreeLibrary(lockDll), lockDll = NULL;printf(&amp;quot;done&amp;quot;);}} É importante sempre lembrar que a Microsoft acha feio, muito feio você ficar dependendo do DllMain pra fazer alguma coisa, mas admite que em alguns casos o único lugar onde podemos rodar código é no DllMain. Nesses casos -- e em alguns outros -- utilize uma comunicação paralela com sua thread travadona, por meio de um evento ou algo do gênero, antes que ela realmente saia. Com isso a thread pode ainda não ter saído, mas pode avisar a thread principal que o que ela precisava fazer já foi feito.
Entre os clássicos e inestimáveis artigos de Matt Pietrek no Microsoft Journal há na edição de setembro de 1999 um bem curto a respeito da inicialização de DLLs. Essa é a leitura mais sucinta, didática e esclarecedora sobre a questão.
</description>
</item>

     
        <item>
  <title>Guia básico para programadores de primeiro int main</title>
  <link>http://www.caloni.com.br/guia-basico-para-programadores-de-primeiro-int-main/</link>
  <pubDate>2007-10-16</pubDate>
  
  <guid>http://www.caloni.com.br/guia-basico-para-programadores-de-primeiro-int-main/</guid>
  <description> Vou aproveitar que meu amigo DQ publicou um artigo muito bom sobre como fazer programas fáceis de manter (merece ser lido!) e vou republicar um artigo do blogue antigo sobre o básico do básico para quem deseja entender como os programas funcionam. Não é nada sofisticado, apenas alguns conceitos comuns que, se você deseja ser programador, deveria procurar saber.
 Código, dados e processador A primeira coisa a saber é o que é um programa. Podemos imaginá-lo como um arquivo que vai ser interpretado pelo computador. Essa interpretação chamamos de execução. Quando um programa está sendo executado também é comum dizermos que ele está rodando. Teoricamente ele pode rodar eternamente, mas o que acontece em casos normais é que ele tem um fim previsto, seja quando o usuário fechar a janela principal (evento externo) ou quando ele terminar o que tinha que fazer (lógica interna).
E do que é feito um programa? Basicamente de duas coisas: dados de entrada e instruções (ou código). Os dados podem estar no próprio programa ou serem lidos de algum outro lugar (do teclado, de outro arquivo, da internet, etc). As instruções do seu programa é o que será interpretado pelo computador. E o que ele fará? Basicamente alterar os dados de entrada. O objetivo fundamental de um programa é gerar dados de saída. Esses dados são escritos/exibidos para algum outro lugar (para a tela, para um arquivo, para a internet, etc).
Vamos analisar essas abstrações em exemplos da vida real:
   Exemplo Dados de entrada Processamento Dados de saída     Bloco de Notas Digitação do usuário Leitura do teclado Texto exibido na tela   Chat Online Envio de mensagem Conexão com a internet Seu amigo recebe a mensagem   Editor de imagem Movimento do mouse Interpretação de movimento Retângulo desenhado   Browser Clique do mouse em uma URL Conexão com o site Exibição da nova página   Jogo de Tiro Clique no botão de tiro Cálculo do projétil Inimigo acertado   Compilador Código do programador Interpretação das instruções Código de máquina (seu programa!)    Como podemos ver, podemos abstrair esse lance de &amp;quot;dados de entrada &#43; processamento = dados de saída&amp;quot; com qualquer tipo de programa que usarmos. Basta relacionar o que fazemos (digitar algo, arrastar o mouse, apertar um botão, etc) para obtermos a saída desejada (texto/gráfico na tela, no arquivo, na impressora, etc). O programa é o elemento que fica no meio fazendo essa &amp;quot;mágica&amp;quot;.
Dados do programa Existem informações intermediárias que precisamos guardar em um programa em execução para que no final consigamos apresentar a saída desejada ao usuário. Essas informações intermediárias também são dados, só que o usuário não os enxerga. A elas chamamos de variáveis. Entenda uma variável como &amp;quot;um lugar na memória onde o programa armazena alguma informação durante o processamento&amp;quot;.
Toda variável é apenas memória interpretada de uma maneira peculiar. Essa maneira de interpretar a memória é chamada de tipo. Cada variável possui o tipo que lhe convém. Basicamente, existem dois tipos de variáveis: número (ou inteiro) e texto (ou string).
Instruções do programa Imagine um programa sendo executado do começo ao fim. A ordem em que um programa é executado é chamado de fluxo de execução. A tendência natural de um programa é ser executado pelo computador da sua primeira instrução até a última, sempre nessa ordem. Ou seja, linha 1, linha 2, linha 3, ...., linha n. Pronto. Acabou.
Porém, se fosse sempre assim, isso quer dizer que o programa seria executado sempre do mesmo jeito, e os dados de saída seriam sempre os mesmos, independente dos dados de entrada. Mas isso não acontece, certo? Quer dizer, se você não mirar direito e apertar o botão certo, o inimigo não vai cair no chão. Isso faz um certo sentido, não?
Seguindo esse raciocínio, podemos deduzir que um programa deve tomar decisões para saber o que fazer. E para tomar essas decisões ele usa o que recebeu como entrada, que são exatamente os dados de entrada. Nesse contexto, tomar decisão significa alterar o fluxo de execução. Ou seja, a ordem não necessariamente será sempre linha 1, linha 2, linha 3, etc, mas poderá ser, por exemplo, linha 1, linha 52, linha 237643, linha 52 de novo, linha 890, e assim por diante.
001: inicia002: lê entrada003: atirar?004: sim! ir para 514005: não! ir para 002006: ......514: acertei?515: sim! ir para 489516: não! ir para 234517: ......234: fui acertado?235: sim! ir para 918236: não! ir para 002...489: aumenta pontos490: ir para 002...918: diminui vida919: morri?920: sim! ir para 980921: não! ir para 002...980: game over!981: sai do programa Note que existem várias perguntas que o programa precisa responder para seguir em frente. Para respondê-las, o programa pede a ajuda do computador para fazer comparações entre variáveis. E aí está o uso desses dados internos.
Mudando o fluxo Bem, até aqui você já aprendeu um montão de coisas:
 Programas podem ser armazenados em arquivos. Quando executados, o computador interpreta suas instruções. Um programa usa dados de entrada para gerar dados de saída. Para tomar decisões, ele utiliza variáveis internas. A ordem das instruções é chamado fluxo de execução. A tomada de decisões altera o fluxo de execução de um programa.  Para concluir, vamos dar uma espiada nas estruturas de comparação de um programa em C e suas conseqüentes mudanças de fluxo. Note também que as comparações são feitas com variáveis internas.
If significa &amp;quot;se&amp;quot;, ou seja, faz uma comparação, e retorna se a comparação é verdadeira (sim!) ou não (não!). Porém, o if apenas faz alguma coisa se o resultado for sim.
Else significa &amp;quot;senão&amp;quot;, ou seja, é o complemento do if. Lembra-se que o if só faz alguma coisa se o resultado da comparação for sim? Pois bem, o else permite fazer outra coisa se o resultado for não.
While significa &amp;quot;enquanto&amp;quot;, e é o nosso primeiro exemplo de laço, ou loop. Um loop faz constantemente a mesma coisa enquanto o resultado da comparação for sim. Uma vez que for não (pode ser a primeira, inclusive), ele não faz mais nada e o programa continua seu fluxo natural.
For significa &amp;quot;por&amp;quot;, com o mesmo sentido que em &amp;quot;ele me chutou por 5 vezes seguidas&amp;quot;. Ele pode ter muitos usos, mas o tradicional é fazer n vezes alguma coisa, sabendo que n é um número de vezes já conhecido. Nesse caso, o loop serve apenas para repetir um determinado número de vezes uma ação, sem nunca variar esse número de vezes.
É só isso? Programar não tem segredo. É tudo uma questão de gostar, aprender, executar, aprender, gostar mais, aprender mais, executar mais, etc. Não exatamente nessa ordem. Tudo vai depender dos seus dados de entrada. Mas o fluxo já começou sua execução...
Para saber mais  Arquitetura de von Neumann - Wikipédia Máquina de Turing - Wikipédia A inteligência do if - parte 1 A inteligência do if - parte 2  Se ainda está difícil compreender  Resolva exercícios de lógica. Leia livros bem introdutórios (até para criança vale) como Introdução Ilustrada à Computação.  </description>
</item>

     
        <item>
  <title>História do Windows - parte 5.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-50/</link>
  <pubDate>2007-10-08</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-50/</guid>
  <description>Em novembro de 1998 (apenas para parceiros Microsoft) é lançada a versão 5.0 do Windows NT, conhecida como Windows 2000. Melhorias significativas foram feitas no acesso à internet, intranet e extranet. Aplicações de gerenciamento se integram fortemente e a grande novidade em termos de estruturação de dados é o Active Directory, uma tecnologia compatível com o conceito de Distributed File System, que viabiliza uma nova forma das empresas organizarem seus dados de maneira mais transparente à rede. Assim começou a História do Windows para redes de gente grande.
Vamos aproveitar que a versão NT foi melhorada para dar uma recapitulada geral de como as coisas funcionam internamente no sistema operacional. Em um desenho da arquitetura veremos diferentes módulos que fazem parte do sistema operacional que dividem funções específicas e que possuem métodos específicos de comunicação interna e externa. Importante notar que a divisão entre os componentes que descreverei abaixo já existia desde a primeira versão do NT, sendo que apenas alguns itens foram adicionados, como o Gerenciador de Plug &amp;amp; Play e o Gerenciador de Energia. Os elementos principais do Windows, visto sob camadas de abstração, são:
 Aplicações Win32, POSIX, OS/2; Subsistemas Win32, POSIX, OS/2; Subsistemas de integridade; Serviços do Executivo (em inglês Executive Services); Gerenciador de I/O ou I/O Manager; Gerenciador de Memória Virtual ou VMM, o Virtual Memory Manager; Process Manager, PnP Manager e Power Manager; Object Manager; Microkernel; Kernel mode drivers; Hardware Abstraction Layer (aka HAL); Por fim, o hardware.   Um outro item importantíssimo que foi movido da versão 3.51 para a 4.0 é a GDI, responsável pelos gráficos. Inicialmente ela estava no modo de usuário, mas a necessidade de aumentar o desempenho do sistema fez com que ela fosse incorporada ao núcleo do sistema. Agora vamos dissecar as partes interessantes.
 As aplicações, ou programas, que rodam sobre o sistema operacional preferencialmente são feitas para rodar no Windows, mas não precisa ser assim. A abstração inicial que se fez foi o uso de subsistemas que suportam um ambiente de execução. Essa foi a maneira escolhida pelos projetistas para que existisse compatibilidade com outros sistemas operacionais, como o OS/2 e POSIX (um padrão de aplicativo utilizado em ambientes UNIX/Linux). A mesma abstração permite que se rodem aplicativos 16 bits em cima do ambiente NT, que é todo feito em 32.
Os subsistemas de compatibilidade são serviços do sistema operacional que fornecem o ambiente de execução adequado para cada tipo de aplicação. Quando o usuário executa um arquivo, o loader do Windows detecta o tipo de aplicação tentando rodar e carrega o subsistema necessário. Dessa forma a execução de aplicativos MS-DOS e Windows 3.11 se torna transparente para o usuário. No entanto, as proteções necessárias (e.g. acesso a interrupções) serão respeitadas. Além dos subsistemas que irão fornecer os mecanismos necessários para a execução dos aplicativos dependendo de seu formato, existem aqueles subsistemas que tomam conta de alguns detalhes cruciais para a correta execução das tarefas do sistema operacional. Entre eles o mais importante é a parte de segurança, responsável por realizar o login dos usuários.
Os chamados Serviços do Executivo basicamente são o conjunto de funções que estão disponíveis no modo de usuário para realizar operações mais complexas no núcleo do sistema, como leitura/escrita em arquivo, criação de threads, chamada direta de um driver, etc. Mais basicamente ainda, se trata de um vetor de ponteiros de funções que são chamadas em kernel mode quando o modo de usuário chama uma interrupção ou comando em assembly específico para realizar uma chamada de sistema.
O I/O Manager é um componente muito usado toda hora no sistema, pois ele trata de chamadas de leitura/escrita em qualquer dispositivo, seja um arquivo, uma porta serial ou uma placa de vídeo. Como conceitualmente as requisições do sistema operacional foram organizadas como operações de entrada e saída, o I/O Manager é essencial para a maioria das operações com dispositivos, sejam físicos, lógicos ou virtuais.
A memória virtual é parte integrante e indispensável para o desempenho e normal funcionamento do sistema operacional. Entre suas responsabilidades estão a necessidade de dividir a memória entre os diferentes processos de acordo com o uso e protegê-la contra leituras, escritas e execuções não autorizadas. Parte integrante do Memory Manager, embora freqüentemente visto como um módulo separado por sua lógica, o Gerenciador de Cachê, em inglês Cache Manager, se concentra mais em estabelecer as diretizes usadas para paginar partes da memória para o disco e tornar a carregá-las na memória principal (RAM).
O Process Manager, PnP Manager e Power Manager possuem funções mais periféricas, mas não menos importantes. O Process Manager cria novos processos e mantém a relação entre eles. O PnP (Plug and Play) Manager, novo no Windows 2000, gerencia a adição e remoção de dispositivos que são plugáveis enquanto a máquina está ligada. O Gerenciador de Energia, também novo, teve sua importância aumentada com o advindo do uso massivo de laptops. É ele que controla coisas como a hibernação do sistema operacional, por exemplo.
O Gerenciador de Objetos, o Object Manager, também é parte central e obrigatória do sistema operacional, pois ele gerencia todos os recursos disponíveis tanto em kernel quanto em user mode (espelhado pelo kernel). No Windows, qualquer recurso é representado por um objeto, seja um arquivo, uma thread, um processo, um evento, uma interrupção, etc. Sendo que tudo é representado como um objeto, esse módulo foi especialmente criado para gerenciar todos os recursos de uma vez. Dessa forma tipos de controle global, como o controle de acesso, pôde ser centralizado em apenas um lugar no código, assim como o gerenciamento de handles, que são manipuladores de recursos que existem em modo de usuário.
O microkernel pode ser entendido como a parte que faz coisas muito básicas em um sistema operacional. Tão básicas quanto executar as threads, gerenciar interrupções e abstrair pequenas diferenças entre arquiteturas. Os drivers em kernel mode fazem par com o microkernel, e podem ser escrito pela Microsoft ou por fabricantes de dispositivos. São eles os responsáveis por controlar o hardware que está atrás do sistema, como o disco, a porta serial, a rede, a placa de vídeo, a própria CPU, etc. Muitos podem ser lógicos, como os filtros e os drivers de sistema de arquivos e, acredite se quiser, costumam ser mais complexos que os que controlam diretamente o hardware.
A HAL, Hardware Abstraction Layer, ou Camada de Abstração de Hardware, é totalmente dependente de plataforma, e justamente por causa disso ela é totalmente isolada do resto do sistema operacional, tornando a portabilidade mais fácil de ser suportada. Em alguns casos a HAL é implementada como um conjunto de macros, o que quer dizer que você terá que recompilar seus drivers para mudar de plataforma (x86 para x64, por exemplo). Além disso, existe um conjunto de DLLs compiladas para cada plataforma, que é renomeada (para hal.dll) e copiada durante a instalação. Isso explica porque em algumas situações se você copia a instalação do Windows de uma máquina para outra com diferenças relevantes de arquitetura pode ser que as coisas não saiam exatamente como você esperava.
E por fim, a não ser que estejamos falando do XBox, o hardware é feito por terceiros, como a Intel, a AMD e a NVIDIA, e é onde você instala o seu sistema operacional do coração para rodar seus aplicativos do coração. O bom de um sistema operacional do coração é que você não percebe sua existência quando está rodando seu jogo do coração. Pelo menos não deveria. O único momento que o sistema operacional do coração revela sua existência é quando as coisas dão errada e você recebe uma tela azul do coração.
</description>
</item>

     
        <item>
  <title>Debug da BIOS com o SoftIce 16 bits</title>
  <link>http://www.caloni.com.br/debug-da-bios-com-o-softice-16-bits/</link>
  <pubDate>2007-10-02</pubDate>
  
  <guid>http://www.caloni.com.br/debug-da-bios-com-o-softice-16-bits/</guid>
  <description>Para quem acha que ainda não desceu demais o nível existe um ótimo artigo no Code Project de S. Z. Keller (aka ShalomZ) sobre como construir seu próprio sistema operacional. É simples, direta e empolgante a maneira com que ele explica e trata os detalhes básicos, desde quando o computador é ligado até quando o boot loader carrega e entrega o controle de execução. Eu mesmo fiz o teste com a imagem que foi disponibilizada para download e funcionou direitinho. Agora esse meu artigo se dispõe a explicar como você pode fazer para depurar o processo de load do seu primeiro sistema operacional.
Primeiro precisamos de uma ferramenta fundamental para esse tipo de depuração: o SoftIce versão 16 bits. Desconheço algum outro depurador de sistema em 16 bits, mas se você souber de algum, pode usá-lo com esse tutorial com as devidas adaptações.
Passado o desafio inicial de encontrar essa versão do SoftIce e saber usá-la, o resto é fácil:
 Crie uma nova VMWare, Virtual PC, VMSbrubles configurada para bootar pelo disquete. Formate dois disquetes de MS-DOS, FreeDos, Sbrubles-DOS. Copie o setor de boot disponível no artigo do CP para o disquete usando o programa disponível em um dos disquetes. Copie o SoftIce no outro disquete. Efetue o boot com o disquete do SoftIce. Execute o SoftIce (é só rodar, ele permanece residente e é ativado com Ctrl &#43; D). Coloque um breakpoint na int 0x13 (disco) na função 2 (leitura) (faz-se assim: bpint 13 ah=2). Troque o disquete do Softice pelo disquete com o setor de boot do artigo do CP. Efetue novamente o boot na máquina em modo &amp;quot;quente&amp;quot; (usando o próprio SoftIce, comando boot). A execução deve ser paralisada exatamente no ponto onde o código da BIOS lê o setor de boot do seu disquete. Digite p ret e em seguida F10 ou T e seja feliz.  Pelo softice 16 bits conseguimos parar a execução nas interrupções da BIOS e ainda especificar qual das funções será executada, definida no registrador AH; mais detalhes sobre layout de memória do 8086 no artigo do DQ 1.
Quando o código da BIOS é executado, ele precisa, entre outras coisas, fazer três:
 Encontrar o dispositivo padrão de boot. Ler o primeiro setor desse dispositivo para o endereço 0x7C00. Entregar a execução para o código em 0x7C00.  O item 2 é justamente o que utiliza essa interrupção para ler do disco. Eu prefiri colocar o breakpoint no item 2, mas nada impediria de você colocá-lo no item 3 e já iniciar a depuração no código do boot loader. Mas, como eu já passei por problemas encontrados no código da BIOS que impediam o sistema de entregar a execução para o setor de boot, já dei a dica de lambuja caso você também tenha a oportunidade de se divertir em um cliente depurando a BIOS de algum laptop desajustado.
A referência para saber quais as funções para cada interrupção na hora de depurar a BIOS pode ser encontrada em listas como a Ralf Brown&#39;s Interrupt List 2
A partir dessa leitura se usa o comando p ret do depurador, que é mais ou menos o step out do SoftIce 32. Ou seja, ele avança a execução até a função retornar. No caso do SoftIce 16 ele irá avançar até o próximo ret/iret. Por isso que também precisamos executar a próxima instrução (o próprio ret) para cair onde queremos. É nesse ponto que o &amp;quot;nosso&amp;quot; código começa a executar e onde conseguimos colocar breakpoints &amp;quot;de verdade&amp;quot;, ou seja, escrevendo no parte do código que deve ser interrompida a chamada da interrupção de breakpoint (int 3). Lembre-se que não é isso o que é feito para parar no código da BIOS, uma vez que esta reside em memória de somente leitura (pelo menos durante a execução).
  Gerenciamento de memória 386 - Daniel Quadros &amp;#x21a9;&amp;#xfe0e;
 Ralf Brown&#39;s Interrupt List na Wikipedia &amp;#x21a9;&amp;#xfe0e;
   </description>
</item>

     
        <item>
  <title>Introdução ao C&#43;&#43; Builder...Turbo C&#43;&#43;</title>
  <link>http://www.caloni.com.br/introducao-ao-c-builderturbo-c/</link>
  <pubDate>2007-09-26</pubDate>
  
  <guid>http://www.caloni.com.br/introducao-ao-c-builderturbo-c/</guid>
  <description>Após mais de um ano de tentativas, finalmente consegui instalar e iniciar com sucesso o Borland Developer Studio. Esse foi o nome pomposo dado pela Borland para a &amp;quot;continuação&amp;quot; do velho C&#43;&#43; Builder e seus parentes, o Delphi e o C# Builder.
Existem muitas coisas novas ainda para ver, mas não é a usabilidade. Assim como a IDE antiga, é fácil de sair mexendo e fazendo janelas, no bom estilo WYSIWYG dos produtos da Borland.
Para quem começa a desenvolver aplicativos com interface para Windows, deve saber que uma das coisas mais produtivas que já inventaram foi o Visual Basic. De fato, o VB permite que virtualmente qualquer pessoa com conhecimentos mínimos de informática torne-se um gabaritado programador de telinhas.
Porém, com o tempo você percebe que cada ferramenta tem suas vantagens e desvantagens. Uma desvantagem do VB era a falta de flexibilidade. Outra era que a linguagem usada não favorecia muito aqueles que se aventuravam chamando a Win32 API diretamente dos seus programas. Era possível, sim, mas enfadonho e nem sempre as coisas funcionavam como o esperado.
Para as pessoas que chegam nesse nível de necessidade, existem basicamente duas escolhas:
  Permanecer no mundo Microsoft e usar MFC &#43; Win32 API, passando a programar na linguagem em que foi feito o Windows (C/C&#43;&#43;).
  Tentar usar o Delphi, a evolução do Turbo Pascal para Windows, da Borland, que pode ser considerado mais flexível que o VB, mas ainda assim usa uma linguagem alienígena (no sentido de que ainda não é a linguagem nativa do SO).
  Mudar de sistema operacional e esquecer esse negócio de loop de mensagens (eu disse duas escolhas, certo?)
  Bom, eis que surge o C&#43;&#43; Builder: uma ferramenta idêntica ao Delphi, contudo que oferece a linguagem C&#43;&#43; para que todas aquelas pessoas recém-saídas da faculdade e ansiosas por entrar no mercado de trabalho esqueçam aquele papo de Pascal e passem a usar a linguagem da indústria. Pelo jeito, era mais ou menos essa a visão da Borland quando lançaram o produto.
Desde o princípio, o C&#43;&#43; Builder foi lançado em revistas de informática em versões para estudantes, o que estimulava as pessoas financeiramente menos capacitadas (estudantes, como eu) a cada vez mais utilizar essa ferramenta de programação para desenvolver aplicativos Windows, já que, além de não ser pago como o Visual Basic e o Visual C&#43;&#43;, não era nem tão limitado quando o primeiro nem tão complicado quanto o segundo. E estava sempre entre os programas completos para serem testados na revista que acabou de chegar na banca. Nossa, como era divertido programar por prazer!
O mais impressionante no Builder era que desde o começo, na versão 1, já tínhamos aquela palheta maravilhosa cheio de todos os controles que já faziam parte do Windows 95. Tudo isso por causa de uma estratégia simples e eficaz: os componentes são os mesmos do Delphi. O que o C&#43;&#43; Builder adicionou foi uma camada de interface para que C&#43;&#43; e Object Pascal conversassem. O resultado disso é espantoso: é possível programar em C&#43;&#43; puro, chamar APIs diretamente, e ainda usar os componentes em Delphi, além de também poder desenvolver em Delphi e mesclar ambas as linguagens em um projeto. É possível até usar herança entre componentes escritos em Delphi e C&#43;&#43; Builder.
 Quando entrei na Scua comecei a trabalhar profissionalmente com o C&#43;&#43; Builder, ao desenvolver o aplicativo de administração do software de controle de acesso. Na época não tínhamos muito tempo para perder desenvolvendo tudo em Win32 API ou usar algo mais rústico como a MFC, que é mais parecido com a finada biblioteca OWL do que com a VCL (a biblioteca visual de componentes usada pela Borland para Delphi e Builder). E não, usar Visual Basic não era uma alternativa. Como a produtividade estava em jogo, hoje tenho certeza que fizemos uma boa escolha.
 Eu gostava do C&#43;&#43; Builder antigo: sem frescura de registrar componentes e sem necessidade de instalação. Até hoje uso a versão 1.0 para brincar de vez em quando, pois é relativamente pequena; apenas copio para uma pasta e ainda funciona muito bem.
Mas desde que o mundo gerenciado veio à tona, para instalar esse singelo produto da Borland você vai precisar de alguns pré-requisitos da Microsoft:
 Microsoft .NET Framework SDK 1.1 Visual J# .NET Redistributable Package 1.1 Microsoft XML 4.0 SP2 Parser and SDK  Se for necessária mais alguma instalação, não se preocupe: o Borland Turbo C&#43;&#43; Instalation Wizard irá te avisar no momento da instalação, que deverá ser a última a ser realizada.
Após tudo isso instalado, finalmente conseguiremos rodar nossa ferramenta RAD. Aliás, antes que eu me esqueça, RAD é uma abreviação para Rapid Application Development.
Se você nunca usou essa ferramenta, ao abrir o ambiente, irá se deparar com vários elementos que precisam ser nomeados e explicados para fazer algum sentido. Mesmo que muitas coisas sejam novas, algumas devem estar sempre gravadas em sua memória:
Sempre que você clicar em algum componente gráfico para ser editado - como uma janela, um botão, uma lista - o Object Inspector será o lugar para editá-lo. Ele está dividido em propriedades e eventos. Propriedades são as características gráficas e comportamentais do componente que está sendo editado. Eventos especificam métodos para tratar as ações recebidas de algum componente (ex: clique de um botão).
A palheta é onde estão todos os componentes que podem ser usados no momento para a edição do programa. Existe uma infinidade deles, tais como: botões, menus, caixas de seleção, listas de itens, barras de rolagem, listas de ações, imagens, rótulos, grupos de botões, e assim vai a valsa. Para usá-los, basta arrastar para uma janela e editar suas propriedades.
Onde estão todos os meus arquivos? O Gerenciador de Projetos está aí para ajudá-lo. Todas as units (unidades de código) e forms (janelas) que você criar no projeto estará visível para fácil acesso. É muito importante saber organizar um projeto, pois conforme se avança, ele tende a se tornar maior e mais complexo. Junto do Gerenciador de Projetos existe o seu ajudante, o Structure. Na visão de design, o Structure irá mostrar os controles inseridos nas janelas; na visão de unit, o Structure irá mostrar os includes, macros, classes e funções do código-fonte exibido no momento.
Update: este foi um overview geral por cima do que era o C&#43;&#43; Builder há mais de dez anos. Não consegui validar um projeto antigo na IDE porque as ferramentas da Borland seguiram por caminhos muito tortos e a versão mais nova (que instalei) não conseguiu importar. De qualquer forma, fica o post legado.
</description>
</item>

     
        <item>
  <title>Why is my DLL locked?</title>
  <link>http://www.caloni.com.br/why-is-my-dll-locked/</link>
  <pubDate>2007-09-24</pubDate>
  
  <guid>http://www.caloni.com.br/why-is-my-dll-locked/</guid>
  <description>The Windows code responsible to call DllMain for each loaded and unloaded DLLs uses an exclusive access object, the so-called mutex, to synchronize its calls. The result is that inside a process just one DllMain can be called at a given moment. This object-mutex is called &amp;quot;loader lock&amp;quot; into the Microsoft documentation.
I wrote a silly code that represents quite well what I&#39;ve seen in lots of production code. For many times I was unable to realize what was going on (whether because I didn&#39;t know about the loader lock or the code readability was too bad). The code say by itself: calling CreateThread inside DllMain must lock your execution forever.
A simple victim of all this can be an executable using a poorly written DLL, just like the code above:
int main(){printf(&amp;quot;load dll&amp;quot;);HMODULE lockDll = LoadLibrary(_T(&amp;quot;dll_lock.dll&amp;quot;));if( lockDll ){Sleep(2000);printf(&amp;quot;free dll&amp;quot;);FreeLibrary(lockDll), lockDll = NULL;printf(&amp;quot;done&amp;quot;);}} It is important to remember that a DllMain dependant code is a very, very bad thing. Nevertheless, there are some particular cases the only place to run our code is inside DllMain. In these cases, when detected, try to run a side by side communication with your locked thread using an event object (or equivalent) before it really returns. Using this craft the thread can warn the waiting thread that the important thing to be done is done, and the waiting thread can go to sleep and stop waiting forever locked threads.
Among the classic Matt Pietrek posts in Microsoft Journal there is in the [1999 september edition] a short one about DLL initialization. That is the more sucint, didatic and simple text about this question.
[[1999 september edition]]: http://bytepointer.com/resources/pietrek_debug_init_routines.htm
</description>
</item>

     
        <item>
  <title>Hook de COM no WinDbg</title>
  <link>http://www.caloni.com.br/hook-de-com-no-windbg/</link>
  <pubDate>2007-09-18</pubDate>
  
  <guid>http://www.caloni.com.br/hook-de-com-no-windbg/</guid>
  <description>Continuando com o tema hooks no WinDbg vamos aqui &amp;quot;hookear&amp;quot; e analisar as chamadas de métodos de um objeto COM. O que será feito aqui é o mesmo experimento feito para uma palestra de engenharia reversa que apresentei há um tempo atrás, mas com as opções de pause, rewind, replay e câmera lenta habilitadas.
Antes de começar, se você não sabe nada sobre COM, não deveria estar aqui, mas nunca é tarde para aprender. Pra começar, vamos dar uma olhada na representação da interface IUnknown em UML e em memória:
Como podemos ver, para implementar o polimorfismo os endereços das funções virtuais de uma classe são colocados em uma tabela, a chamada vtable, famosa tanto no COM quanto no C&#43;&#43;. Existe uma tabela para cada classe-base polimórfica, e não para cada objeto. Se fosse para cada objeto não faria sentido deixar esses endereços &amp;quot;do lado de fora&amp;quot; do leiaute. E não seria nada simples e elegante fazer uma cópia desse objeto.
Assim, quando você chama uma função virtual de um objeto o código em assembly irá chamar o endereço que estiver na posição correspondente ao método chamado dentro da vtable. Se você chama AddRef, por exemplo, que é o segundo método na tabela, será chamado o endereço da posição número dois. Com isso, mesmo desconhecendo de que tipo é o objeto a função certa será chamada porque existe um ponteiro para essa tabela no início da interface.
Sabendo de tudo isso, agora sabemos como teoricamente proceder para colocar uns breakpoints nessas chamadas:
Note que o breakpoint não é colocado dentro da tabela, o que seria absurdo. Uma tabela são dados e dados geralmente não são executados (eu disse geralmente). Porém, usamos a tabela para saber onde está o começo da função para daí colocar a parada nesse endereço, que por fazer parte do código da função é (quem diria!) executado.
Agora vamos sair da teoria e tentar fazer as coisas mais ou menos parecidas na prática. O nosso sorteado desse artigo foi o IMalloc, a interface de alocação de memória do COM, que existe desde a época em que não se sabia direito pra que esse tal de COM iria servir. O IMalloc é definido como se segue:
MIDL_INTERFACE(&amp;quot;00000002-0000-0000-C000-000000000046&amp;quot;)IMalloc : public IUnknown{public:virtual void *STDMETHODCALLTYPE Alloc( /* [in] */ SIZE_T cb) = 0;virtual void *STDMETHODCALLTYPE Realloc( /* [in] */ void *pv,/* [in] */ SIZE_T cb) = 0;virtual void STDMETHODCALLTYPE Free( /* [in] */ void *pv) = 0;virtual SIZE_T STDMETHODCALLTYPE GetSize( /* [in] */ void *pv) = 0;virtual int STDMETHODCALLTYPE DidAlloc( void *pv) = 0;virtual void STDMETHODCALLTYPE HeapMinimize(void) = 0;}; Nesse experimento, como iremos interceptar quando alguém aloca ou desaloca memória, nossos alvos são os métodos Alloc e Free. Para saber onde eles estão na tabela, é só contar, começando pelos métodos do IUnknown, que é de quem o IMalloc deriva. Se houvessem mais derivações teríamos que contar da primeira interface até a última. Portanto: QueryInterface um, AddRef dois, Release três, Alloc quatro, Realloc cinco, Free seis. OK. Contar foi a parte mais fácil.
Agora iremos precisar interceptar primeiro a função que irá retornar essa interface, pois do contrário não saberemos onde fica a vtable. Nesse caso, a função é a ole32!CoGetMalloc. Muitas vezes você irá usar a ole32!CoCreateInstance(Ex) ou a CoGetClassObject diretamente na DLL que pretende interceptar. Outras vezes, você receberá o ponteiro em alguma ocasião diversa. O importante é conseguir o ponteiro de alguma forma.
Nesse exemplo iremos obter o ponteiro através de um aplicativo de teste trivial, ignorando todas aquelas proteções antidebugging que podem estar presentes no momento da reversa, feitos por alguém que lê meu blog (quanta pretensão!):
/** @brief A stupid sample to show WinDbg COM hooking! */#include &amp;lt;windows.h&amp;gt;#include &amp;lt;objbase.h&amp;gt;#include &amp;lt;objidl.h&amp;gt;int main(){CoInitialize(NULL);IMalloc* malloc = 0;if( CoGetMalloc(1, &amp;amp;malloc) == 0 ){if( void* pAlloc = malloc-&amp;gt;Alloc(0x1000) ){malloc-&amp;gt;Free(pAlloc);}malloc-&amp;gt;Release();}CoUninitialize();}  Vamos fazer de conta que é desnecessário dizer como se compila o fonte acima.
cl /c imalloc-hook.cpplink imalloc-hook.obj ole32.lib Agora é só depurar!
Abra o WinDbg. Na opção &amp;quot;File, Open Executable&amp;quot; selecionamos a nossa vítima, cujo nome você escolhe na hora de compilar o fonte acima. Aqui ele irá chamar imalloc-hook.exe. A seguir, colocamos um breakpoint na função da ole32, mandamos rodar, e esperamos a parada do código:
0:000&amp;gt; bp ole32!CoGetMalloc0:000&amp;gt; bl0 e 774ddcf8 0001 (0001) 0:**** ole32!CoGetMalloc0:000&amp;gt; gBreakpoint 0 hitModLoad: 76360000 7637d000 C:WINDOWSsystem32IMM32.DLL...ModLoad: 746e0000 7472b000 C:WINDOWSsystem32MSCTF.dlleax=0012ff7c ebx=00000000 ecx=775e67f0 edx=775e67f0 esi=00000001 edi=00403374eip=774ddcf8 esp=0012ff70 ebp=0012ffc0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246ole32!CoGetMalloc:774ddcf8 8bff mov edi,edi Maravilha. Alguém chamou a função que queríamos (quem será?). Agora podemos dar uma olhada na pilha e no protótipo da CoGetMalloc:
HRESULT CoGetMalloc(DWORD dwMemContext, LPMALLOC *ppMalloc);0:000&amp;gt; dd esp L30012ff70 0040101d 00000001 0012ff7c0:000&amp;gt; dd poi(esp&#43;8) L10012ff7c 00000000 Como podemos ver nos parâmetros da pilha o nosso chamador passou certinho o valor 1 no campo reservado e um ponteiro no segundo parâmetro para uma área onde, se der tudo certo, será escrito o endereço de um IMalloc, que podemos chamar carinhosamente de this. De início vemos que a variável está zerada. Agora vamos executar a função até a saída e examinar os resultados.
0:000&amp;gt; bp /1 /c @$csp @$ra;gBreakpoint 1 hiteax=00000000 ebx=00000000 ecx=775e6034 edx=775e67f0 esi=00000001 edi=00403374eip=0040101d esp=0012ff7c ebp=0012ffc0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246IMalloc&#43;0x101d:0040101d 85c0 test eax,eax0:000&amp;gt; dd 0012ff7c L1 ; o endereço da variável0012ff7c 775e6034 ; o endereço da interface0:000&amp;gt; dd 775e6034 L1 ; onde está a vtable?775e6034 775e600c ; o endereço da vtable0:000&amp;gt; dd 775e600c775e600c 77562cfb 774dcf29 774dcf29 774dd00d ; a vtable ! ! !775e601c 774dd665 774dcfe8 774dd400 77562d46 ; a vtable ! ! !775e602c 77562d6e 775e6034 775e600c 774c0000 ; a vtable ! ! !775e603c 00000000 00000000 00154d70 774cbff4775e604c 00000000 00000000 00000000 00000000... E não é que tudo deu certo? A variável foi preenchida, e partir dela demos uma espiadela nos endereços das funções da vtable. Nós pegamos o valor da variável que foi preenchida (o endereço da interface) e obtemos os seus primeiros 4 bytes (o endereço da vtable) e listamos o seu conteúdo (a própria vtable!). Agora basta usarmos o resultados de nossas contagens lá em cima e colocarmos os breakpoints nas funções corretas. E mandar rodar. E analisar os resultados.
0:000&amp;gt; bp 774dd00d &amp;quot;.echo IMalloc::Alloc&amp;quot;0:000&amp;gt; bp 774dcfe8 &amp;quot;.echo IMalloc::Free&amp;quot;0:000&amp;gt; gIMalloc::Alloceax=775e6034 ebx=00000000 ecx=775e600c edx=774dd00d esi=00000001 edi=00403374eip=774dd00d esp=0012ff70 ebp=0012ffc0 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246ole32!IsValidIid&#43;0xe4:774dd00d 8bff mov edi,edi0:000&amp;gt; dd esp L30012ff70 &amp;lt;strong&amp;gt;00401031 775e6034 00001000&amp;lt;/strong&amp;gt; ; o this é nosso, e foi pedido para alocar 4KB (0x1000)0:000&amp;gt; bp /1 /c @$csp @$ra;g ; Step Out para pegar o retornoBreakpoint 3 hiteax=001597f0 ebx=00000000 ecx=7c9106eb edx=00150608 esi=00000001 edi=00403374eip=00401031 esp=0012ff7c ebp=0012ffc0 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206IMalloc&#43;0x1031:00401031 85c0 test eax,eax0:000&amp;gt; reaxeax=001597f0 ; esse é o endereço da memória alocadagIMalloc::Freeeax=774dcfe8 ebx=00000000 ecx=775e6034 edx=775e600c esi=00000001 edi=00403374eip=774dcfe8 esp=0012ff70 ebp=0012ffc0 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206ole32!IsValidIid&#43;0xbf:774dcfe8 8bff mov edi,edi0:000&amp;gt; dd esp L30012ff70 &amp;lt;strong&amp;gt;00401041 775e6034 001597f0&amp;lt;/strong&amp;gt; ; nosso this e endereço alocado (pedindo pra desalocar)g ; é isso aí Note que a função pode eventualmente ser chamada internamente (pelo próprio objeto) ou até por outro objeto que não estamos interessados em interceptar (lembre-se que os métodos de uma classe são compartilhados por todos os objetos). Por isso é importante sempre dar uma olhada no primeiro parâmetro, que é o this que obtemos primeiramente.
Com isso termina o nosso pequeno experimento de como é possível interceptar chamadas COM simplesmente contando e usando o WinDbg. OK, talvez um pouquinho a mais, mas nada de quebrar a cabeça.
</description>
</item>

     
        <item>
  <title>Aquisição de recurso é inicialização</title>
  <link>http://www.caloni.com.br/aquisicao-de-recurso-e-inicializacao/</link>
  <pubDate>2007-09-14</pubDate>
  
  <guid>http://www.caloni.com.br/aquisicao-de-recurso-e-inicializacao/</guid>
  <description>O título desse artigo é uma técnica presente no paradigma da programação em C&#43;&#43;, razão pela qual não temos o operador finally. A idéia por trás dessa técnica é conseguirmos usar recursos representados por objetos locais de maneira que ao final da função esses objetos sejam destruídos e, junto com eles, os recursos que foram alocados. Podemos chamar de recursos aquele arquivo que necessita ser aberto para escrita, o bitmap que é exibido na tela, o ponteiro de uma interface COM, etc. O nosso exemplo é sobre arquivos:
#include &amp;lt;stdio.h&amp;gt;class File{public:File(char* name){m_file = fopen(name, &amp;quot;r&amp;quot;);}~File(){fclose(m_file);}FILE* m_file;};int UseFile(){File config(&amp;quot;config.txt&amp;quot;);// using config.txtreturn 0; // config.m_file released}  Ignorei tratamento de erros e a dor de cabeça que é a discussão sobre inicializações dentro do construtor, matéria para um outro artigo. Fora os detalhes, o que temos é (1) uma classe que se preocupa em alocar os recursos que necessita e no seu fim desalocá-los, (2) uma função que usa um objeto dessa classe, alegremente apenas preocupada em usar e abusar do objeto. A demonstração da técnica reside no fato que a função não se preocupa em desalocar os recursos alocados pelo objeto config. Algo óbvio, desejável e esperado.
Para vislumbrarmos melhor a utilidade dessa técnica convém lidarmos com as famigeradas exceções. A possibilidade de nossa função ou alguma função chamada por essa lançar uma exceção enquanto nosso objeto está ainda construído -- e com o recurso alocado -- faz com que seja vital a classe do objeto ter sido bem construída a ponto de prever essa situação e liberar os recursos no destrutor. Daí o uso da técnica se torna necessário.
Por outro lado, ao usarmos objetos, devemos ter plena confiança nas suas capacidades de gerenciar os recursos que foram por eles alocados. Só assim se tem liberdade o suficiente para nos concentrarmos no código da função e solenemente ignorarmos a implementação da classe que estamos utilizando. Afinal, temos que considerar que muitas vezes o código-fonte não está disponível. Veja a mesma função com uma chance de desvio incondicional (o lançamento de uma exceção):
void BlowUpFunction(){// things aren&#39;t that good, so...throw Scatadush();}int UseFileEx(){File config(&amp;quot;config.txt&amp;quot;);BlowUpFunction(); // exception thrown:// config.m_file is // automagically releasedreturn 0;} Nesse exemplo tudo funciona, certo? Até se a exceção for lançada, o recurso será desalocado, pois o objeto é destruído. Isso ilustra como várias técnicas de C&#43;&#43; podem conviver harmoniosamente. Mais que isso, se ajudam mutuamente. O que seria das exceções se não existissem os construtores e destrutores? Da mesma forma, os recursos são alocados e desalocados baseado na premissa de construção e destruição de objetos. Por sua vez, essa premissa vale em qualquer situação, existindo ou não exceções.
Agora, e se a exceção de BlowUpFunction é lançada e a classe File não está preparada para fechar o arquivo no destrutor? Esse é o caso da versão 2 de nossa classe File, logo abaixo. Apesar de ser a segunda versão ela foi piorada (acontece nas melhores famílias e classes):
class File2{public:void Open(char* name){m_file = fopen(name, &amp;quot;r&amp;quot;);}void Close(){fclose(m_file);}FILE* m_file;};int UseFile2(){File2 config;config.Open(&amp;quot;config.txt&amp;quot;);BlowUpFunction(); // exception thrown:// the resource was // NOT releasedconfig.Close(); // resource releasedreturn 0;}  Nesse caso o código de UseFile2 acaba deixando um recurso alocado por conta de uma exceção que ocorreu em uma função secundária chamada lá pelas tantas em um momento delicado demais para ocorrerem exceções. Note que o destrutor de File2 é chamado assim como o de File, só que este não libera os recursos do objeto. Ele não usa a técnica RAII (Resource Acquisition Is Initialization, ou o título do artigo em inglês).
Nesse tipo de classe o convívio com exceções gera um dilema: onde está o erro? Como consertá-lo? Se o problema é encontrado numa hora apertada e temos cinco minutos para revolver isso, capturar a exceção causada por BlowUpFunction é uma boa idéia. Só que nem sempre as soluções de cinco minutos são as mais maduras. Podemos não saber muito bem o que fazer com esse tipo de exceção, por exemplo. Isso geraria um tratamento de erro ou redundante se tratarmos ali mesmo o Scatadush, já tratado em um escopo mais externo, ou fragmentado se apenas desalocarmos o recurso de File2 e relançarmos a exceção. Eu nem diria fragmentado, pois estamos tratando um erro inventado, se considerarmos que é função dos objetos desalocarem os recursos que foram por eles mesmos alocados.
A opção que dura mais de cinco minutos pode evitar futuras dores de cabeça: arregaçar as mangas e refazer a classe File2 observando o princípio de RAII. Possivelmente algo na interface deverá ser alterado, o que causará a alteração de mais códigos-fonte que utilizam essa classe. Alterar mais códigos-fonte significa testar novamente mais partes do software, algumas nem de perto relacionadas com o problema em si. Ou seja, não é cômodo, mas é íntegro. Sabendo que futuras funções que usarem essa classe já estarão corretas, mesmo que uma exceção seja lançada e não seja capturada, é um dado significativo: representa produtividade futura.
A decisão sobre qual solução é a melhor está muito além do escopo desse artigo, pois obviamente cada caso é um caso. Mas não custa nada pensar um pouco sobre C&#43;&#43; quando se estiver programando. E &amp;quot;aquisição de recurso é inicialização&amp;quot; faz parte do modo de pensar dessa linguagem.
</description>
</item>

     
        <item>
  <title>Guia básico de controle de código (Source Safe)</title>
  <link>http://www.caloni.com.br/guia-basico-de-controle-de-codigo-source-safe/</link>
  <pubDate>2007-09-12</pubDate>
  
  <guid>http://www.caloni.com.br/guia-basico-de-controle-de-codigo-source-safe/</guid>
  <description>O primeiro passo para se passar no Teste do Joel é possuir algum tipo de controle de código. E ele está mais do que certo. Não existe nada mais frustrante do que não ter exatamente o código-fonte da versão que está rodando no cliente ou não saber o que mudou desde que a versão foi entregue. Esse tipo de coisa pode acabar com uma empresa ou fazer com que ela fique muito mal vista no mercado.
Porém, independente do mercado, existe um bom motivo para o desenvolvedor possuir algum tipo de controle de código: controle. Se você ou sua equipe não conseguem corrigir todos os bugs, pelo menos saberão o que já foi feito. Se você achou um bug que não existia antes da versão 10, o histórico das mudanças entre a versão estável 9 e a versão não-tão-estável 10 vai te dar uma pista muito boa de onde o problema pode ter sido gerado. Visto dessa forma, não importa muito o tamanho da equipe ou da organização. O importante de um bom código é que suas mudanças estejam sempre registradas, visíveis e disponíveis a qualquer um.
Um controle de código para uma pessoa só não precisa ser nada muito sofisticado, sendo que um amontoado de ZIPs pode dar conta do recado. Porém, a partir do momento em que o número de desenvolvedores aumenta para dois ou mais, aí o controle baseado em ZIPs começa a ruir, e é necessário usar uma ferramenta mais apropriada. Existem algumas opções, que vai do gosto e necessidades de cada um:
  Visual Source Safe ou VSS não é gratuito nem robusto o suficiente para agüentar toneladas de código-fonte, mas vem junto do Visual Studio e pode ser apropriado para empresas de porte pequeno ou médio (e empresas de um programador só).
  Concurrent Version System ou CVS é um sistema fonte aberto, gratuito e robusto. Suficiente para agüentar toneladas de código-fonte e equipes de vários andares. Atualmente está sendo substituído gradualmente pelo
  Subversion ou SVN, um substituto moderno do antigo CVS; igualmente gratuito e poderoso, está rapidamente se tornando a opção predominante.
  Vou explicar aqui os principais passos para começar a utilizar um controle de código usando como exemplo o Source Safe versão 2005 que, apesar de não ser gratuito, é muito usado em empresas que programam para Windows e já utilizam o Visual Studio há muito tempo.
Antes de qualquer coisa é necessário criar uma base de dados onde estarão os fontes. Para isso a primeira execução do programa irá exibir um assistente que irá guiá-lo pelos poucos e simples passos para a criação de uma nova base.
O processo é bem simples, baseado em Next, Next, até que você chega em momento de decisão, onde deve escolher qual dos dois métodos de controle de fonte irá utilizar:
  Lock-Modify-Unlock Model. O modelo clássico do Source Safe, permite que apenas um programador altere um fonte de cada vez. Se você é novo nesse negócio de controle de fonte, recomendo essa opção, que é a mais indolor. Em equipes pequenas costuma funcionar. E esse é o modelo que iremos utilizar aqui.
  Copy-Modify-Merge Model. Esse novo modelo segue o princípio do CVS e do Subversion. Nele todos podem alterar ao mesmo tempo qualquer código-fonte. Porém, na hora de subir as modificações de volta para a base é necessário um passo intermediário conhecido como merge. É onde são resolvidos conflitos, caso algum desenvolvedor tenha feito modificações no mesmo local que você. Geralmente é escolhida uma ou mais pessoas para gerenciar essa parte do processo. Esse modelo tem funcionado bastante em projetos de fonte aberto e de empresas grandes.
  Agora que a base está criada, o próximo passo é torná-la disponível a todos. A maneira mais fácil de fazer isso é criando um compartilhamento na rede (de preferência oculto) e divulgando às pessoas interessadas. É claro que você, como bom administrador, irá ter que criar os usuários que irão acessar a base.
Após esse processo de integração, os usuários podem começar a usar o Source Safe através da primeira opção do início do assistente (Database Selection).
Antes de começar a mexer nos fontes, o Source Safe pede que você defina um diretório raiz onde começa a ramificação de pastas dos seus fontes. Isso pode ser feito pela opção File, Set Working Folder (Ctrl &#43; D). A partir daí, cada pasta é chamada de projeto (project) no Source Safe. Para criar novos projetos/pastas, use a opção &amp;quot;File, Create Project&amp;quot;. Para adicionar novos arquivos, &amp;quot;File, Add Files&amp;quot;. Cada usuário pode definir seu próprio diretório de trabalho por máquina, mas geralmente é uma boa idéia mantê-los todos utilizando a mesma pasta.
Após adicionar os arquivos do projeto, é possível fazer modificações usando a opção check-out. O check-out quer dizer que os fontes saem (OUT) da base e são copiados com direito de escrita para seu disco local. Após feitas as modificações, usa-se a opção check-in para subir as modificações para o banco. O check-in quer dizer que as modificações feitas no disco local entram (IN) na base. Cada operação feita com esses dois passos é armazenada no histórico do Source Safe, e podem ser utilizadas para voltar versões antigas, comparar versões antigas novas, etc.
Quando todos os fontes que subirem constituirem uma alteração madura, compilável, testada pelo desenvolvedor e pronta para ser repassada para os testadores, deve-se criar um rótulo, ou label, para que futuramente essa versão possa ser facilmente identificada entre os milhões de modificações de fonte que sua equipe irá fazer ao longo do tempo. Se essa versão se tornar uma &amp;quot;entregável&amp;quot;, pode-se utilizar o rótulo para obter exatamente a versão entregue a qualquer momento, independente de quantas modificações terem sido feitas depois. Essa marcação de fontes pode ser muito útil na ocorrência de incêndios, e todos sabemos que eles ocorrem com mais freqüência do que gostaríamos. Por isso é importante estar preparado.
Se você chegou até aqui, quer dizer que está realmente interessado em controlar seus fontes. Parabéns! O controle de fontes vem com algumas vantagens. Vamos supor que já exista uma versão estável no Source Safe e você precisa fazer alguma correção/teste como prova de conceito. Esse tipo de fonte normalmente seria descartável, mas agora que você possui uma ferramenta de controle de fonte funcionando, isso não é necessário.
Se é necessário desenvolver uma prova de conceito, pode-se optar por criar uma ramificação do fonte, ou branch. Essa opção cria um novo projeto no Source Safe com fontes existentes, mantém o histórico de modificações, mas gera uma nova linha de vida do fonte. Qualquer modificação feita em um branch fica nesse branch, seja o principal ou secundário. É possível também no futuro juntar dois branchs.
Agora, se a modificação é um simples teste durante a depuração, pode ser feito o check-out para modificações temporárias. Se mais tarde for decidido que as modificações não serão efetuadas na base, basta executar a opção undo check-out, que volta o fonte da base para o disco local e mantém a versão intacta. Use essa opção com cuidado, pois quaisquer modificações no disco local serão perdidas.
Agora que os fontes estão vivendo tranqüilamente no controle de fontes, é possível executar builds automatizados de tempos em tempos. Isso garante a estabilidade do seu projeto, pois junto dos builds é possível fazer testes, tanto da compilação em si quanto depois de compilado.
O Source Safe possui uma ferramenta em linha de comando que faz as mesmas operações que a versão gráfica, além de possuir uma série de interfaces COM que podem ser usadas para interagir com o controle de fontes através de scripts. Além de outras ferramentas de automação de builds que podem ser integradas, como o NAnt e o CruiseControl.
O resumo da ópera é: cuide bem dos seus fontes. Muito trabalho, tempo e dinheiro são despendidos com desenvolvimento. Não cuidar do resultado de tudo isso é como botar fogo no estoque de uma fábrica.
</description>
</item>

     
        <item>
  <title>Antidebug: Detectando Attach</title>
  <link>http://www.caloni.com.br/antidebug-detectando-attach/</link>
  <pubDate>2007-09-10</pubDate>
  
  <guid>http://www.caloni.com.br/antidebug-detectando-attach/</guid>
  <description>Hoje foi um belo dia para engenharia reversa e análise de proteções. Dois ótimos programas vieram ao meu conhecimento: um monitor de chamadas de API e um monitor de chamadas de COM (complementando o primeiro, que não monitora funções depois que CoCreateInstance foi chamado). Além de que no site do primeiro programa - de algum entusiasta do bom e velho Assembly Win32, diga-se de passagem - encontrei o código-fonte para mais uma técnica antidebugging, o que nos leva de volta para a já consagrada série de técnicas antidepuração.
O objetivo dessa proteção é detectar se, após o executável ter sido iniciado, algum depurador metido a besta tentou atachar-se no processo criado, ou seja, tentou iniciar o processo de depuração após o aplicativo já ter iniciada a execução. Isso é possível - de certa forma trivial - na maioria dos depuradores (se não todos), como o Visual Studio e o WinDbg. Diferente da técnica de ocupar a DebugPort, que impede a ação de attach, a proteção nesse caso não protege diretamente; apenas permite que o processo saiba do suposto ataque antes de entregar o controle ao processo depurador.
O código que eu encontrei nada mais faz do que se aproveitar de uma peculiaridade do processo de attach: ao disparar o evento, a função ntdll!DbgUiRemoteBreakin é chamada. Ora, se é chamada, é lá que devemos estar, certo? O código, então, insere um breakpoint hardcoded no início dessa função para capturar esse evento. Para compilar o código basta chamar o compilador seguido do linker, lembrando que precisamos da user32.lib linkada para chamar a função API MessageBox. Após o programa ter sido executado qualquer tentativa de attach irá exibir uma mensagem de detecção seguida pelo capotamento do programa.
Existem inúmeras maneiras de fazer a mesma coisa. O exemplo citado é o que é chamado comumente nas rodinhas de crackers de shellcode, que é um nome bonitinho para &amp;quot;array de bytes que na verdade é um assembly de um código que faz coisas interessantes&amp;quot;. Shellcode for short =).
Maneiras alternativas de fazer isso são:
 Declarar uma função naked no Visual Studio, criar uma função vazia logo após e fazer continha de mais e menos para chegar ao tamanho que deve ser copiado. Criar uma estrutura cujos membros são opcodes disfarçados. Dessa forma é possível no construtor dessa estrutura preencher os valores corretamente e usá-la como uma &amp;quot;função móvel&amp;quot;.  Ambas possuem prós e contras. Os contras estão relacionados com a dependência do ambiente. Na primeira alternativa é necessário configurar o projeto para desabilitar o &amp;quot;Edit and Continue&amp;quot;, enquanto no segundo é necessário alinhar a estrutura em 1 byte.
Seja qual for a solução escolhida, ao menos temos a vantagem do impacto no sistema de nosso aplicativo ser praticamente nulo, pois isolamos em duas funções - AntiAttachAbort e InstallAntiAttach - um hook de uma API local (do próprio processo) que supostamente nunca deveria ser chamada em um binário de produção. Além do mais, existem maneiras mais a la C&#43;&#43; de fazer coisas como &amp;quot;live assembly&amp;quot;. Mas isso já é matéria para futuros e excitantes artigos =D.
</description>
</item>

     
        <item>
  <title>História do Windows - parte 4.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-40/</link>
  <pubDate>2007-09-04</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-40/</guid>
  <description>Em meio a uma febre de consumismo, no dia 24 de agosto de 1995, foi lançado a revolução no sistema gráfico da Microsoft: a interface do Windows 95. Ela foi considerada muito mais amigável que suas versões anteriores. Ainda possuía a vantagem de não necessitar mais de uma instalação prévia do DOS, passou a suportar nomes de arquivos longos, incluir suporte a TCP/IP e dial-up networking integrados. Muitas mudanças foram feitas no sistema em si, como a passagem para 32 bits (como já vimos, parcial) e o novo conceito de threads, que é o que veremos com mais detalhes neste artigo.
 Bem, o &amp;quot;novo conceito&amp;quot; de threads já havia sido implementado no Windows NT desde o seu rascunho e já existia no início do projeto, mas não no velho Windows 3.1 de 16 bits, que foi a versão anterior ao 95. Parte dos requisitos do sistema foi que ele seria compatível com o NT no nível de aplicativo, o que de fato aconteceu.
 Para esse milagre da multiplicação das threads acontecer a Microsoft foi obrigada a portar boa parte do código de 16 bits para 32 e entrar em modo protegido. Mesmo assim, um legado razoável do MS-DOS permaneceu debaixo dos panos suportando o novo sistema operacional através de suas interrupções e código residente. Ou seja, havia ainda partes do SO rodando em modo real.
Com o lançamento da nova versão do NT foi necessário modernizar a interface para ser compatível com o Windows 95, o que fez com que o Windows 4.0 fosse mais bonitinho. No entanto, o núcleo dos dois sistemas era completamente diferente. Enquanto um era 32 bits puro desde o primeiro int main, o outro era um sistema de compatibilidade para fornecer um Windows caseiro que fosse vendável e desse à Microsoft o retorno financeiro esperado. Deu certo por um bom tempo, até a chegada do Windows XP, que uniu as duas famílias de sistemas operacionais, pois descontinuou o Windows ME e tornou o Windows 2000 Professional mais amigável para o uso geral.
E como funciona o sistema de threads? Uma thread é uma linha de execução de código. Ser um sistema multithreading significa que ele permite que múltiplas linhas de execução de código rodem em paralelo e, dependendo do número de processadores, ao mesmo tempo.
Porém, em uma plataforma com apenas um processador, como é natural supor, apenas uma thread roda de cada vez. Para dar a impressão de rodar ao mesmo tempo o tempo de execução das threads é dividido entre elas, de forma que aparentemente todas elas rodam ao mesmo tempo. Essa unidade de divisão do tempo de execução é conhecido como quantum, ou Time Slice, e é caracterizado como o tempo em que uma thread fica rodando até que outra thread tome o seu lugar, ou seja, ocorra uma troca de contexto (switch context). Quando uma thread é criada ela ganha seu primeiro time slice (se não iniciar suspensa) e divide o tempo de processamento com outras threads que executam no mesmo processador.
Para exemplificar o uso de threads imagine um programa que quebra senhas por força bruta. Funciona assim: enquanto uma thread fica cuidando das mensagens da janela, como digitação e movimentação do mouse e janela, uma segunda thread irá ficar constantemente tentanto descobrir sua senha digitada por tentativa e erro. Toda vez que é alterado um caractere na senha, a thread quebradora reinicia seu trabalho.
Todo programa inicia com uma thread que roda seu int main. A criação de uma nova thread é feita através da chamada da função API CreateThread.
void StartBruteForceThread(){g_bruteForceThread = CreateThread(NULL, 0, BruteForceThread, NULL, 0, &amp;amp;g_bruteForceThreadId);} Para quem está acompanhando a série de artigos sobre o Windows deve lembrar que assim como na criação de janelas, na criação de uma thread é passada uma função de callback. Só que diferente de uma função de janela, essa função não é executada na mesma thread que criou a janela, mas é um novo &amp;quot;int main&amp;quot; para uma nova linha de execução, que irá rodar em paralelo com a primeira. Essa segunda linha de execução termina quando retornamos dessa função, que no nosso exemplo é nunca, mas poderia ser quando fosse terminada sua tarefa.
Bom, acho que para explicar o uso de um sistema multithreading em um artigo só não basta. Mas para explicar por que sua senha deve ter mais de três caracteres, acho que é o bastante. Até a próxima.
</description>
</item>

     
        <item>
  <title>Hook de API no WinDbg</title>
  <link>http://www.caloni.com.br/hook-de-api-no-windbg/</link>
  <pubDate>2007-08-29</pubDate>
  
  <guid>http://www.caloni.com.br/hook-de-api-no-windbg/</guid>
  <description>Basicamente existem duas maneiras de um executável obter o endereço de uma função API do Windows: ou ele usa uma lib de interface com a DLL (o chamado &amp;quot;link estático&amp;quot;) ou ele chama a função GetProcAddress explicitamente 1.
Para conseguir saber as funções das quais um executável obtém o endereço através da primeira técnica podemos utilizar o mundialmente famoso Dependency Walker. Ele nos mostrará quais DLLs ele utiliza e quais funções por DLL ele quer o endereço. Ele também nos avisa sobre as DLLs que estão utilizando delay load, uma técnica inventada no Visual Studio para que os executáveis não dependam estaticamente de APIs muito novas que podem não existir em versões do Windows mais antigas. Com o (carinhosamente chamado) Depends também é possível fazer hook de chamadas de API utilizando a opção profiling (F7), mas não costuma funcionar muito bem com trojans, pois eles capotam antes que alguma coisa interessante ocorra.
O importante do Dependency Walker para o WinDbg é que com um editor é possível copiar todas as funções exibidas em sua interface para um editor, usar um pouco de regular expressions e criar uma batelada de breakpoints:
...bp user32!GetDC &amp;quot;.echo GetDC; g&amp;quot;bp user32!GetDesktopWindow &amp;quot;.echo GetDesktopWindow; g&amp;quot;bp user32!GetDlgCtrlID &amp;quot;.echo GetDlgCtrlID; g&amp;quot;bp user32!GetDlgItem &amp;quot;.echo GetDlgItem; g&amp;quot;bp user32!GetDlgItemTextW &amp;quot;.echo GetDlgItemTextW; g&amp;quot;bp user32!GetFocus &amp;quot;.echo GetFocus; g&amp;quot;... O comando &amp;quot;bp&amp;quot; cria um breakpoint no endereço requisitado. O que está entre aspas são os comandos que você deseja executar quando o breakpoint for disparado. No caso, para todas as funções será impresso o seu nome (comando &amp;quot;.echo&amp;quot;) e a execução irá continuar (comando &amp;quot;g&amp;quot;). Ao rodar o programa, as chamadas das funções são mostradas na saída do depurador:
...GetDesktopWindowGetDCGetFocusGetDlgItemGetDCGetDlgItemGetDCGetDlgItemGetDCGetDlgItemTextW... Lindo, não? Porém ainda podem estar sendo chamadas as funções obtidas pela segunda técnica, a do GetProcAddress. Para esse caso devemos ir um pouquinho mais fundo e rodar o executável duas vezes. Na primeira, coletamos as funções que são obtidas por essa técnica através do seguinte comando:
bp kernel32!GetProcAddress &amp;quot;da poi(esp &#43; 8); g&amp;quot; O comando &amp;quot;da&amp;quot; exibe o conteúdo de uma string em C (caracteres ANSI e terminada em zero) na memória. A memória no caso é o &amp;quot;apontado do valor contido no segundo parâmetro da pilha&amp;quot;. Complicado? Nem tanto: lembre-se que o ESP aponta sempre pro endereço de retorno da função chamadora e os parâmetros são sempre empilhados na ordem inversa da declaração em C. Logo, se o protótipo de GetProcAddress é:
FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName); O último parâmetro empilhado (ESP&#43;4) é o hModule, e o penúltimo (ESP&#43;8) é o lpProcName, que é o lugar onde é passado o nome da função.
Devemos lembrar de colocar esse breakpoint bem no início da execução e rodar o executável uma vez. Com isso coletamos o conjunto de nomes de funções usadas para chamar GetProcAddress:
...746e29f8 &amp;quot;ImmReleaseContext&amp;quot;746e2a30 &amp;quot;ImmNotifyIME&amp;quot;746e2934 &amp;quot;CtfImmEnterCoInitCountSkipMode&amp;quot;746e2978 &amp;quot;CtfImmLeaveCoInitCountSkipMode&amp;quot;746e29bc &amp;quot;ImmGetDefaultIMEWnd&amp;quot;746e2a64 &amp;quot;ImmSetConversionStatus&amp;quot;746e2aa0 &amp;quot;ImmGetConversionStatus&amp;quot;746e2adc &amp;quot;ImmGetProperty&amp;quot;746e2b10 &amp;quot;ImmGetOpenStatus&amp;quot;... Daí é só organizar a lista obtida em ordem alfabética, acabar com duplicidades e criar o mesmo tipo de breakpoint que foi usado para as funções estáticas (pode ser sem o nome da DLL porque, embora não recomendado, o WinDbg se vira para encontrar os símbolos). Depois de criados os comandos, rodamos novamente o executável e, logo no início, já colocamos todos os breakpoints das funções coletadas.
Essa é uma maneira rústica, porém eficaz e rápida de obter a lista de execução da API utilizada por um programa 2.
  Uma variação do método GetProcAddress é a técnica de delay load usado pelo Visual C&#43;&#43;. Porém, como o Dependency Walker nos mostra também as DLLs que estão linkadas usando essa técnica se torna dispensável um tratamento ad hoc. &amp;#x21a9;&amp;#xfe0e;
 Essa técnica nem sempre funciona com todas as chamadas API, pois o aplicativo ainda pode utilizar outras maneiras de obter o endereço de uma função e chamá-la. A solução definitiva seria escrever diretamente um assembly esperto no começo da função, o que pode gerar mais problemas que soluções. Do jeito que está, conseguimos resolver 90% dos nossos problemas com análise de chamadas API. O resto nós podemos resolver em futuros artigos. &amp;#x21a9;&amp;#xfe0e;
   </description>
</item>

     
        <item>
  <title>Antidebug: ocupando a DebugPort</title>
  <link>http://www.caloni.com.br/antidebug-ocupando-a-debugport/</link>
  <pubDate>2007-08-23</pubDate>
  
  <guid>http://www.caloni.com.br/antidebug-ocupando-a-debugport/</guid>
  <description>Quando um depurador inicia um processo para ser depurado ou, o caso abordado por este artigo, se conecta em um processo já iniciado, as comunicações entre esses dois processos é feita através de um recurso interno do Windows chamado de LPC (Local Procedure Call). O sistema cria uma &amp;quot;porta mágica&amp;quot; de comunicação específica para a depuração e os eventos trafegam por meio dela.
Entre esses eventos podemos citar os seguintes:
 Breakpoints disparados. Exceções lançadas. Criação/saída de threads. Load/unload de DLLs. Saída do processo.  No caso de se conectar em um processo já existente, é chamada a função da API DebugActiveProcess. A partir dessa chamada, se retornado sucesso, o processo que depura agora está liberado para ficar chamando continuamente a função API WaitForDebugEvent. E o código se resume a isto:
void DebugLoop(){bool exitLoop = false;while( ! exitLoop ){DEBUG_EVENT debugEvt;WaitForDebugEvent(&amp;amp;debugEvt, INFINITE);switch( debugEvt.dwDebugEventCode ){// This one...// That one...// Process is going out.case EXIT_PROCESS_DEBUG_EVENT:exitLoop = true;break;}// Unfreeze the thread who sent the debug event.// Otherwise, it stays frozen forever!ContinueDebugEvent(debugEvt.dwProcessId, debugEvt.dwThreadId, DBG_EXCEPTION_NOT_HANDLED);}}  O detalhe interessante desse processo de comunicação depurador/depurado é que um processo só pode ser depurado por apenas UM depurador. Ou seja, enquanto houver um processo depurando outro, os outros processos só ficam na vontade.
Partindo desse princípio, podemos imaginar uma proteção baseada nessa exclusividade, criando um processo protetor que conecta no processo protegido e o &amp;quot;depura&amp;quot;. Fiz um código de exemplo que faz justamente isso: ele atacha em um processo para depurá-lo (basta passar o PID como parâmetro) e não deixa mais outro depurador ocupar a debug port. Os passos para testá-lo são:
 Compilar o código. Executar o notepad (ou qualquer outra vítima). Obter seu PID (Process ID). Executar o protetor passando o PID como parâmetro. Tentar &amp;quot;atachar&amp;quot; no processo através do Visual C&#43;&#43;.  Após o processo de attach, a porta de debug é ocupada, e a comunicação entre depurador e depurado é feita através do LPC. Abaixo uma pequena ilustração de como as coisas ocorrem:
Basicamente o processo fica recebendo eventos de debug (através da fila de mensagens LPC) continuamente até o evento final, o de final de processo. Note que se alguém tentar derrubar o processo que depura o processo depurado cai junto.
O ponto forte desse tipo de proteção é que não afeta a compreensão e a legibilidade do código. De fato o próprio código que &amp;quot;protege&amp;quot; está em outro processo. O fraco, eu diria, é a sua alta visibilidade. Todo mundo que tentar atacar verá dois processos serem criados; e isso já faz pensar...
Por isso é necessário pensar bem na implementação. Particularmente uma coisa a ser bem arquitetada é a união entre depurador e depurado. Quanto melhor essas duas peças forem encaixadas, tão mais difícil será para o atacante separá-las. Uma idéia adicional é utilizar a mesma técnica na direção oposta, ou seja, o processo depurado se atachar no depurador.
Dessa vez não vou afirmar que, uma vez entendido o problema, a solução torna-se óbvia. Isso porque ainda não pensei o suficiente para achar uma solução óbvia. Idéias?
</description>
</item>

     
        <item>
  <title>Erro de compilação: funções muito novas na Win32 API</title>
  <link>http://www.caloni.com.br/erro-de-compilacao-funcoes-muito-novas-na-win32-api/</link>
  <pubDate>2007-08-21</pubDate>
  
  <guid>http://www.caloni.com.br/erro-de-compilacao-funcoes-muito-novas-na-win32-api/</guid>
  <description>Quando fala-se em depuração geralmente o pensamento que vem é de um código que já foi compilado e está rodando em alguma outra máquina e gerando problemas não detectados nos testes de desenvolvedor. Mas nem sempre é assim. Depuração pode envolver problemas durante a própria compilação. Afinal de contas, se não está compilando, ou foi compilado errado, é porque já existem problemas antes mesmo da execução começar.
O fonte abaixo, por exemplo, envolve um detalhe que costuma atormentar alguns programadores, ou por falta de observação ou documentação (ou ambos).
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;windows.h&amp;gt;void main(void){typedef enum _COMPUTER_NAME_FORMAT{ComputerNameNetBIOS,ComputerNameDnsHostname,ComputerNameDnsDomain,ComputerNameDnsFullyQualified,ComputerNamePhysicalNetBIOS,ComputerNamePhysicalDnsHostname,ComputerNamePhysicalDnsDomain,ComputerNamePhysicalDnsFullyQualified,ComputerNameMax} COMPUTER_NAME_FORMAT;COMPUTER_NAME_FORMAT CF = ComputerNameDnsDomain;char szDomainName[MAX_COMPUTERNAME_LENGTH];DWORD dwSize = sizeof(szDomainName);//GetComputerName(szDomainName, &amp;amp;dwSize);GetComputerNameEx(CF, szDomainName, &amp;amp;dwSize);}  Tirando o fato que o retorno void não é mais um protótipo padrão da função main e que a definição da enumeração COMPUTER_NAME_FORMAT dentro da função main é no mínimo suspeita, podemos testar a compilação e verificar que existe exatamente um erro grave neste fonte:
cl getcomputername.cppgetcomputername.cpp(26) : error C3861: &#39;GetComputerNameEx&#39;: identifier not found A função GetComputerNameEx parece não ter sido definida, apesar de estarmos incluindo o header windows.h, que é o pedido pela documentação do MSDN.
Esse tipo de problema acontece na maioria das vezes por dois motivos:
 o header responsável não foi incluído (não é o caso, como vimos), é necessário especificar a versão mínima do sistema operacional.  De fato, se criarmos coragem e abrirmos o arquivo winbase.h, que é onde a função é definida de fato, e procurarmos pela função GetComputerNameEx encontramos a seguinte condição:
#if (_WIN32_WINNT &amp;gt;= 0x0500)typedef enum _COMPUTER_NAME_FORMAT {ComputerNameNetBIOS,ComputerNameDnsHostname,ComputerNameDnsDomain,ComputerNameDnsFullyQualified,ComputerNamePhysicalNetBIOS,ComputerNamePhysicalDnsHostname,ComputerNamePhysicalDnsDomain,ComputerNamePhysicalDnsFullyQualified,ComputerNameMax} COMPUTER_NAME_FORMAT ;WINBASEAPIBOOLWINAPIGetComputerNameExA (__in COMPUTER_NAME_FORMAT NameType,__out_ecount_part_opt(*nSize, *nSize &#43; 1) LPSTR lpBuffer,__inout LPDWORD nSize);WINBASEAPIBOOLWINAPIGetComputerNameExW (__in COMPUTER_NAME_FORMAT NameType,__out_ecount_part_opt(*nSize, *nSize &#43; 1) LPWSTR lpBuffer,__inout LPDWORD nSize);#ifdef UNICODE#define GetComputerNameEx GetComputerNameExW#else#define GetComputerNameEx GetComputerNameExA#endif // !UNICODE//...#endif // _WIN32_WINNT Ou seja, para que essa função seja visível a quem inclui o windows.h, é necessário antes definir que a versão mínima do Windows será a 0x0500, ou seja, Windows 2000 (vulgo Windows 5.0). Aliás, é como aparece na documentação. Um pouco de observação nesse caso seria o suficiente para resolver o caso, já que tanto abrindo o header quanto olhando no exemplo do MSDN nos levaria a crer que é necessário definir essa macro:
#define _WIN32_WINNT 0x0500#include &amp;lt;windows.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;tchar.h&amp;gt;void _tmain(void){TCHAR buffer[256] = TEXT(&amp;quot;&amp;quot;);TCHAR szDescription[8][32] = {TEXT(&amp;quot;NetBIOS&amp;quot;), TEXT(&amp;quot;DNS hostname&amp;quot;), TEXT(&amp;quot;DNS domain&amp;quot;), TEXT(&amp;quot;DNS fully-qualified&amp;quot;), TEXT(&amp;quot;Physical NetBIOS&amp;quot;), TEXT(&amp;quot;Physical DNS hostname&amp;quot;), TEXT(&amp;quot;Physical DNS domain&amp;quot;), TEXT(&amp;quot;Physical DNS fully-qualified&amp;quot;)};int cnf = 0;DWORD dwSize = sizeof(buffer);for( cnf = 0; cnf &amp;lt; ComputerNameMax; cnf&#43;&#43; ){if (!GetComputerNameEx( (COMPUTER_NAME_FORMAT)cnf, buffer, &amp;amp;dwSize) ){_tprintf(TEXT(&amp;quot;GetComputerNameEx failed (%d)\n&amp;quot;),GetLastError());return;}else _tprintf(TEXT(&amp;quot;%s: %s\n&amp;quot;), szDescription[cnf], buffer);dwSize = sizeof(buffer);ZeroMemory(buffer, dwSize);}}  Outra observação que poderia ter ajudado na hora de codificar seria dar uma olhada no que os caras escrevem na seção de advertências (remarks) da documentação:
 To compile an application that uses this function, define the _WIN32_WINNT macro as 0x0500 or later. For more information, see Using the Windows Headers.
 Podemos também notar pela definição do COMPUTER_NAME_FORMAT dentro do main que o código estava no meio do caminho de cometer um sacrilégio: declarar funções e estruturas que já estão definidas nos headers da API. Portanto, se você já encontrou algum código parecido com esse, é hora de colocar em prática algumas teorias de refactoring.
</description>
</item>

     
        <item>
  <title>Junctions</title>
  <link>http://www.caloni.com.br/junctions/</link>
  <pubDate>2007-08-17</pubDate>
  
  <guid>http://www.caloni.com.br/junctions/</guid>
  <description>Semana passada baixei uma nova imagem para minha máquina de desenvolvimento. Esse esquema do pessoal da engenharia instalar as coisas para você facilita muito as coisas, mas existe o risco de algo ser instalado no lugar errado, que foram os casos do DDK e do SDK do Windows. Aqui no desenvolvimento, para efeito de padronização, utilizamos a seguinte estrutura de diretórios para esses dois aplicativos:
Library|- ddk|- legacy|- mssdk Porém, por algum motivo desconhecido os instaladores da Microsoft não seguem o nosso padrão: o SDK é instalado em %programfiles%, Microsoft Platform SDK e o DDK em C:, WINDDK, 3790.1830. Para corrigir este pequeno ato relapso eu até poderia reinstalar ambos os aplicativos no local correto, gastanto algumas horas do dia, mas existe uma outra solução mais rápida e simpática chamada de junction.
Um junction é um link simbólico (symbolic link) de diretório. É praticamente um atalho, com a diferença que ele se comporta exatamente como se fosse o próprio objeto para o qual aponta: qualquer arquivo criado ou apagado usando o junction cria ou apaga um arquivo real no diretório real para o qual ele aponta. Essa característica pode ser tão útil quanto perigosa, por isso devem-se utilizar junctions com cuidado.
Para criar um junction pode-se usar uma ferramenta disponível no Windows Resource Kit chamada linkd.exe. Porém, para evitar de ter que baixar todo o pacote para usar um único arquivo, existe uma outra ferramenta desenvolvida à parte por Mark Russinovich chamada... junction. O comando para criar junctions é bem fácil e direto:
junction c:\library\mssdk &amp;quot;path where is microsoft platform sdk&amp;quot;junction c:\library\ddk &amp;quot;path where is winddk&amp;quot; E é isso aí. A partir de agora tanto as pastas originais quanto os junctions criados para elas respondem como se fossem a mesma coisa, porém com paths diferentes.
 &amp;quot;Neo, sooner or later, you&#39;re going to realize, just as I did, that there&#39;s a different between knowing the path... and walking the path...&amp;quot;
 No Windows Vista os junctions também funcionam para arquivos e possuem seu próprio aplicativo nativo, o mklink.exe. Porém, ele chama os links para diretórios de junctions (em português, junções) e os links para arquivos de links mesmo. Você pode notar uma pequena gamb.. adaptação técnica ao mudarem o nome da pasta &amp;quot;Documents and Settings&amp;quot; para &amp;quot;Users&amp;quot; (ou &amp;quot;Usuários&amp;quot;, na versão em português). Esse link é extremamente necessário para a compatibilidade daqueles aplicativos feitos às pressas que não se importam em perguntar para o sistema onde está a pasta de documentos do usuário, fixando o path como se ele fosse estar sempre lá.
</description>
</item>

     
        <item>
  <title>História da Linguagem C: Parte 2</title>
  <link>http://www.caloni.com.br/historia-da-linguagem-c-parte-2/</link>
  <pubDate>2007-08-15</pubDate>
  
  <guid>http://www.caloni.com.br/historia-da-linguagem-c-parte-2/</guid>
  <description>No princípio... não, não, não. Antes do princípio, quando C era considerada a terceira letra do alfabeto e o que tínhamos eram linguagens experimentais para todos os lados, dois famigerados senhores dos Laboratórios Bell, K. Thompson e D. Ritchie, criaram uma linguagem chamada B. E B era bom.
O bom de B era sua rica expressividade e sua simples gramática. Tão simples que o manual da linguagem consistia de apenas 30 páginas. Isso é menos do que as 32 palavras reservadas de C. As instruções eram definidas em termos de ifs e gotos e as variáveis eram definidas em termos de um padrão de bits de tamanho fixo, geralmente a word, ou palavra, da plataforma, que utilizada em expressões definiam seu tipo. Esse padrão de bits era chamado rvalue. Imagine a linguagem C de hoje em dia com apenas um tipo: int.
Como esse padrão de bits nunca muda de tamanho, todas as rotinas da biblioteca recebiam e retornavam sempre valores do mesmo tamanho na memória. Isso na linguagem C quer dizer que o char da época ocupava tanto quanto o int. Existia inclusive uma função que retornava o caractere de uma string na posição especificada:
c = char(string, i); /* the i-th character of the string is returned */ Sim! Char era uma função, um conversor de &amp;quot;tipos&amp;quot;. No entanto a própria variável que armazenava um char tinha o tamanho de qualquer objeto da linguagem. Esse é o motivo pelo qual, tradicionalmente, as seguintes funções recebem e retornam ints em C e C&#43;&#43;:
int getchar( void ); // read a character from stdinint putchar( int c ); // writes a character to stdoutvoid *memset( void *dest, int c, size_t count ); // sets buffers to a specified character Segue o exemplo de uma função na linguagem B, hoje muito famosa:
/* The following function is a general formatting, printing, andconversion subroutine. The first argument is a format string.Character sequences of the form `%x&#39; are interpreted and causeconversion of type &#39;x&#39; of the next argument, other charactersequences are printed verbatim. Thusprintf(&amp;quot;delta is %d*n&amp;quot;, delta);will convert the variable delta to decimal (%d) and print thestring with the converted form of delta in place of %d. Theconversions %d-decimal, %o-octal, *s-string and %c-characterare allowed.This program calls upon the function `printn&#39;. (see section9.1) */printf(fmt, x1,x2,x3,x4,x5,x6,x7,x8,x9) {extrn printn, char, putchar;auto adx, x, c, i, j;i= 0;	/* fmt index */adx = &amp;amp;x1;	/* argument pointer */loop :while((c=char(fmt,i&#43;&#43;) ) != `%&#39;) {if(c == `*e&#39;)return;putchar(c);}x = *adx&#43;&#43;;switch c = char(fmt,i&#43;&#43;) {case `d&#39;: /* decimal */case `o&#39;: /* octal */if(x &amp;lt; O) {x = -x ;putchar(&#39;-&#39;);}printn(x, c==&#39;o&#39;?8:1O);goto loop;case &#39;c&#39; : /* char */putchar(x);goto loop;case &#39;s&#39;: /* string */while(c=char(x, j&#43;&#43;)) != &#39;*e&#39;)putchar(c);goto loop;}putchar(&#39;%&#39;) ;i--;adx--;goto loop;}  Como podemos ver, vários elementos (se não todos) da linguagem C já estão presentes na B.
</description>
</item>

     
        <item>
  <title>GINA x Credential Provider</title>
  <link>http://www.caloni.com.br/gina-x-credential-provider/</link>
  <pubDate>2007-08-13</pubDate>
  
  <guid>http://www.caloni.com.br/gina-x-credential-provider/</guid>
  <description>Não fui convidado a participar do tema, mas como já faz algum tempo que o rascunho deste artigo está no molho, e aproveitando que meu amigo Ferdinando resolveu escrever sobre nossa amiga em comum, darei continuidade à minha empolgação sobre o tagging e largarei aqui este pequeno adendo.
Com a chegada do Windows Vista, uma velha conhecida minha e dos meus colegas deixou de fazer parte do sistema de autenticação do sistema operacional: a velha GINA, Graphical Identification aNd Authentication.
Basicamente se trata de uma DLL que é chamada pelo WinLogon, o componente responsável pelo famoso Secure Attention Sequence (SAS), mais conhecido por Ctrl &#43; Alt &#43; Del. Ele efetua o logon do usuário, mas quem mostra as telas de autenticação, troca de senha, bloqueio da estação é a GINA. Mexi com várias GINAs há um tempo atrás: GINAs invisíveis, GINAs que autenticam smart cards, GINAs que autenticam pela impressão digital, e por aí vai a valsa.
O Windows já vem com uma GINA padrão, a MsGina.dll, que autentica o usuário baseada em usuário e senha e/ou smart card. Teoricamente o intuito original de uma GINA fornecida por terceiros era permitir outros meios de autenticação. Para isso o fornecedor deveria trocar todas as telas de autenticação pela equivalente de acordo com o novo tipo de autenticação (por exemplo, um campo com uma impressão digital para permitir o uso de biometria em vez de senha). Porém, um outro uso pode ser controlar o login dos usuários baseado em outras regras além das que o Windows já fornece.
Apesar de útil, o sistema baseado em GINAs tinha um pequeno problema: permitia somente a troca exclusiva, ou seja, só uma GINA pode ser ativada. Se não for a da Microsoft, que seja a do fornecedor, e apenas a de um fornecedor. Isso começa a ficar limitado diante das novas e conflitantes maneiras que um usuário possui hoje em dia de fazer logon: nome e senha, íris dos olhos, impressão digital, formato do nariz e assim por diante. Todas essas autenticações deveriam estar disponíveis ao mesmo tempo para que o usuário escolha qual deles lhe convém.
Foi por isso que surgiu seu substituto natural no Windows Vista: o Credential Provider.
O sistema de Credential Provider permite que inúmeras DLLs sejam registradas no sistema para receberem eventos de logon, seja para criar uma nova sessão (tela de boas vindas) ou apenas para se autenticar já em uma sessão iniciada, como, por exemplo, nos casos em que o Controle da Conta do Usuário (UAC: User Account Control) entra em ação.
O sistema de coleta foi simplificado e modernizado: agora a interface não se baseia em funções exportadas, como a GINA, mas em interfaces COM disponíveis. O desenvolvedor também consegue escolher os cenários em que ele pretende entrar em ação:
 Efetuar logon. Desbloquear estação. Mudar a senha. Efetuar conexão de rede (antes do logon).  Baseado no número de CPs registrados no sistema, o LogonUI (processo responsável por exibir a tela de boas vindas) irá exibir as respectivas credenciais para cada um dos CPs envolvidos no logon.
Já que fomos brindados com um exemplo de GINA stub do Ferdinando também irei disponibilizar um outro exemplo, este um pouco mais perigoso, da época de laboratório da faculdade. Se trata igualmente de uma GINA que se aproveita da implementação da GINA original, porém na hora de autenticar um usuário ela captura os dados do logon (usuário e senha) e grava em uma parte do registro acessível apenas pelo sistema (lembre-se que a GINA, por fazer parte do WinLogon, roda na conta de sistema).
 É claro que para utilizar essa GINA, você deve possuir direitos de administração, ou conhecer alguma brecha de segurança. Eu optei pela segunda opção, já que não tinha a primeira. Podemos dizer apenas que o artigo sobre falhas de segurança relacionadas a usuários avançados do Russinovich pôde resolver meu problema.
 </description>
</item>

     
        <item>
  <title>Antidebug: interpretação baseada em exceção (parte 2)</title>
  <link>http://www.caloni.com.br/antidebug-interpretacao-baseada-em-excecao-parte-2/</link>
  <pubDate>2007-08-09</pubDate>
  
  <guid>http://www.caloni.com.br/antidebug-interpretacao-baseada-em-excecao-parte-2/</guid>
  <description>No primeiro artigo vimos como é possível &amp;quot;enganar&amp;quot; o depurador através de exceções e assim fazer o atacante perder um tempo considerável tentando se desvencilhar dos breakpoints de mentira. Porém, vimos também que essa é uma solução difícil de manter no código-fonte, além de possuir o ponto fraco de ser facilmente contornada se descoberta. Agora é a hora de tornar as coisas mais fáceis de manter e ao mesmo tempo garantir maior dificuldade mesmo que o atacante descubra o que está acontecendo debaixo do seu nariz.
O upgrade apresentado aqui continua utilizando o lançamento de exceções intrinsecamente, mas agora não depende mais da divisão do código em minifunções e chamá-las aos poucos. Em vez disso, temos apenas que pegar traços de código e colocá-los em torno de uma macro milagrosa que fará tudo o que quisermos. Isso, claro, depois de algumas marteladas que serão explicadas aqui.
void LongJmp(restorePoint){BackToStart(restorePoint);}int Start(){if( RestorePoint() == Defined ){LongJmp(if);}else{CallFunc();}return 0;} A solução acima está apresentada em pseudo-código para tornar mais claro o conceito. Note que existe uma espécie de &amp;quot;retorno invisível&amp;quot;, não baseado em retorno de pilha, envolvido. Para implementá-lo, contudo, podemos nos ajeitar com o velho e bom padrão C ANSI, com as rotinas setjmp e longjmp. Para entender a implementação dessa funções na plataforma 8086 precisamos ter primeiro uma visão básica da estrutura de chamada de funções baseada em pilha.
Registradores são variáveis reservadas do processador que podem ser utilizadas pelo código assembly da plataforma envolvida. Stack frame (estrutura da pilha) nada mais é que a hierarquia de chamadas das funções, o &amp;quot;quem chamou quem&amp;quot; em uma execução qualquer. Call e ret são instruções em assembly para chamar uma função (call) e sair de uma função (ret), respectivamente. Ambas alteram o stack frame.
Imagine que você tem uma função, CallFunc, e outra função, Func, e que uma chame a outra. Para analisarmos apenas a chamada de função, e apenas isso, vamos considerar que Func não recebe nenhum parâmetro e não retorna nenhum valor. O código em C fica, então, assim:
void Func(){return;}void CallFunc(){Func();} Simples, não? Por esse mesmo motivo o disassembly terá que ser igualmente simples. Em CallFunc ele deverá conter a chamada da função (call) e em Func o retorno da chamada (ret). Se você compilar o código acima e o assembly vier com mais coisas pode ser que que eventualmente apareça mais código embutido em versões Debug, ou se estiver muito diferente ou inexistente pode ser uma otimização do seu compilador.
Func:00411F73 prev_instruction ; ESP = 0012FD38 (four bytes stacked up)00411F74 ret ; *ESP = 00411FA3 (return address)CallFunc:00411F9C prev_instruction00411F9E call Func (411424h) ; ESP = 0012FD3C00411FA3 next_instruction A partir do assembly acima podemos concluir no mínimo duas coisas:
 a pilha &amp;quot;cresce&amp;quot; para baixo, pois seu valor decrementou de quadro (0012FD3C para 0012FD38 são 4 byte a menos). o valor de retorno da função chamada é o endereço da próxima instrução após a chamada (call), no caso 00411FA3.  Ora, da mesma forma que conseguimos acompanhar essa simples execução, o atacante também o fará. Por isso que no meio dessa chamada iremos colocar o lançamento de uma exceção e, no retorno, faremos não do modo convencional apresentado, mas por uma outra técnica que, ao invés de utilizar a instrução ret, seta &amp;quot;manualmente&amp;quot; o valor do registrador ESP (estado da pilha) e &amp;quot;pula&amp;quot; para a próxima instrução de CallFunc.
Func:00411F60 throw_exception00411F61 ...00411F73 catch_exception00411F74 mov ESP, 0012FD3C ; ESP = 0012FD3C, como em CallFunc00411F75 jmp 00411FA3 ; &amp;quot;pula&amp;quot; para CallFunc::next_instruction Toda essa esculhambada em assembly não precisa ser necessariamente feita em linguagem de baixo nível. Foi apenas uma maneira que encontrei pra ilustrar as diferenças entre retorno baseado em pilha e alteração no fluxo do código. Como já foi dito, para a sorte e o bem-estar de todos, essa mesma técnica pode ser implementada com funções C da biblioteca ANSI:
jmp_buf stack_state;void Func(){longjmp(stack_state, 1);}void CallFunc(){// setting returns 0// returning returns not 0if( setjmp(stack_state) == 0 )Func();int x = 10;} Essa foi a técnica adicionada à solução do lançamento de exceções. E o código final ficou mais claro (além de rápido, por economizar o uso de uma thread para leitura dos comandos).
/** The only purpose of this function is to generate an exception. */DWORD LongJmp(jmp_buf* env){__try{__asm int 3}__except( EXCEPTION_EXECUTE_HANDLER ){longjmp(*env, 1);}return ERROR_SUCCESS;}/** And God said: &#39;int main!&#39;*/int main(){DWORD ret = ERROR_SUCCESS;while( cin ){string line;cout &amp;lt;&amp;lt; &amp;quot;Type something\n&amp;quot;;getline(cin, line);jmp_buf env;if( setjmp(env) == 0 ){LongJmp(&amp;amp;env);}else{cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl;}}return (int) ret;}  À primeira vista parece um desperdício o if estar diretamente no código (lembre-se que vamos utilizar a mesma estrutura condicional em várias e várias partes do código. Para tornar mais claro seu uso, resumir a chamada protegida e permitir que a proteção seja desabilitada em debug, vamos criar uma macro:
/** Use this macro instead LongJmp*/#define ANTIDEBUG(code){jmp_buf env;if( setjmp(env) == 0 ){LongJmp(&amp;amp;env);}else{code;}}/** And God said: &#39;int main!&#39;*/int main(){DWORD ret = ERROR_SUCCESS;while( cin ){string line;cout &amp;lt;&amp;lt; &amp;quot;Type something\n&amp;quot;;getline(cin, line);ANTIDEBUG(( cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl ));}return (int) ret;}  Veja que como agora permitimos a seleção do anti-debug por chamada, fica mais fácil escolher quais os pontos a serem protegidos e quais não devem/podem por conta de perfomance ou outro detalhe obscuro que sempre existe na vida de um programador C&#43;&#43;.
</description>
</item>

     
        <item>
  <title>História do Windows - parte 3.51</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-351/</link>
  <pubDate>2007-08-07</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-351/</guid>
  <description>Bem-vindos. Esta é a série História do Windows. Nos anos 90, a relação IBM/Microsoft era muito próxima por causa do desenvolvimento do OS/2, o projeto de um novo sistema operacional. As empresas cooperavam entre si e tinham acesso uma ao código da outra. A Microsoft desejava avançar seu desenvolvimento no Windows, enquanto a IBM desejava que todo trabalho futuro fosse baseado em OS/2. Para resolver essa tensão as duas combinaram que a IBM iria desenvolver o OS/2 versão 2.0 para substituir o OS/2 versão 1.3 e o Windows v3.0, enquanto a Microsoft iria desenvolver um novo sistema operacional, o OS/2 versão 3.0 para depois suceder ao OS/2 anterior. Com tudo combinado entre as grandes corporações, é lógico que esse acordo foi por água abaixo.
A relação IBM/Microsoft foi terminada. A IBM continuou a desenvolver o OS/2 v2.0 enquanto a Microsoft mudou o nome de seu ainda não lançado OS/2 v3.0 para Windows NT. O Windows NT foi tão massivamente promovido que a maioria das pessoas nem se deu conta que ele era um OS/2 redesenhado. Ambas as empresas obtiveram os direitos de utilizarem as tecnologias do OS/2 e do Windows que foram desenvolvidas até a quebra do acordo.
A IBM lançou a versão 2.0 do OS/2 no início dos anos 90. O sistema foi uma grande melhora sobre o antigo OS/2 v1.3. Apresentava um novo sistema de janelas orientado a objetos (o Workplace Shell) para substituir o Presentation Manager, um novo sistema de arquivos (o HPFS) para substituir o sistema FAT utilizado pelo DOS e Windows e aproveitou todas as vantagens das capacidades 32 bits do processador 386 da Intel. Ele também rodava programas DOS e Windows 3.0, uma vez que a IBM tinha acesso e direito a essas duas tecnologias.
Para concorrer com a IBM a Microsoft lançou o Windows 3.1, com pequenas melhorias à sua versão anterior, a 3.0.
A Microsoft continuou a desenvolver o Windows NT. A empresa requeriu os serviços de Dave Cutler, um dos chefes arquitetos da VMS na Digital Equipment Corporation (hoje parte da Compaq) para desenvolver o NT dentro de um projeto de sistema operacional mais capaz. Cutler estava desenvolvendo um seguimento para o VMS na DEC chamado Mica, e quando a DEC desistiu do projeto ele acabou trazendo para a Microsoft sua especialidade nesse sistema e algum engenheiros do projeto com ele. A DEC acreditava que ele usara parte do código do Mica no Windows NT e acabou processando a Microsoft. A empresa de Gates teve que eventualmente pagar 150 milhões para a DEC, além de concordar em suportar o chip Alpha CPU da DEC na plataforma NT, e é por isso que existe uma pasta com essa arquitetura no CD de instalação do Windows NT.
Sendo um sistema operacional completamente novo o Windows NT sofreu com questões de compatibilidade com hardware e software geralmente usados na época. Ele era também concentrado em recursos, o que o deixava aceitável apenas para máquinas maiores e mais caras. Tanto que inicialmente foi dirigido a servidores de rede, workstations e máquinas de desenvolvimento de software. Por causa disso, a maioria dos usuário foi incapaz de migrar para a plataforma NT. E o Windows NT ainda estava projetado graficamente como o Windows 3.1, o que era inferior ao OS/2 Workplace Shell. Em resposta, a Microsoft começou a desenvolver um sucessor para o Windows 3.1, um projeto de codinome Chicago. Chicago tinha por objetivo apresentar uma nova GUI que competisse com o OS/2 Workplace Shell. Ele também foi projetado para ser de 32 bits e suportar execução multitarefa, como o OS/2 e o Windows NT. Só algumas partes do Chicago, entretanto, foram convertidas para 32 bits, e o resto permaneceu em 16. A Microsoft argumentou que a conversão total iria atrasar em muito o projeto, o que acabaria por encarecê-lo além do limite.
Para o Chicago foi desenvolvida uma nova API para substituir a de 16 bits do Windows anterior. Essa API foi chamada de Win32, e a outra renomeada para Win16. Houveram 3 ramificações: uma para o Chicago, outra para o NT e uma terceira chamada Win32s, que foi um subconjunto para o Windows 3.1 garantir a compatibilidade retroativa das versões. Também foi pensado num mínimo de compatibilidade entre o Chicago e o Windows NT, mesmo que os dois possuíssem duas arquiteturas radicalmente diferentes.
Em setembro de 1994 é lançada o Windows NT 3.5. A versão Workstation substituiu o Windows NT 3.1 e a versão Server o Windows NT 3.1 Advanced Server.
Como todo projeto de sucesso, a primeira coisa a ser feita é definir os objetivos principais. No caso do Windows NT não foi diferente. É importante para nós sabermos que objetivos eram esses e como eles foram mudando de acordo com o momento histórico de forma a analisarmos as conseqüências. Em outubro de 1988 os objetivos do novo sistema operacional eram os seguintes:
 Compatibilidade com OS/2; Segurança; Suporte a POSIX; Multiprocessamento; Rede integrada; Confiabilidade.  Como o Windows 3.0 fez um sucesso enorme, a compatibilidade nativa passou a ser do próprio Windows caseiro, sendo o OS/2 sendo implementado como um mero subsistema. Subsistema no Windows basicamente quer dizer ambiente virtual de execução de processos feitos para rodar em outro sistema operacional. Essa maneira de suportar processos de outros sistemas operacionais foi usado tanto para o OS/2 quanto para o Windows 16 bits, o MS-DOS e aplicativos POSIX, o padrão utilizado para arquiteturas derivadas do UNIX.
O tempo do projeto foi inicialmente estimado em pouco mais de dois anos. Ao final, quatro anos e meio se passaram até a chegada do primeiro release, que era grande e lento para as máquinas da época. Assim foi iniciado o projeto Daytona, que teve como novos objetivos tornar a nova versão do NT mais rápida e confiável. Foi lançada então a versão 3.51.
O Windows NT é um sistema operacional de 32 bits. Isso quer dizer, entre outras coisas, que ele suporta duas propriedades fundamentais dos sistemas operacionais modernos: modo protegido de execução e memória virtual. O modo protegido de execução permite a divisão entre a parte confiável do sistema operacional, que roda em kernel mode, e a parte não-confiável, que não possui acesso às instruções privilegiadas; a parte não-confiável chamamos de user mode. A memória virtual abstrai a memória física e permite isolamento de memória entre aplicativos, evitando que um programa invada a memória do outro.
Além disso, foi criada uma camada de abstração do hardware (HAL, Hardware Abstraction Layer) que livrou boa parte do código de ter sido escrito em assembly, fazendo assim que ele fosse facilmente portável.
</description>
</item>

     
        <item>
  <title>História do Windows - parte 3.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-30/</link>
  <pubDate>2007-08-03</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-30/</guid>
  <description>Em 22 de maio de 1990 a versão 3.0 do Windows foi lançada. Foi melhorado o gerenciador de programas e o sistema de ícones, além de um novo gerenciador de arquivos e suporte a 16 cores. Entre as mudanças internas podemos citar a velocidade e a confiabilidade. Como a partir dessa versão apareceram muitos desenvolvedores que passaram a suportar a plataforma, o número de programas disponíveis aumentou, o que conseqüentemente fez com que as vendas alavancassem. Três milhões de cópias foram vendidas apenas no primeiro ano, e assim o Windows se tornou padrão nos computadores domésticos. Quando a versão 3.1 foi lançada, em 6 de abril de 1992, mais três milhões de cópias foram vendidos em apenas dois meses.
As fontes TrueType foram adicionadas, junto de novas capacidades multimídia. Outro grande avanço foi na área de comunicação entre aplicativos com a implementação da tecnologia OLE (Object Linking and Embedding), que permitiu documentos de diferentes fabricantes serem intercambiados.
Em novembro de 1993 foi lançada a primeira versão que integrou o Windows e a rede de trabalho, o Windows for Workgroups 3.1. O suporte a compartilhamento de arquivos e impressoras apareceu a partir daí. Duas aplicações novas também surgiram: Microsoft Mail, cliente de mail para uso em redes, e Schedule&#43;, uma agenda de trabalho.
E, finalmente, agora já é hora de conversarmos sobre a figura ilustre que popularizou ainda mais o desenvolvimento para Windows.
Quem começou a programar para Windows naquela época com certeza deve ter ouvido falar do livro clássico de Charles Petzold, uma das poucas referências naquela época sem internet: Programming Windows 3.1. É um livro consideravelmente completo se considerarmos a época em que foi escrito. Vários exemplos estão disponíveis em suas páginas, mas para os que não viveram essa época (como eu) existe a versão eletrônica disponível para download. Você deve estar se perguntando se todo esse código-fonte serve para alguma coisa hoje em dia. Por incrível que pareça, serve sim. E para demonstrar o conceito de compatibilidade retroativa da Microsoft, iremos utilizar os mesmos exemplos deste livro, sem por nem tirar uma linha de código. Com o devido copyright e respeito merecidos ao autor, é claro =).
Programar interfaces naquela época não era bem o &amp;quot;clicar e arrastar&amp;quot; de hoje em dia. Eram necessários profundos conhecimentos sobre como o sistema operacional se relacionava com o seu programa e vice-versa. Hoje em dia é possível ainda programar como antigamente, já que toda a estrutura continua a mesma. Porém, é algo extremamente contraproducente de se fazer com as IDEs modernas que existem e suas barras de controles pré-fabricados e código automático. Faremos da forma mais rústica para entender como as coisas funcionam por baixo dos panos, o que por si só será extremamente produtivo para o nosso conhecimento.
Antes de ser criada uma janela, é necessário registrar uma classe de janela no sistema, cuja relação com uma janela é mais ou menos a mesma entre classe e objeto no paradigma de orientação a objetos. Você primeiro define uma classe para sua janela e posteriormente pode criar inúmeras janelas a partir da mesma classe.
WNDCLASS wndclass; //Dados sobre a classe de janela.wndclass.style = CS_HREDRAW | CS_VREDRAW;wndclass.lpfnWndProc = WndProc; // Função de janela (isso é importante!)...wndclass.lpszClassName = szAppName;RegisterClass (&amp;amp;wndclass) ; // Registra a classe de janela. Quando você define uma classe e a registra está dizendo para o sistema qual será sua função de janela, i. e., qual será a função responsável por receber as mensagens das janelas criadas.
wndclass.lpfnWndProc = WndProc ; // Função de janela....long FAR PASCAL WndProc (HWND hwnd, WORD message, WORD wParam, LONG lParam){switch( message ) // Manipulando as mensagens....} Uma mensagem é um evento que ocorre relativo à sua janela ou o que está acontecendo ao redor dela no mundo Windows. Por exemplo, as janelas recebem eventos a respeito dos cliques do usuário, redesenho da janela, etc. Quem envia essas mensagens é o próprio Windows, e ele espera uma resposta da sua função de janela. Agora a parte esquisita: quem envia essas mensagens para o Windows é o seu próprio aplicativo!
O aplicativo fica aguardando por eventos em um loop conhecido como loop de mensagens. A função do loop basicamente é chamar a função GetMessage e redirecionar as mensagens obtidas para as respectivas funções de janela.
while( GetMessage (&amp;amp;msg, NULL, 0, 0) ){TranslateMessage (&amp;amp;msg);DispatchMessage (&amp;amp;msg); // Despacha a mensagem para a função de janela.} E aqui está o código completo:
/*--------------------------------------------------------HELLOWIN.C -- Displays &amp;quot;Hello, Windows&amp;quot; in client area(c) Charles Petzold, 1990--------------------------------------------------------*/#include &amp;lt;windows.h&amp;gt;long FAR PASCAL WndProc (HWND, WORD, WORD, LONG) ;int PASCAL WinMain (HANDLE hInstance, HANDLE hPrevInstance,LPSTR lpszCmdParam, int nCmdShow){static char szAppName[] = &amp;quot;HelloWin&amp;quot; ;HWND hwnd ;MSG msg ;WNDCLASS wndclass ;if (!hPrevInstance){wndclass.style = CS_HREDRAW | CS_VREDRAW ;wndclass.lpfnWndProc = WndProc ;wndclass.cbClsExtra = 0 ;wndclass.cbWndExtra = 0 ;wndclass.hInstance = hInstance ;wndclass.hIcon = LoadIcon (NULL, IDI_APPLICATION) ;wndclass.hCursor = LoadCursor (NULL, IDC_ARROW) ;wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;wndclass.lpszMenuName = NULL ;wndclass.lpszClassName = szAppName ;RegisterClass (&amp;amp;wndclass) ;}hwnd = CreateWindow (szAppName, // window class name&amp;quot;The Hello Program&amp;quot;, // window captionWS_OVERLAPPEDWINDOW, // window styleCW_USEDEFAULT, // initial x positionCW_USEDEFAULT, // initial y positionCW_USEDEFAULT, // initial x sizeCW_USEDEFAULT, // initial y sizeNULL, // parent window handleNULL, // window menu handlehInstance, // program instance handleNULL) ; // creation parametersShowWindow (hwnd, nCmdShow) ;UpdateWindow (hwnd) ;while (GetMessage (&amp;amp;msg, NULL, 0, 0)){TranslateMessage (&amp;amp;msg) ;DispatchMessage (&amp;amp;msg) ;}return msg.wParam ;}long FAR PASCAL WndProc (HWND hwnd, WORD message, WORD wParam, LONG lParam){HDC hdc;PAINTSTRUCT ps;RECT rect;switch (message){case WM_PAINT:hdc = BeginPaint (hwnd, &amp;amp;ps) ;GetClientRect (hwnd, &amp;amp;rect) ;DrawText (hdc, &amp;quot;Hello, Windows!&amp;quot;, -1, &amp;amp;rect,DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;EndPaint (hwnd, &amp;amp;ps) ;return 0 ;case WM_DESTROY:PostQuitMessage (0) ;return 0 ;}return DefWindowProc (hwnd, message, wParam, lParam) ;}  Esse exemplo é bem velho, mas compila e funciona até hoje, depois de passados 17 anos. Pode não rodar, mas esta é outra história.
cl /c hellowin.clink hellowin.obj user32.lib gdi32.libhellowin.exe O Windows 3.x tinha uma particularidade nefasta: qualquer aplicativo poderia travar o sistema como um todo. Se lembrarmos que o Windows antigamente era multitarefa e não-preemptivo, podemos deduzir que enquanto é executada a função de janela de um aplicativo o sistema aguarda por esse aplicativo indefinidamente. Se o aplicativo trava, ele nunca retorna. Se ele nunca retorna, o sistema fica eternamente esperando pelo retorno da função de janela. Alguns travamentos conseguiam ser resolvidos por interrupção, mas a maioria não. No próximo capítulo da série veremos como os sistemas de 32 bits resolveram esse pequeno problema.
O que o resto do código do Petzold faz? Dê uma olhada na documentação do MSDN. Ela ainda está disponível, já que todos os aplicativos precisam utilizar essas funções, seja diretamente ou através de imensos frameworks de interface com o usuário. E existem pessoas que precisam suportar código-fonte legado.
Já que agora você sabe o que são funções de janela, mensagens e afins, por que não ver tudo isso funcionando? O Microsoft Visual Studio possui uma ferramenta muito útil para isso chamada Spy&#43;&#43; (spyxx.exe). Existem também aplicativos equivalentes (com fonte). Outra ferramenta muito útil, principalmente na hora de desenvolver janelas com controles comuns do Windows, é o Control Spy.
Para saber mais dê uma passada no sítio do Charles Petzold.
</description>
</item>

     
        <item>
  <title>História da Linguagem C: Parte 1</title>
  <link>http://www.caloni.com.br/historia-da-linguagem-c-parte-1/</link>
  <pubDate>2007-08-01</pubDate>
  
  <guid>http://www.caloni.com.br/historia-da-linguagem-c-parte-1/</guid>
  <description>Confesso que adoro estudar sobre a história da linguagem C. Essa verdadeira adoração pela linguagem me fez estudar suas precursoras, como as linguagens BCPL e B. Posso dizer que todo esse conhecimento, no final das contas, valeu a pena. Hoje entendo muito melhor as decisões tomadas na criação da linguagem e, principalmente, a origem de algumas idiossincrasias e boas idéias que permaneceram até hoje.
Em 21 de julho de 1967 Martin Richards libera o manual da sua recém-criada linguagem BCLP. Na verdade, ela havia sido criada em 66 e implementada na primavera do ano seguinte no Instituto de Tecnologia de Massachusetts (vulgo MIT). Seus objetivos eram claros, como para todo criador de uma nova linguagem: melhorar uma linguagem anterior. Nesse caso, foi uma melhoria da Combined Programming Language (CPL), retirando, de acordo com Martin, &amp;quot;todas aquelas características da linguagem completa que tornavam a compilação difícil&amp;quot;.
E BCPL era de fato bem simples. Não tinha tipos, era limpa e poderosa. Porém, mais importante que tudo isso, ela era portável. E essa portabilidade, aliada ao fato que escrever compiladores para ela era bem mais simples (alguns compiladores rodavam com apenas 16 KB), a tornaram especialmente popular na época.
Essa portabilidade era obtida com o uso de um artifício mais ou menos conhecido da comunidade C/C&#43;&#43; hoje em dia: a divisão entre código objeto e código final. O compilador era dividido em duas partes: a primeira parte era responsável por criar um código em estado intermediário feito para rodar em uma máquina virtual. Esse código era chamado de O-code (O de object). A segunda parte do compilador era responsável por traduzir esse O-code no código da máquina-alvo (onde iria ser rodado o programa). Essa sacada genial de 40 anos atrás permitiu que fosse mais simples fazer um compilador para uma nova plataforma e portar todo o código que já tinha sido escrito para uma plataforma anterior, driblando o grande problema daquela época: a incompatibilidade entre plataformas.
Perceba que é possível fazer toda a parte do compilador detrás do código-objeto uma única vez e, conforme a necessidade, criar novos interpretadores BCPL para máquinas diferentes.
O código intermediário é gerado para uma máquina virtual. O interpretador, cerca de um quinto do compilador, tem a função de traduzir o código gerado para a máquina-alvo. Qualquer semelhança com Java ou .NET não é mera coincidência. Pois é. As boas idéias têm mais idade que seus criadores.
É inevitável também não fazer a associação entre essa forma de funcionamento do compilador BCPL e a divisão feita em C/C&#43;&#43; entre o pré-processador, o compilador e o ligador (linker, em inglês).
O uso do pré-processador na linguagem C facilitou a portabilidade por um bom tempo, quando não existiam typedefs. Diferente do BCPL, C já tinha tipagem, o que quer dizer que era necessário escolher o espaço de armazenamento que seria utilizado para as variáveis. Com o pré-processamento, essa escolha pode ser feita de maneira seletiva, documentada e generalizada.
#ifdef SBRUBLE_PLATFORM#define UINT unsigned char /* space limitation */#else#define UINT unsigned int#endif Como é natural, o código-fonte de uma aplicação tende a crescer em muitas linhas durante sua evolução, especialmente se estamos falando de sistemas operacionais. A compilação desse código vai tomar cada vez mais tempo no processo de desenvolvimento. Por isso, manter esse código-fonte em um mesmo arquivo eventualmente torna-se inviável, tornando a compilação de módulos separados uma solução pra lá de elegante. Compila-se apenas o módulo que foi modificado e liga-se esse módulo com módulos pré-compilados.
Para continuar lendo sobre a história da linguagem existe uma segunda parte.
</description>
</item>

     
        <item>
  <title>C and C&#43;&#43; Operators Precedence Table</title>
  <link>http://www.caloni.com.br/c-and-c-operators-precedence-table/</link>
  <pubDate>2007-07-30</pubDate>
  
  <guid>http://www.caloni.com.br/c-and-c-operators-precedence-table/</guid>
  <description> Wanderley, your explanation about why a program compiles in C&#43;&#43; and not in C seems to me logic and correct, but gave me some doubts, because I always learned that the C and C&#43;&#43; operator precedence are the same thing. I checked out the Appendix A in the &amp;quot;C &#43;&#43; - How To Program&amp;quot; (sixth edition) and the book table is equal to the C operators precedence table and it is different from the C&#43;&#43; precedence table presented by you in the article. I went to the internet and found out in two websites the table and both are equal to the book table:
 Wikipedia CppPreference  From where did you get the presented C&#43;&#43; table?
[]s,
Márcio Andrey Oliveira
 Dear Márcio,
You have been my most productive reader ever. Besides having found the portability fail using static variables inside ifs, now you put in check the precedence table comparison between these two languages. In fact, some things were not so clear in that post. Let&#39;s clarify everything now (or at least try) using trustworthy sources, including the Wikipedia link sent to me.
The first doubt it&#39;s about the most basic principle: what is a precedence table? Well, it is what defines, amount a set of concurrent operations in a language, which will be the evaluation order. In other words, what cames first, what cames next, etc. Through this table is possible to know all the language facts, as the fact that the multiplication operators are evaluated before the addition operators.
This way, the table can resolve 99% of the evaluation order issues in a language, but it is not perfect.
Let&#39;s see, by example, the conditional operator, most of the times known by ternary operator. Given its peculiar format, even having the precedence lower than the comma operator, the language doesn&#39;t allow a misinterpretation. If so,
a ? b , c : d will be interpreted as
a ? ( b , c ) : d and not as
( a ? b ) , ( c : d ) that would be the logic result if we followed the precedence table, since the comma operator has lower precedence than the ternary operator. But that doesn&#39;t make any sense in the language, and that&#39;s why the first form is understood by the compiler, even contradicting the precedence table. This is corroborated by the following quote from Wikipedia in the page you shared:
 A precedence table, while mostly adequate, cannot resolve a few details. In particular, note that the ternary operator allows any arbitrary expression as its middle operand, despite being listed as having higher precedence than the assignment and comma operators.
 That is one of the reasons why the precedence table is just a way to express the grammar rules of a language in a simple and resumed manner. It is not the grammar neither ought to be. Let&#39;s see one more quotation, this time from the Stroustrup himself, just after presented the C&#43;&#43; precedence table (by the way, that was the source used by me to get the table for my post):
 A few grammar rules cannot be expressed in terms of precedence (also known as binding strength) and associativity.
 We can see from my example, the Wikipedia example and the Stroustrup example that the ternary operator is the main victim. Not for less. Talking about the grammar, the C ternary operator definition is different from the C&#43;&#43; ternary operator definition. While in C this operator is defined like this:
conditional-expression:logical-OR-expressionlogical-OR-expression ? expression : conditional-expression In C&#43;&#43; language it is defined like this:
conditional-expression:logical-OR-expressionlogical-OR-expression ? expression : assignment-expression This little difference can give us some (rare) situations where we can get a syntax error in C. As in a Wikipedia example, the following expression:
e = a ? b : c = d It is interpreted by the C language as:
e = ( ( a ? b : c ) = d ) In the C&#43;&#43; language is interpreted as:
e = ( a ? b : ( c = d ) )  In the C language case, we have a compilation error because the code is trying to assign a value to a lvalue (remember that lvalues can&#39;t be assigned to anything).
( a ? b : c ) = d  But in C&#43;&#43; there&#39;s no invalid assignment, what makes a no error compilation performed.
Now, one last question, that seems to be the most relevant in this precedence issue: why is the Stroustrup book precedence table different from the C precedence table?
Well, I believe that, after all our analysis, the answer must be somewhat obvious: knowing that, in the ternary operator, the third operand is an assignment-expression, it is most likely the table is agree with the grammar if we put a extra weight for the assignment operators before the ternary operator. This way, if the third operand is an assignment operation (as the case above), the imaginary parentesis will be put first in the assignment operation, making the grammar definition valid:
( a ? b : ( c ) = d ) I hope this second post about the precedence table have cleared a bit more about the subject. It is not easy to understand the C language, but once you start to try, one magic door opens. Some things to remember from this experience:
 The precedence table is not in the Standard; it is deduced from the grammar rules. There are rare expressions where we can&#39;t use the precedence table (e.g. ternary operator). Nobody knows so well a language to the point to understand 100% from it; after all, nobody (and nothing) is perfect.  </description>
</item>

     
        <item>
  <title>Movendo o cursor do mouse com o teclado</title>
  <link>http://www.caloni.com.br/movendo-o-cursor-do-mouse-com-o-teclado/</link>
  <pubDate>2007-07-26</pubDate>
  
  <guid>http://www.caloni.com.br/movendo-o-cursor-do-mouse-com-o-teclado/</guid>
  <description>Bom, vamos deixar de papo furado e &amp;quot;codar&amp;quot;. Para essa primeira tentativa iremos desenvolver um programa que move o cursor do mouse quando pressionada uma tecla de atalho e voltar à sua posição original quando pressionada outra tecla.
 Nota de desculpas: eu sei que estou sendo rabugento demais com o mouse. Já é o segundo artigo que escrevo falando como evitar o mouse e isso deve realmente irritar os fãs desse ponteirinho irritante.
 Como eu já havia dito anteriormente, uso o mouse quando necessário. Quando ele não é necessário ele fica clicando inconscientemente no Windows Explorer, já que utilizo a configuração de clique único, onde as pastas e arquivos ficam selecionáveis apenas pousando o cursor sobre eles. Eu gosto dessa configuração, exceto pelo comportamento desagradável que ocorre quando mudo para a janela do Windows Explorer e meu mouse ganha vida própria, selecionando alguma pasta ou arquivo e mudando meu foco de seleção.
Portanto, o objetivo desse programa é simples e direto: mover o mouse para um canto enquanto eu uso meu teclado. Nada mais, nada menos. Para isso iremos registrar alguns atalhos globais no Windows. Para registrar atalhos globais no Windows utilizamos a função do Windows API RegisterHotKey e é o que estou usando no código. O importante aqui é saber que iremos ser avisados do pressionamento das teclas que registrarmos por meio dessa função através do loop de mensagens da thread que chamar a função.
Um loop de mensagens é a maneira definida pelo Windows para avisar as aplicações dos eventos que ocorrerem no sistema que são relevantes para as suas janelas. Teremos chance de observar isso mais vezes, mas por enquanto basta ter uma visão geral do fluxo de mensagens que ocorre quando digitarmos a nossa tecla de atalho.
Como você pode ver o código não tem muitos segredos. Para registrar os atalhos, usamos a função RegisterHotKey. Para manipular os eventos usamos o tal loop de mensagens e manipulamos a mensagem WM_HOTKEY de acordo com a tecla pressionada. Para mover o mouse usamos a função SetCursorPos (e para armazenar a posição atual GetCursorPos). Por fim, para ler configurações de um .ini usamos a função GetPrivateProfileInt. Abaixo um exemplo desse arquivo texto:
[HideCursor]DisableX=600DisableY=0 Você acha que os atalhos &amp;quot;WinKey &#43; Del&amp;quot;, &amp;quot;WinKey &#43; Insert&amp;quot; e &amp;quot;WinKey &#43; End&amp;quot; foram uma má escolha para essa função de esconder o mouse? Concordo. Fiz de propósito. Que tal customizar o programa para que as teclas sejam lidas do arquivo de configuração HideCursor.ini?
</description>
</item>

     
        <item>
  <title>Antidebug: interpretação baseada em exceção (parte 1)</title>
  <link>http://www.caloni.com.br/antidebug-interpretacao-baseada-em-excecao-parte-1/</link>
  <pubDate>2007-07-20</pubDate>
  
  <guid>http://www.caloni.com.br/antidebug-interpretacao-baseada-em-excecao-parte-1/</guid>
  <description>Um depurador utiliza breakpoints para &amp;quot;paralisar&amp;quot; momentaneamente a execução do programa sendo depurado. Para isso ele se utiliza de uma bem conhecida instrução conhecida como int 3. Essa instrução gera uma exceção -- exceção de breakpoint -- que é capturada pelo sistema operacional e repassada para o código de tratamento dessa exceção. Em programas sendo depurados esse código está localizado no depurador. Em programas &amp;quot;livres&amp;quot; esse código normalmente não existe e ao acontecer essa exceção o aplicativo simplesmente &amp;quot;capota&amp;quot;.
A idéia principal na proteção baseada em exceção é tomarmos conta dessas exceções durante a execução do aplicativo. Fazendo isso podemos nos aproveitar desse fato e, no código responsável por tratar a exceção, executar o código protegido. A solução discutida aqui é parecido com um interpretador de scripts. Consiste basicamente de duas threads. A primeira thread lê uma seqüência de instruções e manda a segunda thread executá-las passo a passo. Para fazer isso a segunda thread usa um conjunto de pequenas funções com blocos de código bem definidos. Em pseudocódigo isso ficaria assim:
void Function1();void Function2();void Function3();//...void FunctionN();void ExecThread(){while( true ){ExecFunction(funcNumber);}}int Functions[] = { 3, 4, 1, 2, 34, 66, 982};int Start(){CreateThread(ExecThread);for( 0 to size(Functions) ){ExecThreadToExecFunc(Function[i]);}return 0;}  A proteção ainda não está aí. Mas fará parte intrínseca da thread de execução. Tudo que precisamos fazer é adicionar um tratamento de exceções e fazer chover ints 3. As exceções disparadas pela int 3 são capturadas por uma segunda função que antes de retornar o controle executa a próxima instrução enfileirada:
DWORD ExceptFilter(){ExecFunction(number);// goes to except codereturn EXCEPTION_EXECUTE_HANDLER;}void ExecThread(){while( true ){__try{// breakpoint exception__asm int 3// it stops the debugger // if we have an attached // debugger in the process// or throws an exception // if there is no one}__except( ExceptFilter() ){// does nothing}Sleep(someTime);}}  O algoritmo da thread de execução continua o mesmo. Só que o ponto onde cada instrução é executada depende do lançamento de uma exceção. Note que essa exceção tem que ocorrer para que a chamada da próxima instrução ocorra. Isso é fundamental, pois dessa forma ninguém pode simplesmente retirar o int 3 do código para evitar o lançamento da exceção. Se fizer isso, então mais nenhuma instrução será executada.
Na prática, se alguém tentar depurar um programa desse tipo vai ter que enfrentar dezenas ou centenas de lançamento de exceções até descobrir o que está acontecendo. Claro que, como em toda a proteção de software, ela não é definitiva; tem por função dificultar o trabalho de quem tenta entender o software. Isso não vai parar aqueles que são realmente bons no que fazem.
O preço pago por essa proteção fica na visibilidade e compreensão do código-fonte comprometidos pelo uso da técnica. A programação fica baseada em uma máquina de estados e as funções ficam limitadas a algum tipo de padronização no comportamento. Quando mais granular for o pseudoscript, ou seja, quanto menores forem os blocos de código contido nas minifunções, mais difícil de entender o código será.
Fiz um código de exemplo que recebe entrada por um prompt de comandos e mapeia a primeira palavra digitada para o índice de uma função que deve ser chamada. O resto da linha digitada é passado como parâmetro para essa função. A thread de interpretação lê a entrada do usuário e escreve em uma variável-string global, ao mesmo tempo que a thread de execução espera essa string ser preenchida para executar a ação.
Foi usado o pool dessa variável para o código ficar mais simples, mas o ideal seria algum tipo de sincronismo, como eventos, por exemplo.
O ponto forte da proteção é que a pessoa precisa entender o que está acontecendo para tomar alguma atitude inteligente para solucionar o &amp;quot;problema&amp;quot;. O ponto fraco é que após entendido o problema a solução torna-se fácil de visualizar. Tão fácil que eu nem pretendo citar aqui.
Futuramente veremos uma maneira de tornar as coisas mais legíveis e usáveis no dia-a-dia de um programador de software de segurança.
</description>
</item>

     
        <item>
  <title>What happens inside the sizeof operator</title>
  <link>http://www.caloni.com.br/what-happens-inside-the-sizeof-operator/</link>
  <pubDate>2007-07-16</pubDate>
  
  <guid>http://www.caloni.com.br/what-happens-inside-the-sizeof-operator/</guid>
  <description>The question: how to get the size of a struct member without declaring it as a variable in memory? In pseudocode:
static const size_t FIELD_SIZE_MSGID = 15;struct FEEDER_RECORD_HEADER{char MessageID[FIELD_SIZE_MSGID];char MessageIndex[10];};// error C2143: syntax error : missing &#39;)&#39; before &#39;.&#39;char MessageIndexBuffer[sizeof(FEEDER_RECORD_HEADER.MessageIndex) &#43; 1];// error C2070: &#39;&#39;: illegal sizeof operandchar MessageIndexBuffer[sizeof(FEEDER_RECORD_HEADER::MessageIndex) &#43; 1];  In this first try (even being a nice one) we can clearly see by instinct that the construction is not supposed to work. The compiler error is not even clear. The member access operator (the point sign) needs to have as its left some variable or constant of the same type of the struct. Since the operand is the type itself, there is no deal.
The second test is more feasible. Even the compiler can alert us. We have accessed the right member in the right struct but in the wrong way. As we&#39;re not using a static member or, in other words, a class variable, we can&#39;t access the member by scope. We need an object. But in order to have an object we are supposed to have to create one, and this is exactly what is not allowed in our solution.
This kind of problem reminds me about a curious feature inside the sizeof operator: it doesn&#39;t evaluate the expressions used as operands. How&#39;s that? Well, as the sizeof main purpose is to provide us the memory size filled by the expression, it simply doesn&#39;t make sense to execute the expression. We just need to note that the language we&#39;re talking about defends eficiency and clarity as main principles. If you want to execute the expression, we do it without using sizeof operator.
So, now we know that everything put inside a sizeof is not going to be executed in fact. It works somewhat like the c&#43;&#43; &amp;quot;dead zone&amp;quot;: is the place where - talking about executable code - nothing runs. That means we can build a object inside sizeof that nothing is going to happen, except for the expression size. Let&#39;s look the resulting assembly:
sz = sizeof( (new FEEDER_RECORD_HEADER)-&amp;gt;MessageID ); // this...mov dword ptr [sz], 0Fh ; ... is translated into this Another way to do the same thing (for those who can&#39;t bear the use of operator new delete, seeing the code as a memory leak):
sz = sizeof( ((FEEDER_RECORD_HEADER*)0)-&amp;gt;MessageID ); // this...mov dword ptr [sz], 0Fh ; ... is translated into this Conclusion: the operator new is called and nothing happens. We got what we wanted. That shows us one more time that the little details built inside a language layout are only very important in the exact time we need them.
</description>
</item>

     
        <item>
  <title>Precedence difference</title>
  <link>http://www.caloni.com.br/precedence-difference/</link>
  <pubDate>2007-07-10</pubDate>
  
  <guid>http://www.caloni.com.br/precedence-difference/</guid>
  <description>Once upon a time my old friend Kabloc wrote this little and &amp;quot;harmless&amp;quot; function in order to print the multiplication table:
#include &amp;lt;stdio.h&amp;gt;int main(){int f1,f2,s=0;for(f1=1;(f1==11&amp;amp;&amp;amp;s!=5)?s=5,f1=0,putchar(10):(f1&amp;lt;=10)?f1=f1:f1=12,f1&amp;lt;=11;f1&#43;&#43;)for(f2=1&#43;s;f2&amp;lt;=5&#43;s;f2&#43;&#43;)printf(&amp;quot;%dx%d=%d%c&amp;quot;,f2,f1,f1*f2,(f2==5&#43;s)?10:9);return 0;}  Despite the fact the result is a strong candidate to The International Obfuscated C Code Contest the Linux guys told him the code was not successful on GCC, and somewhere inside those four lines there was a non-standard piece of code.
Asked to solve the problem, given my congenital inclination to random subjects involving C&#43;&#43;, I decided to fix the things up in my old-n-good Visual Studio 2003. Nonetheless, it compiles C source code as well. We just need to rename the file from .cpp to .c. It was doing this that I found the following compiler error:
error C2106: &#39;=&#39; : left operand must be l-value That happens in the line 6, the first for line. In other words, a C source that compiles as C&#43;&#43; but gives us a lack of l-value error since compiled as pure C.
Thinking about the problem rather intuitively than rationally I imagined that could be some little difference in the precedence table. Keeping that in mind, wrested the standard papers for both languages and took a look at this reduced C&#43;&#43; table and C ANSI standard from 1989:
   C C&#43;&#43;     [L2R] () [] -&amp;gt; . () [] -&amp;gt; . [L2R]   [R2L] ! ~ &#43;&#43; -- ! ~ &#43;&#43; -- [R2L]   [L2R] * / % * / % [L2R]   [L2R] &#43; - &#43; - [L2R]   [L2R] &amp;lt;&amp;lt; &amp;gt;&amp;gt; &amp;lt;&amp;lt; &amp;gt;&amp;gt; [L2R]   [L2R] &amp;lt; &amp;lt;= &amp;gt; &amp;gt;= &amp;lt; &amp;lt;= &amp;gt; &amp;gt;= [L2R]   [L2R] == != == != [L2R]   [L2R] &amp;amp; &amp;amp; [L2R]   [L2R] ^ ^ [L2R]   [L2R] | | [L2R]   [L2R] &amp;amp;&amp;amp; &amp;amp;&amp;amp; [L2R]   [L2R] || || [L2R]   [R2L] ?: = &#43;= -= *= /= %= [R2L]   [R2L] = &#43;= -= *= /= %= ?: [L2R]   [L2R] , , [L2R]    Besides some now less important details we can notice in the end of the table a inversion between the ternary operator and the attribution operator and, more importantly, the inversion of the evaluation order. In C, the ternary operator is evaluated from right to left (R2L), whilst in C&#43;&#43; from left to right (L2R), like the rest. This is going to shows us that, in line 6, the same expression has two different interpretations in each language.
In order to understand bit by bit the problem, let&#39;s disassemble the second part of that for:
( f1 == 11 &amp;amp;&amp;amp; s != 5 ) ? s = 5, f1 = 0, putchar(10) : ( f1 &amp;lt;= 10 ) ? f1 = f1 : f1 = 12, f1 &amp;lt;= 11;  We have two ternary operators nestled. In accordance with C&#43;&#43; standard, the ternary operators have less precedence than the attribution operators and are evaluated from left to right. In other words, in first place all the atributions inside the expression are made before any ternary operator. After that, the first ternary operator is executed, followed by the second:
( ( f1 == 11 &amp;amp;&amp;amp; s != 5 ) ? (s = 5), (f1 = 0), putchar(10) : ( f1 &amp;lt;= 10 ) ) ? (f1 = f1) : (f1 = 12), f1 &amp;lt;= 11;  Now let&#39;t take a look in C. In this language, different from C&#43;&#43;, the ternary operators have more precedence than the attribution operators, and are executed from right to left. That means the first and last ternary operators are executed, ignoring the right attribution, and after that the first ternary operator is executed. Only after these two events the right attribution is evaluated:
( ( f1 == 11 &amp;amp;&amp;amp; s != 5 ) ? s = 5, f1 = 0, putchar(10) : ( ( f1 &amp;lt;= 10 ) ? f1 = f1 : f1 ) ) = 12, f1 &amp;lt;= 11; All this make us to see the attribution to 12 will be done on the first ternary operator result, which possible values could be from the putchar return or f1. Remember that the comma operator purpose outside function calls is to chain expressions, execute them and return the value from the rightmost expression:
s = 5, f1 = 0, putchar(10) // makes s equals 5, f1 equals 0 and returns the putchar call value.f1 = f1 : f1 // in both cases the returned value is the f1 variable Well, the f1 variable is an integer. And putchar return as well. This is not going to break any type rule. However, breaks the attribution gold rule: &amp;quot;put an lvalue in the right side of an attribution&amp;quot;.
f1 = 12; // right; nothing to sayputchar(10) = 12; // woops! what&#39;s that? putchar doesn&#39;t return variable but a constant value This finishes the long explanation about why that little insignificant error at the beginning of this article happened only in the C language. This is a perfect example of the little differences between these two languages. Perhaps do you use parenthesis like a crazy, and are not going to find this kind of problems inside your source code. Perhaps not.
</description>
</item>

     
        <item>
  <title>História do Windows - parte 2.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-20/</link>
  <pubDate>2007-07-04</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-20/</guid>
  <description> Eu seu, eu sei. A maioria dos meus leitores odiou o tema História do Windows na era paleozóica. Porém, como eu disse na parte 1.0, estou apenas satisfazendo a outra parte de leitores que procurou no Google por esse tema e acabou caindo no meu antigo blog. Mas vejamos o lado bom: a partir da próxima versão iremos destrinchar a API do sistema, entendendo o porquê das coisas serem como elas são. No momento os deixo apenas com história, pois é desconhecido para mim como funcionavam os primeiros rabiscos do MS-DOS Shell, mais conhecido como Windows/386. Bom divertimento!
 Assim, em 9 de dezembro de 1987, é lançado o aperfeiçoadíssimo Windows 2.0, que fez do PC um ambiente muito mais parecido com um computador Macintosh. O novo sistema possui ícones para representar programas e arquivos, fornece suporte para memória expandida e janelas que podem se sobrepor(!). Porém, ainda utilizava o modelo de memória do 8088 e portanto era limitado a 1 Megabyte, ainda que certas pessoas houvessem tido sucesso rodando o sistema em cima de outro multitarefa como DesqView.
A Apple, vendo a extrema semelhança entre seu sistema e o Windows, abriu um processo em 1988 alegando ter a Microsoft quebrado o acordo feito em 1985. A Microsoft se defendeu tendo o argumento que a licença lhe dava o direito do uso dessas características. Uma guerra judicial se arrastou por quatro anos. A Microsoft ganhou. Ao final, a Apple declarou que a Microsoft havia infligido 170 de seus copyrights. A corte judicial disse que o acordo de licença dava direito de uso da Microsoft de todos menos nove. Então a Microsoft alegou que os copyrights restantes não poderiam ser reinvidicados pela lei do copyright, já que a Apple pegou suas idéias da interface gráfica desenvolvida pela Xerox em seus computadores Star. Assim, um impresso de 01/06/93, disponível no Microsoft Timeline, resumiu a solução final:
 &amp;quot;Microsoft announces that Judge Vaughn R. Walker of the U.S. District Court of Northern California ruled today in Microsoft&#39;s favor in the Apple vs. Microsoft and Hewlett-Packard copyright suit. The judge granted Microsoft&#39;s and Hewlett-Packard&#39;s motions to dismiss the last remaining copyright infringement claims against Microsoft Windows 2.03 and 3.0, as well as, the HP NewWave.&amp;quot;
 Uma outra frase resume o caminho trilhado pela empresa a partir de então:
 &amp;quot;Microsoft become the top software vendor in 1988 and never looked back...&amp;quot; - Microsoft
 Com o advento dos novos lançamentos da Intel, os processadores 80286 e 80386, o Windows acabou sendo atualizado duas vezes para aproveitar as novas características dos dois sistemas. E assim nasceram as versões 2.1.x do Windows, respectivamente conhecidas como Windows/286 e Windows/386.
A próxima versão do Windows é que vai alavancar as vendas da Microsoft de uma vez por todas. Veremos que boa parte da API que usamos hoje em dia já existia no Windows 3.0, e boa parte das peculiaridades que nos perseguem até hoje.
</description>
</item>

     
        <item>
  <title>Introdução ao SoftICE</title>
  <link>http://www.caloni.com.br/introducao-ao-softice/</link>
  <pubDate>2007-07-02</pubDate>
  
  <guid>http://www.caloni.com.br/introducao-ao-softice/</guid>
  <description>O que acontece quando você precisa depurar um programa e não tem o Visual Studio instalado na máquina onde o problema está ocorrendo? Ora, para isso que existe o Remote Debugging. Eu uso direto. Você só precisa rodar um pequeno programa na máquina que vai ser depurada e abrir uma porta ou duas. O resto o Visual Studio da máquina que vai depurar faz.
Tudo bem, mas e se estamos falando de depuração em kernel mode? Bem, nesse caso o mais indicado é o nosso já conhecido WinDbg. Só precisamos de um cabo serial, firewire ou USB conectando as duas máquinas.
Mas a vida pode ser complicada às vezes. O WinDbg em versões antigas até rodava em plataforma 9x (95/98/ME), mas agora já não roda mais. Felizmente eu mantenho uma versão das antigonas, só para garantir. Só que ele rodava apenas para depurar em user mode, o que de qualquer forma não seria útil nesse caso.
Existe uma ferramenta de depuração no DDK do Windows 98 chamada WDEB386. Sua existência está documentada no próprio DKK. Funciona similarmente ao WinDbg, ou seja, o depurador em parte roda na máquina depurada e em parte na máquina que depura, e ambas são conectadas por um cabo serial. Teoricamente essa ferramenta serviria para depurar o kernel dos sistemas 9x, mas na maioria das vezes tive problemas com ela. Não que nunca tenha funcionado. Até já consegui essa proeza uma vez depois de muito ler a documentação e resolver uma série de problemas que não estavam documentados. Se você leitor quiser tentar a sorte, vá em frente.
Para piorar as coisas, existe mais um último problema: a máquina não está ao alcance de um cabo serial. Para esse último caso talvez fosse a hora de chamar um produto não-Microsoft que dá conta do recado muito bem: o SoftICE.
O SoftICE é um depurador de kernel e user mode que é instalado na própria máquina depurada. Ou seja, ele não precisa de uma segunda máquina só para rodar o depurador ou parte dele. Funciona no MS-DOS (versão 16 bits), plataforma 9x e NT. Criado pela Numega, mais tarde foi comprado pela Compuware, que passou a vendê-lo como um pacote para desenvolvimento de drivers, o Driver Studio. No seu time de desenvolvimento passaram nomes consagrados como Matt Pietrek e Mark Russinovich.
Essa ferramenta teve seus dias de glória quando a maioria dos crackers a utilizava para quebrar a proteção de programas e do sistema operacional. Tanto foi famosa que foram desenvolvidas diversas técnicas para detectar se o SoftICE estava ativo na máquina, mais ou menos o equivalente das diversas técnicas atuais para detectar se um programa está sendo executado dentro de uma máquina virtual.
O SoftICE deve ser instalado na máquina do desenvolvedor para gerar os símbolos dos programas e na máquina que vai ser depurada para depurar. Isso quer dizer que ele não precisa ser ativado na máquina do desenvolvedor. Só precisamos usar uma ferramenta chamada Symbol Loader, responsável por gerar símbolos e empacotar os fontes para serem usados na máquina depurada.
Na hora de instalar, você tem três opções:
 Full installation: desenvolvimento e depuração; use se for desenvolver e depurar na mesma máquina. Host machine: apenas desenvolvimento; não serve para depuração. Target machine: depuração; instale essa opção na máquina de testes.  Após esse processo e a compilação do seu driver favorito podemos gerar os símbolos.
Infelizmente, o Driver Studio só traduz os símbolos corretamente até a versão 6 do Visual C&#43;&#43;, ou seja, não inclui nenhuma das versões .NET do Visual Studio (2002/2003/2005&#43;). A Compuware se negou a oferecer suporte para os novos compiladores, talvez até prevendo que o produto iria ser descontinuado em breve.
A geração de símbolos pode ser feita de modo gráfico pelo Symbol Loader ou pela linha de comando. As opções chamadas source e package são importantes para traduzir utilizando o código-fonte e empacotar esse código-fonte no arquivo gerado. Note que eu disse empacotar, o que significa que o fonte vai estar dentro do arquivo de símbolos. Portanto, se a licença do seu software é de código fechado, nunca se esqueça de apagar esse arquivo quando estiver na máquina de um cliente.
Se tudo der certo no final teremos dois arquivos a serem copiados para a máquina depurada. Depois de copiados e o driver instalado, insira pelo Symbol Loader o arquivo NMS na lista de símbolos a serem carregados no reboot. Após configurar o depurador como lhe aprouver basta reiniciar a máquina. Feito o reboot, existe uma tecla mágica que irá nos levar para o mundo da tela preta, o ambiente padrão do SoftICE: Ctrl&#43;D.
A interface é divida em pseudo-janelas que ficam organizadas em camadas. Para exibir/esconder as janelas ou especificar o tamanho de uma delas usa-se o comando w. Aliás, basta começar a digitar um comando e o programa irá listar os comandos possíveis.
Com certeza existe um monte de coisas novas para aprender quando se troca de depurador. Mais uma vez, assim como o WinDbg, temos a opção de utilizar o sistema de janelas ou a linha de comando. Aqui vão algumas dicas importantes:
 Para mostrar a tela do SoftICE, Ctrl&#43;D. Digite novamente e ela some e o sistema volta a rodar. Os nomes dos comandos se assemelham aos do WinDbg. Tente usá-los e sinta as diferenças. A ajuda do programa é muito boa e explica direitinho todos os detalhes do ambiente. Caso algo falhe, RTFM!  Essa parece ser uma introdução muito básica ao SoftICE. E na verdade é. Teremos outras oportunidades mais pra frente de usar esse poderoso depurador, principalmente naqueles casos onde um problema só acontece no Windows 95 Release A e sem rede. Isso não é tão incomum quanto parece.
</description>
</item>

     
        <item>
  <title>A Inteligência do if: Parte 2</title>
  <link>http://www.caloni.com.br/a-inteligencia-do-if-parte-2/</link>
  <pubDate>2007-06-29</pubDate>
  
  <guid>http://www.caloni.com.br/a-inteligencia-do-if-parte-2/</guid>
  <description>Vimos na primeira parte desse artigo como o if revolucionou o mundo da computação ao trazer um salto que depende de condições anteriores e, portanto, depende do estado do programa. A ele chamamos de salto condicional. Também vimos como o resto das construções lógicas de uma linguagem são apenas derivações montadas a partir de saltos condicionais e incondicionais. Nesta segunda parte veremos como implementar um saldo condicional baseando-se no fato de que o computador pode apenas realizar operações matemáticas. Afinal de contas, um computador não &amp;quot;pensa&amp;quot;.
Uma condição, item necessário para o funcionamento do salto condicional, nada mais é do que o conjunto de um cálculo matemático e o seu resultado, sendo o salto dependente desse resultado. Geralmente o resultado usado é uma flag, um indicador, definida pela arquitetura, como o armazenador de resultado para comparações de igualdade. Na plataforma 8086, por exemplo, as instruções que comparam memória definem uma flag chamada de Zero Flag (ZF) que é modificada sempre logo após executada uma instrução da categoria de comparações de valores.
É comum nas arquitetura o resultado de uma comparação ser igual a zero se os elementos são iguais e diferente de zero se são diferentes. O resultado, então, denota a diferença entre as memórias comparadas, e se não há diferença o resultado é zero.
set memA, 1set memB, 1cmp memA, memB # ZF=0set memA, 1set memB, 0cmp memA, memB # ZF=1 Mas como de fato comparar? Aí é que reside a mágica das portas lógicas e operações booleanas. A comparação acima pode ser feita com uma porta lógica XOR, o OU-eXclusivo, por exemplo, e o resultado pode ser obtido e armazenado se a saída for conectada a um flip-flop (um flip-flop, ou multivibrador biestável, é um circuito de computador capaz de armazenar o valor de 1 bit, o necessário para o nosso salto). Vamos por partes.
Uma porta lógica é uma série de circuitos que recebe uma ou mais entradas e que resulta em uma saída, sendo as entradas e a saída representadas pelo sinal 1 e 0. As portas lógicas costumam ser nomeadas pela sua função na lógica booleana. Dessa forma, uma porta AND, ou E, é uma porta em que a saída será 1 se todas as suas entradas forem 1, e 0 se pelo menos uma de suas entradas for 0.
Um flip-flop é o circuito que é usado para armazenar os resultados das portas lógicas de forma que após ter sido alimentado o valor não se perde. É o bloco mais fundamental de memória de um computador. Ele não se esquece depois que as entradas foram zeradas e pode ser reiniciado quando novas entradas forem fornecidas. É a maneira de gravar dados temporários na memória RAM da placa-mãe ou na memória cache do processador.
O flip-flop serve para que o valor do ZF permaneça após a instrução XOR entre os registradores que serão comparados. Eis como funciona: é usada uma porta lógica XOR para cada um dos bits dos valores comparados, fazendo com que qualquer bit diferente tenha uma saída 1. Se todos os bits dos valores comparados forem iguais a zero, significa que os valores são idênticos. Para agrupar todas essas saídas é usada uma porta lógica OR, fazendo com que um único bit diferente de zero (ou mais) reflita na saída. A saída da porta OR, por sua vez, é invertida através da porta NOT colocada antes do flip-flop. Ou seja, se os valores forem idênticos (saída zero da porta OR) a saída final será 1, do contrário será zero.
No final das contas, esse valor armazenado por um flip-flop é a flag ZF da arquitetura 8086. Se houver alguma diferença entre os valores, como foi o caso no exemplo acima, o valor final será o um invertido, ou seja, zero. Esse valor armazenado pode ser usado nas próximas instruções para realizar o salto, que dependerá do que estiver nessa flag. Dessa forma temos o nosso resultado realizado automaticamente através de um cálculo matemático.
Um salto incondicional, como vimos na parte um, é um salto para um outro ponto no código que vai ser feito de qualquer forma. Pode ser uma instrução do processador saltar para um endereço definido em algum lugar da memória. O goto possui como destino o endereço X, sendo que X depende do que estiver em seu próprio endereço.
001 set memA, 004002 jump memA003 code # not executed004 code005 ... Agora, para executar o salto condicional, precisamos não apenas de um, mas de dois endereços de destino, cada um deles com um endereço de memória. Podemos definir o primeiro endereço como o armazenador do salto se a condição for falsa, e o segundo endereço se a condição for verdadeira.
001 set memA, 006002 set memB, 005003 cmp memC, memD004 jz memA005 code # ZF=1006 code # ZF=0007 ... Se os valores em memC e memD forem iguais a comparação feita na linha 003 deixará o ZF igual a 0 e portanto o comando jz (jump if zero, saltar se zero) irá realizar o salto para a linha 006, que é o endereço contido em memA. Caso contrário não será feito o salto, ou seja, a próxima instrução será a da linha 005, a mesma contida em memB.
Agora você pode estar se perguntando por que existe o endereço em memB, já que se a condição for falsa o código simplesmente seguirá o fluxo normal. Bom, este memB é meramente figurativo, pois estou tentando demonstrar como não existe, de fato, uma &amp;quot;inteligência&amp;quot; na instrução de comparação que determine a igualdade de dois valores. Tudo se resume a circuitos realizando cálculos matemáticos.
Para isso continue imaginando o memB sendo usado como o endereço a ser usado caso a condição falhe. Esse endereço está localizado logo após o memA na memória. Se memA estiver em 080, memB estará em 081.
080 memA # 006081 memB # 005 Dessa forma, para executar o salto baseado em um resultado de 0 ou 1 (o Zero Flag) só temos que alterar o endereço da próxima instrução para o valor do endereço de comparação mais o valor de ZF, que pode ser 1 ou 0. Se for 0 será o próprio endereço da condição (memA), mas se for 1 será esse endereço mais 1 (ZF), ou seja, memB.
001 set memA, 006002 set memB, 005003 cmp memC, memD # muda ZF004 jump [memA &#43; ZF]005 code # ZF=1006 code # ZF=0007 ... Lembre-se que essa é apenas uma demonstração de como pode funcionar um salto condicional através de cálculos matemáticos. De maneira alguma estou afirmando que é feito dessa forma. Aliás, existem inúmeras formas de realizar esse salto. Uma segunda solução seria adicionar a defasagem (offset) entre o endereço da próxima instrução e o endereço do salto. Meu objetivo foi apenas ilustrar que, dado um problema, pode haver várias soluções. Talvez mais para a frente veremos como é implementado um if em assembly, subindo mais um nível de abstração. Por enquanto estamos apenas trabalhando no nível filosófico. O mais importante de todos.
</description>
</item>

     
        <item>
  <title>História do Windows - parte 1.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-10/</link>
  <pubDate>2007-06-26</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-10/</guid>
  <description>Devido à grande procura através de mecanismos de busca (vulgo Google), estarei republicando esse artigo dividido em partes (até porque existem partes não acabadas), cada parte descrevendo um conceito geral do que representou cada versão do sistema operacional. Bem-vindos ao História do Windows.
Tudo começou em 1981, quando chegou às lojas o primeiro IBM PC, uma poderosa máquina de 4.7 MHZ, 64 (KB!) de RAM e um drive de disquete de 160 KB. Já havia sido lançado em agosto o MS-DOS, sistema operacional encomendado pela IBM à empresa recém-criada por Paul Allen e Bill Gates, a Microsoft Corporation. O DOS foi baseado num sistema básico anterior produzido pela Seattle Computer Products.
No mesmo ano uma empresa chamada Xerox pôs ao mundo uma estação de trabalho gráfica chamada Star. Do Star vieram os conceitos de janelas, ícones, e o uso de um hardware apontador de tela chamado de mouse. De lá foram tiradas, portanto, as principais idéias que moldaram a criação dos futuros sistemas operacionais que revolucionaram o conceito de interação computador/usuário, como o LISA, da Apple -- que mais tarde também deu origem ao Macintosh -- e o sistema gráfico da Microsoft chamado Windows.
Em novembro de 1983 a Microsoft Corporation anuncia oficialmente, no Plaza Hotel em Nova York, o Microsoft Windows, a próxima geração de sistemas operacionais que irá ter uma interface gráfica para o usuário (GUI) e ambiente multitarefa. É possível que o nome original do sistema tivesse sido Interface Manager se um dos gênios do departamento de marketing da Microsoft, Rowland Hanson, não tivesse convencido o fundador da empresa, Bill Gates, que Windows seria um nome melhor por ser mais intuitivo. A promessa inicial dizia que o sistema iria ser lançado em abril do próximo ano.
No início daquele ano, então, foi mostrada uma versão beta aos chefões da IBM, que não se mostraram muito entusiamados. Na verdade, a criadora do Personal Computer estava trabalhando num novo projeto que substituiria o sistema original da Microsoft, o MS-DOS.
Surgiram concorrentes potenciais do Microsoft Windows. VisiOn, da VisiCorp, foi a primeira GUI oficial lançada para PC. GEM (Graphical Environment Manager), lançada pela Digital Research no começo de 1983. No entanto ambos careciam do suporte de desenvolvedores para a plataforma. Ora, se ninguém quer fazer programas para um sistema, quem vai querer comprá-lo?
Um produto chamado Top View fora lançado pela IBM em fevereiro de 1985, baseado em DOS com um gerenciador multitarefa, mas sem uma GUI. Era lento e precisava de muita memória. Acabou sendo descontinuado dois anos depois e nunca chegou a ter uma interface gráfica.
Antes do lançamento do Windows, advogados da Apple alertavam sobre a possibilidade do sistema infringir os direitos e patentes que a empresa tinha sobre as características da sua interface gráfica, a LISA (janelas com barra de título, menus drop-downs, suporte a mouse, etc). Daí o fundador da Microsoft, Bill Gates, teve a idéia brilhante de firmar um contrato de licença com a Apple, dando-lhe o direito de incluir em todas as futuras versões do Windows e programas os conceitos de GUI adquiridos pelo sistema gráfico da Apple (isso antes do Windows ser lançado).
Finalmente, em 20 de novembro de 1985, a Microsoft lança o Windows 1.0, quase dois anos depois da promessa inicial. Foi vendido inicialmente por 100 USD. Continha em seu pacote: MS-DOS Executive, Calendar, Cardfile, Notepad, Terminal, Calculator, Clock, Reversi, Control Panel, PIF (Program Information File) Editor, Print Spooler, Clipboard, RAMDrive, Windows Write e Windows Paint.
O novo sistema não fez muito sucesso de imediato. Pelo contrário, foi considerado lento e primitivo. Devido às limitações impostas pela Apple o sistema não pôde apresentar certas características como a sobreposição de janelas e a famosa lixeira (um conceito proprietário da Apple). Ficou cerca de dois anos boiando no mercado até que foi lançado um produto chamado Aldus PageMaker 1.0. PageMaker foi o primeiro programa WYSIWYG (What You Seee Is What You Get) para o PC. Tinha a grande novidade de juntar tipos e gráficos no mesmo documento. Depois de um ano, a Microsoft lança uma planilha de cálculos chamada Excel. Mais tarde outros produtos como Microsoft Word e Corel Draw ajudaram a aumentar a popularidade do Windows, embora esse ainda precisasse de muitas melhoras.
</description>
</item>

     
        <item>
  <title>Disassembling the array operator</title>
  <link>http://www.caloni.com.br/disassembling-the-array-operator/</link>
  <pubDate>2007-06-22</pubDate>
  
  <guid>http://www.caloni.com.br/disassembling-the-array-operator/</guid>
  <description>Arrays are fascinating in C language because they are so simple and so powerful at the same time. When we start to really understand them and realize all its power we are very close to understand another awesome feature of the language: pointers.
When I was reading the K&amp;amp;R book (again) I was enjoying the language specification details in the Appendix A. It was specially odd the description as an array must be accessed:
 A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type &amp;quot;pointer to T&amp;quot; and the other shall have enumeration or integral type. The result is an lvalue of type &amp;quot;T&amp;quot;. (...) The expression E1 [ E2 ] is identical (by definition) to *( (E1) &#43; (E2) ).
 Notice that the rules don&#39;t specify the order of expressions to access the array. In other words, it doesn&#39;t matter for the language if we use a pointer before the integer or an integer before the pointer.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cassert&amp;gt;int main(){char q[] = &amp;quot;Show me your Code, &amp;quot;&amp;quot;and I&#39;ll tell you who you are.&amp;quot;;int i = 13;std::cout &amp;lt;&amp;lt; &amp;quot;And the language is: &amp;quot; &amp;lt;&amp;lt; q [ i ] &amp;lt;&amp;lt; std::endl;assert( q[i] == i[q] );assert( q[13] == 13[q] );assert( *(q &#43; i) == &amp;quot;That&#39;s C!&amp;quot;[7] );return 13[q] - &amp;quot;CThings&amp;quot;[0];}  The q[i] bellow shows that we can use both orders and the code will compile successfully.
std::cout &amp;lt;&amp;lt; &amp;quot;And the language is: &amp;quot; &amp;lt;&amp;lt; i [ q ] &amp;lt;&amp;lt; std::endl; This code doesn&#39;t show how obscure we can be. If we use a constant integer replacing the i, by example, the code starts to be an IOCCC participant:
std::cout &amp;lt;&amp;lt; &amp;quot;And the language is: &amp;quot; &amp;lt;&amp;lt; 13 [ q ] &amp;lt;&amp;lt; std::endl; Is this a valid code yet, right? The expression types are following the rule. It is easy to see if we always think about using the &amp;quot;universal match&amp;quot; *( (E1) &#43; (E2) ). Even bizarre things like this are easy to realize:
std::cout &amp;lt;&amp;lt; 8[&amp;quot;Is this Code right?&amp;quot;] &amp;lt;&amp;lt; std::endl; Obs.: this kind of &amp;quot;obscure rule&amp;quot; hardly will pass in a code review since it is a useless feature. Be wise and don&#39;t use it in production code. This is just an amusing detail in the language specification scope. It can help in analysis, never in programming.
</description>
</item>

     
        <item>
  <title>Introdução ao Debugging Tools for Windows (usando o Logger para monitorar APIs)</title>
  <link>http://www.caloni.com.br/introducao-ao-debugging-tools-for-windows/</link>
  <pubDate>2007-06-20</pubDate>
  
  <guid>http://www.caloni.com.br/introducao-ao-debugging-tools-for-windows/</guid>
  <description>O WinDbg é uma ferramenta obrigatória em uma das minhas mais divertidas tarefas aqui na Open: engenharia reversa de cavalos de tróia. Não tenho o código-fonte desses programas, não posso executá-los em minha própria máquina e não consigo fazer tudo que preciso usando apenas o depurador integrado do Visual Studio (como remontar o assembly do programa, por exemplo). Tudo isso faz do WinDbg a alternativa perfeita (senão uma das únicas). É um depurador que permite ser usado tanto através de janelas quanto através de comandos, o que permite um aprendizado em doses homeopáticas: comece com as janelas e aos poucos ganhe o controle total. Conseqüentemente cada dia aprendo um comando novo ou um novo uso para um comando que já conheço.
Abaixo um esboço de como o WinDbg se parece, com suas principais janelas. A de comandos é a da direita.
Ele não está limitado apenas para engenharia reversa de código malévolo. Esse é o uso que eu faço dele. Meu amigo Thiago, por exemplo, resolve problemas em servidores que rodam código gerenciado com WinDbg. É a maneira ideal de depurar um problema em uma máquina onde o ambiente de desenvolvimento não está disponível nem pode ser instalado. Outro ponto relevante é que ele não depura apenas um programa em particular, mas pode ser usado para depurar um sistema inteiro. Chamado de kernel debugging, podemos usar esse modo de funcionamento para resolver os problemas que surgem logo depois de espetar algum periférico novo comprado na Santa Ifigênia.
Mas esse artigo não é apenas sobre o WinDbg. Ele não vem sozinho. É uma interface amigável para alguns depuradores linha de comando e outras ferramentas disponíveis no Debugging Tools for Windows, pacote disponível gratuitamente no sítio da Microsoft e atualizado geralmente de seis em seis meses. Nele podemos encontrar:
 CDB: depurador que roda em user mode e é uma &amp;quot;linha de comando agradável&amp;quot; para um programador avançado. NTSD: depurador que roda em user mode, da mesma forma que o CDB, mas também pode ser usado como um redirecionador de comandos para o depurador de kernel (logo abaixo). Existem algumas diferenças sutis entre esses dois depuradores (como o fato do NTSD não criar janelas quando usado como redirecionador), mas são diferenças que se aprendem no dia-a-dia. KD: depurador que roda em kernel mode, pode analisar dados do sistema local ou depurar um sistema remoto conectado através de um cabo serial ou por meio de um pipe criado por uma máquina virtual.  Existem outros métodos mais avançados ainda para conseguir depurar uma máquina tão tão distante, por exemplo.
 Logger: tracer de chamadas de funções da API. Pode ser usado para análise de performance ou para fazer o que eu faço com os trojans, que é dar uma olhada nas funções que eles chamam constantemente. Logviewer: visualiza resultados gerados pelo Logger.  Existem ainda outras ferramentas, mas estas são as principais que costumo utilizar. Para saber como usá-las de acordo com suas necessidades recomendo a leitura de um pequeno tutorial para o WinDbg que vem junto da instalação, o kernel_debugging_tutorial.doc. Ele é apenas a introdução dos principais comandos e técnicas. Depois de ter dominado o básico, pode partir para o arquivo de ajuda, que detalha de forma completa todos os comandos, técnicas e ferramentas de todo o pacote: o debugger.chm. A maioria dos comandos que precisava encontrei usando essa ajuda ou em alguns blogs muito bons, como o Crash Dump Analysis. Porém, acredite: no WinDbg, você quase sempre vai encontrar o comando que precisa.
Para exemplificar um uso prático dessas ferramentas vamos usar o Logger para descobrir quais funções API estão sendo chamadas constantemente por um cavalo de tróia, uma coisa um tanto comum em ataques a bancos. Para tornar as coisas mais reais ainda vamos utilizar o código-fonte de um suposto cavalo de tróia usado em minhas apresentações:
#include &amp;lt;windows.h&amp;gt;#include &amp;lt;shlwapi.h&amp;gt;int WINAPI WinMain(...){CHAR wndTxt[MAX_PATH];while( true ){HWND fgWin = GetForegroundWindow();wndTxt[0] = 0;if( GetWindowText(...) ){if( StrStrI(wndTxt, &amp;quot;Fict Bank&amp;quot;) ){MessageBox(fgWin, &amp;quot;Hi! Like to be under attack?&amp;quot;,&amp;quot;Free Trojan&amp;quot;, MB_OK);break;}}}ExitProcess(ERROR_SUCCESS);}  Para compilar esse programa, você só precisa digitar os seguintes comandos em um console do Visual Studio:
cl /c freetrojan.cpplink freetrojan.obj user32.lib shlwapi.lib O logger.exe possui uma extensão que pode ser usada pelo WinDbg para usar os mesmos comandos a partir do depurador. Mas para tornar as coisas mais fáceis nesse primeiro contato iremos iniciar o programa através do próprio executável:
logger freetrojan.exe Irá aparecer uma janela onde selecionamos o conjunto de APIs que serão capturadas. Podemos manter todas as categorias selecionadas e mandar rodar usando o botão &amp;quot;Go&amp;quot;. Aguarde o programa executar por um tempo para termos um pouco de dados para analisar. Em minhas análises reais eu geralmente deixo ele atacar, seja no sítio real do banco ou em uma armadilha. Depois do ataque posso confirmar qual a API que ele utilizou. Se quiser fazer isso nesse teste basta criar uma janela que contenha o texto &amp;quot;Fict Bank&amp;quot; em seu título. Após isso, podemos finalizar o processo pelo Gerenciador de Tarefas.
Mesmo após finalizá-lo ele continuará na lista de processos, como se tivesse travado. Na verdade, a parte injetada do Logger mantém o processo no ar, em um estado semi-morto (ou semi-vivo). Depois de finalizar o Logger fechando sua janela principal ambos os processos terminam e podemos ler o resultado da captura em uma pasta chamada LogExts criada por padrão no Desktop ou Área de Trabalho. Podemos dar uma olhada nos resultados através do visualizador de logs gerados, o Logviewer.
Algumas colunas do Logviewer são tão úteis que vale a pena mencioná-las:
 Module: determina quem chamou a API, o próprio executável ou alguma DLL. Call Duration: tempo em milissegundos que a chamada da função demorou. API Function: o nome da função API que foi chamada. Return Value: o retorno da chamada da função.  De quebra ele exibe todos os parâmetros das funções de acordo com o tipo, identificando inclusive quando se trata de uma enumeração ou define reservado. Essa &amp;quot;mágica&amp;quot; é feita interpretando os headers que ficam na pasta Debugging Tools for Windows, winext, manifest, tarefa executada pelo Logger no início.
O Debugging Tools é um pacote extremamente poderoso de ferramentas para programadores avançados. De maneira alguma conseguirei cobrir tudo que é possível fazer com essas ferramentas em apenas um blog e muito menos em um post. Porém, espero que essa pequena introdução seja o começo de uma série de artigos bem interessantes sobre debugging e uma série de testes realizados pelos meus leitores.
</description>
</item>

     
        <item>
  <title>A Inteligência do if: Parte 1</title>
  <link>http://www.caloni.com.br/a-inteligencia-do-if-parte-1/</link>
  <pubDate>2007-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/a-inteligencia-do-if-parte-1/</guid>
  <description>No nível mais baixo, podemos dizer que as instruções de um computador se baseiam simplesmente em cálculos matemáticos e manipulação de memória. E entre os tipos de manipulação existe aquela que muda o endereço da próxima instrução que será executada. A essa manipulação damos o nome de salto.
O salto simples e direto permite a organização do código em subrotinas. Subrotinas permitem o reaproveitamento de código com parâmetros de entrada distintos, o que economiza memória, mas computacionalmente é &amp;quot;inútil&amp;quot;, já que pode ser implementado simplesmente pela repetição das mesmas subrotinas. O que eu quero dizer é que, do ponto de vista da execução, a mesma seqüência de instruções será executada. Pense no fluxo de execução de uma rotina que chama várias vezes a mesma subrotina:
sub:coderetroutine:codecall subcodecall subcodecall sub Ela é, na prática, equivalente a uma rotina que contém várias cópias da subrotina na memória, uma seguida da outra.
routine:codesub:codecodesub:codecodesub:code A grande sacada computacional não são subrotinas. O real motivo pelo qual hoje os computadores são tão úteis para os seres humanos é a invenção de um conceito chamado salto condicional. Ou seja, não é um salto certo, mas um salto que será executado caso a condição sob a qual ele está subordinado for verdadeira:
codeif cond:call subcodeif cond:call subcodeif cond:call subcode Os saltos condicionais, vulgarmente conhecidos como if, permitiram às linguagens de programação possuírem construções de execução mais sofisticadas: laços, iterações e seleção de caso. Claro que no fundo todas essas construções não passam de um conjunto formado por saltos condicionais e incondicionais. Peguemos o while e seu bloco, por exemplo. A construção em uma linguagem de programação possui uma condicional seguido de um bloco de código que se repete enquanto a condicional for verdadeira:
while cond:code Enquanto para o programador dessa fictícia linguagem existe um controle de execução no início que determina quando o código deixará de ser executado repetidamente, para o compilador o while não passa de um salto no final do bloco para o começo de um if.
label:if cond:codejump label O for, por outro lado, possui tradicionalmente em seu início três operações: inicialização, condição e incremento. O código começa executando a inicialização e verifica a condição uma primeira vez. Após executado o bloco de código condicionado ao for, o incremento será executado, e mais uma vez a condição verificada. Caso a condição seja verdadeira novamente o bloco de código volta a executar, para no final executar o incremento e verificar a condição, e assim por diante.
for: i = 0; i &amp;lt; 10; i&#43;&#43;code Do ponto de vista do compilador, que irá transformar esta lógica em código de máquina, o for não passa de um contador que é incrementado a cada iteração com um salto incondiconal no final do bloco de código executado.
i = 0label:if i &amp;lt; 10:codei&#43;&#43;jump label O switch-case, ou seleção, filtra um determinado valor em comparações de igualdade, a condição, em série. Quando é encontrada alguma igualdade verdadeira o código atrelado é executado e o código imediatamente seguinte ao switch é executado. Opcionalmente o bloco inteiro após uma seleção é ignorado.
switch i:case 0:codecase 1:codecase 2:codedefault:code Essa lógica embutida nas linguagens de programação são convertidas pelo compilador em vários ifs seguidos e unidos por um else, o que torna a comparação exclusiva. No final de cada bloco de código existe um salto incondicional para o final da construção.
if i = 0:codejump labelelif i = 1:codejump labelelif i = 2:codejump labelelse:codelabel: Neste artigo vimos como todas as construções de uma linguagem de programação, independente do seu nível, podem ser convertidas em um conjunto de saltos, condicionais e incondicionais. Em um próximo artigo veremos como o salto condicional verdadeiramente funciona, e como pode ser implementado usando apenas operações matemáticas. Afinal, matemática básica é o bloco lógico mais básico que temos em um computador. Qualquer computador.
</description>
</item>

     
    
  </channel>
</rss>
