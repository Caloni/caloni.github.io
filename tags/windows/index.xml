<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>windows on Blogue do Caloni</title>
    <link>http://www.caloni.com.br/tags/windows/</link>
    <description>Recent content in windows on Blogue do Caloni</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Wed, 16 Sep 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.caloni.com.br/tags/windows/" rel="self" type="application/rss+xml" />
    
     
        <item>
  <title>História do Windows</title>
  <link>http://www.caloni.com.br/historia-do-windows/</link>
  <pubDate>2020-09-16</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows/</guid>
  <description>&lt;p&gt;Escrevi esta lista de artigos sobre a evolução do sistema operacional Windows há muitos anos, mas eles nunca estiveram juntos em um post que é uma lista. Bom, segue:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.caloni.com.br/historia-do-windows-parte-10&#34;&gt;Parte 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.caloni.com.br/historia-do-windows-parte-20&#34;&gt;Parte 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.caloni.com.br/historia-do-windows-parte-30&#34;&gt;Parte 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.caloni.com.br/historia-do-windows-parte-351&#34;&gt;Parte 3.5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.caloni.com.br/historia-do-windows-parte-40&#34;&gt;Parte 4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.caloni.com.br/historia-do-windows-parte-50&#34;&gt;Parte 5&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.caloni.com.br/historia-do-windows-parte-51&#34;&gt;Parte 5.1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
</item>

     
        <item>
  <title>Winmock</title>
  <link>http://www.caloni.com.br/winsock-mock/</link>
  <pubDate>2020-04-10</pubDate>
  
  <guid>http://www.caloni.com.br/winsock-mock/</guid>
  <description>&lt;p&gt;Testar sistemas com rede simulada pode ser muito complexo ou muito simples. Se for feito em C ou se os endpoints forem em C é muito simples: basta trocar as funções originais pelas suas. Como tudo em C são funções com nome bem definido e assinatura flexível você não precisa declarar a assinatura da função, ou pode mudar no meio do caminho.&lt;/p&gt;
&lt;p&gt;Existe um recurso interessante da winsock, um define chamado INCLWINSOCKAPIPROTOTYPES, que pode desabilitar a publicação das assinaturas das funções de socket do header winsock2.h. E por que isso é importante? Porque essas assinaturas já possuem a informação que essas funções deverão ser importadas de uma DLL (no caso a Ws232.dll). Isso muda o nome da função C. Além disso, a convenção de chamada da API do Windows é baseada em Pascal, e não cdecl, sendo a desvantagem não existir número de argumentos variáveis na pilha.&lt;/p&gt;
&lt;p&gt;As funções C do winsock/socket, connect, send, recv, select, etc, são apenas funções C cujos nomes são conhecidíssimos. Elas são linkadas com programas que usam alguma biblioteca de socket. Nada impede que nós mesmos sobrescrevamos essas funções para implementá-las em nosso programa. É isso o que o uso do define acima possibilita: ele evita a importação direto da DLL da Microsoft e com isso você pode usar uma implementação de terceiros ou a sua própria, que não precisa se comunicar com a rede.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 5.1</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-51/</link>
  <pubDate>2007-11-19</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-51/</guid>
  <description>&lt;p&gt;Continuando a &lt;a href=&#34;http://www.caloni.com.br/historia-do-windows&#34;&gt;História do Windows&lt;/a&gt;, chega às lojas no dia 25 de outubro de 2001 a unificação entre as plataformas de uso doméstico e corporativo do sistema. O Windows XP usa o kernel de 32 bits de seus antecessores Windows NT e Windows 2000. É vendido em duas edições: Home e Professional Edition. O design do sistema foi totalmente remodulado para suportar ao mesmo tempo a facilidade de uso do usuário doméstico e a robustez e confiabilidade dos clientes corporativos.&lt;/p&gt;
&lt;p&gt;Do ponto de vista da arquitetura, pouca coisa mudou, e essa versão mudou internamente de 5.0 (Windows 2000) para 5.1 (Windows XP) . Ou seja, praticamente um patch de correção.&lt;/p&gt;
&lt;p&gt;Agora, além do sistema 32 bits que todos já conheciam, é lançada a primeira versão 64 bits do Windows, o Windows XP 64-bit Edition. Na época a Intel se preparava para o fracasso de mercado que foi o Intel IA-64 e esse Windows suportava essa nova arquitetura. Na verdade, o projeto foi além das expectativas e aplicou sua primeira versão do Windows-on-Windows 64-bit (WOW64), que permitia a execução de aplicativos 32 bits (x86) em cima da nova plataforma. Isso era feito pela tradução literal do código do assembly &amp;quot;antigo&amp;quot; para o assembly novo, além de outras técnicas auxiliares.&lt;/p&gt;
&lt;p&gt;Atualmente essa versão do Windows não é mais suportada.&lt;/p&gt;
&lt;p&gt;Como se tornou uma prática desde os tempos do Windows NT, a versão para servidores é sempre lançada algum tempo depois da versão para estações de trabalho. Assim foi com o Windows NT Server, o Windows 2000 Server e agora com o Windows XP, rebatizado em sua versão servidores para Windows 2003 Server, cujo código é uma evolução do XP original.&lt;/p&gt;
&lt;p&gt;Da mesma forma, com o lançamento da versão 64 para a plataforma x86, uma nova versão do Windows foi criada: a Windows XP Professional x64 Edition. Baseada no código do Windows 2003 Server SP1, essa nova versão se aproveitava da compatibilidade do x86-64 com a velha plataforma e otimizava a interação e execução dos velhos aplicativos 32, usando uma versão melhorada do WOW64, que se aproveitava da possibilidade de ficar trocando entre os modos 32 e 64 durante a execução dos aplicativos.&lt;/p&gt;
&lt;p&gt;No decorrer da história do Windows avançamos uns bons 20 anos até agora. Muita coisa que deveria ter sido falada não foi, e muita coisa que não merecia ser mencionada, foi. Abaixo podemos vislumbrar por onde passamos, onde chegamos e para onde vamos.&lt;/p&gt;
&lt;p&gt;Como podemos ver, não falarei mais aqui sobre a &amp;quot;outra ramificação&amp;quot; do Windows , aquela constituída por Windows 95, 98 e ME. Não falarei do processo antitruste contra a Microsoft por conta da venda do sistema operacional com o Internet Explorer e Media Player embutidos; não discursarei sobre os protestos dos consumidores quando a Microsoft cobrou pela versão de atualização do Windows 98, o Second Edition; muito menos esbravejarei sobre a raiva dos usuários pelo superaquecimento do processador por conta do Windows ME e sua duvidável interface revolucionária.&lt;/p&gt;
&lt;p&gt;Pelo contrário. Acho que é uma boa hora para adentrar mais ainda nas entranhas da arquitetura NT e entender algumas coisas até então pouco exploradas.&lt;/p&gt;
&lt;p&gt;Na eterna briga entre sistemas operacionais, uma categoria bem abastada (principalmente as discussões Tanenbaum x Torvalds) diz respeito aos sistemas monolíticos e aos baseados em microkernel. Basicamente os sistemas monolíticos possuem todo o seu código executando em modo privilegiado, inclusive os device drivers. Nos sistemas baseados em microkernel, no entanto, existe apenas uma fina camada de interface rodando em modo privilegiado, que serve de interação entre todos os serviços, driver e aplicativos e o hardware.&lt;/p&gt;
&lt;p&gt;O problema em si não é a organização dos componentes do sistema operacional em torno de um ou de outro design, mas o que isso implica em termos de eficiência.&lt;/p&gt;
&lt;p&gt;Abaixo podemos ver o esboço do que seria um sistema operacional com kernel monolítico, com todos acessando todos em modo kernel:&lt;/p&gt;
&lt;p&gt;Ao ser projetado, o objetivo do Windows nunca foi ser um sistema operacional de microkernel, embora umas boas almas tenham clamado o contrário. No entanto, a organização monolítica acima foi feita de tal forma que uma visão lógica do sistema operacional nos diria que a tentativa original foi dividir os serviços em camadas e componentes (servidores), de forma que as camadas superiores pudessem confiar nos serviços das camadas inferiores, tal como é em uma pilha TCP/IP.&lt;/p&gt;
&lt;p&gt;Porém, as coisas não são tão simples assim. O SO inteiro não é feito dessa forma. Foram usados diversos modelos para a organização do sistema, e é fácil perceber isso se enxergamos o todo através de várias visões.&lt;/p&gt;
&lt;p&gt;A visão acima, o caos, é o que temos quando só pensamos em módulos acessando módulos e código arbitrário rodando em kernel mode. Contudo, abaixo, por exemplo, podemos ver o resultado lógico da divisão em camadas em um kernel monolítico. Existe organização, embora esta esteja toda em código privilegiado.&lt;/p&gt;
&lt;p&gt;O acesso, porém, não é protegido, e eventuamente vão existir existir diversos atalhos (documentados ou não) para alcançar as coisas de maneira mais rápida, para o bem da velocidade.&lt;/p&gt;
&lt;p&gt;Uma última e terceira visão, baseada em componentes, divide o código em gerenciadores e provedores de serviços. Conceitualmente  essa divisão permitiria a migração de todo o código não-crítico para user mode, embora não seja o que ocorre.&lt;/p&gt;
&lt;p&gt;Essa divisão foi feita inicialmente e mantida apenas para serviços não-críticos que pudessem rodar em código não-privilegiado e a manutenção dos subsistemas: Win32, POSIX, MS-DOS. Nessa última visão conseguimos ainda visualizar um microkernel, mas é importante notar que não estamos falando aqui do conceito puro e formal que definimos no início da explicação.&lt;/p&gt;
&lt;p&gt;O esboço final, dessa forma, ficou sendo um sistema operacional dividido em componentes, com a maioria rodando em modo privilegiado (kernel mode), cuja divisão lógica primária tende a ser em camadas. É muito importante ter essa visão da coisa conforme nos aprofundamos nos mistérios do ring0.&lt;/p&gt;
&lt;p&gt;Para a organização dos recursos do sistema foi adotado um outro modelo, semelhante (embora não seja) ao conceito de orientação a objetos. Nesse modelo, os recursos são organizados em entidades identificáveis em sua maioria por um ponteiro opaco (kernel) ou um identificador, chamado de handle (user mode). Todos os recursos recebem o mesmo tratamento, embora se refiram a coisas extremamente diferentes, como um arquivo, uma porta de rede, um pedaço de memória, um processo e uma janela.&lt;/p&gt;
&lt;p&gt;Essa organização foi adotada principalmente pela sua grande vantagem de minimizar mudanças, uma vez que as informações sobre os recursos são armazenadas em estruturas opacas, isto é, elas existem, porém não são acessíveis a todos. Isso permite que elas sofram mudanças internas no decorrer do tempo sem impactar para seus usuários.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 5.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-50/</link>
  <pubDate>2007-10-08</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-50/</guid>
  <description>&lt;p&gt;Em novembro de 1998 (apenas para parceiros Microsoft) é lançada a versão 5.0 do Windows NT, conhecida como Windows 2000. Melhorias significativas foram feitas no acesso à internet, intranet e extranet. Aplicações de gerenciamento se integram fortemente e a grande novidade em termos de estruturação de dados é o Active Directory, uma tecnologia compatível com o conceito de Distributed File System, que viabiliza uma nova forma das empresas organizarem seus dados de maneira mais transparente à rede. Assim começou a &lt;a href=&#34;http://www.caloni.com.br/historia-do-windows&#34;&gt;História do Windows&lt;/a&gt; para redes de gente grande.&lt;/p&gt;
&lt;p&gt;Vamos aproveitar que a versão NT foi melhorada para dar uma recapitulada geral de como as coisas funcionam internamente no sistema operacional.&lt;/p&gt;
&lt;p&gt;A ilustração abaixo divide os módulos que fazem parte do sistema operacional. É importante sempre ter essa imagem indelével em nossa mente para entender como as coisas funcionam.&lt;/p&gt;
&lt;p&gt;É importante notar que essa distribuição já existia desde a primeira versão do NT, sendo que apenas alguns itens foram adicionados (como o Gerenciador de Plug &amp;amp; Play e o Gerenciador de Energia).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Um outro item importantíssimo que foi movido da versão 3.51 para a 4.0 é a GDI, responsável pelo gráfico. Inicialmente ela estava no modo de usuário, mas a necessidade de aumentar o desempenho do sistema fez com que ela fosse incorporada ao núcleo do sistema.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Agora vamos dissecar as partes interessantes.&lt;/p&gt;
&lt;p&gt;As aplicações que rodam sobre o sistema operacional preferencialmente são feitas para rodar no Windows. Mas não precisa ser assim. A abstração inicial que se fez foi o uso de subsistemas que suportam um ambiente de execução. Essa foi a maneira escolhida pelos projetistas para que existisse compatibilidade com outros sistemas operacionais, como o OS/2 e Posix (um padrão de aplicativo utilizado em ambientes Unix/Linux). A mesma abstração permite que se rodem aplicativos 16 bits em cima do ambiente NT, que é todo feito em 32.&lt;/p&gt;
&lt;p&gt;Os subsistemas são serviços do sistema operacional que fornecem o ambiente de execução adequado para cada tipo de aplicação. Quando o usuário executa um arquivo, o loader do Windows detecta o tipo de aplicação tentando rodar e carrega o subsistema necessário. Dessa forma a execução de aplicativos MS-DOS e Windows 3.11 se torna transparente para o usuário. No entanto, as proteções necessárias (e.g. acesso a interrupções) serão respeitadas.&lt;/p&gt;
&lt;p&gt;Além dos subsistemas que irão fornecer os mecanismos necessários para a execução dos aplicativos dependendo de seu formato, existem aqueles subsistemas que tomam conta de alguns detalhes cruciais para a correta execução das tarefas do sistema operacional. Entre eles o mais importante é a parte de segurança, responsável por realizar o login dos usuários.&lt;/p&gt;
&lt;p&gt;Isso basicamente é o conjunto de funções que estão disponíveis no modo de usuário para realizar operações mais complexas no núcleo do sistema, como leitura/escrita em arquivo, criação de threads, chamada direta de um driver, etc. Mais basicamente ainda, se trata de um vetor de ponteiros de funções que são chamadas em kernel mode quando o modo de usuário chama uma interrupção ou comando em assembly específico para realizar uma chamada de sistema.&lt;/p&gt;
&lt;p&gt;É um componente muito usado toda hora no sistema, pois ele trata de chamadas de leitura/escrita em qualquer dispositivo, seja um arquivo, uma porta serial ou uma placa de vídeo. Como conceitualmente as requisições do sistema operacional foram organizadas como operações de entrada e saída, o I/O Manager é essencial para a maioria das operações com dispositivos, sejam físicos, lógicos ou virtuais.&lt;/p&gt;
&lt;p&gt;A memória virtual é parte integrante e indispensável para o desempenho e normal funcionamento do sistema operacional. Entre suas responsabilidades estão a necessidade de dividir a memória entre os diferentes processos de acordo com o uso e protegê-la contra leituras, escritas e execuções não autorizadas.&lt;/p&gt;
&lt;p&gt;Parte integrante do Gerenciador de Memória, embora freqüentemente visto como um módulo separado por sua lógica, o Gerenciador de Cachê (Cache Manager) se concentra mais em estabelecer as diretizes usadas para paginar partes da memória para o disco e tornar a carregá-las na memória principal (RAM).&lt;/p&gt;
&lt;p&gt;Possuem funções mais periféricas, mas não menos importantes. O Gerenciador de Processos cria novos processos e mantém a relação entre eles. O Gerenciador de PnP (Plug and Play), novo no Windows 2000, de um modo geral gerencia a adição e remoção de dispositivos que são plugáveis enquanto a máquina está ligada. O Gerenciador de Energia, também novo, teve sua importância aumentada com o advindo do uso massivo de laptops. É ele que controla coisas como a hibernação do sistema operacional.&lt;/p&gt;
&lt;p&gt;O Gerenciador de Objetos também é parte central e obrigatória do sistema operacional, pois ele gerencia todos os recursos disponíveis tanto em kernel quanto em user mode (espelhado pelo kernel). No Windows, qualquer recurso é representado por um objeto, seja um arquivo, uma thread, um processo, um evento, uma interrupção, etc. Sendo que tudo é representado como um objeto, esse módulo foi especialmente criado para gerenciar todos os recursos de uma vez. Dessa forma tipos de controle global, como o controle de acesso, pôde ser centralizado em apenas um lugar no código, assim como o gerenciamento de handles, que são manipuladores de recursos que existem em modo de usuário.&lt;/p&gt;
&lt;p&gt;O microkernel pode ser entendido como a parte que faz coisas muito básicas em um sistema operacional. Tão básicas quanto executar as threads, gerenciar interrupções e abstrair pequenas diferenças entre arquiteturas.&lt;/p&gt;
&lt;p&gt;Faz par com o microkernel, e pode ser escrito pela Microsoft ou por fabricantes de dispositivos. São eles os responsáveis por controlar o hardware que está atrás do sistema, como o disco, a porta serial, a rede, a placa de vídeo, a própria CPU, etc. Muitos podem ser lógicos, como os filtros e os drivers de sistema de arquivos e, acredite se quiser, costumam ser mais complexos que os que controlam diretamente o hardware.&lt;/p&gt;
&lt;p&gt;A HAL é totalmente dependente de plataforma. Por causa disso, ela é totalmente isolada do resto do sistema operacional, tornando a portabilidade mais fácil de ser suportada. Em alguns casos a HAL é implementada como um conjunto de macros, o que quer dizer que você terá que recompilar seus drivers para mudar de plataforma (x86 para x64, por exemplo). Além disso, existe um conjunto de DLLs compiladas para cada plataforma, que é renomeada (para hal.dll) e copiada durante a instalação. Isso explica porque em algumas situações se você copia a instalação do Windows de uma máquina para outra com diferenças relevantes de arquitetura pode ser que as coisas não saiam exatamente como você esperava.&lt;/p&gt;
&lt;p&gt;A não ser que estejamos falando do Xbox, o hardware é feito por terceiros, como a Intel, a AMD e a NVIDIA, e é onde você instala o seu sistema operacional do coração para rodar seus aplicativos do coração. O bom de um sistema operacional do coração é que você não percebe sua existência quando está rodando seu jogo do coração. Pelo menos não deveria.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 4.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-40/</link>
  <pubDate>2007-09-04</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-40/</guid>
  <description>&lt;p&gt;Em meio a uma febre de consumismo, no dia 24 de agosto de 1995, foi lançado a revolução no sistema gráfico da Microsoft: a interface do Windows 95. Ela foi considerada muito mais amigável que suas versões anteriores, que já vimos nesta série da &lt;a href=&#34;http://www.caloni.com.br/historia-do-windows&#34;&gt;História do Windows&lt;/a&gt;. Ainda possuía a vantagem de não necessitar mais de uma instalação prévia do DOS, passou a suportar nomes de arquivos longos, incluir suporte a TCP/IP e dial-up networking integrados. Muitas mudanças foram feitas no sistema em si, como a passagem para 32 bits (como já vimos, parcial) e o novo conceito de threads, que é o que veremos com mais detalhes nesse artigo.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Bem, o &amp;quot;novo conceito&amp;quot; de threads já havia sido implementado no Windows NT desde o &amp;quot;scratch&amp;quot;. O conceito já existia no início do projeto, mas não no velho Windows 3. 1 de 16 bits, que foi a versão anterior ao 95. Parte dos requisitos do sistema foi que ele seria compatível com o NT no nível de aplicativo, o que de fato aconteceu.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Para esse milagre da multiplicação das threads acontecer a Microsoft foi obrigada a portar boa parte do código de 16 bits para 32 e entrar em modo protegido. Mesmo assim, um legado razoável do MS-DOS permaneceu debaixo dos panos, suportando o novo sistema operacional através de suas interrupções e código residente.&lt;/p&gt;
&lt;p&gt;Com o lançamento da nova versão do NT, foi necessário modernizar a interface para ser compatível com o Windows 95, o que fez com que o Windows 4.0 fosse mais bonitinho. No entanto, o núcleo dos dois sistemas era completamente diferente. Enquanto um era 32 bits puro desde o primeiro int main, o outro era um sistema de compatibilidade para fornecer um Windows caseiro que fosse vendável e desse à Microsoft o retorno financeiro esperado. Deu certo por um bom tempo, até a chegada do Windows XP, que uniu as duas famílias de sistemas operacionais, pois descontinuou o Windows ME e tornou o Windows 2000 Professional mais amigável para o uso geral.&lt;/p&gt;
&lt;p&gt;Uma thread é uma linha de execução de código. Ser um sistema multithreading significa que ele permite que múltiplas linhas de execução de código rodem em paralelo e, dependendo do número de processadores, ao mesmo tempo.&lt;/p&gt;
&lt;p&gt;Em uma plataforma com apenas um processador, como é natural supor, apenas uma thread roda de cada vez. Contudo, o tempo de execução das threads é dividido entre elas, de forma que aparentemente todas elas rodam ao mesmo tempo. Essa unidade de divisão do tempo de execução é conhecido como Quantum, ou Time Slice, e é caracterizado como o tempo em que uma thread fica rodando até que outra thread tome o seu lugar, ou seja, ocorra uma troca de contexto (switch context).&lt;/p&gt;
&lt;p&gt;Como podemos ver, quando uma thread é criada ela ganha seu primeiro time slice (se não iniciar suspensa) e divide o tempo de processamento com outras threads que executam no mesmo processador.&lt;/p&gt;
&lt;p&gt;Para exemplificar o uso de threads, resolvi fazer um programa que pode nos ser útil no futuro. Se trata de um quebrador de senhas por força bruta. Isso quer dizer que enquanto uma thread fica cuidando das mensagens da janela, como digitação e movimentação, uma segunda thread irá ficar constantemente tentanto descobrir sua senha digitada por tentativa e erro. Toda vez que é alterado um caractere na senha, a thread quebradora reinicia seu trabalho.&lt;/p&gt;
&lt;p&gt;Se você está apenas acompanhando estes artigos sem ter se aprofundado em um livro ou o MSDN, algumas coisas podem parecer novas demais, como a maneira que usei para criar a janela. Diferente de CreateWindow, podemos usar funções que criam o que é chamado de caixa de diálogo (dialog box), que nada mais é que uma janela modal, como a mostrada pelo MessageBox (ou até a System.Windows.Forms.MessageBox). Para isso é necessário desenhar uma janela através de um arquivo de resource, com a extensão rc. Porém, podemos ver que não é difícil entender como um arquivo de resources funciona:&lt;/p&gt;
&lt;p&gt;Também não deve ser muita surpresa saber que uma caixa de diálogo também possui sua função de janela, que é praticamente idêntica a do CreateWindow. A diferença está mais no tratamento das mensagens.&lt;/p&gt;
&lt;p&gt;A surpresa maior deve ficar por conta da nova thread, que é criada através da função da API CreateThread:&lt;/p&gt;
&lt;p&gt;Assim como na criação de janelas, é passada uma função de callback. Só que diferente de uma função de janela, essa função não é executada na mesma thread que criou a janela, mas é um novo &amp;quot;int main&amp;quot; para uma nova linha de execução, que irá rodar em paralelo com a primeira. Essa segunda linha de execução termina quando retornamos dessa função, que no nosso exemplo é nunca, mas poderia ser quando fosse terminada sua tarefa.&lt;/p&gt;
&lt;p&gt;Depois que uma thread termina, existem maneiras das outras threads ficarem sabendo e até obterem seu código de retorno. Isso pode ser feito utilizando-se o handle retornado pela função CreateThread, uma duplicação desse mesmo handle ou até a obtenção de um novo handle através do identificador da thread, o Thread Id (TID).&lt;/p&gt;
&lt;p&gt;Bom, acho que para explicar o uso de um sistema multithreading em um artigo só não basta. Mas para explicar por que sua senha deve ter mais de três caracteres, acho que é o bastante. Até a próxima.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 3.51</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-351/</link>
  <pubDate>2007-08-07</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-351/</guid>
  <description>&lt;p&gt;Bem-vindos. Esta é a série &lt;a href=&#34;http://www.caloni.com.br/historia-do-windows&#34;&gt;História do Windows&lt;/a&gt;. Nos anos 90, a relação IBM/Microsoft era muito próxima por causa do desenvolvimento do OS/2, o projeto de um novo sistema operacional. As empresas cooperavam entre si e tinham acesso uma ao código da outra. A Microsoft desejava avançar seu desenvolvimento no Windows, enquanto a IBM desejava que todo trabalho futuro fosse baseado em OS/2. Para resolver essa tensão, as duas combinaram que a IBM iria desenvolver o OS/2 versão 2.0 para substituir o OS/2 versão 1.3 e o Windows v3.0, enquanto a Microsoft iria desenvolver um novo sistema operacional, o OS/2 versão 3.0 para depois suceder ao OS/2 anterior. É lógico que esse acordo foi por água abaixo.&lt;/p&gt;
&lt;p&gt;A relação IBM/Microsoft foi terminada. A IBM continuou a desenvolver o OS/2 v2.0 enquanto a Microsoft mudou o nome de seu ainda não lançado OS/2 v3.0 para Windows NT. O Windows NT foi tão massivamente promovido que a maioria das pessoas nem se deu conta que ele era um OS/2 redesenhado. Ambas as empresas obtiveram os direitos de utilizarem as tecnologias do OS/2 e do Windows que foram desenvolvidas até a quebra do acordo.&lt;/p&gt;
&lt;p&gt;A IBM lançou a versão 2.0 do OS/2 no início dos anos 90. O sistema foi uma grande melhora sobre o antigo OS/2 v1.3. Apresentava um novo sistema de janelas orientado a objetos (o Workplace Shell) para substituir o Presentation Manager, um novo sistema de arquivos (o HPFS) para substituir o sistema FAT utilizado pelo DOS e Windows e aproveitou todas as vantagens das capacidades 32 bits do processador 386 da Intel. Ele também rodava programas DOS e Windows 3.0, uma vez que a IBM tinha acesso e direito a essas duas tecnologias.&lt;/p&gt;
&lt;p&gt;Para concorrer com a IBM, a Microsoft lançou o Windows 3.1, com pequenas melhorias à sua versão anterior, a 3.0.&lt;/p&gt;
&lt;p&gt;A Microsoft continuou a desenvolver o Windows NT. A empresa requeriu os serviços de Dave Cutler, um dos chefes arquitetos da VMS na Digital Equipment Corporation (hoje parte da Compaq) para desenvolver o NT dentro de um projeto de sistema operacional mais capaz. Cutler estava desenvolvendo um seguimento para o VMS na DEC chamado Mica, e quando a DEC desistiu do projeto ele acabou trazendo para a Microsoft sua especialidade nesse sistema e algum engenheiros do projeto com ele. A DEC acreditava que ele usara parte do código do Mica no Windows NT e acabou processando a Microsoft. A empresa de Gates teve que eventualmente pagar 150 milhões para a DEC, além de concordar em suportar o chip Alpha CPU da DEC na plataforma NT.&lt;/p&gt;
&lt;p&gt;Sendo um sistema operacional completamente novo, Windows NT sofreu com questões de compatibilidade com hardware e software geralmente usados na época. Ele era também concentrado em recursos, o que o deixava aceitável apenas para máquinas maiores e mais caras. Tanto que inicialmente foi dirigido a servidores de rede, workstations e máquinas de desenvolvimento de software. Por causa disso, a maioria dos usuário foi incapaz de migrar para a plataforma NT. E o Windows NT ainda estava projetado graficamente como o Windows 3.1, o que era inferior ao OS/2 Workplace Shell. Em resposta, a Microsoft começou a desenvolver um sucessor para o Windows 3.1, um projeto de codinome Chicago. Chicago tinha por objetivo apresentar uma nova GUI que competisse com o OS/2 Workplace Shell. Ele também foi projetado para ser de 32 bits e suportar execução multitarefa, como o OS/2 e o Windows NT. Só algumas partes do Chicago, entretanto, foram convertidas para 32 bits, e o resto permaneceu em 16. A Microsoft argumentou que a conversão total iria atrasar em muito o projeto, o que acabaria por encarecê-lo além do limite.&lt;/p&gt;
&lt;p&gt;Para Chicago, foi desenvolvida uma nova API para substituir a de 16 bits do Windows anterior. Essa API foi chamada de Win32, e a outra renomeada para Win16. Houveram 3 ramificações: uma para o Chicago, outra para o NT e uma terceira chamada Win32s, que foi um subconjunto para o Windows 3.1 garantir a compatibilidade retroativa das versões. Também foi pensado num mínimo de compatibilidade entre o Chicago e o Windows NT, mesmo que os dois possuissem duas arquiteturas radicalmente diferentes.&lt;/p&gt;
&lt;p&gt;Em setembro de 1994 é lançada o Windows NT 3.5. A versão Workstation substituiu o Windows NT 3.1 e a versão Server o Windows NT 3.1 Advanced Server.&lt;/p&gt;
&lt;p&gt;Como todo projeto de sucesso, a primeira coisa a ser feita é definir os objetivos principais. No caso do Windows NT não foi diferente. É importante para nós sabermos que objetivos eram esses e como eles foram mudando de acordo com o momento histórico de forma a analisarmos as conseqüências. Em outubro de 1988, os objetivos do novo sistema operacional eram os seguintes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Compatibilidade com OS/2&lt;/li&gt;
&lt;li&gt;Segurança&lt;/li&gt;
&lt;li&gt;Suporte a POSIX&lt;/li&gt;
&lt;li&gt;Multiprocessamento&lt;/li&gt;
&lt;li&gt;Rede integrada&lt;/li&gt;
&lt;li&gt;Confiabilidade&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Como o Windows 3.0 fez um sucesso enorme, a compatibilidade nativa passou a ser do próprio Windows caseiro, sendo o OS/2 sendo implementado como um mero subsistema. Subsistema no Windows basicamente quer dizer ambiente virtual de execução de processos feitos para rodar em outro sistema operacional. Essa maneira de suportar processos de outros sistemas operacionais foi usado tanto para o OS/2 quanto para o Windows 16 bits, o MS-DOS e aplicativos POSIX.&lt;/p&gt;
&lt;p&gt;O tempo do projeto foi inicialmente estimado em pouco mais de dois anos. Ao final, quatro anos e meio se passaram até a chegada do primeiro release, que era grande e lento para as máquinas da época. Assim foi iniciado o projeto Daytona, que teve como novos objetivos tornar a nova versão do NT mais rápida e confiável. Foi lançada então a versão 3.51.&lt;/p&gt;
&lt;p&gt;O Windows NT é um sistema operacional de 32 bits. Isso quer dizer, entre outras coisas, que ele suporta duas propriedades fundamentais dos sistemas operacionais modernos: modo protegido de execução e memória virtual. O modo protegido de execução permite a divisão entre a parte confiável do sistema operacional (kernel mode) e a parte não-confiável, que não possui acesso às instruções privilegiadas (user mode). A memória virtual abstrai a memória física e permite isolamento de memória entre aplicativos, evitando que um programa invada a memória do outro.&lt;/p&gt;
&lt;p&gt;Além disso, foi criada uma camada de abstração do hardware (HAL, Hardware Abstraction Layer) que livrou boa parte do código de ter sido escrito em assembly, fazendo assim que ele fosse facilmente portável.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 3.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-30/</link>
  <pubDate>2007-08-03</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-30/</guid>
  <description>&lt;p&gt;Continuando a &lt;a href=&#34;http://www.caloni.com.br/historia-do-windows&#34;&gt;História do Windows&lt;/a&gt;, em 22 de maio de 1990 a versão 3.0 do Windows foi lançada. Foi melhorado o gerenciador de programas e o sistema de ícones, além de um novo gerenciador de arquivos e suporte a 16 cores. Entre as mudanças internas podemos citar a velocidade e a confiabilidade. Como a partir dessa versão apareceram muitos desenvolvedores que passaram a suportar a plataforma, o número de programas disponíveis aumentou, o que conseqüentemente fez com que as vendas alavancassem. Três milhões de cópias foram vendidas apenas no primeiro ano, e assim o Windows se tornou padrão nos computadores domésticos. Quando a versão 3.1 foi lançada, em 6 de abril de 1992, mais três milhões de cópias foram vendidos em apenas dois meses.&lt;/p&gt;
&lt;p&gt;As fontes TrueType foram adicionadas, junto de novas capacidades multimídia. Outro grande avanço foi na área de comunicação entre aplicativos com a implementação da tecnologia OLE (Object Linking and Embedding), que permitiu documentos de diferentes fabricantes serem intercambiados.&lt;/p&gt;
&lt;p&gt;Em novembro de 1993 foi lançada a primeira versão que integrou o Windows e a rede de trabalho, o Windows for Workgroups 3.1. O suporte a compartilhamento de arquivos e impressoras apareceu a partir daí. Duas aplicações novas também surgiram: Microsoft Mail, cliente de mail para uso em redes, e Schedule+, uma agenda de trabalho.&lt;/p&gt;
&lt;p&gt;E, finalmente, agora já é hora de conversarmos sobre...&lt;/p&gt;
&lt;p&gt;Programar interfaces naquela época não era bem o &amp;quot;clicar e arrastar&amp;quot; de hoje em dia. Eram necessários profundos conhecimentos sobre como o sistema operacional se relacionava com o seu programa e vice-versa. Hoje em dia é possível ainda programar como antigamente, já que toda a estrutura continua a mesma. Porém, é algo extremamente contraprodutivo de se fazer com as IDEs modernas que existem e suas barras de controles pré-fabricados e código automático. Faremos da forma mais rústica para entender como as coisas funcionam por baixo dos panos, o que por si só será extremamente produtivo para o nosso conhecimento.&lt;/p&gt;
&lt;p&gt;Antes de ser criada uma janela, é necessário registrar uma classe de janela no sistema, cuja relação com uma janela é mais ou menos a mesma entre classe e objeto no paradigma de orientação a objetos. Você primeiro define uma classe para sua janela e posteriormente pode criar inúmeras janelas a partir da mesma classe.&lt;/p&gt;
&lt;p&gt;Quando você define uma classe e a registra está dizendo para o sistema qual será sua função de janela, i. e., qual será a função responsável por receber as mensagens das janelas criadas.&lt;/p&gt;
&lt;p&gt;Uma mensagem é um evento que ocorre relativo à sua janela ou o que está acontecendo ao redor dela no mundo Windows. Por exemplo, as janelas recebem eventos a respeito dos cliques do usuário, redesenho da janela, etc. Quem envia essas mensagens é o próprio Windows, e ele espera uma resposta da sua função de janela. Agora a parte esquisita: quem envia essas mensagens para o Windows é o seu próprio aplicativo!&lt;/p&gt;
&lt;p&gt;O aplicativo fica aguardando por eventos em um loop conhecido como loop de mensagens. A função do loop basicamente é chamar a função GetMessage e redirecionar as mensagens obtidas para as respectivas funções de janela.&lt;/p&gt;
&lt;p&gt;E aqui está o código completo:&lt;/p&gt;
&lt;p&gt;Esse exemplo é bem velho, mas compila e funciona até hoje, depois de passados 17 anos:&lt;/p&gt;
&lt;p&gt;O Windows 3.x tinha uma particularidade nefasta: qualquer aplicativo poderia travar o sistema como um todo. Se lembrarmos que o Windows antigamente era multitarefa e não-preemptivo, podemos deduzir que enquanto é executada a função de janela de um aplicativo o sistema aguarda por esse aplicativo indefinidamente. Se o aplicativo trava, ele nunca retorna. Se ele nunca retorna, o sistema fica eternamente esperando pelo retorno da função de janela. Alguns travamentos conseguiam ser resolvidos por interrupção, mas a maioria não. No próximo capítulo da série veremos como os sistemas de 32 bits resolveram esse pequeno problema.&lt;/p&gt;
&lt;p&gt;O que o resto do código do Petzold faz? Dê uma olhada na documentação do MSDN. Ela ainda está disponível, já que todos os aplicativos precisam utilizar essas funções, seja diretamente ou através de imensos frameworks de interface com o usuário. E existem pessoas que precisam suportar código-fonte legado.&lt;/p&gt;
&lt;p&gt;Já que agora você sabe o que são funções de janela, mensagens e afins, por que não ver tudo isso funcionando? O Microsoft Visual Studio possui uma ferramenta muito útil para isso chamada Spy++ (spyxx.exe). Existem também aplicativos equivalentes (com fonte). Outra ferramenta muito útil, principalmente na hora de desenvolver janelas com controles comuns do Windows, é o Control Spy.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 2.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-20/</link>
  <pubDate>2007-07-04</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-20/</guid>
  <description>&lt;blockquote&gt;
&lt;p&gt;Eu seu, eu sei. A maioria dos meus leitores odiou o tema &lt;a href=&#34;http://www.caloni.com.br/historia-do-windows&#34;&gt;História do Windows&lt;/a&gt; na era paleozóica. Porém, como eu disse na parte 1.0, estou apenas satisfazendo a outra parte de leitores que procurou no Google por esse tema e acabou caindo no meu antigo blog. Mas vejamos o lado bom: a partir da próxima versão iremos destrinchar a API do sistema, entendendo o porquê das coisas serem como elas são. No momento os deixo apenas com história, pois é desconhecido para mim como funcionavam os primeiros rabiscos do MS-DOS Shell, mais conhecido como Windows/386. Bom divertimento!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Assim, em 9 de dezembro de 1987, é lançado o aperfeiçoadíssimo Windows 2.0, que fez do PC um ambiente muito mais parecido com um computador Macintosh. O novo sistema possui ícones para representar programas e arquivos, fornece suporte para memória expandida e janelas que podem se sobrepor(!). Porém, ainda utilizava o modelo de memória do 8088 e portanto era limitado a 1 Megabyte, ainda que certas pessoas houvessem tido sucesso rodando o sistema em cima de outro multitarefa como DesqView.&lt;/p&gt;
&lt;p&gt;A Apple, vendo a extrema semelhança entre seu sistema e o Windows, abriu um processo em 1988 alegando ter a Microsoft quebrado o acordo feito em 1985. A Microsoft se defendeu tendo o argumento que a licença lhe dava o direito do uso dessas características. Uma guerra judicial se arrastou por quatro anos. A Microsoft ganhou. Ao final, a Apple declarou que a Microsoft havia infligido 170 de seus copyrights. A corte judicial disse que o acordo de licença dava direito de uso da Microsoft de todos menos nove. Então a Microsoft alegou que os copyrights restantes não poderiam ser reinvidicados pela lei do copyright, já que a Apple pegou suas idéias da interface gráfica desenvolvida pela Xerox em seus computadores Star. Assim, um impresso de 01/06/93, disponível no Microsoft Timeline, resumiu a solução final:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Microsoft announces that Judge Vaughn R. Walker of the U.S. District Court of Northern California ruled today in Microsoft&#39;s favor in the Apple vs. Microsoft and Hewlett-Packard copyright suit. The judge granted Microsoft&#39;s and Hewlett-Packard&#39;s motions to dismiss the last remaining copyright infringement claims against Microsoft Windows 2.03 and 3.0, as well as, the HP NewWave.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Uma outra frase resume o caminho trilhado pela empresa a partir de então:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Microsoft become the top software vendor in 1988 and never looked back...&amp;quot; - Microsoft&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Com o advento dos novos lançamentos da Intel, os processadores 80286 e 80386, o Windows acabou sendo atualizado duas vezes para aproveitar as novas características dos dois sistemas. E assim nasceram as versões 2.1.x do Windows, respectivamente conhecidas como Windows/286 e Windows/386.&lt;/p&gt;
&lt;p&gt;A próxima versão do Windows é que vai alavancar as vendas da Microsoft de uma vez por todas. Veremos que boa parte da API que usamos hoje em dia já existia no Windows 3.0, e boa parte das peculiaridades que nos perseguem até hoje.&lt;/p&gt;
</description>
</item>

     
        <item>
  <title>História do Windows - parte 1.0</title>
  <link>http://www.caloni.com.br/historia-do-windows-parte-10/</link>
  <pubDate>2007-06-26</pubDate>
  
  <guid>http://www.caloni.com.br/historia-do-windows-parte-10/</guid>
  <description>&lt;p&gt;Devido à grande procura através de mecanismos de busca (vulgo Google), estarei republicando esse artigo dividido em partes (até porque existem partes não acabadas), cada parte descrevendo um conceito geral do que representou cada versão do sistema operacional. Bem-vindos ao &lt;a href=&#34;http://www.caloni.com.br/historia-do-windows&#34;&gt;História do Windows&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Tudo começou em 1981, quando chegou às lojas o primeiro IBM PC, uma poderosa máquina de 4.7mhz, 64(KB!) de RAM e um drive de disquete de 160KB. Já havia sido lançado em agosto o MS-DOS, sistema operacional encomendado pela IBM à empresa recém-criada por Paul Allen e Bill Gates, a Microsoft Corporation. O DOS foi baseado num sistema básico anterior produzido pela Seattle Computer Products.&lt;/p&gt;
&lt;p&gt;No mesmo ano uma empresa chamada Xerox pôs ao mundo uma estação de trabalho gráfica chamada Star. Do Star vieram os conceitos de janelas, ícones, e o uso de um hardware apontador de tela chamado de mouse. De lá foram tiradas, portanto, as principais idéias que moldaram a criação dos futuros sistemas operacionais que revolucionaram o conceito de interação computador/usuário, como o LISA, da Apple - que mais tarde também deu origem ao Macintosh - e o sistema gráfico da Microsoft chamado Windows.&lt;/p&gt;
&lt;p&gt;Em novembro de 1983 a Microsoft Corporation anuncia oficialmente, no Plaza Hotel em Nova York, o Microsoft Windows, a próxima geração de sistemas operacionais que irá ter uma interface gráfica para o usuário (GUI) e ambiente multitarefa. É possível que o nome original do sistema tivesse sido Interface Manager se um dos gênios do departamento de marketing da Microsoft, Rowland Hanson, não tivesse convencido o fundador da empresa, Bill Gates, que Windows seria um nome melhor por ser mais intuitivo. A promessa inicial dizia que o sistema iria ser lançado em abril do próximo ano.&lt;/p&gt;
&lt;p&gt;No início daquele ano, então, foi mostrada uma versão beta aos chefões da IBM, que não se mostraram muito entusiamados. Na verdade, a criadora do Personal Computer estava trabalhando num novo projeto que substituiria o sistema original da Microsoft, o MS-DOS.&lt;/p&gt;
&lt;p&gt;Surgiram concorrentes potenciais do Microsoft Windows. VisiOn, da VisiCorp, foi a primeira GUI oficial lançada para PC. GEM (Graphical Environment Manager), lançada pela Digital Research no começo de 1983. No entanto ambos careciam do suporte de desenvolvedores para a plataforma. Ora, se ninguém quer fazer programas para um sistema, quem vai querer comprá-lo?&lt;/p&gt;
&lt;p&gt;Um produto chamado Top View fora lançado pela IBM em fevereiro de 1985, baseado em DOS com um gerenciador multitarefa, mas sem uma GUI. Era lento e precisava de muita memória. Acabou sendo descontinuado dois anos depois e nunca chegou a ter uma interface gráfica.&lt;/p&gt;
&lt;p&gt;Antes do lançamento do Windows, advogados da Apple alertavam sobre a possibilidade do sistema infringir os direitos e patentes que a empresa tinha sobre as características da sua interface gráfica, a LISA (janelas com barra de título, menus drop-downs, suporte a mouse, etc). Daí o fundador da Microsoft, Bill Gates, teve a idéia brilhante de firmar um contrato de licença com a Apple, dando-lhe o direito de incluir em todas as futuras versões do Windows e programas os conceitos de GUI adquiridos pelo sistema gráfico da Apple (isso antes do Windows ser lançado).&lt;/p&gt;
&lt;p&gt;Finalmente, em 20 de novembro de 1985, a Microsoft lança o Windows 1.0, quase dois anos depois da promessa inicial. Foi vendido inicialmente por U$100. Continha em seu pacote: MS-DOS Executive, Calendar, Cardfile, Notepad, Terminal, Calculator, Clock, Reversi, Control Panel, PIF (Program Information File) Editor, Print Spooler, Clipboard, RAMDrive, Windows Write e Windows Paint.&lt;/p&gt;
&lt;p&gt;O novo sistema não fez muito sucesso de imediato. Pelo contrário, foi considerado lento e primitivo. Devido às limitações impostas pela Apple o sistema não pôde apresentar certas características como a sobreposição de janelas e a famosa lixeira (um conceito proprietário da Apple). Ficou cerca de dois anos boiando no mercado até que foi lançado um produto chamado Aldus PageMaker 1.0. PageMaker foi o primeiro programa WYSIWYG (What You Seee Is What You Get) para o PC. Tinha a grande novidade de juntar tipos e gráficos no mesmo documento. Depois de um ano, a Microsoft lança uma planilha de cálculos chamada Excel. Mais tarde outros produtos como Microsoft Word e Corel Draw ajudaram a aumentar a popularidade do Windows, embora esse ainda precisasse de muitas melhoras.&lt;/p&gt;
</description>
</item>

     
    
  </channel>
</rss>
