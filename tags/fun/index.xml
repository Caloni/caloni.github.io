<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fun on Blogue do Caloni</title>
    <link>http://www.caloni.com.br/tags/fun/</link>
    <description>Recent content in fun on Blogue do Caloni</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Tue, 07 Apr 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.caloni.com.br/tags/fun/" rel="self" type="application/rss+xml" />
    
     
        <item>
  <title>Meu Try Lock de Pelúcia</title>
  <link>http://www.caloni.com.br/try-lock-de-pelucia/</link>
  <pubDate>2020-04-07</pubDate>
  
  <guid>http://www.caloni.com.br/try-lock-de-pelucia/</guid>
  <description>Alguns implementam o famigerado &amp;quot;mutex pero no mucho&amp;quot;, que é aquele mutex que não faz nada porque ele sabe que só tem uma thread rodando no processo. É uma solução elegante para abstrair o uso de lock em um processo que pode ou não rodar multithread.
Mas isso é uma coisa. Outra coisa é o try lock de pelúcia de um driver de uma empresa que trabalhei certa vez. Como havia situações onde o lock não era nunca liberado, e a thread estava rodando em um nível de interrupção que não poderia mais voltar, ou ela agendava uma execução menos prioritária ou obtia o lock. Mas baixar a prioridade não era uma opção para o programador MacGyver. Então o código acabou pegando o lock na marra.
if( ! try_aquire_mutex() )// dá um tempo...if( ! try_aquire_mutex() )// dá um tempo...// ...// ah, dane-se,// eu vou pegar esse mutex!aquire_mutex(); </description>
</item>

     
        <item>
  <title>Dixit (Jogo)</title>
  <link>http://www.caloni.com.br/dixit-jogo/</link>
  <pubDate>2019-05-20</pubDate>
  
  <guid>http://www.caloni.com.br/dixit-jogo/</guid>
  <description>Uma festa com karaokê e jogos de mesa. O que pode surgir de interessante em um cenário millenial como esse? Um jogo de cartas que em sua simplicidade revela um intrincado sistema que soluciona todos os problemas que outros jogos de mesa costumam ter.
Dixit é um jogo de cartas ilustradas que os competidores ficam em mãos e usam em toda rodada. Em cada rodada um deles vira o &amp;quot;narrador&amp;quot; e usa uma frase para descrever a carta que escolheu. Todos os outros competidores escolhem suas cartas que melhor se encaixam na descrição do narrador e sem saber qual a carta de cada um o objetivo é ter sua carta escolhida pelos outros.
Porém -- e aí está o ponto-chave do jogo -- se a carta do narrador não for escolhida por ninguém ou for escolhida por todos ele não ganha pontos. O objetivo do jogo é incentivar nosso lado subjetivo e fazer com que apenas algumas pessoas te sigam nesse jogo de metáforas, enquanto outras não. E do ponto de vista dos outros jogadores o objetivo é que através de uma descrição que você não tem controle você escolha a melhor carta que se encaixe.
A beleza do jogo está que as cartas em si podem significar muitas poucas palavras inequívocas, mas o narrador poderia detalhar completamente sua carta e perderia, ou poderia usar um termo muito vago e também perderia. O jogo incentiva não uma concordância total entre os jogadores, mas festeja a multiplicidade de visões. E além disso resolve uma série de problemas que jogos costumam ter.
Resolve a universalidade, já que não há qualquer relação nem verbal nem cultural com as cartas em si, apenas com seus jogadores, e o sistema de votos usa simples números, outro traço universal. E ao mesmo tempo, se tratar-se de um grupo culturalmente diverso, explora as diferentes formas de cada pessoa enxergar os significados que as cartas podem ter. O jogo se torna até mais interessante quanto mais diverso for o grupo.
Por depender unicamente da visão dos participantes do jogo ele também resolve a questão da idade (biológica ou mental), pois grupos de idades diferentes terão uma dinâmica diferente. Crianças e jovens usarão descrições das cartas de uma maneira completamente diferente dos mais velhos. Seja um grupo unicamente de velhos ou de jovens isso deve funcionar bem. Porém, mais uma vez, na diversidade de idades é que o jogo deve brilhar mais. Onde jogos geralmente perdem a graça quando são jogados por pessoas com idades e capacidades diferentes aqui o desafio é justamente o diálogo entre os dois mundos.
Conforme jogos vão sendo jogados pelas mesmas pessoas cria-se o vício e logo torna-se manjado ganhar. Porém, em Dixit isso não ocorre, pois aquelas pessoas vão evoluindo a compreensão uns dos outros juntas. Então o mesmo conjunto de cartas vai servindo para diferentes formas de enxergá-las dos mesmos jogadores em níveis diferentes de experiência com o jogo. Com isso Dixit resolve o problema da novidade, enquanto que ao mesmo tempo permite a vinda de novas cartas, que não precisam se relacionar de uma maneira especial (apenas na mente dos participantes).
Por fim, por incentivar a participação em seu núcleo, permitindo que todos ganhem pontos e interajam de maneira ativa em cada rodada, Dixit resolve também o problema da espera, em que muitos jogos os participantes ficam aflitos esperando a sua vez de jogar, que geralmente é o momento mais empolgante. Não nesse jogo. Todo momento é empolgante sempre, o que torna este o estado da arte do entretenimento de mesa. Simples, universal, participativo e criativo.
</description>
</item>

     
        <item>
  <title>Minecraft: O Jogo</title>
  <link>http://www.caloni.com.br/minecraft-game/</link>
  <pubDate>2019-01-06</pubDate>
  
  <guid>http://www.caloni.com.br/minecraft-game/</guid>
  <description>Fundamentado em bases materialistas, a partir das quais Karl Marx se orgulharia, Minecraft é uma luta por recursos e sobrevivência. E por ser simples e fácil de jogar, as crianças adoram. Isso e porque também tem skins na aparência dos players.
Mas qual o objetivo em Minecraft? Ele um jogo pensado como um mundo de blocos onde o que muda são as propriedades físicas desses blocos e o que é possível fazer com eles. Criado por Markus Persson e posteriormente desenvolvido por sua empresa, a Mojang (e depois comprado pela Microsoft), o jogo que atrai crianças, jovens e autistas de todo mundo possui alguns atrativos. O sistema de troféus, como em todo jogo moderno, já foi colocado. Porém, resta a pergunta fatal, filosófica, que quase pode ser ouvida quando se entra no jogo e se começa a minerar: qual o objetivo?
E a resposta ironicamente acaba sendo a mesma sobre o mundo físico em que vivemos: sobreviver. E para isso é necessário obter recursos. Madeira, minério, alimento. Coletado ou caçado. Animais precisam ser mortos ou domesticados para fornecer os recursos que precisamos. Sangue deve jorrar nessa experiência lúdica para que aprendamos que o mundo é um lugar muitas vezes escuro, solitário e vazio de significado.
Claro que com o tempo surgiram os servidores com sub-jogos com objetivos claros e foi tudo por água abaixo. Crianças mimadas.
Mas se concentre no modo clássico do jogo. Survival. Os recursos não brotam como mágica e seu uso não é tão claro. É preciso aprender, e vivenciar no processo. Essa busca por significado, por objetivo, é o maior valor que o jogo tem. Tirando seus gráficos, embora simplistas, esteticamente agradáveis, ou sua movimentação intuitiva, seu sistema de experiência, de programação, de probabilidades, etc.
Jogar Minecraft como um adulto é voltar a ser criança em uma nova versão. E nessa versão aprendemos, como crianças, a pensar como adultos. E nos esquecemos de toda essa baboseira de direitos, de casa aconchegante e comida quentinha. É a vida cruel ensinada através de pixels. Resta ao jogador eventual conseguir encontrar essa magia dentro desse mundo, para ao sair se sentir grato pela vida privilegiada que tem, onde não é necessário se esconder à noite porque os monstros estarão à espreita.
</description>
</item>

     
        <item>
  <title>Para a Cúpula Filho Da Puta</title>
  <link>http://www.caloni.com.br/para-a-cupula-filho-da-puta/</link>
  <pubDate>2017-08-25</pubDate>
  
  <guid>http://www.caloni.com.br/para-a-cupula-filho-da-puta/</guid>
  <description>O Facebook me lembrou de uma imagem antiga do cartunista do Oatmeal que traduzi para o português há cinco anos. Continua atual, será?
</description>
</item>

     
        <item>
  <title>Programa, Mãe Foca!</title>
  <link>http://www.caloni.com.br/programa-mae-foca/</link>
  <pubDate>2016-08-30</pubDate>
  
  <guid>http://www.caloni.com.br/programa-mae-foca/</guid>
  <description>A história das metodologias de desenvolvimento de software segue mais ou menos as oscilações naturais do próprio software: caminha em direção ao caos (e as sessões de refactory buscam desacelerar essa inevitável tendência). Assim como aquela classe que parecia perfeita assim que foi feita, uma metodologia irá se desmanchar frente à lei da mediocridade. Você não consegue software bom com programadores ruins seguindo a melhor metodologia do planeta.
Então a solução nunca parece ser a metologia, já que programadores ruins não melhorarão seguindo qualquer metologia que seja.
Porém, existe um método infalível. Um método que transforma os programadores mais UML do mundo em fazedores de código inquebrável. Programadores acostumados a 15 horas de reunião semanal fritando o processador de produtividade, esbanjando atalhos no Vim, coordenando threads como um maestro que coordena uma orquestra sinfônica tocando a trilha sonora da sua vida.
Esse método chama-se: Programa, Filho da PATA
Ou, do inglês, PMF.
E o que o PMF tem a oferecer? Esse cara parece ter o esboço da resposta:
E como ele pretende fazer isso? Bom, existe um algoritmo, é claro:
 Escreva uma lista da droga que você tem que fazer, usando software escrito por algum programador filho da pata Faça algumas dessas drogas, novamente usando &amp;quot;programação, filho da pata Teste se essa droga está boa, e se não estiver então conserte com programação, filho da pata  E se você está preocupado com o foco muito no código, e não nos resultados para seu cliente, existe até um &amp;quot;capítulo&amp;quot; sobre gerência, a &amp;quot;Gerência, Coisão&amp;quot;:
Para fazer Gerência, Coisão, você deve fazer o seguinte:
 Ache o que os clientes querem perguntando para eles. Arrume a droga que os Programadores Filhos da PATA precisam fazer. Fale para os Programadores Filhos da PATA quando as drogas que eles fizeram não está boa o suficiente para vender.  Simples e conciso. Acho que até a gerência deve conseguir se lembrar desses três passos.
Não há nada de errado em usar outras metologias em cima da PMF, mas há tudo de errado em substituir uma coisa por outra. A PMF é primordial para terminar alguma coisa. É o suprasumo da eficiência. Com ela todas as coisas eventualmente são solucionadas. Usar apenas a metologia do seu coração sem aplicar PMF não irá entregar nada.
E por mais curioso que seja, há de fato uma tendência nas pessoas de enxergar a solução de todos os seus problemas não fazendo absolutamente nada. Apenas preenchendo cartões em um dashboard. Não é bem por aí. Claro que há uma parcela de nada que pode ajudar a organizar a bagunça que é uma equipe de programadores batucando código, mas esse nada nunca pode atrapalhar os... programadores batucando código!
Afinal, é com código que se constrói algo, certo? Seja aumentando, modificando ou apagando código. Seja transformando código em um passo-a-passo em um txt. Ou em um papel de pão. Código é apenas uma abstração de resolução de problemas. O quão bem você resolver o problema é o que conta, não a sua linguagem de programação do coração. Muitos problemas podem ser solucionados apenas com papel e caneta (ou lápis). Linguagens de programação, até certo ponto, podem virar também metodologias mágicas que prometem entregar soluções mágicas sem dor.
Mas adivinha, só? Seu cliente está cantando e andando sobre qual é a linguagem, a ferramenta, o tamanho da fonte. Ele só quer seu problema resolvido.
Então o jeito é: &amp;quot;Puroguramingu, Mazaafakkaa!&amp;quot; =)
</description>
</item>

     
        <item>
  <title>Real Programmers Don&#39;t Use Java</title>
  <link>http://www.caloni.com.br/real-programmers-dont-use-java/</link>
  <pubDate>2014-02-20</pubDate>
  
  <guid>http://www.caloni.com.br/real-programmers-dont-use-java/</guid>
  <description>When I was a newbie (and a wanna-be) I enjoyed reading &amp;quot;Real Programmers Don&#39;t Use Pascal&amp;quot;, a satiric text that influenced and encouraged me into the path of &amp;quot;C/C&#43;&#43; enlightenment&amp;quot;, most even than K&amp;amp;R&#39;s book. Since then I thought that being a &amp;quot;Real Programmer&amp;quot; was something close to everything one needs to know to get (hard) things done (quickly). Being a &amp;quot;Quiche Eater&amp;quot; was, in couterpart, comparable to nothing. Real Programmers solve real problems! Quiche Eaters are losers who study the academic concepts of computer science and never do a damn useful and/or working program (maybe you know some guy like this).
Jokes apart, the spirit of the text can also be used by those who already find them very good programmers and believe no longer have to grow professionally. The times my ego inflates I still remember that my code use child APIs and an operating system that is a joke. I also remember that there are some people out there designing a starship that will leave the orbit of the Solar System!
On the other hand, many people that just got out of CS course still find programming a difficult matter. This text reminds us that life was difficult 20, 40, 70 years ago, when engineers and programmers were the same person and when you didn&#39;t know that what you were doing could put millions at risk in a project.
Hence, the Real Programmer live in the past. And he always will be worthier than young folks, because he knows how to solve that blue screen problem that nobody else does. As I always say, paraphrasing an illustrious figure in Brazilian television, who is afraid to open Visual Studio and is eternally designing the software instead does not go very far: &amp;quot;who knows to do, do it right way!&amp;quot; .
Here follows a brief summary of the original text adapted to the current times and with my prejucided view of thinking about it. If you wish to use your politically correct piece of mind and criticize me, be my guest!
Languages. Remember: the need to invent more languages/resources to do your job is to remind yourself about your own incompetence to invent such excuse. You are one of those who says &amp;quot;every problem has a specific tool&amp;quot; or something like that. In other words: an inefficient programmer. Don&#39;t you see that everything you need is C. If C won&#39;t do, then assembly will. If none of them, then is isn&#39;t worth doing.
Structured Programming. It is the first and last paradigm to be applied. After all, Object Orientation is another excuse to not program. They are more abstractions that, once you are a dead weight, you are unable to solve a problem using just functions and variables. No, you need classes, inheritance, templates and whatever the hell that will transform your simple and straight code into a magical horn of plenty that will only impress others at the futility and complexity of the solution.
Data structure. Another great concept to fool yourself. Today are many who enslave us to weird SQL layouts and weird frameworks that do all the work. We all know that the only really useful to know the structure is the array. The rest are variants of the same theme: queues and stacks.
Operating system. Mac and Windows are just toys and Linux is a video game that takes more work to set up than playing. The programmer actually uses something like mainframes or other beta operating system, which are too weird and can make a real mess in the hands of those who have not read the WHOLE manual. And knowing all known major kernel bugs and its location by heart at the time of booting is vital.
Tools. If you depend on an IDE that have Code Completion and other fancy stuff or any other editor that depends on your favorite 17,459 plugins installed, then you are not a Real Programmer. A Real Programmer actually use what he have on hand at the time, like notepad, hexdump or even some beeps . The tool is no limit to one that can really code.
Debugging. Are you saying that you need the source code in order to debug? So you do not have a clue of what the program does. Just a few glances at call stack and the registers can make a Real Programmer solve a bug that Quiche Eaters would not get after analyzing those charts with boxes inside UML and use cases for months.
The Real Programmers Work is certainly not doing trivial databases to trivial programs that access SQL with trivial queries. Neither are those horrible websites with PHP/Apache and scripts and more scripts written by kids. No, sir. These are programs that deal with the OS in a more intimate way (HD encryption, file system drivers, critical communication services, etc.), or are programs that do something really useful (compilers, the operating system itself). Or maybe those programs that deal directly with hardware (complex microcontrollers, robots, ships, medical devices, etc.).
The Fun of every Real Programmer is actually chat with friends (about programming), read something (about programming) and watch intelligent movies (about programming or people who have some kind of intellectual challenge to solve &amp;quot;the hard way&amp;quot;). Is there anything more fun than that?
And, finally, in their Natural Habitat, we can find pages and pages of assembly code scattered around the table, a computer locked by a remote kernel debugging serial cable, some notes in hex on a piece of paper, a few dozen browser pages openned about the behavior of functions in BIOS SATA HDDs with 500 GB working on RAID4, coffee (of course), chips, stains on the carpet. When there&#39;s nothing to do the environment is pretty tidy and one cannot notice the presence of Real Programmers in sight.
And the Future of Real Programmer? Well, C may even be dying. But so what? It seems C&#43;&#43; supports pointers as well. The rest of the useless abstractions like classes and inheritance may be totally ignored. The basics will always exist. Forget versions with multiple inheritance and enigmatic concepts. Be a (wo)man!
The real, happy, final truth is: regardless of how much more the world becomes &amp;quot;managed&amp;quot; behind frameworks and programmers who prefer to &amp;quot;do projects&amp;quot; behind their office packages and use cases, when problems pop up, some bug murky life threatening useful for a project, a Real Programmer will be there to save the day, because only a programmer really knows how to do his job well done and have a good night of sleep knowing that everything will just be OK.
If it doesn&#39;t, there will be always a Real Programmer to save the day.
&amp;quot;As long as there are ill-defined goals, bizarre bugs, and unrealistic schedules, there will be Real Programmers willing to jump in and Solve The Problem, saving the documentation for later. Long live FORTRAN!&amp;quot;
</description>
</item>

     
        <item>
  <title>eXtreme Go Horse</title>
  <link>http://www.caloni.com.br/extreme-go-horse/</link>
  <pubDate>2012-09-27</pubDate>
  
  <guid>http://www.caloni.com.br/extreme-go-horse/</guid>
  <description>O Go Horse Power (GHP) foi criado por um blogue hoje extinto. As premissas dessa nova metodologia de desenvolvimento era que o projeto fosse feito da maneira mais rápida possível.
Contudo, eles não contavam com a versão turbinada do desleixo humano.
A eXtreme Go Horse (XGP) é o suprassumo das metodologias do mercado brasileiro de desenvolvimento. Quem nunca trabalhou em uma empresa gerida por essas regras? (Bom, pelo menos XGH pelo jeito tem até controle de fonte, algo que era até meio raro uns anos atrás):
1- Pensou, não é XGH
XGH não pensa, faz a primeira coisa que vem à mente. Não existe segunda opção, a única opção é a mais rápida
2- Existem três formas de se resolver um problema
Estas são: a correta, a errada e a XGH, que é igual à errada, só que mais rápida. XGH é mais rápido que qualquer metodologia de desenvolvimento de software que você conhece (Vide Axioma 14).
3- Quanto mais XGH você faz, mais precisará fazer
Para cada problema resolvido usando XGH, mais uns 7 são criados. Mas todos eles serão resolvidos da forma XGH. XGH tende ao infinito.
4- XGH é totalmente reativo
Os erros só existem quando aparecem.
5- XGH vale tudo, só não vale dar o toba
Resolveu o problema? Compilou? Commit e era isso.
6- Commit sempre antes de update
Se der merda, a sua parte estará sempre correta.. E seus colegas que se fodam.
7- XGH não tem prazo
Os prazos passados pelo seu cliente são meros detalhes. Você SEMPRE conseguirá implementar TUDO no tempo necessário (nem que isso implique em acessar o BD por um script malaco)
8- Esteja preparado para pular fora quando o barco começar a afundar¿
Ou coloque a culpa em alguém ou algo. Pra quem usa XGH, um dia o barco afunda. Quanto mais o tempo passa, mais o sistema vira um monstro. O dia que a casa cair, é melhor seu curriculum estar cadastrado na APInfo, ou ter algo pra colocar a culpa
9- Seja autêntico, XGH não respeita padrões
Escreva o código como você bem entender, se resolver o problema, commit e era isso
10- Não existe refactoring, apenas rework
Se der merda, refaça um XGH rápido que solucione o problema. O dia que o rework implicar em reescrever a aplicação toda, pule fora, o barco irá afundar (Vide Axioma 8)
11- XGH é totalmente anárquico
A figura de um gerente de projeto é totalmente descartável. Não tem dono, cada um faz o que quiser na hora que os problemas e requisitos vão surgindo (Vide Axioma 4)
12- Se iluda sempre com promessas de melhorias
Colocar TUDO no código como uma promessa de melhoria ajuda o desenvolvedor XGH a não sentir remorso ou culpa pela cagada que fez. É claro que o refactoring nunca será feito (Vide Axioma 10)
13- XGH é absoluto, não se prende à coisas relativas
Prazo e custo são absolutos, qualidade é totalmente relativa. Jamais pense na qualidade e sim no menor tempo que a solução será implementada, aliás¿ não pense, faça!
14- XGH é atemporal
Scrum, XP¿Tudo isso é modinha. O XGH não se prende às modinhas do momento, isso é coisa de viado. XGH sempre foi e sempre será usado por aqueles que desprezam a qualidade
15- XGH nem sempre é POG
Muitas POG¿s exigem um raciocínio muito elevado, XGH não raciocina (Vide Axioma 1).
16- Não tente remar contra a maré
Caso seus colegas de trabalho usam XGH para programar e você é um coxinha que gosta de fazer as coisas certinhas, esqueça! Pra cada Design Pattern que você usa corretamente, seus colegas gerarão dez vezes mais código podre usando XGH.
17- O XGH não é perigoso até surgir um pouco de ordem
Este axioma é muito complexo, mas sugere que o projeto utilizando XGH está em meio ao caos. Não tente por ordem no XGH (Vide Axioma 16), é inútil e você pode jogar um tempo precioso no lixo. Isto fará com que o projeto afunde mais rápido ainda (Vide Axioma 8). Não tente gerenciar o XGH, ele é auto suficiente (Vide Axioma 11), assim como o caos.
18- O XGH é seu brother, mas é vingativo
Enquanto você quiser, o XGH sempre estará do seu lado. Mas cuidado, não o abandone. Se começar um sistema utilizando XGH e abandoná-lo para utilizar uma metodologia da moda, você estará fudido. O XGH não permite refactoring (vide axioma 10), e seu novo sistema cheio de frescurites entrará em colapso. E nessa hora, somente o XGH poderá salvá-lo.
19- Se tiver funcionando, não rela a mão
Nunca altere, e muito menos questione um código funcionando. Isso é perda de tempo, mesmo porque refactoring não existe (Vide Axioma 10). Tempo é a engrenagem que move o XGH e qualidade é um detalhe desprezível.
20- Teste é para os fracos
Se você meteu a mão num sistema XGH, é melhor saber o que está fazendo. E se você sabe o que está fazendo, vai testar pra que? Testes são desperdício de tempo, se o código compilar, é o suficiente.
21- Acostume-se ao sentimento de fracasso iminente
O fracasso e o sucesso andam sempre de mãos dadas, e no XGH não é diferente. As pessoas costumam achar que as chances do projeto fracassar utilizando XGH são sempre maiores do que ele ser bem sucedido. Mas sucesso e fracasso são uma questão de ponto de vista. O projeto foi por água abaixo mas você aprendeu algo? Então pra você foi um sucesso!
22- O problema só é seu quando seu nome está no Doc da classe
Nunca ponha a mão numa classe cujo autor não é você. Caso um membro da equipe morra ou fique doente por muito tempo, o barco irá afundar! Nesse caso, utilize o Axioma 8.
Este texto foi copiado daqui e daqui. Não existem donos conhecidos do XGH (já devem ter morrido de desgosto). Fiquei com medo de não encontrar mais essa metologia, que é pouco divulgada e muito útil.
</description>
</item>

     
        <item>
  <title>Programadores de verdade não usam Java</title>
  <link>http://www.caloni.com.br/programadores-de-verdade-nao-usam-java/</link>
  <pubDate>2009-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/programadores-de-verdade-nao-usam-java/</guid>
  <description>Quando era um newbie (e um wanna-be) gostava de ler o &amp;quot;Real Programmers Don&#39;t Use Pascal&amp;quot;, um texto humorístico que mais me influenciou e encorajou a caminho da iluminação C/C&#43;&#43; do que o livro de K&amp;amp;R. A partir dele, supunha eu, ser um &amp;quot;programador de verdade&amp;quot; era ser tudo. Ser um Quiche Eater (Comedor de Torta) não era nada. Programadores de verdade é que resolvem os problemas de verdade! Quiche Eaters são os losers que estudam os conceitos acadêmicos da ciência da computação e nunca fazem um maldito programa que preste (conhece alguém assim?).
Piadas à parte, para mim o humor do texto ainda pode ser aproveitado por aqueles que já se acham muito bons e acreditam não terem mais como crescer profissionalmente. Quando meu ego infla demais, ainda me lembro que enquanto programo com APIs de brincadeirinha e um sistema operacional que é uma piada tem gente projetando uma nave que vai sair da órbita do Sistema Solar!
Por outro lado, muitas pessoas recém-saídas da faculdade de computação ainda acham programação uma matéria difícil. Esse texto nos lembra que difícil era a vida 20, 40, 70 anos atrás, quando engenheiros e programadores eram a mesma pessoa, e quando se você não soubesse o que estava fazendo colocaria projetos de milhões em risco.
Por consequência, o programador de verdade vive no passado. E ele sempre se valoriza frente ao povão jovem, porque ele sabe resolver aquele problema de tela azul que mais ninguém sabe. E como eu costumo dizer, parafraseando uma figura ilustre da televisão brasileira, quem tem medo de abrir o Visual Studio e em vez disso fica projetando eternamente o software não vai muito longe: &amp;quot;quem sabe faz na hora!&amp;quot;.
Aqui segue um breve resumo do texto original adaptado para os tempos atuais e com a minha visão preconceituosa de pensar sobre o assunto. Se quiser, use sua parte politicamente correta da mente e critique à vontade!
Linguagens. Lembre-se: inventar que você precisa de mais linguagens/recursos para fazer seu trabalho é lembrar que você é incompetente o suficiente para inventar esse tipo de desculpinha. Você é daqueles que diz &amp;quot;cada problema tem sua ferramenta específica&amp;quot; ou algo do tipo. Ou seja, um programador politicamente correto e ineficiente. Não vê que tudo o que você precisa está na linguagem C. Se não estiver, então está no assembly. Se não estiver nem no C nem no assembly não vale a pena ser pensado a respeito.
Programação Estruturada. É o primeiro e último paradigma a ser aplicado. Afinal de contas, Orientação a Objetos é mais uma desculpinha para não programar. São abstrações e mais abstrações para inventar que, uma vez que você é um peso morto que não consegue resolver um problema com funções e variáveis, precisa de classes, herança, templates e outras tranqueiras que vão transformar seu código simples e reto em uma cornucópia mágica que só vai impressionar os outros pela inutilidade e complexidade da solução!
Estrutura de dados. Outro ótimo conceito para enganar a si mesmo. Hoje são muitos os que se escravizam nos leiautes SQL e classes estranhas de frameworks estranhos que fazem todo o trabalho. Todos sabemos que a única estrutura realmente útil de saber é o array. O resto são variantes do mesmo tema: filas e pilhas.
Sistema operacional. Mac e Windows são brinquedinhos e Linux é um vídeo-game que dá mais trabalho de configurar do que de jogar. O programador de verdade usa algo como mainframes ou qualquer outro sistema operacional beta, que são bem esquisitos de mexer e que podem fazer um verdadeiro estrago nas mãos de quem não tiver lido TODO o manual. E saber todos os bugs conhecidos e importantes do kernel e sua localização de cor na hora de bootar é vital.
Ferramentas. Se você depende de uma IDE que tem Code Completion e outros penduricalhos do tipo, ou depende de algum outro editor seu favorito com seus 17459 plugins instalados, então você não é um programador de verdade. um programador de verdade usa o que tiver à mão na hora que precisar, seja um notepad, um hexdump ou até mesmo alguns beeps. A ferramenta não é limite para quem sabe programar de verdade.
Depuração. Vai dizer que precisa do código-fonte para depurar? Então você não faz a mínima ideia do que o programa faz. Apenas algumas olhadas na call stack e nos registradores podem fazer um programador de verdade solucionar um bug que os comedores de torta não conseguiriam depois de analisar aqueles gráficos UML com caixinhas dentro e casos de uso por meses a fio.
O Trabalho de programadores de verdade com certeza não é fazer programinhas que acessam basezinhas de SQL com opção de consulta e cadastro. Nem são aqueles saitezinhos com PHP/Apache, scripts e mais scripts. Não, senhor. São programas que lidam com o Sistema Operacional de uma forma mais íntima (criptografia de HD, drivers de File System, serviços de comunicação crítica, etc), ou são programas que fazem algo de verdadeiramente útil (compiladores, o próprio sistema operacional). Ou tavez que mexam diretamente com hardware (microcontroladores complexos, robôs, naves, aparelhagem médica, etc).
A Diversão de todo programador de verdade é conversar com os amigos (sobre programação), ler alguma coisa (sobre programação) e assistir filmes inteligentes (sobre programação ou pessoas que fizeram algum tipo de desafio intelectual &amp;quot;na marra&amp;quot;). Existe algo mais divertido que isso?
E, por fim, em seu Habitat Natural, poderemos encontrar páginas de código assembly espalhadas em volta da mesa, um computador travado por uma depuração remota de kernel por cabo serial, algumas anotações em hexa em um pedaço de papel, algumas dezenas de páginas abertas no navegador sobre comportamento das funções BIOS em HDs SATA com mais de 500 GB trabalhando em RAID4, café, salgadinhos, manchas no carpete. Quando não há nada para fazer, o ambiente está arrumadíssimo e não se nota a presença de programadores de verdade à vista.
E o Futuro do programador de verdade? Bom, a linguagem C pode até estar morrendo. Mas, e daí? Essa tal de C&#43;&#43; ainda suporta ponteiros. O resto das abstrações afeminadas como classes e herança podem ser totalmente ignoradas. O básico sempre existirá. Esqueça as versões com herança múltipla e o enigmático concepts. Seja homem!
O fato é que, independente de quanto mais o mundo se tornar &amp;quot;gerenciado&amp;quot; por trás de frameworks e programadores que preferem &amp;quot;fazer projetos&amp;quot; atrás de seus pacotes de escritório e casos de uso, quando algum problema pipocar, algum bug tenebroso ameaçar a vida útil de um projeto, um programador de verdade estará lá para salvar o dia, pois só um programador de verdade sabe fazer o seu trabalho. E bem feito.
PS: Na verdade, me lembrei. Eu peguei esse cacoete de falar &amp;quot;quem sabe faz na hora&amp;quot; do meu amigo Thiago. Ele também dizia &amp;quot;se vira nos 30!&amp;quot;. Bom, se eu citar todas as frases brilhantes que ele usava quando trabalhávamos juntos o texto vai ficar bem longo =)
Se você gostou desse texto, talvez goste de eXtreme Go Horse!
</description>
</item>

     
        <item>
  <title>Estranho</title>
  <link>http://www.caloni.com.br/estranho/</link>
  <pubDate>2008-03-06</pubDate>
  
  <guid>http://www.caloni.com.br/estranho/</guid>
  <description>Bom, é hora de dizer tchau. Essa é minha última semana escovando bits na empresa onde estava por três anos. É estranho e esquisito dizer isso, mas me sinto um tanto aliviado. Nessa empreitada, porém, aprendi algumas coisas que valem a pena colocar na bagagem. Sempre é melhor entender do que criticar.
Por exemplo, vejamos a palavra estranho: quantas vezes você já pronunciou essa palavra quando estava diante de um problema daqueles esotéricos? Muitas vezes, não foi? E os problemas não-esotéricos?
Quando nos acostumamos a usar uma palavra para aliviar a dor de não entendermos o que está acontecendo diante de nós, visto pelos nossos próprios olhos, estamos nos condicionando a parar de cutucar nosso cérebro para encontrar uma resposta rápida e racional para o que está acontecendo. Em suma: nos fechamos ao mundo falando &amp;quot;estranho&amp;quot;.
Não por esse motivo, mas por estarmos cansados de tanto ouvir falar essa palavra, eu e meu amigo Thiago começamos a instituir uma &amp;quot;taxa simbólica&amp;quot; de 1 (um) real para os que proferirem a dita cuja, e passamos a usar o dinheiro arrecadado para o bem da comunidade, comprando o que nós, programadores, mais veneramos nos momentos de debugging: bolachas!
Essa &amp;quot;medida provisória&amp;quot; aos poucos foi se alastrando pelas mesas do departamento, ao ponto máximo de todos da área técnica, além do diretor comercial, colaborar para a nossa &amp;quot;caixinha de um real&amp;quot;.
Criamos um ambiente livre de estranhos. E criamos um trauma em nossas cabeças. A partir das primeiras semanas, toda vez que estávamos em algum lugar em que uma pessoa desconhecida (um estranho) dizia a palavra, soava um sino em nossas cabeças, quase fazendo com que nossa mão acusadoramente se erguesse e fizesse o gesto com o dedo indicando que a pessoa, a partir daquele momento, estava devendo um real para nossa caixinha comunitária.
E assim fomos indo, meses a fio, sem falar essa palavra na presença dos fiscais do um real, que éramos todos nós. A proibição foi linear e englobou todas as situações de vida social em que poderíamos nos expressar: no trabalho, no almoço, por mensagem instantânea, por e-mail, pelo celular, fora do trabalho, nos artigos do blogue...
Pois é, caro leitor, nos artigos do blogue. Se você procurar nestes últimos três anos qualquer menção à palavra &amp;quot;estranho&amp;quot; por aqui com certeza não irá encontrar.
Até agora, quando finalmente foi quebrado o encanto. Quer dizer, oficialmente a cobrança está extinta, mas nossas mentes sempre irão conter esse sino acusador tocando no ônibus, nas ruas, no cinema, no shopping, em casa. Enfim, nos códigos estranhos de nossa vida.
</description>
</item>

     
    
  </channel>
</rss>
