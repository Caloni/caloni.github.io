<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>learning on Blogue do Caloni</title>
    <link>http://www.caloni.com.br/tags/learning/</link>
    <description>Recent content in learning on Blogue do Caloni</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Tue, 07 Apr 2009 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.caloni.com.br/tags/learning/" rel="self" type="application/rss+xml" />
    
     
        <item>
  <title>A fila das threads</title>
  <link>http://www.caloni.com.br/a-fila-das-threads/</link>
  <pubDate>2009-04-07</pubDate>
  
  <guid>http://www.caloni.com.br/a-fila-das-threads/</guid>
  <description>&lt;p&gt;Em um ambiente multithreading diversas threads disputam &amp;quot;a tapas&amp;quot; a atenção do processador (CPU). Certo? Podemos dizer que, em um ambiente com muito processamento a realizar, de certa forma é isso que acontece. São threads e mais threads rodando um pedacinho de código cada vez que passam pelo processador.&lt;/p&gt;
&lt;p&gt;Um ambiente complexo como um sistema operacional executando dezenas (às vezes centenas) de programas é repleto de pequenos detalhes que podem fazer o iniciante logo desanimar quando tentar depurar um programa com mais de uma thread. De fato, eu já percebi que muitos não vão saber nem como começar a pensar sobre o problema.&lt;/p&gt;
&lt;p&gt;Uma forma de visualizar o cenário multithread começa na fila das threads. Elas estão indo em direção ao guichê das CPUs onde vão conseguir tempo de processamento para rodar seu código. Depois que elas esgotam seu tempo elas se dirigem para o final da fila esperando por mais tempo para executar mais código.&lt;/p&gt;
&lt;p&gt;Para simplificar este cenário vamos imaginar duas threads iniciando com o mesmo código. Esse código incrementa um contador global até ele chegar a dez, quando a função retorna e as threads terminam.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int count = 0;

increment() {
  while( count &amp;lt; 10 ) {
    count++;
    print(tid, count);
  }
}

main() {
  thread t1(increment);
  thread t2(increment);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O tid no pseudo-código acima é sinônimo para Thread ID, o identificador único de uma thread, que costuma ser um número. Para simplificar vamos dar ao id os apelidos de t1 e t2. Esta é uma possível saída do código acima, dependendo de quantos processadores e cores possui a máquina:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t1 1
t1 2
t1 3
t1 4
t1 5
t1 6
t1 7
t1 8
t1 9
t1 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pelo jeito a primeira thread não deu chance para a outra executar. Isso acontece por causa do pequeno espaço de tempo que é necessário para realizar a tarefa de incrementar uma variável. É tão pequena a tarefa que nem foi suficiente para a primeira thread ficar sem tempo e a CPU mandar ela para o fim da fila. Por isso a segunda thread nunca chegou a incrementar o contador.&lt;/p&gt;
&lt;p&gt;Quando uma thread quer realizar algum processamento, ela precisa entrar na fila das threads ativas, que aguardam pela CPU que irá atendê-las. Nessa fila ela pega uma senha e aguarda a sua vez. Só que cada vez que uma thread é atendida ela ganha um tempo limitado de atendimento, que na arquitetura do sistema operacional é chamado de quantum ou time slice. Se o quantum de uma thread estoura, ou a thread não tem mais nada pra fazer, ela sai do guichê de atendimento e volta a ficar inativa, ou volta para o final da fila, aguardando por mais processamento.&lt;/p&gt;
&lt;p&gt;Uma thread pode opcionalmente ir para o final da fila por conta própria. Para isso, basta que ela chame uma função do sistema operacional pedindo para dormir. Por isso geralmente essa função é chamada de sleep na API do sistema operacional. Nessa função costuma haver um parâmetro de quanto tempo a thread deseja dormir. Se for maior que zero ela vai para a fila de threads dormindo até passar esse tempo, para depois se dirigir à fila de threads ativas, aguardar para ser processada. Se o tempo passado for exatamente zero ela vai direto para essa última fila, mas ficará sem executar do mesmo jeito, pois esta é a fila de quem está aguardando pela sua próxima fatia de tempo de processamento.&lt;/p&gt;
&lt;p&gt;Se chamarmos a função para dormir no código da thread antes de voltar a incrementar o contador é possível que a segunda thread tenha chance de executar.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;increment() {
  while( count &amp;lt; 10 ) {
    count++;
    print(tid, count);
    sleep();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Agora cada thread, depois de incrementar uma vez o contador, volta para o final da fila. Dessa forma vemos uma thread de cada vez incrementando o mesmo contador.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t1 1
t2 2
t1 2
t2 3
t1 4
t2 4
t2 6
t2 7
t1 5
t1 8
t2 8
t2 9
t2 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Peraí, o mesmo contador? Isso pode gerar problemas. Se duas threads tentarem incrementar o mesmo contador ao mesmo tempo, quem garante que elas não irão incrementar o mesmo valor? Bom, se você é bom observador já deve ter reparado que na execução acima ocorreu exatamente isso, com mais de uma thread incrementando o contador com o mesmo valor.&lt;/p&gt;
&lt;p&gt;Para forçar isso acontecer mais rápido e de maneira mais gritante podemos fazer a thread ir para o final da fila antes de incrementarmos e após pegarmos o valor atual do contador. Note que nesses testes a saída muda completamente dependendo de quantos processadores sua máquina tem. O resultado às vezes pode ser bem bizarro do que o visto nesse artigo. &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;increment() {
  while( count &amp;lt; 10 ) {
    int c = count;
    sleep();
    c++;
    print(tid, c);
    count = c;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O código acima pode gerar a seguinte saída:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t1 1
t2 1
t1 2
t2 2
t1 3
t2 3
t1 4
t2 4
t1 5
t2 5
t2 6
t1 6
t2 7
t1 7
t1 8
t2 8
t2 9
t1 9
t2 10
t1 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Explicando mais uma vez com mais detalhes: quando uma thread guarda o valor do contador na variável local e volta para o final da fila, ela deixa de armazenar o contador atualizado para apenas &lt;strong&gt;depois&lt;/strong&gt; que todas as outras threads passarem na sua frente. Só que as outras threads também pegam o mesmo valor do contador, pois ele ainda não foi alterado. Quando chega a hora da segunda passada no guichê das CPUs, todas as threads incrementaram o mesmo valor do contador. Se houvesse apenas um processador em uma máquina o fluxo de execução do ponto de vista do processamento único para duas threads ficaria mais ou menos o seguinte (zzz é quando uma thread dorme):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t1 c = count (0)
t1 zzz
t2 c = count (0)
t2 zzz
t1 c++ (1)
t2 c++ (1)
t1 print c (1)
t2 print c (1)
t1 count = c (1)
t2 count = c (1)
t1 c = count (1)
t1 zzz
t2 c = count (1)
t2 zzz
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O exemplo acima forçou essa situação, mas é preciso lembrar que isso pode acontecer mesmo sem a thread dormir. É possível que o tempo da thread se esgote e ela pare de ser atendida justo na hora que iria salvar a variável c no contador global. Dessa forma, ela vai para o final da fila à força e, quando voltar a ser atendida, uma outra thread já terá lido o valor anterior para ela própria incrementar.&lt;/p&gt;
&lt;p&gt;O que gostaríamos que acontecesse para corrigir o problema é forçar a segunda thread a esperar antes que a primeira termine todo o processo de incrementar e salvar no contador global, o que resolveria o nosso problema (o wait no exemplo abaixo é uma thread aguardando e não fazendo nada):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t1 c = count (0)
t1 zzz
t2 wait
t1 c++ (1)
t2 wait
t1 print c (1)
t2 wait
t1 count = c (1)
t2 wait
t1 ready
t2 c = count (1)
t1 wait
t2 c++ (2)
t1 wait
t2 print c (2)
t1 wait
t2 count = c (2)
t2 ready
t1 c = count (2)
t2 wait
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Esse wait do fluxo, ou seja, deixar a próxima thread aguardando a que chegou primeiro incrementar, pode ser obtido se utilizarmos um mecanismo de acesso exclusivo fornecido pelo sistema operacional. Uma outra história para contar, que chamarei de &amp;quot;A sala da fila das threads&amp;quot;.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Eu mesmo em meus testes não pude usar sleep passando zero como o tempo para dormir porque meu número de processadores não permite que eu faça esse experimento, já que sempre vão existir processadores dispostos a reprocessar a thread que acabou de ir para o final de sua fila. &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
</item>

     
        <item>
  <title>A inteligência do if - parte 1</title>
  <link>http://www.caloni.com.br/a-inteligencia-do-if-parte-1/</link>
  <pubDate>2007-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/a-inteligencia-do-if-parte-1/</guid>
  <description>&lt;p&gt;No nível mais baixo, podemos dizer que as instruções de um computador se baseiam simplesmente em cálculos matemáticos e manipulação de memória. E entre os tipos de manipulação existe aquela que muda o endereço da próxima instrução que será executada. A essa manipulação damos o nome de salto.&lt;/p&gt;
&lt;p&gt;O salto simples e direto permite a organização do código em subrotinas. Subrotinas permitem o reaproveitamento de código com parâmetros de entrada distintos, o que economiza memória, mas computacionalmente é &amp;quot;inútil&amp;quot;, já que pode ser implementado simplesmente pela repetição das mesmas subrotinas. O que eu quero dizer é que, do ponto de vista da execução, a mesma seqüência de instruções será executada. Pense no fluxo de execução de uma rotina que chama várias vezes a mesma subrotina:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sub:
  code
  ret

routine:
  code
  call sub
  code
  call sub
  code
  call sub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ela é, na prática, equivalente à uma rotina que contém várias cópias da subrotina na memória, uma seguida da outra.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;routine:
  code
  sub:
    code
  code
  sub:
    code
  code
  sub:
    code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A grande sacada computacional não são subrotinas. O real motivo pelo qual hoje os computadores são tão úteis para os seres humanos é a invenção de um conceito chamado salto condicional. Ou seja, não é um salto certo, mas um salto que será executado caso a condição sob a qual ele está subordinado for verdadeira:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;code
if cond:
  call sub
code
if cond:
  call sub
code
if cond:
  call sub
code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Os saltos condicionais, vulgarmente conhecidos como if, permitiram às linguagens de programação possuírem construções de execução mais sofisticadas: laços, iterações e seleção de caso. Claro que no fundo todas essas construções não passam de um conjunto formado por saltos condicionais e incondicionais. Peguemos o while e seu bloco, por exemplo. A construção em uma linguagem de programação possui uma condicional seguido de um bloco de código que se repete enquanto a condicional for verdadeira:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while cond:
  code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enquanto para o programador dessa fictícia linguagem existe um controle de execução no início que determina quando o código deixará de ser executado repetidamente, para o compilador o while não passa de um salto no final do bloco para o começo de um if.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;label:
if cond:
  code
  jump label
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O for, por outro lado, possui tradicionalmente em seu início três operações: inicialização, condição e incremento. O código começa executando a inicialização e verifica a condição uma primeira vez. Após executado o bloco de código condicionado ao for, o incremento será executado, e mais uma vez a condição verificada. Caso a condição seja verdadeira novamente o bloco de código volta a executar, para no final executar o incremento e verificar a condição, e assim por diante.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for: i = 0; i &amp;lt; 10; i++
  code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Do ponto de vista do compilador, que irá transformar esta lógica em código de máquina, o for não passa de um contador que é incrementado a cada iteração com um salto incondiconal no final do bloco de código executado.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i = 0
label:
  if i &amp;lt; 10:
    code
    i++
    jump label
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;O switch-case, ou seleção, filtra um determinado valor em comparações de igualdade, a condição, em série. Quando é encontrada alguma igualdade verdadeira o código atrelado é executado e o código imediatamente seguinte ao switch é executado. Opcionalmente o bloco inteiro após uma seleção é ignorado.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;switch i:
  case 0:
    code
  case 1:
    code
  case 2:
    code
  default:
    code
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Essa lógica embutida nas linguagens de programação são convertidas pelo compilador em vários ifs seguidos e unidos por um else, o que torna a comparação exclusiva. No final de cada bloco de código existe um salto incondicional para o final da construção.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if i = 0:
  code
  jump label
elif i = 1:
  code
  jump label
elif i = 2:
  code
  jump label
else:
  code
label:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Neste artigo vimos como todas as construções de uma linguagem de programação, independente do seu nível, podem ser convertidas em um conjunto de saltos, condicionais e incondicionais. Em um próximo artigo, que chamaremos de &amp;quot;A inteligência do if - parte 2&amp;quot;, veremos como o salto condicional verdadeiramente funciona, e como pode ser implementado usando apenas operações matemáticas. Afinal, matemática básica é o bloco lógico mais básico que temos em um computador; qualquer computador.&lt;/p&gt;
</description>
</item>

     
    
  </channel>
</rss>
