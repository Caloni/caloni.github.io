<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>learning on Blogue do Caloni</title>
    <link>http://www.caloni.com.br/tags/learning/</link>
    <description>Recent content in learning on Blogue do Caloni</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Tue, 07 Apr 2009 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.caloni.com.br/tags/learning/" rel="self" type="application/rss+xml" />
    
     
        <item>
  <title>A fila das threads</title>
  <link>http://www.caloni.com.br/a-fila-das-threads/</link>
  <pubDate>2009-04-07</pubDate>
  
  <guid>http://www.caloni.com.br/a-fila-das-threads/</guid>
  <description>Em um ambiente multithreading diversas threads disputam &amp;quot;a tapas&amp;quot; a atenção do processador (CPU). Certo? Podemos dizer que, em um ambiente com muito processamento a realizar, de certa forma é isso que acontece. São threads e mais threads rodando um pedacinho de código cada vez que passam pelo processador.
Um ambiente complexo como um sistema operacional executando dezenas (às vezes centenas) de programas é repleto de pequenos detalhes que podem fazer o iniciante logo desanimar quando tentar depurar um programa com mais de uma thread.</description>
</item>

     
        <item>
  <title>A inteligência do if - parte 1</title>
  <link>http://www.caloni.com.br/a-inteligencia-do-if-parte-1/</link>
  <pubDate>2007-06-18</pubDate>
  
  <guid>http://www.caloni.com.br/a-inteligencia-do-if-parte-1/</guid>
  <description>No nível mais baixo, podemos dizer que as instruções de um computador se baseiam simplesmente em cálculos matemáticos e manipulação de memória. E entre os tipos de manipulação existe aquela que muda o endereço da próxima instrução que será executada. A essa manipulação damos o nome de salto.
O salto simples e direto permite a organização do código em subrotinas. Subrotinas permitem o reaproveitamento de código com parâmetros de entrada distintos, o que economiza memória, mas computacionalmente é &amp;quot;inútil&amp;quot;, já que pode ser implementado simplesmente pela repetição das mesmas subrotinas.</description>
</item>

     
    
  </channel>
</rss>
