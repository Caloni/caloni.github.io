<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Ponto Flutuante Afundando</title>
  <meta name="author" content="" />
  <meta name="description"
        content="Quando armazenamos valores monetários em doubles seus cálculos conseguem manter a precisão e na maioria das vezes o ajuste de precisão funciona. Porém, encontrei alguns casos onde a subtração de dois..."/>

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta itemprop="name" content="Ponto Flutuante Afundando"/>
  <meta itemprop="description"
        content="Quando armazenamos valores monetários em doubles seus cálculos conseguem manter a precisão e na maioria das vezes o ajuste de precisão funciona. Porém, encontrei alguns casos onde a subtração de dois..."/>
  <meta itemprop="image"
        content=""/>

  
  <meta property="og:title" content="Ponto Flutuante Afundando"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/ponto-flutuante-afundando/"/>
  <meta property="og:image"
        content=""/>
  <meta property="og:description"
        content="Quando armazenamos valores monetários em doubles seus cálculos conseguem manter a precisão e na maioria das vezes o ajuste de precisão funciona. Porém, encontrei alguns casos onde a subtração de dois..."/>
  <meta property="og:site_name" content="Blogue do Caloni"/>
  <meta property="article:published_time"
        content="2013-11-07T00:00:00&#43;00:00"/>
  <meta property="article:section" content="posts"/>

  
  
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site"
        content=""/>
  <meta name="twitter:title" content="Ponto Flutuante Afundando"/>
  <meta name="twitter:description"
        content="Quando armazenamos valores monetários em doubles seus cálculos conseguem manter a precisão e na maioria das vezes o ajuste de precisão funciona. Porém, encontrei alguns casos onde a subtração de dois..."/>
  <meta name="twitter:creator"
        content=""/>
  <meta name="twitter:image:src"
        content="
                     /images/movies.png
                   "/>

  
  <link href="" rel="alternate" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">
  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/brand.svg">
        <div class="title is-6">&nbsp;Blogue do Caloni</div>
      </a>

      
      <label class="button navbar-burger is-white" for="navbar-burger-state">
        <span></span>                               
        <span></span>
        <span></span>
      </label>
    </div>

    
    <input type="checkbox" id="navbar-burger-state"/>

    <div class="navbar-menu">
      <div class="navbar-end" style="padding: 10px;">
      <big><b>
       <a title="posts dessa categoria" href="/categories/blog">blog</a>  <a title="posts dessa categoria" href="/categories/cinema">cinema</a>  <a title="posts dessa categoria" href="/categories/code">code</a> 
      </big></b>
      </div>
    </div>

  </div>
</nav>


      
      <div class="container">
        <p class="title">Ponto Flutuante Afundando</p>

        <p class="subtitle">

    <a style="text-decoration: underline;" href="https://github.com/Caloni/blog/blob/master/content/post/ponto-flutuante-afundando.md" title="source">
    2013-11-07
    </a>

</p>

        <div class="taglist">
            <i>Este ainda é um rascunho publicado prematuramente e está sujeito a mudanças substanciais.</i>

        </div>

        

        
          <div class="content">
            
              <p>Quando armazenamos valores monetários em doubles seus cálculos conseguem manter a precisão e na maioria das vezes o ajuste de precisão funciona. Porém, encontrei alguns casos onde a subtração de dois valores fazia &ldquo;perder&rdquo; um centavo (ou comparações exatas) justamente pela limitação da precisão do ponto flutuante. Nesse exemplo os valores são 2.358,93 - 1.386,93, que em uma conta de padaria (mas correta) dá 972,00 (até a Calc do Windows e o Excel funcionam), mas pelo Visual Studio 2010 chega perto, mas erra o alvo:</p>
<p>Isso ocorre porque sua representação dentro da variável double é diferente de 272.0 do outro double. Depurando vemos mais claramente:</p>
<p>Ou seja, quando fazemos a subtração de d2 em d1, nossa precisão raspa um pouquinho e escapa pela beirada:</p>
<p>Na comparação com o valor redondo aparece a falha, mas note que isso não ocorre com os outros valores d1 e d2, já que o armazenamento adquire o mesmo formato:</p>
<p>Há uma forma de arredondamento já disponível no C99 (mas não no Visual Studio 2010) que pode ser útil para esses casos. A única coisa que é preciso fazer é arredondar os valores antes do cálculo:</p>
<p>É uma decisão arbitrária essa de arredondar para cima, mas se for adotada em todo o sistema (e já fazendo parte de um padrão, no caso, o C99), não deverão existir problemas de interpretação de cálculos entre os componentes.</p>
<p>O mercado financeiro agradece =).</p>
<p>UPDATE: Não estou de acordo com o armazenamento de valores monetários em doubles em vez de inteiros pelo simples motivo que não há moedas no sistema financeiro com unidades que se dividem ad infinitum. Por consequência, existe sempre uma unidade básica e indivisível (que no caso do Brasil é o centavo de real). Ou seja, como o objetivo é contar o total dessas unidades que não se dividem, o uso de inteiros é brainless.</p>
<p>UPDATE: Existe uma discussão exatamente sobre isso no Grupo C/C++ Brasil, que recomendo a leitura, o que me levou a escrever o post. Particularmente, sigo o raciocínio do Pedro Lamarão.</p>

            

          </div>

        <div class="taglist">
            
    
      <a href="/categories/code">code</a> 
      <a href="/tags/draft">draft</a> 
    


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/elvira-a-rainha-das-trevas/">Elvira A Rainha das Trevas<span class="icon"><i class="fa fa-arrow-right"></i></span></a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/a-morte-lhe-cai-bem/"><span class="icon"><i class="fa fa-arrow-left"></i></span>A Morte lhe Cai Bem</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
