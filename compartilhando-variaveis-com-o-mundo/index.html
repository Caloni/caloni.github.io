<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Compartilhando variáveis com o mundo</title>
  <meta name="author" content="" />
  <meta name="description"
        content="Desde que comecei a programar, para compartilhar variáveis entre processo é meio que consenso usar-se a milenar técnica do crie uma seção compartilhada no seu executável/DLL. Isso funciona desde a..."/>

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta itemprop="name" content="Compartilhando variáveis com o mundo"/>
  <meta itemprop="description"
        content="Desde que comecei a programar, para compartilhar variáveis entre processo é meio que consenso usar-se a milenar técnica do crie uma seção compartilhada no seu executável/DLL. Isso funciona desde a..."/>
  <meta itemprop="image"
        content=""/>

  
  <meta property="og:title" content="Compartilhando variáveis com o mundo"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/compartilhando-variaveis-com-o-mundo/"/>
  <meta property="og:image"
        content=""/>
  <meta property="og:description"
        content="Desde que comecei a programar, para compartilhar variáveis entre processo é meio que consenso usar-se a milenar técnica do crie uma seção compartilhada no seu executável/DLL. Isso funciona desde a..."/>
  <meta property="og:site_name" content="Blogue do Caloni"/>
  <meta property="article:published_time"
        content="2008-01-30T00:00:00&#43;00:00"/>
  <meta property="article:section" content="post"/>

  
  
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site"
        content=""/>
  <meta name="twitter:title" content="Compartilhando variáveis com o mundo"/>
  <meta name="twitter:description"
        content="Desde que comecei a programar, para compartilhar variáveis entre processo é meio que consenso usar-se a milenar técnica do crie uma seção compartilhada no seu executável/DLL. Isso funciona desde a..."/>
  <meta name="twitter:creator"
        content=""/>
  <meta name="twitter:image:src"
        content="
                     /images/movies.png
                   "/>

  
  <link href="" rel="alternate" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">
  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/brand.svg">
        <div class="title is-6">&nbsp;Blogue do Caloni</div>
      </a>

      
      <label class="button navbar-burger is-white" for="navbar-burger-state">
        <span></span>                               
        <span></span>
        <span></span>
      </label>
    </div>

    
    <input type="checkbox" id="navbar-burger-state"/>

    <div class="navbar-menu">
      <div class="navbar-end" style="padding: 10px;">
      <big><b>
       <a title="posts dessa categoria" href="/categories/blog">blog</a>  <a title="posts dessa categoria" href="/categories/cinema">cinema</a>  <a title="posts dessa categoria" href="/categories/code">code</a> 
       <a href="/caloni"><span class="icon"><i class="fa fa-user"></i></a> <a href="index.xml"><span class="icon"><i class="fa fa-rss"></i></a>
      </big></b>
      </div>
    </div>

  </div>
</nav>


      
      <div class="container">
        <p class="title">Compartilhando variáveis com o mundo</p>

        <p class="subtitle">
<i>

    <a href="https://github.com/Caloni/post/commits/master/compartilhando-variaveis-com-o-mundo.md" title="History">
    2008-01-30
    </a>

<span class="icon"><i class="fa fa-clock-o"></span></i>5 </i>
 <span class="icon"><i class="fa fa-pencil"></i></span><a href="https://github.com/Caloni/post/blob/master/compartilhando-variaveis-com-o-mundo.md" title="GitHub">876</a>
</p>

        <div class="taglist">
            <i>Este ainda é um rascunho publicado prematuramente e está sujeito a mudanças substanciais.</i>

        </div>

        

        
          <div class="content">
            
              <p>Desde que comecei a programar, para compartilhar variáveis entre processo é meio que consenso usar-se a milenar técnica do crie uma seção compartilhada no seu executável/DLL. Isso funciona desde a época em que o Windows era em preto e branco. Mas, como tudo em programação, existem mil maneiras de assar o pato. Esse artigo explica uma delas, a não-tão-milenar técnica do use memória mapeada nomeada misturada com templates.</p>
<p>Era comum (talvez ainda seja) fazer um código assim:</p>
<pre><code>// aqui definimos uma nova seção (note o 'shared' usado como atributo)
#pragma section(&quot;shared&quot;, read, write, shared)

// um conjunto de variáveis agrupadas para facilitar o compartilhamento
struct EstruturaDoCoracao
{
    int meuIntPreferido;
    char meuCharAmigo;
    double meuNumeroDePontoFlutuanteCamarada;
};

// uma instância da struct acima para podermos usar nos processo amigos
__declspec(allocate(&quot;shared&quot;)) EstruturaDoCoracao g_coracao;

int main()
{
    g_coracao.meuCharAmigo = 'C';
    g_coracao.meuIntPreferido = 42;
    g_coracao.meuNumeroDePontoFlutuanteCamarada = 3.14159265358979323846264338;
} 
</code></pre>
<p>Aquele pragma do começo garante que qualquer instância do mesmo executável, mas processos distintos, irão compartilhar qualquer variável definida dentro da seção &ldquo;shared&rdquo;. O nome na verdade não importa muito - é apenas usado para clareza - , mas o atributo do final, sim.</p>
<p>Algumas desvantagens dessa técnica são:</p>
<ul>
<li>
<p>Não permite compartilhamento entre executáveis diferentes, salvo se tratar-se de uma DLL carregada por ambos.</p>
</li>
<li>
<p>É um compartilhamento estático, que permanece do início do primeiro processo ao fim do último.</p>
</li>
<li>
<p>Não possui proteção, ou seja, se for uma DLL, qualquer executável que a carregar tem acesso à área de memória.</p>
</li>
</ul>
<p>Muitas vezes essa abordagem é suficiente, como em hooks globais, que precisam apenas de uma ou duas variáveis compartilhadas. Também pode ser útil como contador de instâncias, do mesmo jeito que usamos as variáveis estáticas de uma classe em C++ (vide sharedptr do boost, ou a CString do ATL, que usa o mesmo princípio).</p>
<p>Houve uma vez em que tive que fazer hooks direcionados a threads específicas no sistema, onde eu não sabia nem qual o processo host nem quantos hooks seriam feitos. Essa é uma situação onde fica muito difícil usar a técnica milenar.</p>
<p>Foi daí que eu fiz um conjunto de funções alfa-beta de compartilhamento de variáveis baseado em template e memória mapeada:</p>
<pre><code>#pragma once
#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;

/** Aloca uma variável em memória mapeada, permitindo a qualquer processo
com direitos enxergá-la e alterá-la.
*/

template&lt;typename T&gt;
HANDLE AllocSharedVariable(T** pVar, PCTSTR varName)
{
    DWORD varSize = sizeof(T);
    HANDLE ret = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
        0, varSize, varName);

    if( ret )
    {
        *pVar = (T*) MapViewOfFile(ret, FILE_MAP_ALL_ACCESS, 0, 0, 0);

        if( ! *pVar )
        {
            DWORD err = GetLastError();
            CloseHandle(ret);
            SetLastError(err);
        }
    }
    else
        *pVar = NULL;

    return ret;
}

/** Abre uma variável que foi criada em memória mapeada, permitindo ao
processo atual enxergar e alterar uma variável criada por outro processo.
*/
template&lt;typename T&gt;
HANDLE OpenSharedVariable(T** pVar, PCTSTR varName)
{
    DWORD varSize = sizeof(T);
    HANDLE ret = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, varName);

    if( ret )
    {
        *pVar = (T*) MapViewOfFile(ret, FILE_MAP_READ | FILE_MAP_WRITE, 0, 0, varSize);

        if( ! *pVar )
        {
        DWORD err = GetLastError();
        CloseHandle(ret);
        ret = NULL;
        SetLastError(err);
        }
    }
    else
        *pVar = NULL;

    return ret;
}

/** Libera visualização de uma variável em memória mapeada. Quando o último processo
liberar a última visualização, a variável é eliminada da memória.
*/
template&lt;typename T&gt;
VOID FreeSharedVariable(HANDLE varH, T* pVar)
{
    if( pVar )
        UnmapViewOfFile(pVar);
    if( varH )
        CloseHandle(varH);
} 
</code></pre>
<p>Como pode-se ver, o seu funcionamento é muito simples: uma função-template que recebe uma referência para um ponteiro de ponteiro do tipo da variável desejada, o seu nome global e retorna uma variável alocada na memória de cachê do sistema. Como contraparte existe uma função que abre essa memória baseada em seu nome e faz o cast (coversão de tipo) necessário. Ambas as chamadas devem chamar uma terceira função para liberar o recurso.</p>
<p>O segredo para entender mais detalhes dessa técnica é pesquisar as funções envolvidas: CreateFileMapping, OpenFileMapping, MapViewOfFile e UnmapViewOfFile. Bem, o CloseHandle também ;)</p>
<p>Ah, é mesmo! Fiz especialmente para o artigo:</p>
<pre><code>#define _CRT_SECURE_NO_DEPRECATE
#include &quot;ShareVar.h&quot;
#include &lt;windows.h&gt;
#include &lt;tchar.h&gt;

#include &lt;stdio.h&gt;

#define SHARED_VAR &quot;FraseSecreta&quot;

/** Exemplo de como usar as funções de alocação de memória compartilhada
AllocSharedVariable, OpenSharedVariable e FreeSharedVariable.
*/
int _tmain(int argc, PTSTR argv[])
{
    // passou algum parâmetro: lê a variável compartilhada e exibe

    if( argc &gt; 1 )
    {
        system(&quot;pause&quot;);

        TCHAR (*sharedVar)[100] = 0; // ponteiro para array de 100 TCHARs
        HANDLE varH = AllocSharedVariable(&amp;sharedVar, _T(SHARED_VAR));

        if( varH &amp;&amp; sharedVar )
        {
            _tprintf(_T(&quot;Frase secreta: '%s'n&quot;), *sharedVar);
            _tprintf(_T(&quot;Pressione &lt;enter&gt; para retornar...&quot;));
            getchar();
        }
    }
    else // não passou parâmetro: escreve na variável 
    // compartilhada e chama nova instância
    {
        TCHAR (*sharedVar)[100] = 0; // ponteiro para array de 100 TCHARs
        HANDLE varH = AllocSharedVariable(&amp;sharedVar, _T(SHARED_VAR));

        if( varH &amp;&amp; sharedVar )
        {
            PTSTR cmd = new TCHAR[ _tcslen(argv[0]) + 10 ];
            _tcscpy(cmd, _T(&quot;\&quot;&quot;));
            _tcscat(cmd, argv[0]);
            _tcscat(cmd, _T(&quot;\&quot; 2&quot;));

            _tcscpy(*sharedVar, _T(&quot;Tuintuintuclaim&quot;));
            _tsystem(cmd);

            delete [] cmd;
        }
    }

    return 0;
} 
</code></pre>
<p>Preciso lembrar que essa é uma versão inicial ainda, mas que pode muito bem ser melhorada. Duas idéias interessantes são: parametrizar a proteção da variável (através do SECURITYATTRIBUTES) e transformá-la em classe. Uma classe parece ser uma idéia bem popular. Afinal, tem tanta gente que só se consegue programar se o código estiver dentro de uma.</p>
<ul>
<li>
<p>MSDN Library - by Microsoft</p>
</li>
<li>
<p>Code Project - by Developers</p>
</li>
<li>
<p>Google - by Google</p>
</li>
</ul>

            

          </div>

        <div class="taglist">
            
    
    
      <a href="/categories/code">code</a> 
      <a href="/tags/draft">draft</a> 
    
    <a href="https://twitter.com/intent/tweet?text=Desde%20que%20comecei%20a%20programar%2c%20para%20compartilhar%20vari%c3%a1veis%20entre%20processo%20%c3%a9%20meio%20que%20consenso%20usar-se%20a%20milenar%20t%c3%a9cnica...%20http%3a%2f%2fwww.caloni.com.br%2fcompartilhando-variaveis-com-o-mundo%2f from @caloni " style="text-decoration: underline;" title="Twitter">twitter</big></a>


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/compartilhando-variaveis-com-o-mundo-v2/">Compartilhando variáveis com o mundo v2<span class="icon"><i class="fa fa-arrow-right"></i></span></a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/rmthread-rode-codigo-em-processo-vizinho/"><span class="icon"><i class="fa fa-arrow-left"></i></span>RmThread: rode código em processo vizinho</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
