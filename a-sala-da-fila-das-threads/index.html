<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - A sala da fila das threads</title>
  <meta name="author" content="" />
  <meta name="description"
        content="Quando falei sobre a fila das threads, e como cada thread espera pacientemente em uma fila até chegar sua vez de ser atendida no guichê das CPUs, também vimos como é fácil fazer caquinhas em um..."/>

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta itemprop="name" content="A sala da fila das threads"/>
  <meta itemprop="description"
        content="Quando falei sobre a fila das threads, e como cada thread espera pacientemente em uma fila até chegar sua vez de ser atendida no guichê das CPUs, também vimos como é fácil fazer caquinhas em um..."/>
  <meta itemprop="image"
        content=""/>

  
  <meta property="og:title" content="A sala da fila das threads"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/a-sala-da-fila-das-threads/"/>
  <meta property="og:image"
        content=""/>
  <meta property="og:description"
        content="Quando falei sobre a fila das threads, e como cada thread espera pacientemente em uma fila até chegar sua vez de ser atendida no guichê das CPUs, também vimos como é fácil fazer caquinhas em um..."/>
  <meta property="og:site_name" content="Blogue do Caloni"/>
  <meta property="article:published_time"
        content="2009-04-17T00:00:00&#43;00:00"/>
  <meta property="article:section" content="post"/>

  
  
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site"
        content=""/>
  <meta name="twitter:title" content="A sala da fila das threads"/>
  <meta name="twitter:description"
        content="Quando falei sobre a fila das threads, e como cada thread espera pacientemente em uma fila até chegar sua vez de ser atendida no guichê das CPUs, também vimos como é fácil fazer caquinhas em um..."/>
  <meta name="twitter:creator"
        content=""/>
  <meta name="twitter:image:src"
        content="
                     /images/movies.png
                   "/>

  
  <link href="" rel="alternate" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">
  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/brand.svg">
        <div class="title is-6">&nbsp;Blogue do Caloni</div>
      </a>

      
      <label class="button navbar-burger is-white" for="navbar-burger-state">
        <span></span>                               
        <span></span>
        <span></span>
      </label>
    </div>

    
    <input type="checkbox" id="navbar-burger-state"/>

    <div class="navbar-menu">
      <div class="navbar-end" style="padding: 10px;">
      <big><b>
       <a title="posts dessa categoria" href="/categories/blog">blog</a>  <a title="posts dessa categoria" href="/categories/cinema">cinema</a>  <a title="posts dessa categoria" href="/categories/code">code</a> 
       <a href="/caloni"><span class="icon"><i class="fa fa-user"></i></a> <a href="index.xml"><span class="icon"><i class="fa fa-rss"></i></a>
      </big></b>
      </div>
    </div>

  </div>
</nav>


      
      <div class="container">
        <p class="title">A sala da fila das threads</p>

        <p class="subtitle">
<i>

    <a href="https://github.com/Caloni/post/commits/master/a-sala-da-fila-das-threads.md" title="History">
    2009-04-17
    </a>

<span class="icon"><i class="fa fa-clock-o"></span></i>4 </i>
 <span class="icon"><i class="fa fa-pencil"></i></span><a href="https://github.com/Caloni/post/blob/master/a-sala-da-fila-das-threads.md" title="GitHub">710</a>
</p>

        <div class="taglist">
            <i>Este ainda é um rascunho publicado prematuramente e está sujeito a mudanças substanciais.</i>

        </div>

        

        
          <div class="content">
            
              <p>Quando falei sobre a fila das threads, e como cada thread espera pacientemente em uma fila até chegar sua vez de ser atendida no guichê das CPUs, também vimos como é fácil fazer caquinhas em um programa que roda paralelamente duas threads ou mais.</p>
<p>Também falei que iríamos resolver esse problema, afinal de contas, temos que salvar todos aqueles programas que usam dezenas de threads trabalhando ao mesmo tempo para contar números de um até dez.</p>
<p>A boa notícia é que o salvamento é mais simples do que parece: coloque todas as suas threads em uma sala trancada e deixe apenas uma chave. As threads terão que brigar para sair da sala e, depois que a vencedora sair, as outras terão que ficar esperando ela voltar.</p>
<p>Confuso? Se estiver, ainda bem. Isso quer dizer que estamos novamente em um daqueles artigos com &ldquo;pseudo-parábolas&rdquo;, a maneira mais ilustrada de explicar as coisas.</p>
<p>Os SOs modernos possuem inúmeras maneiras de controlar e monitorar o acesso a recursos do sistema. Neste breve artigo irei falar apenas de um: o critical section, ou, em tradução livre, &ldquo;seção crítica&rdquo;. O &ldquo;seção&rdquo; desse nome diz respeito a uma seção do programa, ou seja, um pedaço de código mesmo. Um pedaço de código crítico.</p>
<p>Resumidamente, um critical section é um recurso que apenas uma thread por vez pode obter. Para que outra thread tenha acesso ao mesmo critical section, a primeira thread que o obteve deve soltá-lo. Enquanto ela não solta, as outras threads ficam paradas, esperando pela chave, na sala trancada.</p>
<p>Do ponto de vista do programador, o critical secton é apenas uma estrutura que é usada na chamada de quatro funções básicas: para inicializar o recurso, para entrar na seção crítica.aspx), para sair da seção crítica.aspx) e para liberar o recurso.aspx) (quando aquele critical section não mais será usado).</p>
<p>Falando assim, parece simples. Bom, na verdade é simples, mesmo. Tudo que você precisa para corrigir o programa do artigo anterior é criar um critical section e fazer com que as threads obtenham-no antes de mexer com o contador compartilhado.</p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
 
#define MAX_GLOBAL_COUNTER 10
 
int g_globalCounter = 0;
CRITICAL_SECTION g_globalCounterCS;
 
DWORD WINAPI IncrementGlobalCounter(PVOID)
{
    DWORD tid = GetCurrentThreadId();
 
    while( g_globalCounter &lt; MAX_GLOBAL_COUNTER )
    {
        // esse é o começo de nossa seção crítica
        // só uma thread entra por vez por aqui
        EnterCriticalSection(&amp;g_globalCounterCS);

        int temp = g_globalCounter;
        temp = temp + 1;
        Sleep(0); // vou para o final da fila antes de contar
        g_globalCounter = temp;

        // esse é o fim de nossa seção crítica
        // a partir dessa chamada outra thread pode entrar pelo começo
        LeaveCriticalSection(&amp;g_globalCounterCS);

        printf(&quot;Counter: %d\t\tThread: %d\n&quot;, temp, tid);
    }
    return 0;
}
 
int main()
{
    HANDLE threads[3];
    DWORD tids[3];

    // precisamos inicializar nosso recurso de seção crítica	
    InitializeCriticalSection(&amp;g_globalCounterCS);

    for( int i = 0; i &lt; 3; ++i )
    {
        threads[i] = CreateThread(NULL, 0, IncrementGlobalCounter, 0, 0, &amp;tids[i]);
        printf(&quot;Thread %i: %d\n&quot;, i, tids[i]);
    }
 
    WaitForMultipleObjects(3, threads, TRUE, INFINITE);

    // precisamos liberar o recurso de seção crítica
    DeleteCriticalSection(&amp;g_globalCounterCS);
}
</code></pre>
<p>Para finalizar, algo para pensar: se uma thread só consegue um critical section depois que outra thread soltá-lo, o que acontece se essa outra thread estiver esperando por outro critical section que uma thread que aguarda estiver segurando?</p>
<p>Acabamos de ilustrar um procedimento muito simples para cagar completamente no código e gerar um travamento que pode demorar de horas a semanas para ser detectado e resolvido. É o conhecido deadlock. Se você não entendeu ainda, imagine que, para voltar à sala das threads, a primeira thread que saiu precisa de duas chaves; só que ela só pegou a primeira, e a segunda está dentro da sala. Para pegar a segunda chave, ela precisa entrar na sala, só que a sala está trancada pelas duas chaves!</p>
<p>Deadlocks são sempre indesejáveis, e é por isso que existem diversas técnicas para tentar evitá-los. A mais conhecida é sempre obter os critical sections na mesma ordem. Dessa forma a obtenção de recursos é hierarquizada, o que impede que dois CSs estejam no mesmo nível de obtenção, evitando que duas threads distintas os obtenham.</p>
<p>Espero que tenha ficado claro nossa breve explanação de como podemos controlar programas multithreading. Espero, pois a próxima tarefa é entender outros conceitos mais abstratos e virtuais, como funções virtuais e classes abstratas.</p>

            

          </div>

        <div class="taglist">
            
    
      [<a href="/categories/code">code</a>] 
      [<a href="/tags/draft">draft</a>] 
    
    <a href="https://twitter.com/intent/tweet?text=Quando%20falei%20sobre%20a%20fila%20das%20threads%2c%20e%20como%20cada%20thread%20espera%20pacientemente%20em%20uma%20fila%20at%c3%a9%20chegar%20sua%20vez%20de%20ser...%20http%3a%2f%2fwww.caloni.com.br%2fa-sala-da-fila-das-threads%2f from @caloni " style="text-decoration: underline;" title="Twitter">twitter</big></a>


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/ultimas-pesquisas-na-blogosfera-nacional/">Últimas pesquisas na blogosfera nacional<span class="icon"><i class="fa fa-arrow-right"></i></span></a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/deixe-o-programador-programar/"><span class="icon"><i class="fa fa-arrow-left"></i></span>Deixe o programador programar</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
