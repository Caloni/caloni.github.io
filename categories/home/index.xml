<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>home on Blogue do Caloni</title>
    <link>http://www.caloni.com.br/categories/home/</link>
    <description>Recent content in home on Blogue do Caloni</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pt-br</language>
    <lastBuildDate>Wed, 19 Aug 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.caloni.com.br/categories/home/" rel="self" type="application/rss+xml" />
    
     
        <item>
  <title>Community</title>
  <link>http://www.caloni.com.br/community/</link>
  <pubDate>2020-08-19</pubDate>
  
  <guid>http://www.caloni.com.br/community/</guid>
  <description>Não sei se gosto de Community tanto quanto a primeira vez, uns dez anos atrás. Um de nós três deve ter envelhecido, e não de uma maneira boa: eu, a série ou a sociedade.
As brincadeiras da série em torno do politicamente correto giram confortavelmente no limite do aceitável. E, no pior dos casos, sempre temos Pierce, o velho incorrigível, para fazer os comentários racistas e homofóbicos. Porém, se quando lançada, a série usava esses termos quase como jargões fora do mainstream, gerando um certo ar de estranheza para quem mora fora dos EUA, hoje nosso comportamento, ou ao menos o da sociedade americana, é pautado nesses conceitos. O Grande Irmão está firme e forte por lá. Até nas faculdades há folhetos que correm entre as mãos sobre conceitos como &amp;quot;microagressōes&amp;quot;, e um professor recentemente foi demitido por fazer uma brincadeira sobre esse material. A liberdade de expressão tão elogiada nos EUA é cerceada inconscientemente nessa geração, como se julgamentos verbais fossem um ataque à propriedade privada.
Community não pertence a nada disso. É uma comédia leve e que se diz inteligente por ter um roteiro tão dinâmico e tão metalinguagem. Quando você usa metalinguagem você só pode ser uma pessoa inteligente, certo? A primeira temporada tem bons e maus episódios como qualquer série, mas os bons são muito bons e os maus são apenas experimentação. Experimentar com o humor é delicado, mais ainda que dramas, e eis a força de uma série que se reinventa a cada minuto. Comparada a fórmulas de sitcoms como Friends chega a ser ofensiva, e mesmo séries que confiam no carisma de sua proposta, como High School Musical, apenas confiam nessa premissa inicial e todo o resto segue no piloto automático.
Community não. Seus personagens são bons para os diálogos que possuem, mas são particularmente ótimos por causa do seu elenco e das consequência da atuação empenhada de cada um de seus membros. Eles não estão trabalhando como atores que precisam pagar boletos. Este não é um clima leve como The Big Bang Theory. Eles estão construindo comédia aqui. É pesado, é dramático. Cada rápida expressão inesperada, que oscila entre os extremos Abed e Annie, é uma gota de suor que cai de um projeto ambicioso que explora até quando podemos fazer humor sem se preocupar em ofender alguém, mas em entender por que existe a ofensa quando o mundo pode ser um lugar tão bom a ponto de existir comédias como essa.
A série na primeira temporada se revela numa crescente ingênua e ambiciosa. A direção é fresca e cheia de novidades que acabam esgotando suas ideias e partindo para o verdadeiro herói da história: Abed e seu um milhão de olhos, ou lentes, que observa as décadas passadas na TV e no cinema e nos apresenta em versões de vinte minutos, com qualidade invejável, cores chamativas, sensuais e divertidas. Community nunca irá envelhecer, pois é incapaz de se levar a sério. E por isso mesmo é a série de humor mais íntegra, completa e versátil de todas.
Porém, olhando para as últimas temporadas, quando seu elenco vai se despedindo aos poucos, é possível perceber por que aquelas sete pessoas conseguiam fazer comédia tão bem, e por que simplesmente trocar personagens não funciona com todos os roteiros, diferente do elenco original. Ao mesmo tempo revela o cansaço dos nossos tempos, o peso do politicamente correto, incrustrado na sociedade desde o início do século. A última temporada de Community é uma alfinetada metalinguística profunda demais para ser percebida, mas está lá, para quem quiser analisar.
Pegue o episódio Analysis of Cork-Based Networking como exemplo, na quinta temporada. A espiral de corrupção encontra o protecionismo norte-americano, onde na Califórnia se chega ao cúmulo de haver um alvará para arrumador de flores. A persona de Jonathan Banks se encaixa perfeitamente no papel que ele e Alison Brie protagonizam de lutar para tirar a lama das engrenagens do sistema, mas falta aquela faísca que apenas o timing de Chevy Chase, mesmo sem muitos diálogos, conseguia nos brindar. A mesma faísca falta na participação de Abed, de volta com seu par romântico interpretado por uma irreconhecível Brie Larson (Capitã Marvel). O roteiro é esperto, mas nos faz lembrar o que um casting e direção inspirados não fazem juntos. Este é o último episódio antes da paralisação para as olimpíadas de inverno.
Já em toda sexta e última temporada, qualquer episódio servindo como exemplo, o péssimo casting de Paget Brewster e Keith David estragam qualquer possibilidade da química que antes era inerente na série funcionar. Enquanto Brewster luta para conseguir um pingo de simpatia em sua irrelevância, a função de Keith David é nos fazer sentir falta do que é um ator de comédia em seu ápice como Chevy Chase, um ator para quem se pode entregar qualquer fala para torná-la hilária. Não pela fala em si, mas por tudo o que a persona de Chase investe em seu personagem.
Note como o tema do racismo, tão frequente no início, sequer é colocado em pauta agora. Vira uma piada leve de vez em quando. Não porque as pessoas não falem mais sobre isso lá fora, mas justamente porque essa discussão virou tão mainstream que existe uma cartilha das maneiras corretas de se abordar o tema. Ou seja, se tornou um assunto completamente inútil para se trabalhar uma comédia, que brilha justamente em trazer à tona situações absurdas que ocorrem quando tentamos nos proteger de qualquer coisa do mundo adulto.
Community era uma aula de como crescer em comunidade mesmo sem ter a mínima noção de como fazer isso. Independente dos fracassos em série na vida desses personagens, o mais importante era trazer a noção de que todo mundo consegue falar e agir sobre algo difícil. Community era um plano de ação. Agora foi podado pela polícia do pensamento. Um triste fim que serve como metalinguagem para o que se vive em nossos tempos.
</description>
</item>

     
        <item>
  <title>O Bug Mais Bizarro que já Resolvi</title>
  <link>http://www.caloni.com.br/o-bug-mais-bizarro-que-ja-resolvi/</link>
  <pubDate>2020-05-10</pubDate>
  
  <guid>http://www.caloni.com.br/o-bug-mais-bizarro-que-ja-resolvi/</guid>
  <description>Máquina IBM velha e empoeirada. Criptografia blowfish. Assembly 16 bits. Programa residente. E nenhum depurador funcionando. Tudo o que eu tinha se resumia em dois itens de inventário: o conhecimento, adquirido aos poucos do sistema, e minha imaginação. Era uma amena semana de abril em 2008 isolado em uma sala. Tudo que havia em volta eram papéis com anotações feitas. Observava uma nova pista todo dia, embora sem ter muita certeza. Àquela altura qualquer coisa serviria.
Do outro lado da sala, uma estagiária recém-chegada na empresa observava de longe, talvez com uma certa curiosidade, ou medo, daquele rapaz ligar e desligar um desktop empoeirado enquanto a cada aperto do botão de ligar ele olhava fixamente para a tela por uma ou às vezes duas horas seguidas. Ficava a manhã inteira observando um único boot em câmera lenta. A câmera mais lenta possível, dessas que capturam o bater de asas de um beija-flor. Cada movimentação de um registrador demorava vários minutos de reflexão.
Toda essa odisseia começou com o cara do suporte, um sujeito bonachão que atraía os bugs mais bizarros para nossos sistemas só de olhar para eles. Não eram os piores bugs, mas com certeza os mais bizarros. E quando digo bizarro estou falando de bugs que não dá para imaginar acontecendo na vida real. Quando esse sujeito aparecia junto surgiam bugs na própria Matrix; um gato preto passa duas vezes seguidas pela porta, mas não caminhando: flutuando próximo do teto.
O sujeito chegou na sala de desenvolvimento falando dessa máquina que tinha acabado de chegar do cliente. Haviam instalado a criptografia de disco. Os dados não estavam perdidos, pois o Windows ainda mostrava o seu logo esvoaçante segundos depois de ligarmos o velho desktop de guerra, que já havia vivido pelo menos duas décadas a vida de escritório e não seria agora que deixaria seus dados sumirem sem mais nem menos. Nada disso. O problema era que se você desligasse e ligasse de novo, nada mais aparecia. Tela preta. Sem logo esvoaçante ou cursor piscando. O disco rígido não se mexia. Era um mistério completo.
Mas o bizarro mesmo não era isso, mas o que vinha depois. Você desligava a pobre máquina, novamente. Apertava o botão de ligar. E como uma mulher nos seus trinta ainda não vividos, ela subia com tudo no lugar: logo do Windows, barulhinho irritante da sua tela de boas vindas e as agulhas do disco magnético piscando freneticamente. Tudo certo mais uma vez na terra do Tio Bill. Era possível logar na máquina e usá-la o resto do dia com todos os dados criptografados íntegros.
Agora, sim, o bug está completamente descrito: nos boots ímpares a máquina não bootava. Nos boots pares não havia nada de errado (ou vice-versa). Antes que você comece a confabular o que poderia ser, um cacoete que todos nós, programadores, costumamos ter, já aviso que nesse bug não há relação com energia ou memória RAM. Você podia desligar a máquina e tirar da tomada. Ir tomar um café. Uma hora depois coloca a tomada de novo e a liga. A bendita não funciona. Tire a tomada novamente. Mais um café. Desenergizada novamente, botão de ligar. E tudo estava certinho.
A criptografia desse sistema operava em dois níveis, necessários naquela época. O PC é uma monstruosidade construída em camadas legadas, uma em cima da outra. Abaixo de tudo existe a BIOS que controla todo mundo. Até um certo ponto, pelo menos. O que importa é que nesse primeiro momento do boot não existe sistema operacional. Não existe a querida proteção de memória que os SOs implementam (com a ajuda da arquitetura) para isolar os programas, onde qualquer violação de memória é tratada graciosamente com uma mensagem de erro. Não, mano. Aqui é o modo real. Fica esperto, que se um ponteiro ficar doido você vai levar tiro pra tudo quanto é lado. Ou como diria Morpheus: &amp;quot;Welcome... to the desert... of the real.&amp;quot;
Nesse ambiente pesadão e promíscuo, onde as memórias se encostam e trocam de valores sem qualquer pudor, programas residentes se mantém em memória através do famigerado hook de interrupções. Interrupções é como chamamos as funções originais escritas e armazenadas na BIOS. Ponteiros de funções com código carregado da sua memória. Fazer um hook de uma interrupção é se colocar na frente de uma função dessas, trocando o ponteiro de função pelo endereço de sua função na memória. Então, por exemplo, se um programa roda e consegue sobrescrever o endereço da interrupção responsável por escrever na tela, esse programa pode ligar e desligar pixels que o programa original nem imagina. E em vez do logo esvoaçante e inofensivo do Windows, você poderia escrever o que seria o antepassado do gemidão do zap, versão ASCII Art.
No caso de um programa de criptografia de disco a interrupção mais importantes é... acertou: a de disco. Uma interrupção de disco é responsável por ler e escrever dados de e para o disco. No primeiro momento do boot é vital para o sistema operacional que ele consiga ler setores do disco onde ele próprio está armazenado. Ele deve conseguir ler seus dados do disco, mesmo criptografados, e esses dados precisam ser descriptografados antes que exista um driver de criptografia instalado no Sistema Operacional no ar. É o dilema do ovo e da galinha. É aí que entra o que chamamos de programa residente, o que contém a função de criptografia e cujo endereço é colocado no lugar da interrupção da BIOS para comandos de disco.
É claro que contando isso para vocês a posteriori parece mais fácil, mas meu primeiro instinto foi espetar o WinDbg, o depurador de sistema do Windows, nessa máquina. Porém, rapidamente descobri que não existia sistema operacional para ser depurado. O Windows nem conseguiu subir ainda, quanto mais deixar as pessoas depurarem ele. Então a solução foi apelar para o SoftIce 16 bits, um depurador em modo real, que funciona até que bem sozinho. Porém, o próprio depurador já é um programa residente, e não funciona tão bem quando existem outros programas residentes querendo espaço no disco. Como o programa de criptografia instalava um hook na int13 (essa é a interrupção de disco), as sessões de depuração nessa fase ficavam estranhas rapidamente. O depurador de modo real travava nas primeiras passadas de código. Não havia memória o suficiente ou as chamadas das ints entravam em conflito. De qualquer forma, quando memória entra em conflito no modo real, o barato fica loko, e o jeito é começar tudo de novo em um novo boot (par ou ímpar, mas sempre o segundo).
Então o jeito foi usar o debug.com. Este era um programa que vinha no pacote MS-DOS e em alguns Windows mais velhos que consistia em um depurador de modo real. Era possível carregar um segmento de um arquivo ou da memória real para este depurador e ele seguia passo a passo para você a execução do programa. Em assembly de modo real, claro. Esse foi o jeito que eu consegui ir entendendo o fluxo de execução, pois eram muitos valores e variáveis. Eventualmente até o debug.com também travava, mas isso não importava tanto, pois era possível ir mapeando seu funcionamento aos poucos, anotando as descobertas uma a uma em um pedaço de papel. Uma técnica que pode ser interessante se você se encontrar em tal situação é escrever as ints 3 (interrupção de breakpoint) diretamente na memória do programa e deixar ela ser ativada para depois que capotar sobrescrever com o código antigo. Eventualmente isso também travava. Daí nesse momento o jeito era fingir que estava tudo bem e continuar a execução de um outro ponto, anotando em um pedaço de papel o estado dos registradores e da memória até o momento, para depois ir ligando os pontos.
Depois de alguns dias nesse modus operandi o mundo externo importava cada vez menos. Eu só enxergava registradores sendo movidos, valores sendo empilhados e desempilhados. Na hora do café, esse era o meu tema favorito, para desespero dos meus colegas. Comecei a vislumbrar a possibilidade de existir um bug no código do algoritmo de criptografia. O algoritmo usado se chama Blowfish, um cifrador simétrico em bloco. Seu funcionamento é basicamente pegar um bloco de dados a serem criptografados, aplicar uma chave, e cuspir o mesmo tamanho do bloco de volta. Ele se chama simétrico porque aplicando a mesma chave a um bloco criptografado obtém-se o bloco original.
Não lembro como tive esse insight, mas essa alternância típica dos algoritmos simétricos fazia tocar alguns sinos na minha cabeça de que o bug bizarro dos boots ímpares e pares poderia estar relacionado de alguma forma. Só não sabia ainda como.
Pois bem: bora aprender como funciona esse algoritmo, passo a passo, pois o código usado no sistema estava obviamente escrito em assembly. Não é um código difícil em C, mas um tanto extenso em Assembly. De qualquer forma, tudo é possível se você está trancado em uma sala sem ninguém para importunar. Tudo que você precisa é de tempo e paciência. E café. Não se esqueça do café.
A semana passou rápido. Tudo que me lembro é que de fato foi uma semana de 40 ou mais horas, embora para mim o tempo tivesse parado. A mágica de estar compenetrado em um problema e fazer parte do problema, e eventualmente da solução, me fez descobrir a origem do bug. E a semana inteira se condensou em alguns poucos momentos de prazer em ter capturado esse desgraçado. Irei descrevê-lo agora.
Tudo começa com o IV: o Initialization Vector. Ele é um array de bytes usado em algoritmos criptográficos para diminuir a previsibilidade da série de bytes resultantes do algoritmo. Sem o IV pode-se usar força bruta com várias chaves até encontrar a certa. Com o IV, que é alterado de maneira previsível, mas difícil de rastrear, a mesma chave gera séries de bytes completamente diferentes, impedindo esse tipo de ataque.
O que estava acontecendo nesse caso para o boot estar intermitente era que, como comentado no commit que gloriosamente assinei, as escritas em disco durante o boot gravavam a série de bytes com um IV invertido. Portanto, na hora de ler bytes do disco ele entregaria os dados errados, obviamente, e a máquina não bootaria. Porém, como o algoritmo blowfish é simétrico, e pelo boot conter sempre os mesmos dados no disco, uma segunda escrita feita em um segundo boot inverteria o IV já invertido, gravando os dados originalmente invertidos da maneira correta, e a vida nessa versão de boot seguia feliz e contente, com logo esvoaçante até a música de boas vindas do Windows. Bootando pela terceira vez era repetido o problema do boot pela primeira vez, e assim por diante. Essa era a mágica do boot bizarro desta máquina, a única máquina que descobrimos que escrevia nos setores do disco durante o boot. A maioria apenas lia setores onde estava o sistema operacional para carregá-lo.
Descrevendo a descoberta desse bug hoje, doze anos após o ocorrido, ainda não entendo como consegui descobri-lo. Porém, ele exigiu tanta concentração que me lembro com um prazer indescritível de ter sido capaz de fazê-lo. Todo o tempo despendido se tornou uma marca de felicidade em minha memória, gravada em meu HD temporário desta vida. Lembrarei desses momentos com carinho, e como ela está criptografada também, entenderei que em alguns momentos ela irá soar amarga, mas em vários outros irei ter certeza de ter sido um feito e tanto para um ser humano entender uma máquina em seus detalhes mais obscuros. Esta é a verdadeira felicidade da profissão.
</description>
</item>

     
        <item>
  <title>Macarrão a Carbonara</title>
  <link>http://www.caloni.com.br/macarrao-a-carbonara/</link>
  <pubDate>2020-04-05</pubDate>
  
  <guid>http://www.caloni.com.br/macarrao-a-carbonara/</guid>
  <description>Essa receita foi inventada por um solteiro na Itália, e é muito útil para solteiros no mundo todo. Se for em um restaurante italiano pela primeira vez, siga o conselho do meu amigo, que sempre pede uma Carbonara. Com bacon, queijo, ovos e macarrão na receita, para o restaurante errar essa receita ele terá que ser muito ruim.
Para cada 100g de macarrão, 50g de bacon, 30g de queijo parmesão, picorino ou equivalente, e duas gemas. Pimenta à gosto.
Cozinhe o macarrão. Pese e reserve os ingredientes enquanto isso. Separe as gemas das claras, de preferência sem a capinha que a protege para não cheirar ovo, e misture com o queijo em recipiente separado. Você pode usar um pouco da água do macarrão depois de fervida para amolecer. Corte o bacon em tirinhas finas com todas as camadas da peça, da gordura à carne, disponíveis em cada tirinha. Frite o bacon em uma panela que caiba o macarrão, retirando e guardando o excesso da gordura se necessário; você pode usar o excesso para outras frituras depois. Escorra o macarrão depois de cozido, reservando parte da água usada para cozinhar, e jogue por cima na panela onde foi preparado o bacon e cozinhe ambos ligeiramente, macarrão e bacon. Desligue o fogo e jogue a mistura de gemas e queijo por cima, misturando enquanto adiciona um pouco da água de cozimento do macarrão até dar o ponto. O ponto padrão é ligeiramente úmido, mas você pode experimentar a partir daí.
</description>
</item>

     
        <item>
  <title>Meu Primeiro Amor</title>
  <link>http://www.caloni.com.br/meu-primeiro-amor/</link>
  <pubDate>2017-10-29</pubDate>
  
  <guid>http://www.caloni.com.br/meu-primeiro-amor/</guid>
  <description>A morte pode ser um catalisador de emoções. Através dela passamos por uma transformação dentro de nós que ao mesmo tempo que nos enfraquece pela dor insuportável também nos fortalece pela nossa capacidade de sobreviver. E no fim de um processo de luto algo maravilhoso acontece: voltamos para a vida mais fortes. De vez em quando iremos mexer nessa ferida do passado, e certamente irá sangrar. Mas é através desse sangue que fazemos novos pactos com os que ainda estão vivos. Porque no fundo de todos nós não há muitas diferenças. Somos humanos; estamos condenados a viver sabendo que um dia iremos morrer. Ou pior: os que nos cercam também irão.
Essa história de férias chega exatamente como o verão: inocente, despretensioso. Gostoso de viver. Acompanhamos estes dias através dos olhos de Vada Sultenfuss (Anna Chlumsky), uma menina de pouco mais de onze anos que parece amadurecer mais rápido que suas colegas de escola. Também, pudera: ela está acostumada a conviver com a morte desde que nasceu. Seu pai (um contido e competente Dan Aykroyd), viúvo, cuida de uma funerária em sua própria casa, e Vada inicia sua narrativa falando de todos os seus sintomas para o pai, que prepara seu café da manhã. No final ela conclui: &amp;quot;pai, isso só quer dizer uma coisa: estou morrendo&amp;quot;. Sua resposta: &amp;quot;querida, me passe a maionese da geladeira&amp;quot;.
Os primeiros cinco minutos do filme já introduzem a hipocondria de Vada, sua amizade improvável com Thomas J., um garoto &amp;quot;alérgico a tudo&amp;quot; (Macaulay Culkin, surpreendentemente mais fofo ainda que em Esqueceram de Mim) e a vinda de uma potencial madastra, ou seja, um conflito (Jamie Lee Curtis, muito bem por sinal). Ah, e também sabemos que Vada está perdidamente apaixonada pelo seu professor, Mr. Bixler. Ela quer ser escritora quando crescer e frequenta seu curso de poesia nas férias.
Os passeios de bicicleta entre Vada e Thomas J. evocam uma nostalgia poderosa pela cidadezinha onde moram, pela linda árvore próxima ao lago e por como tudo isso é melhorado pelo diretor de fotografia Paul Elliott (Bravura Indômita), que usa aqui um filtro que mescla o onírico (que mistura as cores dos cenários e dos personagens) com o calor gostoso do verão (e as cores sempre atingidas pelo sol). Tudo isso é acompanhado pela seleção de músicas que beira o clichê, mas que certamente hoje se transformou em uma trilha de clássicos do cinema, e que fazem parte de um elegante passeio por uma época.
E Meu Primeiro Amor flerta a todo momento como um filme piegas, o que seria a coisa mais arriscada que um filme de verão poderia fazer. Porém, a presença de tela de Anna Chlumsky e de Macaulay Culkin, capturados em seus melhores ângulos das melhores tomadas, conseguem fortalecer a poderosa ideia de que este trabalho do diretor Howard Zieff (em seu penúltimo trabalho) não está brincando a serviço. Esta não é uma comédia inconsequente passando nos cinemas, mas um drama intimista sobre o amadurecimento de uma criança atingindo a puberdade cheia de conflitos internos.
Note como Zieff não permite que sua direção fique no caminho do roteiro da estreante Laurice Elehwany porque ele é bom demais. Ele tem falas que capturam a essência das cenas sem revelar muito: &amp;quot;cansei de bingo, acho que podemos tentar o tal do drive-in&amp;quot;, &amp;quot;saia daqui! e só volte em cinco ou sete dias!&amp;quot;. E eu nem vou dizer que a passagem onde Vada explica como ela acha que deve ser o paraíso é um dos grandes momentos do cinema. Não porque ele seja particularmente tocante ou inteligente, mas porque ele entrega dois personagens que todos nós já fomos um dia em um daqueles momentos que se lembra a vida inteira.
Isso porque o filme em si é sobre a própria vida, e o processo de vivê-la mesmo sabendo que a morte dos entes queridos, ou a despedida, é uma realidade que tivemos ou teremos que lidar. &amp;quot;My Girl&amp;quot; tenta enxergar a beleza onde pode haver muita dor e sofrimento. Não é possível criticar um filme que abrace essa ideia com tanto afinco. Não enquanto estivermos todos aqui, empenhados em tornar nossa condenação de viver a mais próxima do paraíso possível.
</description>
</item>

     
        <item>
  <title>Madoka Magica</title>
  <link>http://www.caloni.com.br/madoka-magica/</link>
  <pubDate>2014-04-14</pubDate>
  
  <guid>http://www.caloni.com.br/madoka-magica/</guid>
  <description>A revisita a este animê que para mim ainda é meu favorito -- pela originalidade e pela fuga do lugar-comum e dos roteiros fáceis que a maioria das adaptações dos quadrinhos japoneses são submetidos -- foi feita em apenas uma noite. Mais de quatro horas depois posso reafirmar com convicção: é uma obra ousada para seu formato tanto em história quanto na direção/edição/arte. Desafia o espectador a esquecer os detalhes centrais de uma história que vai se abrindo muito lentamente, e sua força é sentida exatamente por esse cuidado em cada detalhe.
Madoka Mágica é um trabalho caricatual que segue à risca a cartilha de heroinas de cosplay (ou, diria, se usa desse artifício como metalinguagem e crítica ao gênero), mas, mais do que isso, segue um tratamento estilizado e inspirado levemente no surrealismo, mas que empurra a animação para além das histórias de luta ao lidar com conceitos complexos como auto-sacrifício, religião, viagens no tempo, destino e física teórica (além de vida extraterrena) sem perder seu ritmo com história secundárias bobinhas para fazer rir/ganhar tempo. É uma fantasia com um pé na ciência, um pé na filosofia e outro pé na arte. Esse tripé mantém a câmera posicionada nos lugares mais inusitados para capturar cada quadro como se esse fosse uma obra de arte única a resumir aquele momento através de sutis e significativos movimentos.
E há vários momentos que merecem ser congelados para nossa apreciação.
A história gira em torno de Madoka Kaname, uma garota comum que encontra um bicho estranho e mágico que revela que existem garotas mágicas que lutam contra bruxas e salvam pessoas de suicídios. Na verdade, revela mais: ela e sua amiga, Sayaka Miki, podem se tornar garotas mágicas também, e a recompensa por este feito heróico é terem um desejo, qualquer desejo, realizado pelo tal bicho mágico.
O curioso da série é que ela não tem pressa em realizar o que 90% das produções semelhantes ocidentais fariam: um grupo de garotas lutando contra o mal a la Meninas Superpoderosas. No fundo, o &amp;quot;mal&amp;quot; aqui não está materializado e nem tem desejo de fúria. Ele é um conceito, e relativo, dependendo do ponto de vista. Sequer há emoções em jogo. Na verdade, é mais profundo que isso: a emoção aqui é usada de uma maneira completamente diferente. Uma Meninas Superpoderosas para gente grande.
Mas além da empolgante história o que cativa mesmo o espectador é a qualidade narrativa criada não apenas a partir dos sensacionais traços dos criadores, mas de uma invejável e coesa trilha sonora (Yuki Kajiura) e uma fotografia de cair o queixo (Shinichiro Eto). Tudo isso, com a edição de Rie Matsuhara, combina em uma experiência sensorial cada vez mais fácil de ser encontrada em séries de TV ambiciosas e menos nos cinemas comerciais.
</description>
</item>

     
        <item>
  <title>Os diferentes erros na linguagem C</title>
  <link>http://www.caloni.com.br/os-diferentes-erros-na-linguagem-c/</link>
  <pubDate>2008-02-15</pubDate>
  
  <guid>http://www.caloni.com.br/os-diferentes-erros-na-linguagem-c/</guid>
  <description>Uma coisa que me espanta de vez em quando é o total desconhecimento por programadores mais ou menos experientes dos níveis de erros que podem ocorrer em um fonte escrito em C ou C&#43;&#43;. Desconheço o motivo, mas desconfio que o fato de outras linguagens não terem essa divisão de processos pode causar alguma nivelação entre as linguagens e fazer pensar que o processo de compilação em C é como em qualquer outra linguagem.
Porém, para começar, só de falarmos em compilação já estamos pegando apenas um pedaço do todo, que é a geração de um programa executável em C. Tradicionalmente, dividimos esse processo em três passos:
 Preprocessamento Compilação Linkedição  Vamos dar uma olhada mais de perto em cada um deles e descobrir erros típicos de cada processo.
O preprocessamento é especificado pelos padrões C e C&#43;&#43;, mas, tecnicamente, não faz parte da linguagem. Ou seja, antes que qualquer regra de sintaxe seja verificada no código-fonte, o preprocessamento já terá terminado.
Essa parte do processo lida com substituição de texto e diretivas baseadas em arquivos e símbolos. Por exemplo, a diretiva de preprocessamento mais conhecida
#include &amp;lt;stdio.h&amp;gt; faz com que todo o conteúdo do arquivo especificado seja incluído exatamente no ponto onde for colocada essa diretiva. Isso quer dizer que, antes sequer do código-fonte ser compilado, todo o conteúdo desse header padrão estará no corpo do arquivo C.
Para evitar que o mesmo header seja incluído inúmeras vezes dentro da mesma unidade em C, causando assim erros de redefinição, existe outra diretiva muito usada para cercar esses arquivos públicos:
#ifndef __MEUHEADER__ // se já estiver definido, caio fora até endif#define __MEUHEADER__// conteúdo do header#endif // __MEUHEADER__ Esse conjunto de duas diretivas, por si só, é capaz de gerar os mais criativos e bizarros erros de compilação em C. E estamos falando de erros que ocorrem antes que sequer seja iniciado o processo de compilação propriamente dito. Obviamente que os erros serão capturados durante a compilação, mas o motivo deles terem ocorrido foi um erro decorrente do processo de preprocessamento. Por exemplo, vamos supor que um determinado fonte necessita de uma declaração de função contida em meuheader.h:
#include &amp;quot;header-do-mal.h&amp;quot;#include &amp;quot;meuheader.h&amp;quot;int func(){meuheaderFunc();} Porém, num daqueles acasos da natureza, o header-do-mal.h define justamente o que não poderia definir jamais (obs.: e isso pode muito bem acontecer na vida real, se usamos definições muito comuns):
#ifndef __HEADERDOMAL__#define __HEADERDOMAL__// tirei header da jogada, huahuahua (risos maléficos)#define __MEUHEADER__#endif // __HEADERDOMAL__ Na hora do preprocessamento, o preprocessador não irá mais incluir o conteúdo dentro de header.h:
#ifndef __MEUHEADER__ // se já estiver definido, caio fora até endif#define __MEUHEADER__int meuheaderFunc(); // talvez alguém precise disso#endif // __MEUHEADER__ Conseqüentemente, durante a compilação do código-fonte já preprocessado, sem a declaração da função meuheaderFunc, irá ocorrer o seguinte erro:
error C3861: &#39;meuheaderFunc&#39;: identifier not found Isso em fontes pequenos é facilmente identificável. Em fontes maiores, é preciso ter um pouco mais de cuidado.
Após o processo de preprocessamento, de todos os arquivos indicados terem sido incluídos, de todas as macros terem sido substituídas, todas as constantes colocadas literalmente no código-fonte, temos o que é chamado unidade de compilação, que será entregue ao compilador, que, por sua vez, irá começar a análise sintática de fato, descobrindo novos erros que podem ou não (como vimos) ter a ver com a fase anterior. A figura abaixo ilustra esse processo, com algumas trocas conhecidas:
Dica: quando o bicho estiver pegando, e tudo o que você sabe sobre linguagem C não estiver te ajudando a resolver um problema, tente gerar uma unidade de compilação em C e analisar sua saída. Às vezes o que é claro no código pode se tornar obscuro após o preprocessamento. Para fazer isso no VC&#43;&#43; em linha de comando, use o parâmetro /E.
Se você conseguir passar ileso para a fase de compilação, pode se considerar um mestre do preprocessamento. Por experiência própria, posso afirmar que a maior parte do tempo gasto corrigindo erros de compilação, por ironia do destino, não terá origem na compilação em si, mas no preprocessamento e linkedição. Isso porque o preprocessamento confunde muito o que vimos no nosso editor preferido, e a linkedição ocorre em uma fase onde não importa mais o que está dentro das funções, mas sim o escopo de nomes, um assunto um pouco mais vago do que a linguagem C.
Na compilação você irá encontrar geralmente erros bem comportados, como conversão entre tipos, else sem if e esquecimento de pontuação ou parênteses.
int cannotConvertError(const char* message){int ret = message[0];return ret;}int ret = cannotConvertError(3);error C2664: &#39;cannotConvertError&#39; : cannot convert parameter 1 from &#39;int&#39; to &#39;const char *&#39;if( test() )something;something-else;elseelse-something;error C2181: illegal else without matching ifwhile( (x &amp;lt; z) &amp;amp;&amp;amp; func(x, func2(y) != 2 ){something;}error C2143: syntax error : missing &#39;)&#39; before &#39;{&#39; Claro, não estamos falando de erros relacionados a templates, que são um pesadelo à parte.
Dica: nunca subestime o poder de informação do compilador e da sua documentação. Se o erro tem um código (geralmente tem), procure a documentação sobre o código de erro específico, para ter uma idéia de por que esse erro costuma ocorrer, exemplos de código com esse erro e possíveis soluções. Ficar batendo a cabeça não vai ajudar em nada, e com o tempo, você irá ficar sabendo rapidamente o que aconteceu.
Chegando na linkedição, onde a esperança reside, tudo pode vir por água abaixo. Isso porque você já espera confiante que tudo dê certo, quando, na verdade, um erro bem colocado pode fazer você desistir pra sempre desse negócio de programar em C.
As características mais desejadas para corrigir erros nessa fase são:
 Total conhecimento da fase do preprocessamento Total conhecimento da fase da compilação Total conhecimento de níveis de escopo e assinatura de funções  Os dois primeiros itens são uma maldição previsível que deve-se carregar para todo o sempre. Se você não consegue entender o que aconteceu nas duas primeiras fases, dificilmente irá conseguir seguir adiante com essa empreitada. O terceiro item significa que deve-se levar em conta as bibliotecas que estamos usando, headers externos (com dependências externas), conflitos entre nomes, etc.
Alguns erros mais encontrados aqui são as funções não encontradas por falta da LIB certa ou por LIBs desatualizadas que não se encaixam mais com o projeto, fruto de muitas dores de cabeça de manutenção de código. Essa é a parte em que mais vale a pena saber organizar e definir uma interface clara entre os componentes de um projeto.
Do ponto de vista técnico, é a fase onde o linker junta todos os arquivos-objeto especificados, encontra as funções, métodos e classes necessárias e monta uma unidade executável, como ilustrado pela figura abaixo.
Dica: uma LIB, ou biblioteca, nada mais é que uma coleção de arquivos-objeto que já foram compilados, ou seja, já passaram pelas duas primeiras fases, mas ainda não foram linkeditados. Muitas vezes é importante manter compatibilidade entre LIBs e os projetos que as usam, de forma que o processo de linkedição ocorra da maneira menos dolorosa possível.
É óbvio que, por ter passado pelas três fases de transformação de um código-fonte em um programa executável, não quer dizer que este programa está livre de erros. Os famigerados erros de lógica podem se disfarçar até o último momento da compilação e só se mostrarem quando o código estiver rodando (de preferência, no cliente).
Entre esses erros, os mais comuns costumam se aproveitar de macros, como max, que usa mais de uma vez o parâmetro, que pode ser uma chamada com uma função. A função será chamada duas vezes, mesmo que aparentemente no código a chamada seja feita uma única vez:
#define max(a, b) ( a &amp;gt; b ? a : b )int z = max( func(10), 30 ); Um outro erro que já encontrei algumas vezes é quando a definição de uma classe tem um sizeof diferente do compilado em sua LIB, pela exclusão ou adição de novos membros. Isso pode (vai) fazer com que, durante a execução, a pilha seja corrompida, membros diferentes sejam acessados, entre outras traquinagens. Esses erros costumam acusar a falta de sincronismo entre os headers usados e suas reais implementações.
Enfim, na vida real, é impossível catalogar todos os erros que podem ocorrer em um fonte em C. Se isso fosse possível, ou não existiriam bugs, ou pelo menos existiria uma ferramenta para automaticamente procurar por esses erros e corrigi-los. Bom, existe o Lint.
Criei um projeto com alguns erros básicos, alguns demonstrados aqui, outros não, mas enfim, completamente configuráveis e divididos nessas três fases. É possível habilitar e desabilitar erros através do header cpperrors.h. Espero que gostem.
</description>
</item>

     
        <item>
  <title>A Linguagem de Programação C: O Livro</title>
  <link>http://www.caloni.com.br/the-c-programming-language/</link>
  <pubDate>2007-10-12</pubDate>
  
  <guid>http://www.caloni.com.br/the-c-programming-language/</guid>
  <description>O clássico de Ritchie e Kernighan, criadores da linguagem C, não foi meu primeiro livro de programação. E nem deveria ser. Não o recomendo para iniciantes, pois é necessário possuir algum conhecimento e prática para realmente aproveitar os conceitos desse livro.
Então, o que ler antes disso? Existem tantos livros bons para iniciantes (e tantos livros péssimos). Eu comecei com C Completo e Total, de Herbert Schildt. Não me arrependi. O autor vai descrevendo C para quem já tentou fazer algumas coisas, já programou outras e está afim de tirar as principais dúvidas sobre essa linguagem que tantos abominam por ser difícil, e tantos idolatram por ser poderosa. As práticas do livro já são um bom início para quem quer pensar, entender e programar.
Depois de Schildt passei a ler os livros da Viviane, os famosíssimos módulos do Treinamento em Linguagem C. São ótimos para a prática e para reafirmar os conceitos lidos no primeiro livro. Para uma linguagem tão importante uma segunda opinião é sempre bem-vinda.
Então chegou a hora. Passei algumas das minhas melhores horas na biblioteca lendo como os próprios criadores da linguagem a ensinam, e como o padrão ANSI é definido (em termos bem simplificados, condição perfeita para entender a lógica do compilador). Com o livro é possível perceber claramente que a linguagem é tão simples quanto poderosa, lembrando (quem diria!) o mais abominado ainda assembly. Vamos aos capítulos.
Chapter 1: A Tutorial Introduction O começo é quase sempre o mesmo. Os autores explicam um programa simples na linguagem, fazem alguns testes e explicam linha a linha o que cada coisa significa. O importante aqui é esquecer que existe um sistema operacional rodando por baixo de nosso programa e entender que a linguagem foi desenhada para independer disso. É tão genérica a ponto de independer dela mesma. Explico: enquanto a maioria das linguagens considera sua biblioteca parte integrante da mesma, a linguagem C faz questão de separar as coisas, reafirmando sempre que uma coisa é o preprocessamento, outra é a compilação, outra é a linkedição e nenhuma delas precisa de uma biblioteca, apesar de uma ter sido definida no padrão (baseada no uso comum da linguagem em diversos ambientes).
Se você nunca teve contato com C ou deseja ter uma aproximação mais simplificada e quer entender como as coisas mais simples funcionam na linguagem, este capítulo é imperdível.
Chapter 2: Types, Operators and Expressions Essa é a hora ideal para separar dois conceitos que muitas vezes ficam grudados na mente dos precoces programadores para o resto de suas vidas: uma coisa é um tipo e outra coisa é uma expressão. Uma expressão possui um tipo, que define seu comportamento de acordo com o operador usado. Tudo é explicado muito bem com exemplos bem escritos e que são realmente úteis, como strlen, atoi, strcat (presentes na biblioteca padrão) e até um contador de bits.
Se quiser entender o que cada fragmento de lógica na linguagem significa por completo (e não apenas uma expressão jogada na correria da programação do dia-a-dia) esse capítulo irá explicar. Depois de entendê-lo, nunca mais vai achar bizarro aqueles problemas de precedência que permeiam código pouco sensato.
Chapter 3: Control Flow Apenas após ter explicado os conceitos que regem qualquer linha de código operacional em C os autores se dedicam a explanar as diversas formas de controlar o fluxo do seu programa. Nessa hora a linguagem se desdobra, se torna mágica, simples, flexível e poderosa.
Não basta apenas possuir lógica de programação. Para escrever bons programas é necessário saber como construir os blocos funcionais que irão traduzir seus comandos para o computador. É nesse ponto que é fundamental o domínio de qualquer construção em C, seja um simples if ou uma combinação maluca de switches, whiles e breaks.
Chapter 4: Functions and Program Structure Entendidos os princípios básicos de criação e execução de qualquer programa em C, chegou a hora de explicar como a linguagem suporta a organização de seu código através de funções, módulos e diretivas de preprocessamento. Note que os autores partem do princípio minimalista da linguagem e imagina o que acontece conforme seus programas vão se tornando cada vez maiores. Para isso explicam o mesmo princípio que foi utilizado ao desenhar a linguagem, que até hoje é usada para escrever dezenas de milhares de código em um único projeto, ou até milhões (como em sistemas operacionais).
No desenvolvimento de software a organização é um dos pilares que irá transformar o programador em um mestre da arquitetura de seu próprio código. Não negligencie a lógica das partes maiores do seu código, só se importando com os pequenos pedaços de blocos dentro de uma função. Antes de ser cientista, seja um desenvolvedor nato.
Chapter 5: Pointers and Arrays A dificuldade com que muitos programadores C têm com essas duas características da linguagem fizeram com que fosse dedicado um capítulo inteiro para explicar e reexplicar como os arrays (vetores) e ponteiros funcionam e qual a relação intrínseca entre eles. É também explicada a relação strings x arrays, já que em C uma string é uma cadeia de caracteres.
Se você programa em C e até hoje tem dificuldades para entender completamente esse assunto, sugiro que largue o que você está fazendo agora e leia esse capítulo até o final. Será bem mais proveitoso que ficar zanzando no meio de um monte de blogues (como este aqui).
Chapter 6: Structures A estrutura é uma composição complexa em C, mas permite um organização melhor dos dados, da mesma maneira com que as funções organizam melhor o código.
Aparentemente o tema estrutura é mais simples que ponteiros, e deveria ser tratado antes. Porém, fazer isso impediria abordar o tema de listas ligadas e outras estruturas que dependem do uso de ponteiros para que estruturas referenciem elas mesmas, algo extremamente recorrente no mundo da programação.
É sempre bom lembrar que o uso de estruturas foi o nascimento do C&#43;&#43;, que prima pela elegância na organização e harmonia entre seu código e dados. A linguagem C também não fica para trás, mas é importante saber usar.
Chapters 7 and 8: Input and Output / The UNIX System Interface Para finalizar é abordado o tema da interface com o mundo exterior da linguagem. Desde sempre suportando a maneira mais básica, genérica e portátil de qualquer sistema operacional, o console, talvez hoje essa característica seja um tanto menosprezada pelos usuários de ambientes gráficos. Contudo, não deixa de ter seu valor ainda hoje, nem que seja para escrever programas de teste.
Apêndices Os adendos são incrivelmente úteis e os utilizo ainda hoje como referência. Cá entre nós, o padrão formal da linguagem é algo chato de se ler, e muitos detalhes são perfeitamente ignoráveis para quem não está desenvolvendo um compilador. Contudo, acredito que a maioria dos bons programadores deveria se preocupar em entender como os compiladores entendem seu código, pois muitos dos erros podem ser facilmente resolvidos através do desenvolvimento de uma certa empatia com a linguagem. É por isso que considero o Apêndice A o mais útil de todos.
Por outro lado, sempre fui contra a reinvenção da roda. O que quer dizer que sempre fui a favor do pleno conhecimento da biblioteca padrão, pois ela fornece funções das mais usadas no dia-a-dia, e algumas outras que poderão ter sua serventia um dia desses. Mas para isso elas devem ser conhecidas. Isso quer dizer que uma passada de olhos no Apêndice B não faz mal a ninguém.
O Apêndice C hoje é um pequeno guia dos curiosos para as mudanças que foram infligidas na linguagem quando esta foi padronizada. Como fã incondicional de C, não pude deixar de ler e reler essa parte, já que me dedico também a conhecer os primórdios dessa linguagem. Contudo, é parte opcional para as pessoas práticas (a não ser que você esteja com problemas com código legado do século passado).
Conclusão Livros vêm, livros vão, mas apenas os clássicos permanecerão. A Linguagem de Programação C é um clássico, sem sombra de dúvida, e nunca irá perder seu valor para a linguagem. A maioria dos livros usa-o como referência, assim como os livros tão amados da comunidade C&#43;&#43; sempre usam Stroustrup como referência. Portanto, se puder, reserve um tempo para o passado.
</description>
</item>

     
        <item>
  <title>Disassembling the array operator</title>
  <link>http://www.caloni.com.br/disassembling-the-array-operator/</link>
  <pubDate>2007-06-22</pubDate>
  
  <guid>http://www.caloni.com.br/disassembling-the-array-operator/</guid>
  <description>Arrays are fascinating in C language because they are so simple and so powerful at the same time. When we start to really understand them and realize all its power we are very close to understand another awesome feature of the language: pointers.
When I was reading the K&amp;amp;R book (again) I was enjoying the language specification details in the Appendix A. It was specially odd the description as an array must be accessed:
 A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type &amp;quot;pointer to T&amp;quot; and the other shall have enumeration or integral type. The result is an lvalue of type &amp;quot;T&amp;quot;. (...) The expression E1 [ E2 ] is identical (by definition) to *( (E1) &#43; (E2) ).
 Notice that the rules don&#39;t specify the order of expressions to access the array. In other words, it doesn&#39;t matter for the language if we use a pointer before the integer or an integer before the pointer.
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cassert&amp;gt;int main(){char q[] = &amp;quot;Show me your Code, &amp;quot;&amp;quot;and I&#39;ll tell you who you are.&amp;quot;;int i = 13;std::cout &amp;lt;&amp;lt; &amp;quot;And the language is: &amp;quot; &amp;lt;&amp;lt; q [ i ] &amp;lt;&amp;lt; std::endl;assert( q[i] == i[q] );assert( q[13] == 13[q] );assert( *(q &#43; i) == &amp;quot;That&#39;s C!&amp;quot;[7] );return 13[q] - &amp;quot;CThings&amp;quot;[0];}  The q[i] bellow shows that we can use both orders and the code will compile successfully.
std::cout &amp;lt;&amp;lt; &amp;quot;And the language is: &amp;quot; &amp;lt;&amp;lt; i [ q ] &amp;lt;&amp;lt; std::endl; This code doesn&#39;t show how obscure we can be. If we use a constant integer replacing the i, by example, the code starts to be an IOCCC participant:
std::cout &amp;lt;&amp;lt; &amp;quot;And the language is: &amp;quot; &amp;lt;&amp;lt; 13 [ q ] &amp;lt;&amp;lt; std::endl; Is this a valid code yet, right? The expression types are following the rule. It is easy to see if we always think about using the &amp;quot;universal match&amp;quot; *( (E1) &#43; (E2) ). Even bizarre things like this are easy to realize:
std::cout &amp;lt;&amp;lt; 8[&amp;quot;Is this Code right?&amp;quot;] &amp;lt;&amp;lt; std::endl; Obs.: this kind of &amp;quot;obscure rule&amp;quot; hardly will pass in a code review since it is a useless feature. Be wise and don&#39;t use it in production code. This is just an amusing detail in the language specification scope. It can help in analysis, never in programming.
</description>
</item>

     
    
  </channel>
</rss>
