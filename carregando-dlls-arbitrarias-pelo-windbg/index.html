<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  
  
      
  
      
  

  <head>
  <meta charset="utf-8" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Carregando DLLs arbitrárias pelo WinDbg</title>
  <meta name="author" content="" />

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta property="og:title" content="Carregando DLLs arbitrárias pelo WinDbg"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg/"/>
  <meta property="og:image"
        content="/img/author.jpg"/>
  <meta property="og:description"
        content="Durante meus testes para a correção de um bug me deparei com a necessidade de carregar uma DLL desenvolvida por mim no processo depurado. O detalhe é que o processo depurado é de terceiros e não..."/>

  
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/img/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">

  <div class="container">

    <div class="navbar-brand">
        <img alt="Brand" src="/img/brand.svg">
        &nbsp;
        <a class="navbar-item" title="Go to Home" href="/">
            <div class="is-6">Blogue do Caloni</div>
        </a>
    </div>

    

  </div>
</nav>


      
      <div class="container">
        <p class="title">

Carregando DLLs arbitrárias pelo WinDbg

</p>

        <p class="subtitle">

  Wanderley Caloni,
  
    
  
    
  
  2007-11-23<a href="https://github.com/Caloni/blog/blob/master/content/posts/carregando-dlls-arbitrarias-pelo-windbg.md">.</a>

</p>

        

        
          <div class="content">

            
              <p>Durante meus testes para a correção de um bug me deparei com a necessidade de carregar uma DLL desenvolvida por mim no processo depurado. O detalhe é que o processo depurado é de terceiros e não possuo o fonte. Portanto, as opções para mim mais simples são:</p>
<ul>
<li>
<p>Usar o projeto <a href="http://www.codeproject.com/threads/RmThread.asp">RmThread</a> para injetar a DLL (nesse caso iniciando o processo através dele).</p>
</li>
<li>
<p>Fazer um módulo <em>wrapper</em> para uma DLL qualquer e ser carregado de brinde.</p>
</li>
<li>
<p>Usar o WinDbg e brincar um pouco.</p>
</li>
</ul>
<p>Por um motivo desconhecido a terceira opção me pareceu mais interessante =).</p>
<p>A seqüência mais simples para carregar uma DLL através do WinDbg é chamar <strong>kernel32!LoadLibrary</strong> através de um código digitado na hora, o que podemos chamar de <em>live assembly</em> (algo como &quot;<em>assembly</em> ao vivo&quot;). Porém, essa simples seqüência contém um pouco mais que uma dúzia de passos.</p>
<p>Primeiro devemos parar a execução, voltar para um ponto seguro do código e armazenar o local seguro em um registrador temporário (o WinDbg tem 20 deles, $t0 até $t19).</p>
<pre><code>&lt;Ctrl + Break&gt; &lt;font color=&quot;#339966&quot;&gt;$$ pára a execução em um ponto qualquer&lt;/font&gt;
gu &lt;font color=&quot;#339966&quot;&gt;$$ volta para função chamadora para evitar perda do estado dos registradores&lt;/font&gt;
r$t0 = @$ip &lt;font color=&quot;#339966&quot;&gt;$$ armazena ponteiro de instrução em registrador temporário&lt;/font&gt;
</code></pre>
<!-- raw HTML omitted -->
<blockquote>
<h4 id="diga-para-o-windbg-o-que-vem-por-aí">Diga para o WinDbg o que vem por aí</h4>
</blockquote>
<p>_Note que usamos dois pseudo-registradores (<strong>$t0</strong>, o primeiro registrador temporário do WinDbg, e <strong>$ip</strong>, o registrador que aponta para a próxima instrução que será executada), mas só um deles possue o prefixo '@'. Esse prefixo diz ao WinDbg que o que segue é um registrador. Como o comando <strong>r</strong> já é usado com registradores, é desnecessário usá-lo para <strong>$t0</strong>. Se usarmos sintaxe C++ esse prefixo é obrigatório, enquanto na sintaxe MASM não. Porém, se não usarmos esse prefixo em registradores não-comuns (como é o caso para <strong>$ip</strong>) o WinDbg primeiro tentará interpretar o texto como um número hexadecimal. Ao falhar, tentará interpretar como um símbolo. Ao falhar novamente, ele finalmente irá tratá-lo como um registrador. A diferença na velocidade faz valer a pena digitar um caractere a mais. Faça a prova!_<!-- raw HTML omitted --></p>
<h4 id="_live-assembly_"><em>Live assembly</em></h4>
<p>Parada a execução em um local seguro e armazenado o IP, em seguida podemos alocar memória para entrar o código em <em>assembly</em> da chamada, além do seu parâmetro, no caso o <em>path</em> da DLL a ser carregada.</p>
<pre><code>.dvalloc 0x1000 &lt;font color=&quot;#339966&quot;&gt;$$ alocamos memória para entrar o assembly e o parâmetro da chamada&lt;/font&gt;
Allocated 1000 bytes starting at 00280000
eza 0x00280000 &lt;font color=&quot;#ff0000&quot;&gt;&quot;C:tempMinhaDllInvasora.dll&quot;&lt;/font&gt; &lt;font color=&quot;#339966&quot;&gt;$$ escreve no início da memória o path da DLL&lt;/font&gt;
a 0x0280000+0x100 &lt;font color=&quot;#339966&quot;&gt;$$ agora vamos codificar em live-assembly&lt;/font&gt;
00280100 push 0x00280000 &lt;font color=&quot;#339966&quot;&gt;$$ empilha o parâmetro (path da DLL)&lt;/font&gt;
push 0x00280000
00280105 call kernel32!LoadLibraryA &lt;font color=&quot;#339966&quot;&gt;$$ chama LoadLibraryA&lt;/font&gt;
call kernel32!LoadLibraryA
0028010a int 3 &lt;font color=&quot;#339966&quot;&gt;$$ um breakpoint para tornar as coisas mais fáceis&lt;/font&gt;
int 3
0028010b &lt;font color=&quot;#339966&quot;&gt;$$ um &lt;enter&gt; em uma linha vazia termina a edição do live-assembly&lt;/font&gt;
0:000&gt; &lt;font color=&quot;#339966&quot;&gt;$$ estamos de volta no prompt do WinDbg&lt;/font&gt;
</code></pre>
<p>Note que estamos usando a versão ANSI do LoadLibrary, aquela que termina com A. Sendo assim, escrevemos uma _string _ANSI como parâmetro usando o comando ez<strong>a</strong>.</p>
<h4 id="chamando-o-código-quentinho">Chamando o código quentinho</h4>
<p>O último passo é chamar a função previamente &quot;editada&quot;. Para isso basta mudarmos o endereço da próxima instrução para o começo de nosso código e mandar executar, pois ele irá parar automaticamente no <em>breakpoint</em> que definimos &quot;na mão&quot;, o <strong>int 3</strong> digitado. Após a execução devemos voltar o ponteiro usando nosso <em>backup</em> no registrador <strong>$t0</strong>.</p>
<pre><code>0:000&gt; r$ip = 0x00280000+0x100
0:000&gt; g
ModLoad: 10000000 10045000   &lt;font color=&quot;#ff0000&quot;&gt;C:tempMinhaDllInvasora.dll&lt;/font&gt;
ModLoad: 76390000 763ad000   C:WINDOWSsystem32IMM32.DLL
(398.d90): Break instruction exception - code 80000003 (first chance)
eax=10000000 ebx=7ffdd000 ecx=7c801bf6 edx=000a0608 esi=001a1f48 edi=001a1eb4
eip=0028010a esp=0007fb24 ebp=0007fc94 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
0028010a cc              int     3 &lt;font color=&quot;#339966&quot;&gt;$$ esse é o breakpoint que digitamos no código&lt;/font&gt;
0:000&gt; r$ip = $t0 &lt;font color=&quot;#339966&quot;&gt;$$ mudando o IP para o ponto original&lt;/font&gt;
*** WARNING: Unable to verify checksum for C:tempMinhaDllInvasora.dll
0:000&gt; g
ModLoad: 5cb70000 5cb96000   C:WINDOWSsystem32ShimEng.dll
ModLoad: 6f880000 6fa4a000   C:WINDOWSAppPatchAcGenral.DLL
ModLoad: 76b40000 76b6d000   C:WINDOWSsystem32WINMM.dll
ModLoad: 774e0000 7761d000   C:WINDOWSsystem32ole32.dll
...
</code></pre>
<p>Como pudemos ver pela saída, a DLL foi carregada e agora temos a possibilidade de chamar qualquer código que lá esteja. Como fazer isso? Provavelmente usando o mesmo método aqui aplicado. <em>Live-assembly</em> é o que manda 8).</p>

            

          </div>

        <div class="taglist">
            
    
      <a href="/tags/draft">draft</a>  <a href="/tags/code">code</a> 
    <a class="externalgray" href="https://telegram.me/share/url?url=http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg/">discuss</a>


        </div>

        <div class="navigation-bottom">
            <span class="next-in-section"><a href="http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg-parte-2/">&#x25C1; Carregando DLLs arbitrárias pelo WinDbg - parte 2</a></span>
<span class="prev-in-section"><a href="http://www.caloni.com.br/usando-a-libc-nativa-do-windows/">&#x25B7; Usando a LIBC nativa do Windows</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2021<a href="https://github.com/Caloni/blog">.</a> </i></span>
  </div>
</footer>

  </body>

</html>
