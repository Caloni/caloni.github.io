<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Iteradores não são constantes</title>
  <meta name="author" content="" />
  <meta name="description"
        content="Um bug que já encontrei uma dúzia de vezes entre os novatos da STL é a utilização de iteradores como se eles não fossem mudar nunca. Porém, a verdade é bem diferente: iteradores se tornam inválidos..."/>

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta itemprop="name" content="Iteradores não são constantes"/>
  <meta itemprop="description"
        content="Um bug que já encontrei uma dúzia de vezes entre os novatos da STL é a utilização de iteradores como se eles não fossem mudar nunca. Porém, a verdade é bem diferente: iteradores se tornam inválidos..."/>
  <meta itemprop="image"
        content=""/>

  
  <meta property="og:title" content="Iteradores não são constantes"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/iteradores-nao-sao-constantes/"/>
  <meta property="og:image"
        content=""/>
  <meta property="og:description"
        content="Um bug que já encontrei uma dúzia de vezes entre os novatos da STL é a utilização de iteradores como se eles não fossem mudar nunca. Porém, a verdade é bem diferente: iteradores se tornam inválidos..."/>
  <meta property="og:site_name" content="Blogue do Caloni"/>
  <meta property="article:published_time"
        content="2008-03-04T00:00:00&#43;00:00"/>
  <meta property="article:section" content="post"/>

  
  
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site"
        content=""/>
  <meta name="twitter:title" content="Iteradores não são constantes"/>
  <meta name="twitter:description"
        content="Um bug que já encontrei uma dúzia de vezes entre os novatos da STL é a utilização de iteradores como se eles não fossem mudar nunca. Porém, a verdade é bem diferente: iteradores se tornam inválidos..."/>
  <meta name="twitter:creator"
        content=""/>
  <meta name="twitter:image:src"
        content="
                     /images/movies.png
                   "/>

  
  <link href="" rel="alternate" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">
  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/brand.svg">
        <div class="title is-6">&nbsp;Blogue do Caloni</div>
      </a>

      
      <label class="button navbar-burger is-white" for="navbar-burger-state">
        <span></span>                               
        <span></span>
        <span></span>
      </label>
    </div>

    
    <input type="checkbox" id="navbar-burger-state"/>

    <div class="navbar-menu">
      <div class="navbar-end" style="padding: 10px;">
      <big><b>
       <a title="posts dessa categoria" href="/categories/blog">blog</a>  <a title="posts dessa categoria" href="/categories/cinema">cinema</a>  <a title="posts dessa categoria" href="/categories/code">code</a> 
      </big></b>
      </div>
    </div>

  </div>
</nav>


      
      <div class="container">
        <p class="title">Iteradores não são constantes</p>

        <p class="subtitle">

    <a href="https://github.com/Caloni/blog/blob/master/content/post/iteradores-nao-sao-constantes.md" title="source">
    2008-03-04
    </a>

</p>

        <div class="taglist">
            <i>Este ainda é um rascunho publicado prematuramente e está sujeito a mudanças substanciais.</i>

        </div>

        

        
          <div class="content">
            
              <p>Um bug que já encontrei uma dúzia de vezes entre os novatos da STL é a utilização de iteradores como se eles não fossem mudar nunca. Porém, a verdade é bem diferente: iteradores se tornam inválidos sim, e com muito mais freqüência do que normalmente se imagina. Entre as situações em que iteradores podem mudar estão as seguintes:</p>
<ul>
<li>
<p>Inserção de novo elemento no contêiner</p>
</li>
<li>
<p>Remoção de novo elemento no contêiner</p>
</li>
<li>
<p>Redimensionamento no tamanho do contêiner</p>
</li>
</ul>
<p>Por exemplo, o tradicional código do exemplo abaixo contém o tradicional erro de iterador inválido:</p>
<pre><code>for( container::iterator it = obj.begin(); it != obj.end(); ++it )
{
    if( it-&gt;member == 0 ) // condição para apagar elemento
    {
        obj.erase(it);  // a partir daqui it é inválido,
                        // e não adianta incrementá-lo
    }
}
</code></pre>
<p>Para operações como essa, o retorno geralmente nos dá uma dica de para onde vamos na varredura do contêiner. No caso do método erase, o retorno é o próximo iterador válido, ou o final (retornado pelo método end). Um código mais esperto gera um erro mais sutil:</p>
<pre><code>for( container::iterator it = obj.begin(); it != obj.end(); ++it )
{
    if( it-&gt;member == 0 ) // condição para apagar elemento
    {
        it = obj.erase(it); // ótimo, atualizou it. só
                            // que se ele for o final,
                            // será incrementado
    }
}
</code></pre>
<p>Algo de errado irá acontecer apenas se o elemento removido for o último localizado no contêiner.</p>
<p>Esse é um erro comum para os acostumados com outros tipos de iteração (ex: ponteiros) e que não estudaram os princípios básicos da STL, entre eles o da reutilização de algoritmos. Se fosse usado este princípio, nada disso teria acontecido:</p>
<pre><code>struct remove_if_zero
{
    bool operator() (ObjElement&amp; element)
    {
        return element-&gt;member == 0;
    }
};

obj.remove_if( remove_if_zero() ); // pronto!
</code></pre>
<p>Quando precisamos fazer algo nos elementos de um contêiner STL, é quase certo que existirá um algoritmo genérico para essa tarefa, seja no próprio contêiner ou na forma de função (header algorithm). Nunca se esqueça disso na hora de desenvolver seus próprios algoritmos e não precisará reinventar a roda todos os dias.</p>

            

          </div>

        <div class="taglist">
            
    
      [<a href="/categories/code">code</a>] 
      [<a href="/tags/draft">draft</a>] 
    
    <a href="https://twitter.com/intent/tweet?text=Um%20bug%20que%20j%c3%a1%20encontrei%20uma%20d%c3%bazia%20de%20vezes%20entre%20os%20novatos%20da%20STL%20%c3%a9%20a%20utiliza%c3%a7%c3%a3o%20de%20iteradores%20como%20se%20eles%20n%c3%a3o%20fossem...%20http%3a%2f%2fwww.caloni.com.br%2fiteradores-nao-sao-constantes%2f from @caloni " style="text-decoration: underline;" title="Twitter">twitter</big></a>


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/estranho/">Estranho<span class="icon"><i class="fa fa-arrow-right"></i></span></a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/quando-o-ponteiro-nulo-nao-e-invalido/"><span class="icon"><i class="fa fa-arrow-left"></i></span>Quando o ponteiro nulo não é inválido</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
