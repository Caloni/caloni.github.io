<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  
  
      
  
      
  

  <head>
  <meta charset="utf-8" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Carregando DLLs arbitrárias pelo WinDbg - parte 2</title>
  <meta name="author" content="" />

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta property="og:title" content="Carregando DLLs arbitrárias pelo WinDbg - parte 2"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg-parte-2/"/>
  <meta property="og:image"
        content="/img/author.jpg"/>
  <meta property="og:description"
        content="Como pudemos ver no artigo anterior, o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Por esse motivo, e para tornar as coisas mais divertidas, resolvi..."/>

  
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/img/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">

  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/img/brand.svg">
        <div class="is-6">&nbsp;Blogue do Caloni</div>
      </a>
    </div>

    

  </div>
</nav>


      
      <div class="container">
        
<p class="title">Carregando DLLs arbitrárias pelo WinDbg - parte 2</p>


        <p class="subtitle">

  
    Este é um rascunho e está sujeito a <a style="" href="https://github.com/Caloni/blog/blob/master/content/posts/carregando-dlls-arbitrarias-pelo-windbg-parte-2.md" title="source">mudanças</a>.
  

</p>

        

        
          <div class="content">

            
              <p>Como pudemos ver no artigo anterior, o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Por esse motivo, e para tornar as coisas mais divertidas, resolvi transformar tudo aquilo em um simples script que pode ser executado digitando apenas uma linha.</p>
<p>Se trata do meu primeiro script grande para o WinDbg, por isso, peço que tenham dó de mim =).</p>
<p>Um script no WinDbg nada mais é que uma execução em batch: um arquivo texto cheio de comandos que poderíamos digitar manualmente, mas que preferimos guardar para poupar nossos dedos.</p>
<p>Existem quatro maneiras diferentes de chamar um script no WinDbg, todas muito parecidas, variando apenas se são permitidos espaços antes do nome do arquivo e se os comandos são condensados, isto é, as quebras de linhas substituídas por ponto-e-vírgula para executar tudo em uma linha só.</p>
<ul>
<li>$&lt;nome-do-arquivo - não permite espaços e condensa comandos.</li>
<li>$&gt;&lt;nome-do-arquivo - não permite espaços e não condensa comandos.</li>
<li>$$&lt;nome-do-arquivo - permite espaços e condensa comandos.</li>
<li>$$&gt;&lt;nome-do-arquivo - permite espaços e não condensa comandos.</li>
<li>$$&gt;a&lt;nome-do-arquivo - igual ao anterior, e ainda permite passar argumentos.</li>
</ul>
<p>OBS: a ajuda do WinDbg descreve as diferenças dos comandos acima de forma adversa, afirmando que os comandos '&lt;'  não condensam as linhas e os '&gt;&lt;' o fazem, quando na realidade é o contrário. Não se deixe enganar por esse detalhe.</p>
<p>No caso do script desse artigo, utilizaremos a última forma, pois precisamos de um argumento para funcionar: o nome da DLL. Caso você não digite esse argumento, a ajuda do script será impressa:</p>
<p>Não há qualquer dificuldade. Tudo que você tem que fazer é baixar o script que carrega DLLs e salvá-lo em um lugar de sua preferência. Depois é só digitar o comando que carrega scripts, o path de nosso script e o nome da DLL a ser carregada em uma das três formas exibidas. Eu costumo criar uma pasta chamada &quot;scripts&quot; dentro do diretório de instalação do Debugging Tools, o que quer dizer que posso simplesmente chamar todos meus scripts (ou seja, 1) dessa maneira:</p>
<p>Abaixo um pequeno teste que fiz carregando a DLL do Direct Draw (ddraw.dll) na nossa vítima de plantão:</p>
<p>Simples e indolor.</p>
<p>Vamos agora dar uma olhada no script completo e dissecar as linhas pausadamente. Dessa forma entenderemos como a função inteira funciona e como usar os comandos isoladamente para criar novos scripts.</p>
<p>Como podemos ver, ele é um pouco grandinho. Por isso mesmo que ele é um script, já que não precisamos, sempre que formos usar este comando, ficar olhando para o fonte.</p>
<p>Por falar em olhar, uma primeira olhada revela a seguinte estrutura:</p>
<p>Qualquer semelhança com as instruções em C não é mera coincidência. Essa estrutura de fato verifica se o resultado dentro do .if é verdadeiro. No caso o script verifica se o primeiro parâmetro foi passado, já que os argumentos são acessíveis através dos alias (apelidos) $arg1 - $argn. Essa maneira de usar os argumentos passados no WinDbg ainda não foi documentada, mas encontrei essa dica em um artigo do Roberto Farah, um grande escritor de scripts para o WinDbg.</p>
<p>Da mesma forma, o que não deve ser nenhuma surpresa, o WinDbg suporta comentários. Todas as linhas que contêm '$$' isoladamente são comentários, e seu conteúdo da direita é ignorado, salvo se for encontrado um ponto-e-vírgula.</p>
<p>A primeira coisa que fazemos para carregar a DLL é salvar o estado do registrador IP, que indica onde está a próxima instrução:</p>
<p>Feito isso, usamos um comando não tão comum, mas que pode ser muito útil nos casos em que precisamos capturar algum dado da saída de um comando do WinDbg e usá-lo em outro comando.</p>
<p>A estrutura do .foreach deixa o usuário especificar dois grupos de comandos: o primeiro grupo irá gerar uma saída que pode ser aproveitada no segundo grupo.</p>
<p>A opção &quot;/pS 5&quot; diz ao comando para pular 5 posições antes de capturar o token que será usado no próximo comando. Os tokens são divididos por espaço. Sendo a saída de &quot;.dvalloc 0x1000&quot;</p>
<p>Pulando 5 posições iremos capturar o endereço onde a memória foi alocada. E é isso mesmo que queremos!</p>
<p>O sinônimo do endereço (alias) se torna &quot;addr&quot;, apelido que usamos ao executar o segundo comando, que armazena o endereço no registrador temporário $t0:</p>
<p>Após alocada a memória, gravamos o parâmetro de LoadLibrary, o path da DLL a ser carregada, em seu início.</p>
<p>O código assembly que irá chamar fica um ponto à frente, mas na mesma memória alocada.</p>
<p>Conforme as técnicas vão cada vez ficando mais &quot;não-usuais&quot;, mais difícil fica achar um nome para a coisa. Essa técnica de escrever o assembly de um código através de escritas em hexadecimal dentro de um script do WinDbg eu chamei de &quot;script assembly&quot;. Se tiver um nome melhor, não se acanhe em usá-lo. E me deixe saber =).</p>
<p>Cada comentário de uma instrução em assembly é seguido pela escrita dessa instrução usando o comando e. Se trata de um código bem trivial, fora alguns detalhes que merecem mais atenção.</p>
<p>Os comandos acima servem para salvar e restaurar o estado dos registradores e das flags de execução. Isso permite que possamos executar o código virtualmente em qualquer posição que pararmos no código depurado, já que retornamos tudo como estava ao final da execução do LoadLibrary. É claro que isso não garante que o código estará 100% estável em todas as condições, mas já ajuda um bocado.</p>
<p>Uma chamada através do opcode call (código em hexa 0xe80c) é bem comum e se trata de uma chamada relativa, baseada no estado do Instruction Pointer atual mais o valor especificado. Por isso mesmo que fazemos o cálculo usando o endereço de onde será escrita a próxima instrução, que é o valor que teremos em IP quando este call for executado:</p>
<p>Quando o código estiver completamente escrito na memória alocada, um disassembly dele retornará algo parecido com o código abaixo:</p>
<p>Você pode ver com seus próprio olhos se editar o script comentando o último comando (g), executando o script e executando o disassembly do IP.</p>
<p>Somos um script bem comportado (na medida do possível) e por isso colocamos um breakpoint temporário no final para, quando retornarmos para o código atual, desalocarmos a memória usada para a escrita e execução das instruções.</p>
<p>Eu não me responsabilizo por qualquer (mau) uso do script aqui disponibilizado, assim como as eventuais perdas de código-fonte, trilhas de HD e placas de memória RAM pela sua execução. Assim sendo, bom divertimento.</p>
<p>O criador do DriverEntry me questionou se não seria mais fácil, em vez de escrever todos os opcodes em hexa, usar o comando a, que permite entrar o código assembly diretamente a partir de um endereço especificado. Essa realmente é uma ótima idéia, e de fato eu tentei isso no começo de meus testes. Porém, infelizmente para scripts isso não funciona bem. A partir do comando a o prompt fica esperando uma entrada do usuário, não lendo o assembly que estaria no próprio script. Pior ainda, a escrita do assembly não permite usar os registradores temporários, como $t0 ou $t1, o que nos força a escrever um código dependende de valores constantes. Por esses motivos, tive que apelar para o comando e, que é a forma mais confusa de escrever e entender assembly. Nesse tipo de edição é vital comentar bem cada linha que se escreve.</p>

            

          </div>

        <div class="taglist">
            
    
      <a href="/tags/code">code</a>  <a href="/tags/draft">draft</a> 
    


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/desenhando-em-c-builder/">Desenhando em C&#43;&#43; Builder &#x25B7;</a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg/">&#x25C1; Carregando DLLs arbitrárias pelo WinDbg</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
