<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Carregando DLLs arbitrárias pelo WinDbg - parte 2</title>
  <meta name="author" content="" />
  <meta name="description"
        content="Como pudemos ver no artigo anterior, o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Por esse motivo, e para tornar as coisas mais divertidas, resolvi..."/>

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta itemprop="name" content="Carregando DLLs arbitrárias pelo WinDbg - parte 2"/>
  <meta itemprop="description"
        content="Como pudemos ver no artigo anterior, o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Por esse motivo, e para tornar as coisas mais divertidas, resolvi..."/>
  <meta itemprop="image"
        content=""/>

  
  <meta property="og:title" content="Carregando DLLs arbitrárias pelo WinDbg - parte 2"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg-parte-2/"/>
  <meta property="og:image"
        content=""/>
  <meta property="og:description"
        content="Como pudemos ver no artigo anterior, o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Por esse motivo, e para tornar as coisas mais divertidas, resolvi..."/>
  <meta property="og:site_name" content="Blogue do Caloni"/>
  <meta property="article:published_time"
        content="2007-11-27T00:00:00&#43;00:00"/>
  <meta property="article:section" content="post"/>

  
  
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site"
        content=""/>
  <meta name="twitter:title" content="Carregando DLLs arbitrárias pelo WinDbg - parte 2"/>
  <meta name="twitter:description"
        content="Como pudemos ver no artigo anterior, o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Por esse motivo, e para tornar as coisas mais divertidas, resolvi..."/>
  <meta name="twitter:creator"
        content=""/>
  <meta name="twitter:image:src"
        content="
                     /images/movies.png
                   "/>

  
  <link href="" rel="alternate" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">
  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/brand.svg">
        <div class="title is-6">&nbsp;Blogue do Caloni</div>
      </a>

      
      <label class="button navbar-burger is-white" for="navbar-burger-state">
        <span></span>                               
        <span></span>
        <span></span>
      </label>
    </div>

    
    <input type="checkbox" id="navbar-burger-state"/>

    <div class="navbar-menu">
      <div class="navbar-end" style="padding: 10px;">
      <big><b>
       <a title="posts dessa categoria" href="/categories/blog">blog</a>  <a title="posts dessa categoria" href="/categories/cinema">cinema</a>  <a title="posts dessa categoria" href="/categories/code">code</a> 
      </big></b>
      </div>
    </div>

  </div>
</nav>


      
      <div class="container">
        <p class="title">Carregando DLLs arbitrárias pelo WinDbg - parte 2</p>

        <p class="subtitle">
<i>

    <a href="https://github.com/Caloni/blog/blob/master/content/post/carregando-dlls-arbitrarias-pelo-windbg-parte-2.md" title="source">
    2007-11-27
    </a>

</p>

        <div class="taglist">
            <i>Este ainda é um rascunho publicado prematuramente e está sujeito a mudanças substanciais.</i>

        </div>

        

        
          <div class="content">
            
              <p>Como pudemos ver no artigo anterior, o processo para carregar uma DLL pelo WinDbg é muito extenso, enfadonho e sujeito a erros. Por esse motivo, e para tornar as coisas mais divertidas, resolvi transformar tudo aquilo em um simples script que pode ser executado digitando apenas uma linha.</p>
<p>Se trata do meu primeiro script grande para o WinDbg, por isso, peço que tenham dó de mim =).</p>
<p>Um script no WinDbg nada mais é que uma execução em batch: um arquivo texto cheio de comandos que poderíamos digitar manualmente, mas que preferimos guardar para poupar nossos dedos.</p>
<p>Existem quatro maneiras diferentes de chamar um script no WinDbg, todas muito parecidas, variando apenas se são permitidos espaços antes do nome do arquivo e se os comandos são condensados, isto é, as quebras de linhas substituídas por ponto-e-vírgula para executar tudo em uma linha só.</p>
<ul>
<li>$&lt;nome-do-arquivo - não permite espaços e condensa comandos.</li>
<li>$&gt;&lt;nome-do-arquivo - não permite espaços e não condensa comandos.</li>
<li>$$&lt;nome-do-arquivo - permite espaços e condensa comandos.</li>
<li>$$&gt;&lt;nome-do-arquivo - permite espaços e não condensa comandos.</li>
<li>$$&gt;a&lt;nome-do-arquivo - igual ao anterior, e ainda permite passar argumentos.</li>
</ul>
<p>OBS: a ajuda do WinDbg descreve as diferenças dos comandos acima de forma adversa, afirmando que os comandos &lsquo;&lt;&rsquo;  não condensam as linhas e os &lsquo;&gt;&lt;&rsquo; o fazem, quando na realidade é o contrário. Não se deixe enganar por esse detalhe.</p>
<p>No caso do script desse artigo, utilizaremos a última forma, pois precisamos de um argumento para funcionar: o nome da DLL. Caso você não digite esse argumento, a ajuda do script será impressa:</p>
<pre><code>How to use:
$$&gt;a&lt;path\LoadLibrary.txt mydll.dll
$$&gt;a&lt;path\LoadLibrary.txt c:\\path\\mydll.dll
$$&gt;a&lt;path\LoadLibrary.txt &quot;c:\\path with space\\mydll.dll&quot;
</code></pre>
<p>Não há qualquer dificuldade. Tudo que você tem que fazer é baixar o script que carrega DLLs e salvá-lo em um lugar de sua preferência. Depois é só digitar o comando que carrega scripts, o path de nosso script e o nome da DLL a ser carregada em uma das três formas exibidas. Eu costumo criar uma pasta chamada &ldquo;scripts&rdquo; dentro do diretório de instalação do Debugging Tools, o que quer dizer que posso simplesmente chamar todos meus scripts (ou seja, 1) dessa maneira:</p>
<pre><code>$$&gt;a&lt;scripts\LoadLibrary.txt mydll.dll
</code></pre>
<p>Abaixo um pequeno teste que fiz carregando a DLL do Direct Draw (ddraw.dll) na nossa vítima de plantão:</p>
<pre><code>windbg notepad.exe
Microsoft (R) Windows Debugger Version 6.8.0004.0 X86
Copyright (c) Microsoft Corporation. All rights reserved.
CommandLine: notepad.exe
Symbol search path is: SRV*C:\Symbols*http://msdl.microsoft.com/downloads/symbols
Executable search path is:
ModLoad: 01000000 01014000   notepad.exe
ModLoad: 7c900000 7c9b0000   ntdll.dll
ModLoad: 7c800000 7c8f5000   C:\WINDOWS\system32\kernel32.dll
...
ModLoad: 73000000 73026000   C:\WINDOWS\system32\WINSPOOL.DRV
(8e8.214): Break instruction exception - code 80000003 (first chance)
eax=001a1eb4 ebx=7ffdf000 ecx=00000000 edx=00000001 esi=001a1f48 edi=001a1eb4
eip=7c901230 esp=0007fb20 ebp=0007fc94 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
ntdll!DbgBreakPoint:
7c901230 cc              int     3
0:000&gt; $$&gt;addraw.dll
ModLoad: 73bc0000 73bc6000   C:\WINDOWS\system32\DCIMAN32.dll
ModLoad: 76390000 763ad000   C:\WINDOWS\system32\IMM32.DLL
ModLoad: 629c0000 629c9000   C:\WINDOWS\system32\LPK.DLL
ModLoad: 74d90000 74dfb000   C:\WINDOWS\system32\USP10.dll
Freed 0 bytes starting at 00280000
eax=001a1eb4 ebx=7ffdf000 ecx=00000000 edx=00000001 esi=001a1f48 edi=001a1eb4
eip=7c901230 esp=0007fb20 ebp=0007fc94 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
ntdll!DbgBreakPoint:
7c901230 cc              int     3
</code></pre>
<p>Simples e indolor.</p>
<p>Vamos agora dar uma olhada no script completo e dissecar as linhas pausadamente. Dessa forma entenderemos como a função inteira funciona e como usar os comandos isoladamente para criar novos scripts.</p>
<pre><code>$$
$$ @brief Loads a module inside the debuggee process.
$$ @author Wanderley Caloni &lt;wanderley@caloni.com.br&gt;
$$ @date 2007-11
$$
.if( ${/d:$arg1} )
{
    r $t2 = @$ip
    .foreach /pS 5 ( addr { .dvalloc 0x1000 } ) { r$t0 = addr }
    r $t1 = @$t0 + 0x100
    eza @$t0 &quot;${$arg1}&quot;
    .echo Trying to load the following module:
    da @$t0
    $$ push $ip
    eb @$t1 0x68
    ed @$t1 + 0x01 @$t2
    $$ pushfd
    eb @$t1 + 0x05 0x9c
    $$ pushad
    eb @$t1 + 0x06 0x60
    $$ push $t0
    eb @$t1 + 0x07 0x68
    ed @$t1 + 0x08 @$t0
    $$ call LoadLibrary
    eb @$t1 + 0x0c 0xe8
    ed @$t1 + 0x0d ( kernel32!LoadLibraryA - @$t1 - 0x11 )
    $$ popad
    eb @$t1 + 0x11 0x61
    $$ popfd
    eb @$t1 + 0x12 0x9d
    $$ ret
    eb @$t1 + 0x13 0xc3
    r $ip = @$t1
    bp /1 @$t2 &quot;.dvfree @$t0 0&quot;
    g
}
.else
{
   .echo How to use:
   .echo $$&gt;a&lt;path\LoadLibrary.txt mydll.dll
   .echo $$&gt;a&lt;path\LoadLibrary.txt c:\\path\\mydll.dll
   .echo $$&gt;a&lt;path\LoadLibrary.txt &quot;c:\\path with space\\mydll.dll&quot;
}
</code></pre>
<p>Como podemos ver, ele é um pouco grandinho. Por isso mesmo que ele é um script, já que não precisamos, sempre que formos usar este comando, ficar olhando para o fonte.</p>
<p>Por falar em olhar, uma primeira olhada revela a seguinte estrutura:</p>
<pre><code>.if( ${/d:$arg1} )
{
   ...
}
.else
{
   ...
}
</code></pre>
<p>Qualquer semelhança com as instruções em C não é mera coincidência. Essa estrutura de fato verifica se o resultado dentro do .if é verdadeiro. No caso o script verifica se o primeiro parâmetro foi passado, já que os argumentos são acessíveis através dos alias (apelidos) $arg1 - $argn. Essa maneira de usar os argumentos passados no WinDbg ainda não foi documentada, mas encontrei essa dica em um artigo do Roberto Farah, um grande escritor de scripts para o WinDbg.</p>
<p>Da mesma forma, o que não deve ser nenhuma surpresa, o WinDbg suporta comentários. Todas as linhas que contêm &lsquo;$$&rsquo; isoladamente são comentários, e seu conteúdo da direita é ignorado, salvo se for encontrado um ponto-e-vírgula.</p>
<p>A primeira coisa que fazemos para carregar a DLL é salvar o estado do registrador IP, que indica onde está a próxima instrução:</p>
<pre><code>    r $t2 = @$ip
</code></pre>
<p>Feito isso, usamos um comando não tão comum, mas que pode ser muito útil nos casos em que precisamos capturar algum dado da saída de um comando do WinDbg e usá-lo em outro comando.</p>
<p>A estrutura do .foreach deixa o usuário especificar dois grupos de comandos: o primeiro grupo irá gerar uma saída que pode ser aproveitada no segundo grupo.</p>
<pre><code>.foreach /pS 5 $$pula; ( addr $$alias; { .dvalloc 0x1000 $$saída; } ) { r$t0 = addr }
</code></pre>
<p>A opção &ldquo;/pS 5&rdquo; diz ao comando para pular 5 posições antes de capturar o token que será usado no próximo comando. Os tokens são divididos por espaço. Sendo a saída de &ldquo;.dvalloc 0x1000&rdquo;</p>
<pre><code>Allocated 1000 bytes starting at 00280000
</code></pre>
<p>Pulando 5 posições iremos capturar o endereço onde a memória foi alocada. E é isso mesmo que queremos!</p>
<pre><code>1         2    3     4        5  6
Allocated 1000 bytes starting at 00280000
</code></pre>
<p>O sinônimo do endereço (alias) se torna &ldquo;addr&rdquo;, apelido que usamos ao executar o segundo comando, que armazena o endereço no registrador temporário $t0:</p>
<pre><code>r$t0 = addr
</code></pre>
<p>Após alocada a memória, gravamos o parâmetro de LoadLibrary, o path da DLL a ser carregada, em seu início.</p>
<pre><code>eza @$t0 &quot;${$arg1}&quot;
</code></pre>
<p>O código assembly que irá chamar fica um ponto à frente, mas na mesma memória alocada.</p>
<pre><code>r $t1 = @$t0 + 0x100
</code></pre>
<p>Conforme as técnicas vão cada vez ficando mais &ldquo;não-usuais&rdquo;, mais difícil fica achar um nome para a coisa. Essa técnica de escrever o assembly de um código através de escritas em hexadecimal dentro de um script do WinDbg eu chamei de &ldquo;script assembly&rdquo;. Se tiver um nome melhor, não se acanhe em usá-lo. E me deixe saber =).</p>
<pre><code>    $$ push $ip
    eb @$t1 0x68
    ed @$t1 + 0x01 @$t2
    $$ pushfd
    eb @$t1 + 0x05 0x9c
    $$ pushad
    eb @$t1 + 0x06 0x60
    $$ push $t0
    eb @$t1 + 0x07 0x68
    ed @$t1 + 0x08 @$t0
    $$ call LoadLibrary
    eb @$t1 + 0x0c 0xe8
    ed @$t1 + 0x0d ( kernel32!LoadLibraryA - @$t1 - 0x11 )
    $$ popad
    eb @$t1 + 0x11 0x61
    $$ popfd
    eb @$t1 + 0x12 0x9d
    $$ ret
    eb @$t1 + 0x13 0xc3
</code></pre>
<p>Cada comentário de uma instrução em assembly é seguido pela escrita dessa instrução usando o comando e. Se trata de um código bem trivial, fora alguns detalhes que merecem mais atenção.</p>
<p>Os comandos acima servem para salvar e restaurar o estado dos registradores e das flags de execução. Isso permite que possamos executar o código virtualmente em qualquer posição que pararmos no código depurado, já que retornamos tudo como estava ao final da execução do LoadLibrary. É claro que isso não garante que o código estará 100% estável em todas as condições, mas já ajuda um bocado.</p>
<p>Uma chamada através do opcode call (código em hexa 0xe80c) é bem comum e se trata de uma chamada relativa, baseada no estado do Instruction Pointer atual mais o valor especificado. Por isso mesmo que fazemos o cálculo usando o endereço de onde será escrita a próxima instrução, que é o valor que teremos em IP quando este call for executado:</p>
<pre><code>( kernel32!LoadLibraryA - @$t1 - 0x11 )
</code></pre>
<p>Quando o código estiver completamente escrito na memória alocada, um disassembly dele retornará algo parecido com o código abaixo:</p>
<pre><code>push    offset ntdll!DbgBreakPoint (7c901230) ; empilhamos o IP atual (endereço de retorno)
pushfd ; salva estado das flags atual
pushad ; salva estado dos registradores atual
push    8F0000h ; empilha endereço do path da dll a ser carregada
call    kernel32!LoadLibraryA (7c801d77) ; chamamos LoadLibraryA
popad ; restaura estado dos registradores
popfd ; restaura estado das flags
ret ; retorna para o ponto onde o depurador parou (no caso, 7c901230)
</code></pre>
<p>Você pode ver com seus próprio olhos se editar o script comentando o último comando (g), executando o script e executando o disassembly do IP.</p>
<pre><code>u @$ip
</code></pre>
<p>Somos um script bem comportado (na medida do possível) e por isso colocamos um breakpoint temporário no final para, quando retornarmos para o código atual, desalocarmos a memória usada para a escrita e execução das instruções.</p>
<pre><code>bp /1 @$t2 &quot;.dvfree @$t0 0&quot;
</code></pre>
<p>Eu não me responsabilizo por qualquer (mau) uso do script aqui disponibilizado, assim como as eventuais perdas de código-fonte, trilhas de HD e placas de memória RAM pela sua execução. Assim sendo, bom divertimento.</p>
<p>O criador do DriverEntry me questionou se não seria mais fácil, em vez de escrever todos os opcodes em hexa, usar o comando a, que permite entrar o código assembly diretamente a partir de um endereço especificado. Essa realmente é uma ótima idéia, e de fato eu tentei isso no começo de meus testes. Porém, infelizmente para scripts isso não funciona bem. A partir do comando a o prompt fica esperando uma entrada do usuário, não lendo o assembly que estaria no próprio script. Pior ainda, a escrita do assembly não permite usar os registradores temporários, como $t0 ou $t1, o que nos força a escrever um código dependende de valores constantes. Por esses motivos, tive que apelar para o comando e, que é a forma mais confusa de escrever e entender assembly. Nesse tipo de edição é vital comentar bem cada linha que se escreve.</p>

            

          </div>

        <div class="taglist">
            
    
      [<a href="/categories/code">code</a>] 
      [<a href="/tags/draft">draft</a>] 
    
    <a href="https://twitter.com/intent/tweet?text=Como%20pudemos%20ver%20no%20artigo%20anterior%2c%20o%20processo%20para%20carregar%20uma%20DLL%20pelo%20WinDbg%20%c3%a9%20muito%20extenso%2c%20enfadonho%20e%20sujeito%20a...%20http%3a%2f%2fwww.caloni.com.br%2fcarregando-dlls-arbitrarias-pelo-windbg-parte-2%2f from @caloni " style="text-decoration: underline;" title="Twitter">twitter</big></a>


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/desenhando-em-c-builder/">Desenhando em C&#43;&#43; Builder<span class="icon"><i class="fa fa-arrow-right"></i></span></a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/carregando-dlls-arbitrarias-pelo-windbg/"><span class="icon"><i class="fa fa-arrow-left"></i></span>Carregando DLLs arbitrárias pelo WinDbg</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
