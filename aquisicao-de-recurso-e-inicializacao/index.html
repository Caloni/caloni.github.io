<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  
  
      
  
      
  

  <head>
  <meta charset="utf-8" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Aquisição de recurso é inicialização</title>
  <meta name="author" content="" />

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta property="og:title" content="Aquisição de recurso é inicialização"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/aquisicao-de-recurso-e-inicializacao/"/>
  <meta property="og:image"
        content="/img/author.jpg"/>
  <meta property="og:description"
        content="O título desse artigo é uma técnica presente no paradigma da programação em C&#43;&#43;, razão pela qual não temos o operador finally. A idéia por trás dessa técnica é conseguirmos usar recursos representados..."/>

  
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/img/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">

  <div class="container">

    <div class="navbar-brand">
        <img alt="Brand" src="/img/brand.svg">
        &nbsp;
        <a class="navbar-item" title="Go to Home" href="/">
            <div class="is-6">Blogue do Caloni</div>
        </a>
    </div>

    

  </div>
</nav>


      
      <div class="container">
        <p class="title">

Aquisição de recurso é inicialização

</p>

        <p class="subtitle">

  Wanderley Caloni,
  
    
  
    
  
  2007-09-14<a href="https://github.com/Caloni/blog/blob/master/content/posts/aquisicao-de-recurso-e-inicializacao.md">.</a>

</p>

        

        
          <div class="content">

            
              <p>O título desse artigo é uma técnica presente no paradigma da programação em C++, razão pela qual <a href="http://public.research.att.com/~bs/bs_faq2.html#finally">não temos o operador finally</a>. A idéia por trás dessa técnica é conseguirmos usar recursos representados por objetos locais de maneira que ao final da função esses objetos sejam destruídos e, junto com eles, os recursos que foram alocados. Podemos chamar de recursos aquele arquivo que necessita ser aberto para escrita, o bitmap que é exibido na tela, o ponteiro de uma interface COM, etc. O nosso exemplo é sobre arquivos:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">File</span>
{
	<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	File(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> fileName)
	{
		m_file <span style="color:#f92672">=</span> CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, 
		NULL, OPEN_EXISTING, <span style="color:#ae81ff">0</span>, NULL); <span style="color:#75715e">// if we open the file...
</span><span style="color:#75715e"></span>	}

	<span style="color:#f92672">~</span>File()
	{
		CloseHandle(m_file); <span style="color:#75715e">// ... we need to close it!
</span><span style="color:#75715e"></span>		m_file <span style="color:#f92672">=</span> NULL;
	}

	HANDLE m_file; <span style="color:#75715e">// aquired resource
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">UseFile</span>()
{
	File config(<span style="color:#e6db74">&#34;config.txt&#34;</span>); <span style="color:#75715e">// local object: aquired resource
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// using config.txt
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// the aquired resource  (config.txt) is automagically released
</span><span style="color:#75715e"></span>} 

</code></pre></div><p>Ignorei tratamento de erros e a dor de cabeça que é a discussão sobre inicializações dentro do construtor, matéria para um outro artigo. Fora os detalhes, o que temos é: 1. uma classe que se preocupa em alocar os recursos que necessita e no seu fim desalocá-los, 2. uma função que usa um objeto dessa classe, alegremente apenas preocupada em usar e abusar do objeto. A demonstração da técnica reside no fato que a função não se preocupa em desalocar os recursos alocados pelo objeto config. Algo óbvio, desejável e esperado.</p>
<h4 id="uma-mão-lava-a-outra-ou-técnicas-de-uma-mesma-linguagem-se-ajudam">Uma mão lava a outra (ou &quot;técnicas de uma mesma linguagem se ajudam&quot;)</h4>
<p>Para vislumbrarmos melhor a utilidade dessa técnica convém lidarmos com as famigeradas <strong>exceções</strong>. A possibilidade de nossa função ou alguma função chamada por essa lançar uma exceção enquanto nosso objeto está ainda construído - e com o recurso alocado - faz com que seja vital a classe do objeto ter sido bem construída a ponto de prever essa situação e liberar os recursos no destrutor. Daí o uso da técnica se torna necessário.</p>
<p>Por outro lado, ao usarmos objetos, devemos ter <strong>plena confiança</strong> nas suas capacidades de gerenciar os recursos que foram por eles alocados. Só assim se tem liberdade o suficiente para nos concentrarmos no código da função e solenemente ignorarmos a implementação da classe que estamos utilizando. Afinal, temos que considerar que muitas vezes o código-fonte não está disponível. Veja a mesma função com uma chance de desvio incondicional (o lançamento de uma exceção):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BlowUpFunction</span>()
{
	<span style="color:#75715e">// the things are not that good. so...
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">throw</span> Scatadush();
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">UseFileEx</span>()
{
	File config(<span style="color:#e6db74">&#34;config.txt&#34;</span>); <span style="color:#75715e">// local object: aquired resource
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// using config.txt
</span><span style="color:#75715e"></span>	BlowUpFunction(); <span style="color:#75715e">// an exception is thrown: config.txt is automagically released
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// using config.txt
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// the aquired resource  (config.txt) is released automagically
</span><span style="color:#75715e"></span>} 

</code></pre></div><p>Nesse exemplo tudo funciona, certo? Até se a exceção for lançada, o recurso será desalocado, pois o objeto é destruído. Isso ilustra como várias técnicas de C++ podem conviver harmoniosamente. Mais que isso, se ajudam mutuamente. O que seria das exceções se não existissem os construtores e destrutores? Da mesma forma, os recursos são alocados e desalocados baseado na premissa de construção e destruição de objetos. Por sua vez, essa premissa vale em qualquer situação, existindo ou não exceções.</p>
<p>Agora, e se a exceção de BlowUpFunction é lançada e a classe File não está preparada para fechar o arquivo no destrutor? Esse é o caso da versão 2 de nossa classe File, logo abaixo. Apesar de ser a segunda versão ela foi piorada (acontece nas melhores famílias e classes):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">File2</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#75715e">// the user MUST open the file before the object construction
</span><span style="color:#75715e"></span>	DWORD Open(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> fileName)
	{
		m_file <span style="color:#f92672">=</span> CreateFile(fileName, GENERIC_READ, FILE_SHARE_READ, 
			NULL, OPEN_EXISTING, <span style="color:#ae81ff">0</span>, NULL);
	}

	<span style="color:#75715e">// ... and MUST close it before its destruction
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Close</span>()
	{
		CloseHandle(m_file);
		m_file <span style="color:#f92672">=</span> NULL;
	}

	HANDLE m_file; <span style="color:#75715e">// aquired resource
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">UseFile2</span>()
{
	File2 config; <span style="color:#75715e">// local object
</span><span style="color:#75715e"></span>
	config.Open(<span style="color:#e6db74">&#34;config.txt&#34;</span>); <span style="color:#75715e">// aquired resource
</span><span style="color:#75715e"></span>
	<span style="color:#75715e">// using config...
</span><span style="color:#75715e"></span>	BlowUpFunction(); <span style="color:#75715e">// exception thrown: the resource was NOT released
</span><span style="color:#75715e"></span>	<span style="color:#75715e">// using config...
</span><span style="color:#75715e"></span>
	config.Close(); <span style="color:#75715e">// resource released
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
} 

</code></pre></div><p>Nesse caso o código de UseFile2 acaba deixando um recurso alocado por conta de uma exceção que ocorreu em uma função secundária chamada lá pelas tantas em um momento delicado demais para ocorrerem exceções. Note que o destrutor de File2 é chamado assim como o de File, só que este não libera os recursos do objeto. Ele não usa a técnica RAII (Resource Acquisition Is Initialization, ou o título do artigo em inglês).</p>
<h4 id="poghttpdesciclopediawswikipog-aplicado"><a href="http://desciclo.pedia.ws/wiki/POG">POG</a> aplicado</h4>
<p>Nesse tipo de classe o convívio com exceções gera um dilema: onde está o erro? Como consertá-lo? Se o problema é encontrado numa hora apertada e temos cinco minutos para revolver isso, capturar a exceção causada por BlowUpFunction é uma boa idéia. Só que nem sempre as soluções de cinco minutos são as mais maduras. Podemos não saber muito bem o que fazer com esse tipo de exceção, por exemplo. Isso geraria um tratamento de erro ou redundante - se tratarmos ali mesmo o Scatadush, já tratado em um escopo mais externo - ou fragmentado - se apenas desalocarmos o recurso de File2 e relançarmos a exceção. Eu nem diria fragmentado, pois estamos tratando um erro inventado, se considerarmos que é função dos objetos desalocarem os recursos que foram por eles mesmos alocados.</p>
<p>A opção que dura mais de cinco minutos pode evitar futuras dores de cabeça: arregaçar as mangas e refazer a classe File2 observando o princípio de RAII. Possivelmente algo na interface deverá ser alterado, o que causará a alteração de mais códigos-fonte que utilizam essa classe. Alterar mais códigos-fonte significa testar novamente mais partes do software, algumas nem de perto relacionadas com o problema em si. Ou seja, não é cômodo, mas é íntegro. Sabendo que futuras funções que usarem essa classe já estarão corretas, mesmo que uma exceção seja lançada e não seja capturada, é um dado significativo: representa produtividade futura.</p>
<p>A decisão sobre qual solução é a melhor está muito além do escopo desse artigo, pois obviamente cada caso é um caso. Mas não custa nada pensar um pouco sobre C++ quando se estiver programando. E &quot;aquisição de recurso é inicialização&quot; faz parte do modo de pensar dessa linguagem.</p>

            

          </div>

        <div class="taglist">
            
    
      <a href="/tags/draft">draft</a>  <a href="/tags/code">code</a> 
    


        </div>

        <div class="navigation-bottom">
            <span class="next-in-section"><a href="http://www.caloni.com.br/hook-de-com-no-windbg/">&#x25C1; Hook de COM no WinDbg</a></span>
<span class="prev-in-section"><a href="http://www.caloni.com.br/guia-basico-de-controle-de-codigo-source-safe/">&#x25B7; Guia básico de controle de código (Source Safe)</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2021<a href="https://github.com/Caloni/blog">.</a> </i></span>
  </div>
</footer>

  </body>

</html>
