<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  
  
      
  
      
  

  <head>
  <meta charset="utf-8" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Convenção de Chamada</title>
  <meta name="author" content="" />

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta property="og:title" content="Convenção de Chamada"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/convencao-de-chamada/"/>
  <meta property="og:image"
        content="/img/author.jpg"/>
  <meta property="og:description"
        content="Pergunta de um leitor:
Resposta do Autor: Por que C é zoado :P
OK, a verdade é que não existem (existiam?) muitas regras de sintaxe a serem respeitadas na linguagem pelo compilador. Antigamente, se..."/>

  
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/img/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">

  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/img/brand.svg">
        <div class="is-6">&nbsp;Blogue do Caloni</div>
      </a>
    </div>

    

  </div>
</nav>


      
      <div class="container">
        
<p class="title">Convenção de Chamada</p>


        <p class="subtitle">

  
    Este é um rascunho e está sujeito a <a style="" href="https://github.com/Caloni/blog/blob/master/content/posts/convencao-de-chamada.md" title="source">mudanças</a>.
  

</p>

        

        
          <div class="content">

            
              <p>Pergunta de um leitor:</p>
<p>Resposta do Autor: Por que C é zoado :P</p>
<p>OK, a verdade é que não existem (existiam?) muitas regras de sintaxe a serem respeitadas na linguagem pelo compilador. Antigamente, se não fosse colocado nenhum tipo de retorno era como se ele fosse int por default. Da mesma forma, se não colocar parâmetros vale tudo. É como se fossem os três pontinhos do printf. Afinal, você não ia querer ficar repetindo os parâmetros no .c e no .h, não é mesmo :D</p>
<p>Isso me lembra também que havia a declaração &quot;arcaica&quot; da linguagem (já era arcaica antes mesmo do padrão de 1998 sair):</p>
<p>Sim, sua suposição a respeito do vaargs faz todo sentido. E não, os parâmetros não são inutilizados justamente porque a função chamada pode fazer o que quiser que no retorno o chamador limpa a pilha (e o chamador sabe como ele empilhou os parâmetros-extra).</p>
<p>O padrão de chamada da linguagem (lembra disso?) é cdecl. Isso quer dizer que o chamador é que &quot;limpa a sujeira&quot; depois da chamada. Isso é o que permite o &quot;milagre&quot; do printf (oooohhh ooohh oooooohhhh... sons de anjos cantando) receber n argumentos.</p>
<p>Só vai dar problema se definir outro padrão de chamada ou se a função chamada mexer no que não devia (se esperar outros tipos ou número de argumentos, por exemplo).</p>
<p>Agora que sabemos disso, o comportamento do valist nem deve parecer tão mágico assim. Na verdade, apenas saber que a pilha é onde estão todas as variáveis locais e os endereços de retorno das funções é o suficiente para explorar essa área de memória.</p>
<p>Porém, o uso canônico na linguagem C e a forma mais educada de navegar nos parâmetros extras é usando o header stdarg.h. Isso porque C é uma linguagem independente de plataforma, e a priori não temos a mínima ideia de como os dados estão estruturados no computador. Essa visão das variáveis locais e etc é apenas algo que sabemos sobre a arquitetura PC (8086) porque já brincamos demais de assembly e seus registradores.</p>
<p>Uma versão de quem já manja dos internals da arquitetura onde está programando e não se importa com portabilidade poderia simplesmente caminhar pela pilha a partir do endereço de argc.</p>
<p>Repetindo: isso não é bonito, apesar de simpático. No entanto, se o objetivo é explorar a arquitetura, fique à vontade para navegar pela pilha a partir do endereço das variáveis locais.</p>

            

          </div>

        <div class="taglist">
            
    
      <a href="/tags/code">code</a>  <a href="/tags/draft">draft</a> 
    


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/whiplash/">Whiplash: Em Busca da Perfeição &#x25B7;</a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/a-vida-privada-dos-hipopotamos/">&#x25C1; A Vida Privada dos Hipopótamos</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
