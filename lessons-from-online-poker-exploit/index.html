<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  
  
      
  
      
  

  <head>
  <meta charset="utf-8" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Lessons From Online Poker Exploit</title>
  <meta name="author" content="" />

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta property="og:title" content="Lessons From Online Poker Exploit"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/lessons-from-online-poker-exploit/"/>
  <meta property="og:image"
        content="/img/author.jpg"/>
  <meta property="og:description"
        content="Em 2014 eu palestrei na trilha de segurança do TDC em São Paulo um tema que me deixou muito animado: um exploit baseado em falhas de programação em um código de 10 linhas. O código era tão simples que..."/>

  
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/img/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">

  <div class="container">

    <div class="navbar-brand">
        <img alt="Brand" src="/img/brand.svg">
        &nbsp;
        <a class="navbar-item" title="Go to Home" href="/">
            <div class="is-6">Blogue do Caloni</div>
        </a>
    </div>

    

  </div>
</nav>


      
      <div class="container">
        <p class="title">

Lessons From Online Poker Exploit

</p>

        

        
          <div class="content">

            
              <p>Em 2014 eu palestrei na trilha de segurança do TDC em São Paulo um tema que me deixou muito animado: um exploit baseado em falhas de programação em um código de 10 linhas. O código era tão simples que achei válido traduzir para C e demonstrar como atacar uma simulação de cassino online.</p>
<p>Esta palestra (e o código) se perdeu no tempo, mas eu anotei o nome da pesquisadora que escreveu o post pelo qual me baseei: Laura Diane Hamilton (que também estuda Machine Learning em seu blog). <a href="http://www.lauradhamilton.com/random-lessons-online-poker-exploit">Seu post</a> comenta sobre uma história de 1990 quando hackers se aproveitaram de falhas básicas no algoritmo de embaralhamento de cartas de pôquer.</p>
<p>O código original estava escrito em Pascal, mas é facilmente traduzido para C:</p>
<pre><code>unsigned char Card[52];
unsigned char CurrentCard = 0;
unsigned char JustShuffled = 0;

void DeckShuffle()
{
  unsigned char ctr;
  unsigned char tmp;
  unsigned char random_number;

  /* Fill the deck with unique cards */
  for( ctr = 0; ctr &lt; 52; ctr++ )
    Card[ctr] = ctr + 1;

  /* Generate a new seed based on the system clock */
  srand(time(NULL));

  /* Randomly rearrange each card */
  for( ctr = 0; ctr &lt; 52; ctr++ )
  {
    random_number = rand() % 51;
    tmp = card[random_number];
    card[random_number] = card[ctr];
    card[ctr] = tmp;
  }

  CurrentCard = 0;
  JustShuffled = 1;
}
</code></pre>
<p>Fiz um código para compilar e rodar o embaralhador de cartas que <a href="/code/shuffle_cards.c">embaralha e imprime</a> a saída em cada nova execução para podermos observar mais facilmente os bugs encontrados por Hamilton. A falha número 1, o &quot;An Off-by-One Error&quot;, pode ser feita em C também, se você usar a função rand() da maneira como está no código:</p>
<pre><code>random_number = rand() % 51;
</code></pre>
<p>É um erro simples de ser cometido por programadores incautos, que querem expressar na verdade a obtenção de um número aleatório entre 1 e 52 e ao mesmo tempo obter o índice correto 0-based de um array. No entanto, o resto de uma divisão por N sempre irá cair entre 0 e N-1, já obtendo o índice correto em C.</p>
<pre><code>random_number = rand() % 52;
</code></pre>
<p>Para observar o que Hamilton quer dizer com &quot;a 52a. carta nunca irá cair na 52a. posição&quot; é possível forçar um loop nesse estilo:</p>
<pre><code>/* call only once in main */
srand(time(NULL));

do
{
  DeckShuffle();
}
while( Card[51] != 52 );
</code></pre>
<p>Este loop nunca irá terminar. Faça o teste. Depois compare com a rapidez com que o loop encontra a carta 52 em qualquer outra posição.</p>
<p>A segunda falha, &quot;The Shuffle Isn't Uniform&quot;, diz respeito à distribuição não-uniforme da igual probabilidade de certas cartas estarem em qualquer posição da pilha. Da maneira com que é implementado o algoritmo essa distribuição é enviesada. Temos como provar isso atribuindo pesos a cada embaralhada e depois de um certo tempo exibir os totais:</p>
<pre><code>int CardStats[52];
int j, j2;

for( j = 0; j &lt; 1000; ++j )
{
  for( j2 = 0; j2 &lt; 1000; ++j2 )
  {
    DeckShuffle();
    for( i = 0; i &lt; 52; ++i )
      if( Card[i] == i+1 )
        CardStats[i]++;
  }
}

printf(&quot;cards stats: \n&quot;);
for( i = 0; i &lt; 52; ++i )
{
  printf(&quot;%d &quot;, CardStats[i]);
}
</code></pre>
<p>A versão original do algoritmo rodando um milhão de vezes demonstra o viés de forma descarada:</p>
<pre><code>cards stats:
19270 18869 18685 18442 
18348 18024 18119 17647 
17612 17388 17661 17360 
17183 17018 17176 16621 
16705 16522 16337 16599 
16499 16238 16315 15970 
16294 16388 16294 16418 
16463 16313 16462 16491 
16450 16384 16674 16736 
16577 16879 16933 17159 
17417 17344 17672 18025 
17883 18053 18107 18691 
19042 19152 19559 0
</code></pre>
<p>Com a correção desse viés (e do bug da 52a. carta) aplicada:</p>
<pre><code>random_number = rand() % (ctr - 52) + ctr;
</code></pre>
<p>O resultado se torna muito mais uniforme:</p>
<pre><code>cards stats:
19116 19035 19371 19328 
19293 19327 19308 19277 
19412 19231 19314 19192 
19200 19229 19461 19398 
19299 19314 19452 19291 
19329 19003 19354 19282 
19319 19237 19255 19149 
19321 19291 19123 19266 
19237 19443 19355 19318 
19321 19127 19147 19277 
19250 19307 19353 19169 
19047 19225 19310 19297 
19298 19423 19370 19213
</code></pre>
<p>No entanto, o pior bug talvez seja a união entre a terceira e a quarta falhas apontadas pela pesquisadora: &quot;Using a 32-bit Seed&quot; + &quot;Using the System Clock as a Seed&quot;. Com esses dois unidos o hackerismo fica à solta, pois além das possibilidades de embaralhamento ficarem restritas em 2^32 o uso do clock limita em 86,400,000 milissegundos por dia da função random do Pascal. Em C poderia ser feito algo semelhante.</p>
<p>Um range muito específico de geração da semente do gerador de números aleatórios pode criar uma tabela maleável de possibilidades. Com isso em mãos, de acordo com Hamilton, uma vez que o atacante saiba pelo menos cinco cartas é possível fazer uma busca rápida em um range pequeno possibilidades. Em um jogo de pôquer isso é possível apenas com duas cartas em sua mão e as três cartas na mesa (flop).</p>
<p>Com base nesse comportamento vamos criar um <a href="/code/cassino_exploit.c">exploit</a> que recebe as três cartas do flop fornecidas pelo atacante que está no jogo e que inicia uma busca a partir do horário atual para trás. Conforme o programa encontra matches dessas três cartas juntas ele exibe o deck completo de cartas, a partir do qual o atacante pode verificar se suas cartas constam na distribuição.</p>
<pre><code>time(&amp;curr_time);

printf(&quot;how is the flop? &quot;);
scanf(&quot;%d %d %d&quot;, &amp;flop1, &amp;flop2, &amp;flop3);

while( 1 )
{
  DeckShuffle(curr_time);

  if( Card[0] == flop1 &amp;&amp; Card[1] == flop2 &amp;&amp; Card[2] == flop3 )
  {
    printf(&quot;%d: &quot;, (int) curr_time);
    for( i = 0; i &lt; 52; ++i )
    {
      printf(&quot;%d &quot;, Card[i]);
    }
    printf(&quot;\n&quot;);
  }

  curr_time--;
}
</code></pre>
<p>Por sua vez o <a href="/code/cassino.c">cassino</a> rodará o algoritmo bugado que já vimos. Para simplificar ele já pergunta para o jogador #2 se ele sabe quais são as cartas do jogador #1. Se ele não souber o programa diz ser ainda seguro, mas se acertar isso é revelado.</p>
<pre><code>DeckShuffle();

printf(&quot;(for you) your cards, player#%d: %d %d\n&quot;, 
  player, Card[3 + (player-1) * 2], Card[3 + (player-1) * 2 + 1]);
printf(&quot;(for all) flop: %d %d %d\n&quot;, Card[0], Card[1], Card[2]);

player1_card1 = Card[3];
player1_card2 = Card[4];

printf(&quot;do you know which cards have player #1? &quot;);
scanf(&quot;%d %d&quot;, &amp;player1_guess1, &amp;player1_guess2);

if( player1_guess1 == player1_card1 
  &amp;&amp; player1_guess2 == player1_card2 )
{
  printf(&quot;acerto, miseravi!\n&quot;);
}
else
{
  printf(&quot;no no no, I am still secure!\n&quot;);
}
</code></pre>
<p>Para rodar os programas basta iniciar o cassino e copiar as cartas do flop. Em seguida rodar o exploit e colar o flop. A partir daí ele começa a calcular e quando houver um deck em que aparecem as suas cartas copiar e colar as cartas do adversário, ou seja, o jogador #1, que são as cartas logo depois do flop.</p>
<pre><code>&gt;cassino.exe
(for you) your cards, player#2: 1 21
(for all) flop: 9 22 15
do you know which cards have player #1?

&gt;cassino_exploit.exe
how is the flop? 9 22 15
1614385852: 9 22 15 6 12 1 21 14 ...
1614222117: 9 22 15 4 36 16 25 5 ...
1613983918: 9 22 15 32 31 14 16 ...
^C

(for you) your cards, player#2: 1 21
(for all) flop: 9 22 15
do you know which cards have player #1? 6 12
acerto, miseravi!
</code></pre>

            

          </div>

        <div class="taglist">
            <p class="author">

  Wanderley Caloni,
  
    
  
    
  
  <a href="https://github.com/Caloni/blog/blob/master/content/posts/lessons-from-online-poker-exploit.md">2021-02-26</a>

</p>

            
      <a href="/categories/code">code</a> 
    
    <a class="externalgray" href="https://telegram.me/share/url?url=http://www.caloni.com.br/lessons-from-online-poker-exploit/">discuss</a>


        </div>

      </div>

  </body>

</html>
