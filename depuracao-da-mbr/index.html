<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  
  
      
  
      
  

  <head>
  <meta charset="utf-8" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Depuração da MBR</title>
  <meta name="author" content="" />

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta property="og:title" content="Depuração da MBR"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/depuracao-da-mbr/"/>
  <meta property="og:image"
        content="/img/author.jpg"/>
  <meta property="og:description"
        content="Dando continuidade a um artigo beeeem antigo sobre depuração da BIOS usando SoftIce, como já vimos, podemos igualmente depurar a MBR após a chamada da INT13. Porém, devo atentar para o fato que, em..."/>

  
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/img/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">

  <div class="container">

    <div class="navbar-brand">
        <img alt="Brand" src="/img/brand.svg">
        &nbsp;
        <a class="navbar-item" title="Go to Home" href="/">
            <div class="is-6">Blogue do Caloni</div>
        </a>
    </div>

    

  </div>
</nav>


      
      <div class="container">
        <p class="title">

Depuração da MBR

</p>

        <p class="subtitle">

  Wanderley Caloni,
  
    
  
    
  
  <a href="https://github.com/Caloni/blog/blob/master/content/posts/depuracao-da-mbr.md">2008-03-24</a>

</p>

        

        
          <div class="content">

            
              <p>Dando continuidade a um artigo beeeem antigo sobre <a href="http://www.caloni.com.br/debug-da-bios-com-o-softice-16-bits">depuração da BIOS usando SoftIce</a>, como já vimos, podemos igualmente depurar a MBR após a chamada da INT13. Porém, devo atentar para o fato que, em algumas VMs, e sob determinadas condições do tempo e quantidade de <a href="http://pt.wikipedia.org/wiki/Ectoplasma_%28parapsicologia%29">ectoplasma</a> na atmosfera, é possível que a máquina trave após o <em>hot boot</em> iniciado pelo depurador. Isso provavelmente tem cura usando o espaço de endereçamento alto da memória com a ajuda de aplicativos como LH e UMB.</p>
<p>Porém, estou aqui para contar uma nova forma de depurar essa partezinha do código que pode se tornar um tormento se você só se basear em <em>tracing</em> na tela (ou na COM1): usando o aplicativo <strong>debug</strong> do DOS.</p>
<h4 id="debugexecom">Debug.(exe|com)</h4>
<p>O debug é um programa extremamente antigo, criado antes mesmo do MS-DOS pertencer à Microsoft e do Windows Vista ter sido criado. Como todo sistema operacional, é essencial que exista um programa para verificar problemas em outros programas. Essa foi a &quot;motivação&quot; para a criação do Debug.</p>
<p>Com o passar do tempo e com a evolução dos depuradores modernos, o uso do debug foi diminuindo até a chegada dos 32 bits, quando daí ele parou de vez de ser usado. Com um conjunto limitado de instruções, a versão MS é incapaz de decodificar o <em>assembly</em> de 32 bits, mostrar os registradores extendidos e de depurar em modo protegido.</p>
<p>O <a href="http://www.freedos.org/">FreeDOS</a> é um projeto de fonte aberto que procura criar uma réplica do sistema MS-DOS, com todos seus aplicativos (e um pouco mais). Entre eles, podemos encontrar o <a href="http://www.freedos.org/cgi-bin/lsm.cgi?mode=lsm&amp;lsm=base/debug.lsm">Debug refeito e melhorado</a>. A versão com código-fonte possui suporte às instruções &quot;novas&quot; dos processadores 32 e suporta acesso à memória extendida, modo protegido e melhorias na &quot;interface com o usuário&quot; (como repetição de comandos automática, mudança no valor dos registradores em uma linha, etc). Enfim, nada mau.</p>
<p>É por isso que comecei a utilizá-lo e é nele que me baseio o tutorial logo abaixo.</p>
<h4 id="como-depurar-a-mbr-finalmente">Como depurar a MBR (finalmente!)</h4>
<p>Para conseguirmos essa proeza é necessário reiniciarmos a máquina com algum sistema 16 bits, de preferência que caiba em um disquete. Junto com ele basta uma cópia do debug.com. Após reiniciarmos e aparecer o prompt de comando, podemos chamar o depurador e começar a diversão:</p>
<p><img src="http://i.imgur.com/YlSOCaO.png" alt="Debug"></p>
<p>A MBR fica localizada no primeiro setor do HD ativo (<em>master</em>). A BIOS automaticamente procura esse HD e faz a leitura usando a INT13, função da própria BIOS para leitura de disquetes e derivados.</p>
<p>Lembre-se que nem sempre existirá um MS-DOS para usarmos a INT21, tradicionalmente reservada para este sistema operacional. Portanto, se acostume com as &quot;limitações&quot; das funções básicas da BIOS.</p>
<p>O debug.com inicialmente começa a execução em um espaço de memória baixa. Podemos escrever um <em>assembly</em> qualquer nessa memória e começar a executar. Isso é exatamente o que iremos fazer, e a instrução escolhida será a INT13, pois iremos ler o primeiro setor do HD para a memória e começar a executá-lo. Isso é a depuração da MBR.</p>
<p>Para fazer isso, algumas informações são necessárias, e tudo está disponível no sítio muito simpático e agradável de <a href="http://www.ctyme.com/rbrown.htm">Ralf Brown</a>, o cara que enumerou todas as interrupções conhecidas, além de diversas outras coisas.</p>
<p>Como queremos ler um setor do disco, a função da interrupção que devemos chamar é a <a href="http://www.ctyme.com/intr/rb-0607.htm">AH=02</a>:</p>
<h3 id="disk---read-sectors-into-memory">DISK - READ SECTOR(S) INTO MEMORY</h3>
<pre><code>AH = 02h
AL = number of sectors to read (must be nonzero)
CH = low eight bits of cylinder number
CL = sector number 1-63 (bits 0-5)
high two bits of cylinder (bits 6-7, hard disk only)
DH = head number
DL = drive number (bit 7 set for hard disk)
ES:BX -&gt; data buffer
</code></pre>
<p>Muito bem. Tudo que temos a fazer é preencher os registradores com os valores corretos:</p>
<pre><code>rax 0201 ; função e número de setores (1)
rcx 0001 ; número do cilindro e do setor (cilindro = 0, setor = 1)
rdx 0080 ; número da cabeça (0) e do drive (HD = 0, o bit 7 deve estar levantado)
res 0000 ; segmento em que é executada a MBR
rbx 7e00 ; offset em que é executada a MBR
</code></pre>
<h4 id="por-que-a-mbr-deve-ser-executada-em-0007e00">Por que a MBR deve ser executada em 000:7E00?</h4>
<p>Essa é a maneira em que as coisas são. Você certamente poderia usar outro endereço, mas estamos tentando deixar a emulação de um _boot _o mais próximo possível  de um _boot _de verdade. E, tradicionalmente, o endereço de execução da MBR é em 0000:7E00. Para recordar disso, basta lembrar que o tamanho de um setor é de 0x200 bytes, e que dessa forma a MBR vai parar bem no final do endereçamento baixo (apenas <em>offset</em>).</p>
<p>Essa organização é diferente do endereço inicial da BIOS, que é por padrão 0xFFFF0.</p>
<p>Após definir corretamente os registradores, tudo que temos que fazer é escrever uma chamada à INT13 no endereço atual e executar. O conteúdo inicial do disco será escrito no endereço de memória 0000:7E00. Após isso trocamos o IP atual para esse endereço e começamos a depurar a MBR, como se estivéssemos logo após o <em>boot</em> da máquina.</p>
<p><img src="http://i.imgur.com/0H8qWQw.png" alt="debug2.png"></p>
<h4 id="depurando-a-bios">Depurando a BIOS</h4>
<p>Além da MBR, muitas vezes é preciso depurar a própria BIOS para descobrir o que está acontecendo. Nesse caso, tudo que precisamos fazer é colocar o ponteiro de próxima instrução para a região de memória 0xFFFF0, que traduzido para segmento/<em>offset</em> fica f000:fff0 (mais explicações sobre isso talvez em um futuro artigo).</p>
<pre><code>-rcs f000
-rip fff0
-t
</code></pre>

            

          </div>

        <div class="taglist">
            
    
      <a href="/tags/draft">draft</a>  <a href="/tags/code">code</a> 
    <a class="externalgray" href="https://telegram.me/share/url?url=http://www.caloni.com.br/depuracao-da-mbr/">discuss</a>


        </div>

        <div class="navigation-bottom">
            <span class="next-in-section"><a href="http://www.caloni.com.br/windbg-a-distancia/">&#x25C1; WinDbg a distância</a></span>
<span class="prev-in-section"><a href="http://www.caloni.com.br/como-rodar-qualquer-coisa-como-servico/">&#x25B7; Como rodar qualquer coisa como serviço</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni <a href="https://github.com/Caloni/blog">2021.04.09</a> </i></span>
  </div>
</footer>

  </body>

</html>
