<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Templates em C no lugar de macros</title>
  <meta name="author" content="" />
  <meta name="description"
        content="A grande vantagem dos templates é manter o tipo de seus argumentos. Infelizmente, eles não existem na linguagem C, mas podem ser usados em construções C feitas com a linguagem C&#43;&#43;, como ocorre com..."/>

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta itemprop="name" content="Templates em C no lugar de macros"/>
  <meta itemprop="description"
        content="A grande vantagem dos templates é manter o tipo de seus argumentos. Infelizmente, eles não existem na linguagem C, mas podem ser usados em construções C feitas com a linguagem C&#43;&#43;, como ocorre com..."/>
  <meta itemprop="image"
        content=""/>

  
  <meta property="og:title" content="Templates em C no lugar de macros"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/templates-em-c-no-lugar-de-macros/"/>
  <meta property="og:image"
        content=""/>
  <meta property="og:description"
        content="A grande vantagem dos templates é manter o tipo de seus argumentos. Infelizmente, eles não existem na linguagem C, mas podem ser usados em construções C feitas com a linguagem C&#43;&#43;, como ocorre com..."/>
  <meta property="og:site_name" content="Blogue do Caloni"/>
  <meta property="article:published_time"
        content="2016-01-14T00:00:00&#43;00:00"/>
  <meta property="article:section" content="post"/>

  
  
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site"
        content=""/>
  <meta name="twitter:title" content="Templates em C no lugar de macros"/>
  <meta name="twitter:description"
        content="A grande vantagem dos templates é manter o tipo de seus argumentos. Infelizmente, eles não existem na linguagem C, mas podem ser usados em construções C feitas com a linguagem C&#43;&#43;, como ocorre com..."/>
  <meta name="twitter:creator"
        content=""/>
  <meta name="twitter:image:src"
        content="
                     /images/movies.png
                   "/>

  
  <link href="" rel="alternate" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">
  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/brand.svg">
        <div class="title is-6">&nbsp;Blogue do Caloni</div>
      </a>

      
      <label class="button navbar-burger is-white" for="navbar-burger-state">
        <span></span>                               
        <span></span>
        <span></span>
      </label>
    </div>

    
    <input type="checkbox" id="navbar-burger-state"/>

    <div class="navbar-menu">
      <div class="navbar-end" style="padding: 10px;">
      <big><b>
       <a title="posts dessa categoria" href="/categories/blog">blog</a>  <a title="posts dessa categoria" href="/categories/cinema">cinema</a>  <a title="posts dessa categoria" href="/categories/code">code</a> 
       <a href="/caloni"><span class="icon"><i class="fa fa-user"></i></a> <a href="index.xml"><span class="icon"><i class="fa fa-rss"></i></a>
      </big></b>
      </div>
    </div>

  </div>
</nav>


      
      <div class="container">
        <p class="title">Templates em C no lugar de macros</p>

        <p class="subtitle">
<i>

    <a href="https://github.com/Caloni/post/commits/master/templates-em-c-no-lugar-de-macros.md" title="History">
    2016-01-14
    </a>

<span class="icon"><i class="fa fa-clock-o"></span></i>3 </i>
 <span class="icon"><i class="fa fa-pencil"></i></span><a href="https://github.com/Caloni/post/blob/master/templates-em-c-no-lugar-de-macros.md" title="GitHub">484</a>
</p>

        <div class="taglist">
            <i>Este ainda é um rascunho publicado prematuramente e está sujeito a mudanças substanciais.</i>

        </div>

        

        
          <div class="content">
            
              <p>A grande vantagem dos templates é manter o tipo de seus argumentos. Infelizmente, eles não existem na linguagem C, mas podem ser usados em construções C feitas com a linguagem C++, como ocorre com quem desenvolve device drivers para Windows.</p>
<p>Imagine, por exemplo, a estrutura LISTENTRY.aspx), que é uma tentativa de generalizar não só o tipo de uma lista ligada, como seu posicionamento:</p>
<pre><code>typedef struct _LIST_ENTRY {
  struct _LIST_ENTRY  *Flink;
  struct _LIST_ENTRY  *Blink;
} LIST_ENTRY, *PLIST_ENTRY;
</code></pre>
<p>A lógica por trás de LISTENTRY é que esse membro pode ser inserido em qualquer lugar da estrutura que representará um elemento. Ele pode estar realmente no meio do elemento, pois isso não importa, desde que você saiba voltar para o começo da estrutura. Isso é útil quando um elemento pode fazer parte de diferentes listas.</p>
<pre><code>typedef struct _LIST_ENTRY {
  struct _LIST_ENTRY  *Flink;
  struct _LIST_ENTRY  *Blink;
} LIST_ENTRY, *PLIST_ENTRY;

struct MeuElemento
{
    int x;
    int y;
    LIST_ENTRY entry;
    double d;
    float f;
};

LIST_ENTRY g_head;

int main()
{
    InitializeListHead(&amp;g_head);
}
</code></pre>
<p>OK, temos uma lista ligada cujo head está inicializado. Para inserir um novo item, podemos usar as rotinas InsertHeadList, AppendTailList, RemoveEntryList, PushEntryList, PopEntryList, etc. Enfim, uma infinidade de rotinas já cuidam disso para a gente.</p>
<p>O que não temos é como acessar o elemento. Para isso usamos um truque bem peculiar na linguagem C, já disponível também em kernel:</p>
<pre><code>#define CONTAINING_RECORD(address, type, field) \
    ((type *)( \
    (PCHAR)(address) - \
    (ULONG_PTR)(&amp;((type *)0)-&gt;field)))
</code></pre>
<p>Basicamente a macro obtém a partir do endereço zero o offset do membro que é a entrada da lista ligada e subtrai esse ofsset do endereço do próprio campo, ganhando de brinde o tipo de sua estrutura. Usando a macro com nossa estrutura:</p>
<pre><code>void DoSomething(PLINK_LIST pEntry)
{
    MeuElemento* pElem = CONTAINING_RECORD(pEntry, MeuElemento, entry);
}
</code></pre>
<p>Note que entry é o nome, literal, do membro na estrutura, e não há maneira possível com templates de obter isso. A solução? Usar um nome padronizado. O resultado final pode ser parecido com este:</p>
<pre><code>template&lt;typename T&gt;
T* ContainingRecord(PLIST_ENTRY pEntry)
{
    return ( reinterpret_cast&lt;T*&gt;( (char*)(pEntry) - (size_t)(&amp;((T*)0)-&gt;entry)) );
}
</code></pre>
<p>Em ação:</p>
<pre><code>#include &lt;iostream&gt;

using namespace std;

typedef struct _LIST_ENTRY {
  struct _LIST_ENTRY  *Flink;
  struct _LIST_ENTRY  *Blink;
} LIST_ENTRY, *PLIST_ENTRY;

struct MeuElemento
{
    int x;
    int y;
    LIST_ENTRY entry;
    double d;
    float f;
};

LIST_ENTRY g_head;

template&lt;typename T&gt;
T* ContainingRecord(PLIST_ENTRY pEntry)
{
    return ( reinterpret_cast&lt;T*&gt;( (char*)(pEntry) - (size_t)(&amp;((T*)0)-&gt;entry)) );
}

int main()
{
    auto newElem = new MeuElemento();
    newElem-&gt;x = 42;
    g_head.Flink = &amp;newElem-&gt;entry; // inserindo um elemento
    auto elem = ContainingRecord&lt;MeuElemento&gt;(g_head.Flink);

    cout &lt;&lt; &quot;X is &quot; &lt;&lt; elem-&gt;x &lt;&lt; endl;
}
</code></pre>
<p>&ldquo;Nossa, tudo isso para substituir uma macro já consagrada no WDK??&rdquo; Sim, nesse post o objetivo não ficou muito útil. É apenas uma ideia de substituição possível de ser feita em macros em geral. Pode ser bem documentada, usada há 30 anos, mas ainda é uma macro. Meu conselho: se funciona bem, use. Se vai fazer algo novo, tente sempre templates.</p>

            

          </div>

        <div class="taglist">
            
    
      <a href="/categories/code">code</a> 
      <a href="/tags/draft">draft</a> 
    
    <a href="https://twitter.com/intent/tweet?text=A%20grande%20vantagem%20dos%20templates%20%c3%a9%20manter%20o%20tipo%20de%20seus%20argumentos.%20Infelizmente%2c%20eles%20n%c3%a3o%20existem%20na%20linguagem%20C%2c%20mas...%20http%3a%2f%2fwww.caloni.com.br%2ftemplates-em-c-no-lugar-de-macros%2f from @caloni " style="text-decoration: underline;" title="Twitter">twitter</big></a>


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/pegando-fogo/">Pegando Fogo<span class="icon"><i class="fa fa-arrow-right"></i></span></a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/veludo-azul/"><span class="icon"><i class="fa fa-arrow-left"></i></span>Veludo Azul</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
