<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  
  
      
  
      
  

  <head>
  <meta charset="utf-8" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Gerenciamento de janelas em C&#43;&#43; Builder</title>
  <meta name="author" content="" />

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta property="og:title" content="Gerenciamento de janelas em C&#43;&#43; Builder"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/gerenciamento-de-janelas-em-c-builder/"/>
  <meta property="og:image"
        content="/img/author.jpg"/>
  <meta property="og:description"
        content="As janelas criadas no C&#43;&#43; Builder são equivalentes às janelas criadas pela API, com o detalhe que a VCL gerencia tudo automaticamente. Isso não quer dizer que não podemos tomar controle de tudo. Quer..."/>

  
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/img/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">

  <div class="container">

    <div class="navbar-brand">
        <img alt="Brand" src="/img/brand.svg">
        &nbsp;
        <a class="navbar-item" title="Go to Home" href="/">
            <div class="is-6">Blogue do Caloni</div>
        </a>
    </div>

    

  </div>
</nav>


      
      <div class="container">
        <p class="title">

Gerenciamento de janelas em C&#43;&#43; Builder

</p>

        <p class="subtitle">

  Wanderley Caloni,
  
    
  
    
  
  2007-12-11<a href="https://github.com/Caloni/blog/blob/master/content/posts/gerenciamento-de-janelas-em-c-builder.md">.</a>

</p>

        

        
          <div class="content">

            
              <p>As janelas criadas no C++ Builder são equivalentes às janelas criadas pela API, com o detalhe que a VCL gerencia tudo automaticamente. Isso não quer dizer que não <strong>podemos</strong> tomar controle de tudo. Quer dizer que não <strong>precisamos</strong>.</p>
<p>Abra o Builder. Um projeto padrão é criado. Agora no menu <strong>File</strong>, vá em <strong>New</strong>, <strong>Form</strong>. Isso adicionará um novo formulário ao projeto padrão. Pronto! Temos dois formulários. Agora se formos dar uma passeada no WinMain, vemos que o código para iniciar a VCL se alterou conforme a música:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">//...
</span><span style="color:#75715e"></span><span style="color:#66d9ef">try</span>
{
	Application<span style="color:#f92672">-&gt;</span>Initialize();
	Application<span style="color:#f92672">-&gt;</span>CreateForm(__classid(TForm1), <span style="color:#f92672">&amp;</span>Form1);
	Application<span style="color:#f92672">-&gt;</span>CreateForm(__classid(TForm2), <span style="color:#f92672">&amp;</span>Form2);
	Application<span style="color:#f92672">-&gt;</span>Run();
}
<span style="color:#75715e">//... 
</span><span style="color:#75715e"></span>
</code></pre></div><p>Porém, se rodarmos a aplicação nesse momento, podemos notar que o programa exibe apenas a janela correspondente ao primeiro formulário. De fato, ao chamar o método <strong>Application-&gt;Run()</strong>, apenas o primeiro <em>form</em> criado é exibido. Isso não significa, é claro, que o segundo <em>form</em> não tenha sido criado. Para demonstrar como ele está lá, coloque o seguinte evento no clique de um botão do <strong>Form1</strong>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;Unit2.h&#34; // extern PACKAGE TForm2 *Form2;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> TForm1<span style="color:#f92672">::</span>Button1Click(TObject <span style="color:#f92672">*</span>Sender)
{
	Form2<span style="color:#f92672">-&gt;</span>Show();
} 

</code></pre></div><p>Agora ao clicar do botão a janela correspondente ao formulário número 2 também aparece. Podemos fechá-la e abri-la quantas vezes quisermos que o aplicativo continua rodando. Apenas ao fechar a janela no. 1 o aplicativo realmente encerra. Esse comportamento segue o mesmo padrão da função <strong>main()</strong> na forma clássica das linguagens C/C++:</p>
<pre><code>ShowMessage(&lt;span class=&quot;string&quot;&gt;&quot;O MainForm de Application é o primeiro TForm criado. &quot;&lt;/span&gt;
&lt;span class=&quot;string&quot;&gt;            &quot;É o princípio e o fim, o Alfa e o Ômega. Nele tudo começa e tudo termina&quot;&lt;/span&gt;);
</code></pre>
<p>Podemos, também como em C/C++ padrão, finalizar explicitamente a aplicação chamando o método <strong>Application-&gt;Terminate</strong>. O MainForm em tempo de execução é uma propriedade de somente leitura de Application. Em tempo de <em>design</em>, ele pode ser alterado pela ordem de criação dos formulários no código ou pela IDE em <strong>Project</strong>, <strong>Options</strong>, <strong>Forms</strong>. Lá você também escolhe quais <em>forms</em> serão criados automaticamente.</p>
<p>Esse funcionamento e automação na criação de janelas da VCL foi feita para facilitar a vida do programador. Contudo, nunca estamos presos a somente isso. As maneiras das coisas funcionarem apenas refletem o uso mais comum no ambiente e não tem como função limitar a criatividade do desenvolvedor.</p>
<p>Para exemplificar, vamos inverter as coisas. Coloque um botão no segundo formulário que finalize o programa de maneira explítica:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> TForm2<span style="color:#f92672">::</span>Button1Click(TObject <span style="color:#f92672">*</span>Sender)
{
	Application<span style="color:#f92672">-&gt;</span>Terminate();
} 

</code></pre></div><p>Agora, no evento de <strong>OnClose</strong> (acho que você conhece o Object Inspector, não? Bom, se não conhece, talvez isso mereça um <a href="http://www.caloni.com.br/introducao-ao-c-builderturbo-c">artigo à parte</a>) do <strong>TForm1</strong> insira o seguinte código:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#66d9ef">__fastcall</span> TForm1<span style="color:#f92672">::</span>FormClose(TObject <span style="color:#f92672">*</span>Sender, TCloseAction <span style="color:#f92672">&amp;</span>Action)
{
	Action <span style="color:#f92672">=</span> caNone;
} 

</code></pre></div><p>Pronto! Agora você decide onde termina e onde acaba sua aplicação.</p>
<h4 id="por-baixo-dos-panos-da-vcl">Por baixo dos panos da VCL</h4>
<p><a href="/images/cppbuilder-forms.png"><img src="http://i.imgur.com/ECCRWxD.png" alt="C++ Builder Forms"></a></p>
<p>Se dermos uma olhada bem de perto no que acontece por dentro de um aplicativo que usa a VCL descobriremos que o método Run de Application nada mais é que o <em>loop</em> de mensagens que <a href="http://www.caloni.com.br/historia-do-windows-parte-30">já conhecemos</a>.</p>
<p>Para analisarmos melhor o que ocorre nos <em>internals</em> da coisa, criei um <a href="/images/cppbuilder-forms.7z">projeto simplista</a> que possui dois <em>forms</em>, ambos com quatro botões: 1) mostrar o outro <em>form</em>, 2) esconder a si mesmo, 3) fechar a si mesmo e 4) terminar aplicação. Os dois formulários são tão parecidos que desconfio que sejam gêmeos.</p>
<p>Além disso, iremos precisar do nosso velho e fiel amigo WinDbg, o que o trás de volta à cena do crime depois de alguns artigos de jejum.</p>
<!-- raw HTML omitted -->
<blockquote>
<h4 id="não-fique-de-fora">Não fique de fora!</h4>
</blockquote>
<p><em>Para saber mais sobre o WinDbg e dar suas &quot;WinDbgzadas&quot;, dê uma olhada em alguns <a href="http://www.caloni.com.br/blog/search/WinDbg">artigos interessantes</a></em> <em>sobre depuração usando WinDbg</em>.<!-- raw HTML omitted --></p>
<p>A primeira coisa que um <em>loop</em> de mensagens deveria fazer seria chamar a função <a href="http://msdn2.microsoft.com/en-us/library/ms644936.aspx">GetMessage</a>, que obtém a primeira mensagem em espera na fila de mensagens da <em>thread</em> chamadora. Portanto, vamos dar uma olhada nas chamadas dessa função:</p>
<pre><code>windbg Project1.exe
0:001&gt; bm /a user32!GetMessage?
  1: 7e4191c6 @!&quot;USER32!GetMessageW&quot;
  2: 7e42e002 @!&quot;USER32!GetMessageA&quot;
g
</code></pre>
<p>E o resultado é... nada! Mesmo mexendo com a janela e apertando seus botões não há uma única ocorrência do GetMessage. Bruxaria? Programação oculta?</p>
<p>Nem tanto. Uma alternativa ao GetMessage, que captura a primeira mensagem da fila de mensagens e a retira, é o <a href="http://msdn2.microsoft.com/en-us/library/ms644943.aspx">PeekMessage</a>, que captura a primeira mensagem da fila, mas <strong>mantém a mensagem na fila</strong>. Por algum motivo, os programadores da Borland fizeram seu <em>loop</em> de mensagens usando PeekMessage.</p>
<pre><code>bc*
0:001&gt; bm /a user32!PeekMessage?
  1: 7e41929b @!&quot;USER32!PeekMessageW&quot;
  2: 7e41c96c @!&quot;USER32!PeekMessageA&quot;
g


0:001&gt; g
Breakpoint 2 hit
eax=00b1c6b0 ebx=00000000 ecx=0012ff44 edx=0012fef8 esi=00b1c6b0 edi=0012fef8
eip=7e41c96c esp=0012fec8 ebp=0012ff44 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
USER32!PeekMessageA:
7e41c96c 8bff            mov     edi,edi
</code></pre>
<p>Agora, sim!</p>
<p>Analisando os parâmetros da função PeekMessage podemos obter algumas informações interessantes sobre uma mensagem, como seu código e a janela destino:</p>
<pre><code>0:000&gt; dd @$csp L2
</code></pre>
<ul>
<li>
<p>o que tem nessa pilha?</p>
<p>0012fec8  52079211</p>
</li>
</ul>
<p>0012fef8* pMsg</p>
<pre><code>0:000&gt; dd poi(@$csp+4) L6
</code></pre>
<ul>
<li>
<p>mostrando membros da estrutura MSG</p>
<p>0012fef8</p>
</li>
</ul>
<p>000903ba00000113</p>
<pre><code> 00000001 00000000
</code></pre>
<ul>
<li>
<p>handle da janela</p>
<p>,</p>
</li>
</ul>
<p>código da mensagem</p>
<pre><code>, etc
0012ff08  007bb129 000000e7
</code></pre>
<p>Podemos bater essas informações com as do aplicativo <strong>Spy++</strong>, que captura janelas e suas mensagens:</p>
<pre><code>bd *
g
</code></pre>
<!-- raw HTML omitted -->
<blockquote>
<h4 id="cuidado-com-spy-x-windbg">Cuidado com Spy++ x WinDbg</h4>
</blockquote>
<p>_Normalmente esses dois rodando juntos podem causar alguns conflitos internos. Por isso, quando for usar o Spy++, procure desabilitar seus breakpoints. Após mexer no Spy++, feche-o antes de continuar depurando._<!-- raw HTML omitted --></p>
<p><a href="/images/spyxx-window-search.png"><img src="http://i.imgur.com/6vmV4qb.png" alt="Spy++ Window Search"></a></p>
<p><a href="/images/spyxx-window-search-result.png"><img src="http://i.imgur.com/Wzc7A0u.png" alt="Spy++ Window Search Result"></a></p>
<p>Como podemos ver, nesse caso a janela encontrada foi justamente a que não aparece: TApplication! Sim, a classe principal da VCL é representada em <em>runtime</em> por uma janela escondida, que controla algumas mensagens específicas da aplicação.</p>
<h4 id="mas-o-que-tudo-isso-tem-a-ver-com-o-builder">Mas o que tudo isso tem a ver com o Builder?</h4>
<p>Tem tudo a ver! Mais do que simplesmente programar interfaces, esses conhecimentos permitem fazer a análise de qualquer aplicativo que possua um <em>loop</em> de mensagens. O importante descoberto aqui é que o C++ Builder, assim como o .NET, o Java e o &quot;próximo framework gerenciado&quot;, não pode escapar da fatal realidade de que, para exibir janelas, o aplicativo deverá dançar a música da API Win32.</p>
<pre><code>0:001&gt; bc*
0:001&gt; bp user32!PeekMessageA &quot;.echo PeekMessage; g&quot;
0:001&gt; bp user32!DispatchMessageA &quot;.echo DispatchMessage; g&quot;
0:001&gt; g
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
eax=77c3f88a ebx=00000000 ecx=77c3e9f9 edx=77c61a70 esi=7c90e88e edi=00000000
eip=7c90eb94 esp=0012fe64 ebp=0012ff60 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiFastSystemCallRet:
7c90eb94 c3              ret
</code></pre>

            

          </div>

        <div class="taglist">
            
    
      <a href="/tags/draft">draft</a>  <a href="/tags/code">code</a> 
    


        </div>

        <div class="navigation-bottom">
            <span class="next-in-section"><a href="http://www.caloni.com.br/debug-remoto-no-c-builder/">&#x25C1; Debug remoto no C&#43;&#43; Builder</a></span>
<span class="prev-in-section"><a href="http://www.caloni.com.br/interacao-entre-controles-no-c-builder/">&#x25B7; Interação entre controles no C&#43;&#43; Builder</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2021<a href="https://github.com/Caloni/blog">.</a> </i></span>
  </div>
</footer>

  </body>

</html>
