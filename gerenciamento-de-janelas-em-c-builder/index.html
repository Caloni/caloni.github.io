<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">

  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Blogue do Caloni - Gerenciamento de janelas em C&#43;&#43; Builder</title>
  <meta name="author" content="" />
  <meta name="description"
        content="As janelas criadas no C&#43;&#43; Builder são equivalentes às janelas criadas pela API, com o detalhe que a VCL gerencia tudo automaticamente. Isso não quer dizer que não podemos tomar controle de tudo. Quer..."/>

  <meta name="generator" content="Hugo 0.67.1" />

  
  <meta itemprop="name" content="Gerenciamento de janelas em C&#43;&#43; Builder"/>
  <meta itemprop="description"
        content="As janelas criadas no C&#43;&#43; Builder são equivalentes às janelas criadas pela API, com o detalhe que a VCL gerencia tudo automaticamente. Isso não quer dizer que não podemos tomar controle de tudo. Quer..."/>
  <meta itemprop="image"
        content=""/>

  
  <meta property="og:title" content="Gerenciamento de janelas em C&#43;&#43; Builder"/>
  <meta property="og:type"
        content="article"/>
  <meta property="og:url" content="http://www.caloni.com.br/gerenciamento-de-janelas-em-c-builder/"/>
  <meta property="og:image"
        content=""/>
  <meta property="og:description"
        content="As janelas criadas no C&#43;&#43; Builder são equivalentes às janelas criadas pela API, com o detalhe que a VCL gerencia tudo automaticamente. Isso não quer dizer que não podemos tomar controle de tudo. Quer..."/>
  <meta property="og:site_name" content="Blogue do Caloni"/>
  <meta property="article:published_time"
        content="2007-12-11T00:00:00&#43;00:00"/>
  <meta property="article:section" content="post"/>

  
  
  <meta name="twitter:card" content="summary"/>
  <meta name="twitter:site"
        content=""/>
  <meta name="twitter:title" content="Gerenciamento de janelas em C&#43;&#43; Builder"/>
  <meta name="twitter:description"
        content="As janelas criadas no C&#43;&#43; Builder são equivalentes às janelas criadas pela API, com o detalhe que a VCL gerencia tudo automaticamente. Isso não quer dizer que não podemos tomar controle de tudo. Quer..."/>
  <meta name="twitter:creator"
        content=""/>
  <meta name="twitter:image:src"
        content="
                     /images/movies.png
                   "/>

  
  <link href="" rel="alternate" type="application/rss+xml"
        title="Blogue do Caloni"/>
  <link href="" rel="feed" type="application/rss+xml"
        title="Blogue do Caloni"/>

  
  <link rel="stylesheet" type="text/css" href="/css/capsule.min.css"/>
  
  <link rel="stylesheet" type="text/css" href="/css/custom.css"/>

  
  <script>
  
    
      <!-- Google Analytics -->
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-50557403-2', 'auto');
      ga('send', 'pageview');
    
  
  </script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/list.js"></script>

  
  <link rel="icon" href="/favicon.ico"/>
  </head>


  <body style="min-height:100vh;display:flex;flex-direction:column">

    <nav class="navbar has-shadow is-white"
     role="navigation" aria-label="main navigation">
  <div class="container">

    <div class="navbar-brand">
      <a class="navbar-item" title="Go to Home" href="/">
        <img alt="Brand" src="/brand.svg">
        <div class="title is-6">&nbsp;Blogue do Caloni</div>
      </a>

      
      <label class="button navbar-burger is-white" for="navbar-burger-state">
        <span></span>                               
        <span></span>
        <span></span>
      </label>
    </div>

    
    <input type="checkbox" id="navbar-burger-state"/>

    <div class="navbar-menu">
      <div class="navbar-end" style="padding: 10px;">
      <big><b>
       <a title="posts dessa categoria" href="/categories/blog">blog</a>  <a title="posts dessa categoria" href="/categories/cinema">cinema</a>  <a title="posts dessa categoria" href="/categories/code">code</a> 
       <a href="/caloni"><span class="icon"><i class="fa fa-user"></i></a> <a href="index.xml"><span class="icon"><i class="fa fa-rss"></i></a>
      </big></b>
      </div>
    </div>

  </div>
</nav>


      
      <div class="container">
        <p class="title">Gerenciamento de janelas em C&#43;&#43; Builder</p>

        <p class="subtitle">
<i>

    <a href="https://github.com/Caloni/post/commits/master/gerenciamento-de-janelas-em-c-builder.md" title="History">
    2007-12-11
    </a>

<span class="icon"><i class="fa fa-clock-o"></span></i>5 </i>
 <span class="icon"><i class="fa fa-pencil"></i></span><a href="https://github.com/Caloni/post/blob/master/gerenciamento-de-janelas-em-c-builder.md" title="GitHub">1040</a>
</p>

        <div class="taglist">
            <i>Este ainda é um rascunho publicado prematuramente e está sujeito a mudanças substanciais.</i>

        </div>

        

        
          <div class="content">
            
              <p>As janelas criadas no C++ Builder são equivalentes às janelas criadas pela API, com o detalhe que a VCL gerencia tudo automaticamente. Isso não quer dizer que não podemos tomar controle de tudo. Quer dizer que não precisamos.</p>
<p>Abra o Builder. Um projeto padrão é criado. Agora no menu File, vá em New, Form. Isso adicionará um novo formulário ao projeto padrão. Pronto! Temos dois formulários. Agora se formos dar uma passeada no WinMain, vemos que o código para iniciar a VCL se alterou conforme a música:</p>
<pre><code>//...
try
{
    Application-&gt;Initialize();
    Application-&gt;CreateForm(__classid(TForm1), &amp;Form1);
    Application-&gt;CreateForm(__classid(TForm2), &amp;Form2);
    Application-&gt;Run();
}
//... 
</code></pre>
<p>Porém, se rodarmos a aplicação nesse momento, podemos notar que o programa exibe apenas a janela correspondente ao primeiro formulário. De fato, ao chamar o método Application-&gt;Run(), apenas o primeiro form criado é exibido. Isso não significa, é claro, que o segundo form não tenha sido criado. Para demonstrar como ele está lá, coloque o seguinte evento no clique de um botão do Form1:</p>
<pre><code>#include &quot;Unit2.h&quot; // extern PACKAGE TForm2 *Form2;

void __fastcall TForm1::Button1Click(TObject *Sender)
{
    Form2-&gt;Show();
} 
</code></pre>
<p>Agora ao clicar do botão a janela correspondente ao formulário número 2 também aparece. Podemos fechá-la e abri-la quantas vezes quisermos que o aplicativo continua rodando. Apenas ao fechar a janela no. 1 o aplicativo realmente encerra. Esse comportamento segue o mesmo padrão da função main() na forma clássica das linguagens C/C++:</p>
<pre><code>ShowMessage(&lt;span class=&quot;string&quot;&gt;&quot;O MainForm de Application é o primeiro TForm criado. &quot;&lt;/span&gt;
&lt;span class=&quot;string&quot;&gt;            &quot;É o princípio e o fim, o Alfa e o Ômega. Nele tudo começa e tudo termina&quot;&lt;/span&gt;);
</code></pre>
<p>Podemos, também como em C/C++ padrão, finalizar explicitamente a aplicação chamando o método Application-&gt;Terminate. O MainForm em tempo de execução é uma propriedade de somente leitura de Application. Em tempo de design, ele pode ser alterado pela ordem de criação dos formulários no código ou pela IDE em Project, Options, Forms. Lá você também escolhe quais forms serão criados automaticamente.</p>
<p>Esse funcionamento e automação na criação de janelas da VCL foi feita para facilitar a vida do programador. Contudo, nunca estamos presos a somente isso. As maneiras das coisas funcionarem apenas refletem o uso mais comum no ambiente e não tem como função limitar a criatividade do desenvolvedor.</p>
<p>Para exemplificar, vamos inverter as coisas. Coloque um botão no segundo formulário que finalize o programa de maneira explítica:</p>
<pre><code>void __fastcall TForm2::Button1Click(TObject *Sender)
{
    Application-&gt;Terminate();
} 
</code></pre>
<p>Agora, no evento de OnClose (acho que você conhece o Object Inspector, não? Bom, se não conhece, talvez isso mereça um artigo à parte) do TForm1 insira o seguinte código:</p>
<pre><code>void __fastcall TForm1::FormClose(TObject *Sender, TCloseAction &amp;Action)
{
    Action = caNone;
} 
</code></pre>
<p>Pronto! Agora você decide onde termina e onde acaba sua aplicação.</p>
<p>Se dermos uma olhada bem de perto no que acontece por dentro de um aplicativo que usa a VCL descobriremos que o método Run de Application nada mais é que o loop de mensagens que já conhecemos.</p>
<p>Para analisarmos melhor o que ocorre nos internals da coisa, criei um projeto simplista que possui dois forms, ambos com quatro botões: 1) mostrar o outro form, 2) esconder a si mesmo, 3) fechar a si mesmo e 4) terminar aplicação. Os dois formulários são tão parecidos que desconfio que sejam gêmeos.</p>
<p>Além disso, iremos precisar do nosso velho e fiel amigo WinDbg, o que o trás de volta à cena do crime depois de alguns artigos de jejum.</p>
<blockquote>
<h4 id="não-fique-de-fora">Não fique de fora!</h4>
</blockquote>
<p>Para saber mais sobre o WinDbg e dar suas &ldquo;WinDbgzadas&rdquo;, dê uma olhada em alguns artigos interessantes sobre depuração usando WinDbg.</p>
<p>A primeira coisa que um loop de mensagens deveria fazer seria chamar a função GetMessage, que obtém a primeira mensagem em espera na fila de mensagens da thread chamadora. Portanto, vamos dar uma olhada nas chamadas dessa função:</p>
<pre><code>windbg Project1.exe
0:001&gt; bm /a user32!GetMessage?
  1: 7e4191c6 @!&quot;USER32!GetMessageW&quot;
  2: 7e42e002 @!&quot;USER32!GetMessageA&quot;
g
</code></pre>
<p>E o resultado é&hellip; nada! Mesmo mexendo com a janela e apertando seus botões não há uma única ocorrência do GetMessage. Bruxaria? Programação oculta?</p>
<p>Nem tanto. Uma alternativa ao GetMessage, que captura a primeira mensagem da fila de mensagens e a retira, é o PeekMessage, que captura a primeira mensagem da fila, mas mantém a mensagem na fila. Por algum motivo, os programadores da Borland fizeram seu loop de mensagens usando PeekMessage.</p>
<pre><code>bc*
0:001&gt; bm /a user32!PeekMessage?
  1: 7e41929b @!&quot;USER32!PeekMessageW&quot;
  2: 7e41c96c @!&quot;USER32!PeekMessageA&quot;
g


0:001&gt; g
Breakpoint 2 hit
eax=00b1c6b0 ebx=00000000 ecx=0012ff44 edx=0012fef8 esi=00b1c6b0 edi=0012fef8
eip=7e41c96c esp=0012fec8 ebp=0012ff44 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
USER32!PeekMessageA:
7e41c96c 8bff            mov     edi,edi
</code></pre>
<p>Agora, sim!</p>
<p>Analisando os parâmetros da função PeekMessage podemos obter algumas informações interessantes sobre uma mensagem, como seu código e a janela destino:</p>
<pre><code>0:000&gt; dd @$csp L2
* o que tem nessa pilha?
0012fec8  52079211
0012fef8* pMsg
0:000&gt; dd poi(@$csp+4) L6
* mostrando membros da estrutura MSG
0012fef8
000903ba00000113
00000001 00000000
* handle da janela , código da mensagem , etc
0012ff08  007bb129 000000e7
</code></pre>
<p>Podemos bater essas informações com as do aplicativo Spy++, que captura janelas e suas mensagens:</p>
<pre><code>bd *
g
</code></pre>
<p>Normalmente esses dois rodando juntos podem causar alguns conflitos internos. Por isso, quando for usar o Spy++, procure desabilitar seus breakpoints. Após mexer no Spy++, feche-o antes de continuar depurando.</p>
<p>Como podemos ver, nesse caso a janela encontrada foi justamente a que não aparece: TApplication! Sim, a classe principal da VCL é representada em runtime por uma janela escondida, que controla algumas mensagens específicas da aplicação.</p>
<p>Tem tudo a ver! Mais do que simplesmente programar interfaces, esses conhecimentos permitem fazer a análise de qualquer aplicativo que possua um loop de mensagens. O importante descoberto aqui é que o C++ Builder, assim como o .NET, o Java e o &ldquo;próximo framework gerenciado&rdquo;, não pode escapar da fatal realidade de que, para exibir janelas, o aplicativo deverá dançar a música da API Win32.</p>
<pre><code>0:001&gt; bc*
0:001&gt; bp user32!PeekMessageA &quot;.echo PeekMessage; g&quot;
0:001&gt; bp user32!DispatchMessageA &quot;.echo DispatchMessage; g&quot;
0:001&gt; g
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
PeekMessage
DispatchMessage
...
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
DispatchMessage
PeekMessage
eax=77c3f88a ebx=00000000 ecx=77c3e9f9 edx=77c61a70 esi=7c90e88e edi=00000000
eip=7c90eb94 esp=0012fe64 ebp=0012ff60 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiFastSystemCallRet:
7c90eb94 c3              ret
</code></pre>

            

          </div>

        <div class="taglist">
            
    
    
      <a href="/categories/code">code</a> 
      <a href="/tags/draft">draft</a> 
    
    <a href="https://twitter.com/intent/tweet?text=As%20janelas%20criadas%20no%20C%2b%2b%20Builder%20s%c3%a3o%20equivalentes%20%c3%a0s%20janelas%20criadas%20pela%20API%2c%20com%20o%20detalhe%20que%20a%20VCL%20gerencia%20tudo...%20http%3a%2f%2fwww.caloni.com.br%2fgerenciamento-de-janelas-em-c-builder%2f from @caloni " style="text-decoration: underline;" title="Twitter">twitter</big></a>


        </div>

        <div class="navigation-bottom">
            <span style="float: right;"><a href="http://www.caloni.com.br/debug-remoto-no-c-builder/">Debug remoto no C&#43;&#43; Builder<span class="icon"><i class="fa fa-arrow-right"></i></span></a></span>
<span style="float: left;"><a href="http://www.caloni.com.br/interacao-entre-controles-no-c-builder/"><span class="icon"><i class="fa fa-arrow-left"></i></span>Interação entre controles no C&#43;&#43; Builder</a></span>

        </div>

      </div>

    <footer class="footer">
  <div class="container">
    <span style="float: right;"><i style="font-size: small;">Blogue do Caloni 2020. Copyright é invenção do capitalismo burguês opressor. Todos os direitos não serão reservados.</i></span>
  </div>
</footer>

  </body>

</html>
